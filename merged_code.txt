

// =============================================================================
// FILE: src\App.tsx
// =============================================================================


import React, { useState, useEffect, useRef } from 'react';
import { FireworkCanvas, FireworkCanvasHandle } from './components/FireworkCanvas';
import { SettingsPanel } from './components/ui/SettingsPanel';
import { HUD } from './components/ui/HUD';
import { 
  AppSettings, 
  DEFAULT_SETTINGS, 
  FireworkConfig, 
  DEFAULT_CONFIG, 
  ManualConfig, 
  DEFAULT_MANUAL_CONFIG 
} from './types';

const STORAGE_KEY = 'celestial_fireworks_v4_settings';

const App: React.FC = () => {
  const canvasRef = useRef<FireworkCanvasHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<AppSettings>(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        if (parsed && typeof parsed === 'object' && 'gravity' in parsed) {
          return { ...DEFAULT_SETTINGS, ...parsed };
        }
      }
    } catch (e) {
      console.error('Failed to load settings from localStorage', e);
    }
    return DEFAULT_SETTINGS;
  });

  const [config, setConfig] = useState<FireworkConfig>(DEFAULT_CONFIG);
  const [manualConfig, setManualConfig] = useState<ManualConfig>(DEFAULT_MANUAL_CONFIG);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  }, [settings]);

  const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const randomizeSettings = () => {
    setSettings(prev => ({
      ...prev,
      gravity: Number((Math.random() * 0.12 + 0.04).toFixed(3)),
      friction: Number((0.92 + Math.random() * 0.07).toFixed(3)),
      autoLaunchDelay: Math.floor(1000 + Math.random() * 6000),
      particleCountMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      explosionSizeMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      starBlinkSpeed: Number((0.0003 + Math.random() * 0.002).toFixed(5)),
      trailLength: Math.floor(5 + Math.random() * 30)
    }));
  };

  return (
    <div className="relative w-screen h-screen bg-black overflow-hidden font-sans text-white select-none">
      <style>{`
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }
      `}</style>

      <HUD />

      {/* ä¸»æ§æŒ‰é’® */}
      <div className="absolute top-10 right-10 z-20 flex flex-col gap-5 items-end">
        <button 
          onClick={() => canvasRef.current?.launchCarnival()}
          className="group relative px-10 py-5 bg-gradient-to-br from-amber-400 via-orange-500 to-rose-600 rounded-2xl font-black text-sm tracking-[0.3em] hover:scale-105 active:scale-95 transition-all shadow-2xl shadow-orange-500/40 overflow-hidden border border-white/10"
        >
          <span className="relative z-10 flex items-center gap-3">
            <span className="animate-bounce">ğŸ®</span> å¼€å¯ç››å¤§å˜‰å¹´å ğŸ®
          </span>
          <div className="absolute inset-0 bg-white/20 -translate-x-full group-hover:translate-x-0 transition-transform duration-500"></div>
        </button>
        <button 
          onClick={() => setShowSettings(!showSettings)}
          className="p-4 bg-white/5 hover:bg-white/15 rounded-2xl border border-white/10 transition-all backdrop-blur-xl shadow-2xl flex items-center gap-2 group"
        >
          <SettingsIcon className="w-6 h-6 text-cyan-400 group-hover:rotate-90 transition-transform" />
          <span className="text-xs font-bold tracking-widest text-cyan-400/80 pr-1">å¼•æ“é…ç½®</span>
        </button>
      </div>

      <FireworkCanvas ref={canvasRef} settings={settings} />

      <SettingsPanel 
        show={showSettings} 
        settings={settings} 
        config={config}
        manualConfig={manualConfig}
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onUpdateConfig={setConfig}
        onUpdateManual={setManualConfig}
        onRandomize={randomizeSettings}
        onReset={() => setSettings(DEFAULT_SETTINGS)}
      />
    </div>
  );
};

const SettingsIcon = ({ className }: { className?: string }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);

export default App;


// =============================================================================
// FILE: src\App3D.tsx
// =============================================================================

// FILE: src/App3D.tsx
// ä¸»åº”ç”¨å…¥å£ - æ•´åˆæ–°æ¶æ„çš„ç²’å­æ¨¡æ‹Ÿå™¨

import React, { useState, useRef } from 'react';
import { FireworkScene3D, FireworkScene3DHandle } from './components/FireworkScene3D';
import { ModernSettingsPanel } from './components/ui/ModernSettingsPanel';
import { TimeControlPanel } from './components/ui/TimeControlPanel';
import { HUD3D } from './components/ui/HUD3D';
import { TutorialOverlay, useTutorial } from './components/ui/TutorialOverlay';
import {
  AppSettings,
  DEFAULT_SETTINGS,
  FireworkConfig,
  DEFAULT_CONFIG,
  ManualConfig,
  DEFAULT_MANUAL_CONFIG,
  LaunchFormation
} from './types';
import { TimeController } from './core/TimeController';

const App3D: React.FC = () => {
  const sceneRef = useRef<FireworkScene3DHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [timeController, setTimeController] = useState<TimeController | null>(null);
  const [stats, setStats] = useState({ particles: 0, fireworks: 0, fps: 0 });
  const [autoRotate, setAutoRotate] = useState(true);

  // --- çŠ¶æ€ç®¡ç† ---
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [config, setConfig] = useState<FireworkConfig>(DEFAULT_CONFIG);
  const [manualConfig, setManualConfig] = useState<ManualConfig>(DEFAULT_MANUAL_CONFIG);
  const [logs, setLogs] = useState<string[]>([]);
  const [isLogCollapsed, setIsLogCollapsed] = useState(true);
  
  // --- æ•™ç¨‹ç³»ç»Ÿ ---
  const { showTutorial, completeTutorial, resetTutorial } = useTutorial();

  // --- é€»è¾‘å¤„ç† ---
  const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const handleTimeScaleChange = (scale: number) => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      const tc = currentScene.getTimeController();
      tc.timeScale = scale;
    }
  };

  const handleTogglePause = () => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      currentScene.getTimeController().togglePause();
    }
  };

  const handleRandomize = () => {
    // éšæœºç‰©ç†å‚æ•°
    setSettings(prev => ({
      ...prev,
      gravity: 0.05 + Math.random() * 0.15,
      friction: 0.90 + Math.random() * 0.08,
      particleCountMultiplier: 0.5 + Math.random() * 1.5,
      explosionSizeMultiplier: 0.8 + Math.random() * 0.8,
    }));

    // é‡ç½®é”å®šæ ·å¼ä¸ºéšæœº
    setManualConfig({
      lockedShape: 'RANDOM',
      lockedColor: 'RANDOM',
      lockedTrajectory: 'RANDOM',
      lockedCombo: 'RANDOM',
      lockedFormation: LaunchFormation.RANDOM,
      lockedCount: 1,
      lockedDuration: 0,
      lockedInterval: 100
    });
  };

  const handleReset = () => {
    setSettings(DEFAULT_SETTINGS);
    setConfig(DEFAULT_CONFIG);
    setManualConfig(DEFAULT_MANUAL_CONFIG);
    setLogs([]);
  };

  const handleLaunchLog = (log: string) => {
    setLogs(prev => [log, ...prev].slice(0, 10));
  };

  const handleLaunchCarnival = () => {
    sceneRef.current?.launchCarnival();
  };

  return (
    <div className="relative w-screen h-screen bg-slate-50 overflow-hidden font-sans text-gray-800 select-none">
      {/* å…¨å±€æ ·å¼ */}
      <style>{`
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          background: #10b981;
          cursor: pointer;
          border: 2px solid white;
          box-shadow: 0 2px 6px rgba(16, 185, 129, 0.3);
        }
        
        .custom-scrollbar::-webkit-scrollbar {
          width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: #e2e8f0;
          border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: #cbd5e1;
        }
        
        @keyframes slideUp {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-slideUp {
          animation: slideUp 0.4s ease-out;
        }
      `}</style>

      {/* HUD ä¿¡æ¯æ˜¾ç¤º */}
      <HUD3D />

      {/* å‘å°„æ—¥å¿—æ˜¾ç¤º (å“åº”ç”¨æˆ·éœ€æ±‚: é»˜è®¤æŠ˜å ï¼Œè§†è§‰ç²¾ç®€) */}
      <div className="absolute bottom-10 left-6 z-50 pointer-events-none flex flex-col gap-2 max-w-sm">
        <div 
          className="pointer-events-auto flex items-center gap-2 mb-1 group cursor-pointer"
          onClick={() => setIsLogCollapsed(!isLogCollapsed)}
        >
          <div className={`px-2 py-1 rounded bg-black/20 backdrop-blur-sm text-[9px] font-bold text-white/50 transition-all ${isLogCollapsed ? 'opacity-100' : 'opacity-0'}`}>
            {logs.length} æ¡è®°å½•
          </div>
          <button className="w-6 h-6 rounded-full bg-slate-800/80 text-white/80 border border-white/10 flex items-center justify-center text-[10px] hover:bg-emerald-600 transition-all">
            {isLogCollapsed ? 'ï¼‹' : 'Ã—'}
          </button>
        </div>

        {!isLogCollapsed && logs.slice(0, 5).map((log, i) => (
          <div 
            key={`${i}-${log}`} 
            className="
              px-4 py-2
              bg-white/90 backdrop-blur-xl
              border border-emerald-100/50 
              rounded-2xl shadow-lg
              text-[11px] font-black text-emerald-800
              animate-slideUp
            "
            style={{ 
              opacity: 1 - i * 0.18,
              transform: `scale(${1 - i * 0.05})`,
              boxShadow: '0 4px 12px rgba(16, 185, 129, 0.1)'
            }}
          >
            <span className="mr-2 text-emerald-500">â—†</span>
            {log}
          </div>
        ))}
      </div>

      {/* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */}
      <div className="absolute top-6 right-6 z-20 flex flex-col gap-3 items-end">
        {/* åªä¿ç•™åˆ›æ„å·¥åŠå…¥å£ï¼Œå˜‰å¹´åæŒ‰é’®ç§»å…¥å†…éƒ¨ */}
        <button
          onClick={() => setShowSettings(true)}
          className="
            group flex items-center gap-3 px-5 py-3.5 
            bg-white/90 backdrop-blur-xl border border-white/20
            rounded-2xl shadow-xl hover:shadow-emerald-200/40 
            hover:-translate-y-0.5 active:scale-95 transition-all
          "
        >
          <div className="text-right">
            <div className="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-none mb-1">Workshop</div>
            <div className="text-sm font-black text-gray-800 leading-none">åˆ›æ„å·¥åŠ</div>
          </div>
          <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-emerald-500 to-teal-600 flex items-center justify-center text-white shadow-lg shadow-emerald-500/30 group-hover:rotate-12 transition-all">
            ğŸ¨
          </div>
        </button>
        
        {/* å·¥å…·æŒ‰é’®ç»„ */}
        <div className="flex gap-2">
          {/* æ•™ç¨‹æŒ‰é’® */}
          <button
            onClick={resetTutorial}
            className="
              p-3.5 rounded-xl
              bg-white/90 backdrop-blur
              text-gray-600 hover:text-blue-600
              shadow-lg border border-gray-100
              transition-all
            "
            title="æŸ¥çœ‹æ•™ç¨‹"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </button>
        </div>
      </div>

      {/* 3D çƒŸèŠ±åœºæ™¯ */}
      <FireworkScene3D
        ref={sceneRef}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        autoRotate={autoRotate}
        onTimeUpdate={(tc) => setTimeController(tc)}
        onStatsUpdate={(st) => setStats(st)}
        onLaunch={handleLaunchLog}
      />

      {/* æ—¶é—´æ§åˆ¶é¢æ¿ */}
      <TimeControlPanel
        timeController={timeController}
        stats={stats}
        onTimeScaleChange={handleTimeScaleChange}
        onTogglePause={handleTogglePause}
        autoRotate={autoRotate}
        onToggleAutoRotate={() => setAutoRotate(!autoRotate)}
      />

      {/* è®¾ç½®é¢æ¿ & ç‚¹å‡»å¤–éƒ¨å…³é—­é®ç½© */}
      {showSettings && (
        <div 
          className="fixed inset-0 z-30 bg-black/5 backdrop-blur-[1px]"
          onClick={() => setShowSettings(false)}
        />
      )}

      <ModernSettingsPanel
        show={showSettings}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onUpdateConfig={setConfig}
        onUpdateManual={setManualConfig}
        onRandomize={handleRandomize}
        onReset={handleReset}
        onLaunchCarnival={handleLaunchCarnival}
      />
      
      {/* å¼•å¯¼æ•™ç¨‹ */}
      {showTutorial && (
        <TutorialOverlay onComplete={completeTutorial} />
      )}

      {/* åº•éƒ¨å“ç‰Œæ ‡è¯† */}
      <div className="absolute bottom-4 right-4 text-[10px] text-gray-300 font-medium">
        <span className="font-bold text-gray-400">AETHERIS</span>
        <span className="mx-2 opacity-50">/</span>
        UNIVERSAL PARTICLE ENGINE v2.0
      </div>
    </div>
  );
};

export default App3D;

// END OF FILE: src/App3D.tsx

// =============================================================================
// FILE: src\components\FireworkCanvas.tsx
// =============================================================================


import React, { useEffect, useRef, useState, useCallback, useMemo, useImperativeHandle, forwardRef } from 'react';
import { ParticlePool } from '../core/ParticlePool';
import { Firework } from '../core/Firework';
import { AppSettings } from '../types';

interface Star {
  x: number;
  y: number;
  size: number;
  blinkSpeed: number;
  phase: number;
  layer: number;
}

interface FireworkCanvasProps {
  settings: AppSettings;
}

export interface FireworkCanvasHandle {
  launchCarnival: () => void;
}

export const FireworkCanvas = forwardRef<FireworkCanvasHandle, FireworkCanvasProps>(({ settings }, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fireworksRef = useRef<Firework[]>([]);
  
  const particlePoolRef = useRef<ParticlePool | null>(null);
  const sparklersPoolRef = useRef<ParticlePool | null>(null);
  
  if (!particlePoolRef.current) particlePoolRef.current = new ParticlePool(15000);
  if (!sparklersPoolRef.current) sparklersPoolRef.current = new ParticlePool(1000);

  const getParticlePool = () => particlePoolRef.current!;
  const getSparklersPool = () => sparklersPoolRef.current!;

  const shockwavesRef = useRef<{ x: number, y: number, r: number, a: number }[]>([]);
  
  const [isCharging, setIsCharging] = useState(false);
  const chargeLevelRef = useRef(0);
  const mousePos = useRef({ x: 0, y: 0 });
  const requestRef = useRef<number | undefined>(undefined);
  const lastAutoLaunch = useRef<number>(0);

  const stars = useMemo<Star[]>(() => {
    const s: Star[] = [];
    for (let i = 0; i < 400; i++) {
      s.push({
        x: Math.random() * 4000, 
        y: Math.random() * 3000,
        size: Math.random() * 1.2,
        blinkSpeed: (0.002 + Math.random() * 0.008) * (settings.starBlinkSpeed / 0.0008),
        phase: Math.random() * Math.PI * 2,
        layer: Math.floor(Math.random() * 3)
      });
    }
    return s;
  }, [settings.starBlinkSpeed]);

  const handleResize = useCallback(() => {
    if (canvasRef.current) {
      const dpr = window.devicePixelRatio || 1;
      canvasRef.current.width = window.innerWidth * dpr;
      canvasRef.current.height = window.innerHeight * dpr;
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }
  }, []);

  useEffect(() => {
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);

  const launchFireworkAt = (x: number, y: number, hue?: number, charge?: number) => {
    const startXVariation = (Math.random() - 0.5) * 100;
    const startX = Math.max(0, Math.min(window.innerWidth, x + startXVariation));
    
    fireworksRef.current.push(new Firework({
      startX,
      targetX: x,
      targetY: y,
      hue: hue ?? Math.random() * 360,
      charge: charge ?? 0.2 + Math.random() * 0.5
    }, settings));
  };

  useImperativeHandle(ref, () => ({
    launchCarnival: () => {
      const launch = (count: number, delay: number) => {
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const x = (window.innerWidth * 0.1) + (window.innerWidth * 0.8 * Math.random());
            const y = window.innerHeight * (0.1 + Math.random() * 0.4);
            launchFireworkAt(x, y, Math.random() * 360, 0.4 + Math.random() * 0.4);
          }, delay + i * 180);
        }
      };
      launch(8, 0); 
      launch(12, 1200);
    }
  }));

  const animate = useCallback((time: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    if (!ctx) return;

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#020205';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.fillStyle = '#fff';
    const oxB = (mousePos.current.x - window.innerWidth/2) * 0.005;
    const oyB = (mousePos.current.y - window.innerHeight/2) * 0.005;
    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];
      const opacity = 0.05 + Math.abs(Math.sin(time * s.blinkSpeed + s.phase)) * 0.6;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc((s.x + oxB * s.layer) % window.innerWidth, (s.y + oyB * s.layer) % window.innerHeight, s.size, 0, 6.28);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.22)';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    if (time - lastAutoLaunch.current > settings.autoLaunchDelay && !isCharging) {
      launchFireworkAt(Math.random() * window.innerWidth, 50 + Math.random() * (window.innerHeight * 0.4));
      lastAutoLaunch.current = time;
    }

    ctx.globalCompositeOperation = 'lighter';
    getSparklersPool().updateAndDraw(ctx);

    for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
      const f = fireworksRef.current[i];
      f.update(settings);
      f.draw(ctx);
      if (f.exploded) {
        f.createExplosion(settings, (opts) => getParticlePool().get(opts));
        if (f.charge > 0.5) {
          shockwavesRef.current.push({ x: f.pos.x, y: f.pos.y, r: 0, a: 0.25 });
        }
        fireworksRef.current.splice(i, 1);
      }
    }

    getParticlePool().updateAndDraw(ctx);

    for (let i = shockwavesRef.current.length - 1; i >= 0; i--) {
      const sw = shockwavesRef.current[i];
      sw.r += 16; sw.a -= 0.01;
      ctx.globalAlpha = sw.a;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.r, 0, 6.28);
      ctx.stroke();
      if (sw.a <= 0) shockwavesRef.current.splice(i, 1);
    }

    ctx.globalAlpha = 1;

    if (isCharging) {
      const increment = 0.025 * (1 - chargeLevelRef.current * 0.4);
      chargeLevelRef.current = Math.min(chargeLevelRef.current + increment, 1);
      
      const { x, y } = mousePos.current;
      const hue = (x / window.innerWidth) * 360;
      
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.4 + chargeLevelRef.current * 0.4})`;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, 40 + chargeLevelRef.current * 100, time * 0.003, time * 0.003 + 6.28);
      ctx.stroke();
      
      if (Math.random() > 0.5) {
        const ang = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 50;
        getSparklersPool().get({
          x: x + Math.cos(ang) * dist,
          y: y + Math.sin(ang) * dist,
          hue: (hue + 40) % 360,
          speed: -4 - chargeLevelRef.current * 4,
          angle: ang,
          size: 1,
          decay: 0.1,
          behavior: 'glitter'
        });
      }

      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${0.1 + chargeLevelRef.current * 0.4})`;
      ctx.beginPath();
      ctx.arc(x, y, chargeLevelRef.current * 50, 0, 6.28);
      ctx.fill();
      ctx.restore();
    }

    requestRef.current = requestAnimationFrame(animate);
  }, [isCharging, stars, settings]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [animate]);

  const updateMousePos = (e: React.MouseEvent | React.TouchEvent) => {
    const x = 'touches' in e ? (e as React.TouchEvent).touches[0].clientX : (e as React.MouseEvent).clientX;
    const y = 'touches' in e ? (e as React.TouchEvent).touches[0].clientY : (e as React.MouseEvent).clientY;
    mousePos.current = { x, y };
    
    if (Math.random() > 0.8) {
      getSparklersPool().get({
        x, y,
        hue: (performance.now() / 15) % 360,
        speed: Math.random() * 2,
        size: 0.7,
        decay: 0.06
      });
    }
  };

  const handleMouseDown = (e: React.MouseEvent | React.TouchEvent) => {
    setIsCharging(true);
    chargeLevelRef.current = 0;
    updateMousePos(e);
  };

  const handleMouseUp = () => {
    if (!isCharging) return;
    const xRatio = mousePos.current.x / window.innerWidth;
    const h = xRatio < 0.5 ? 170 + xRatio * 180 : (xRatio - 0.5) * 120;
    launchFireworkAt(mousePos.current.x, mousePos.current.y, h, chargeLevelRef.current + 0.1);
    setIsCharging(false);
    chargeLevelRef.current = 0;
  };

  return (
    <canvas
      ref={canvasRef}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onMouseMove={updateMousePos}
      onTouchStart={handleMouseDown}
      onTouchEnd={handleMouseUp}
      onTouchMove={updateMousePos}
      className="cursor-crosshair w-full h-full block touch-none"
    />
  );
});


// =============================================================================
// FILE: src\components\FireworkScene3D.tsx
// =============================================================================

// FILE: src/components/FireworkScene3D.tsx

import React, { useEffect, useRef, useImperativeHandle, forwardRef, memo } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

import { ParticlePool3D } from '../core/ParticlePool3D';
import { Firework3D } from '../core/Firework3D';
import { TimeController } from '../core/TimeController';
import {
  AppSettings,
  CameraMode,
  ExplosionType,
  AscensionType,
  FireworkConfig,
  ManualConfig,
  ColorStyle,
  LaunchFormation
} from '../types';

/**
 * æ˜¾å¼å®šä¹‰ Props æ¥å£ï¼Œç¡®ä¿ TypeScript åœ¨çˆ¶ç»„ä»¶å¼•ç”¨æ—¶ä¸ä¼šæŠ¥é”™
 */
export interface FireworkScene3DProps {
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  autoRotate: boolean;
  onTimeUpdate?: (timeController: TimeController) => void;
  onStatsUpdate?: (stats: { particles: number; fireworks: number; fps: number }) => void;
  onLaunch?: (log: string) => void;
}

/**
 * å®šä¹‰ç»„ä»¶æš´éœ²ç»™å¤–éƒ¨çš„æ“ä½œæ¥å£
 */
export interface FireworkScene3DHandle {
  launchCarnival: () => void;
  launchAt: (x: number, y: number, z: number) => void;
  getTimeController: () => TimeController;
}

/**
 * å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºä¸€ä¸ªå‘å…‰çš„ç²’å­è´´å›¾
 */
const createDetailedParticleTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  if (!ctx) return new THREE.Texture();

  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
  gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

/**
 * FireworkScene3D æ ¸å¿ƒç»„ä»¶
 * ä½¿ç”¨ React.ForwardRefRenderFunction æ˜¾å¼å£°æ˜ä»¥è·å¾—æœ€ä½³ TS æ”¯æŒ
 */
const FireworkScene3DInner: React.ForwardRefRenderFunction<FireworkScene3DHandle, FireworkScene3DProps> = (
    { settings, config, manualConfig, autoRotate, onTimeUpdate, onStatsUpdate, onLaunch },
    ref
) => {
  // === åŸºç¡€å¼•ç”¨ ===
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const composerRef = useRef<EffectComposer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const requestRef = useRef<number>(0);

  // === ä¸šåŠ¡é€»è¾‘å¼•ç”¨ (ç”¨äºåœ¨ä¸è§¦å‘ useEffect çš„æƒ…å†µä¸‹åŒæ­¥çŠ¶æ€) ===
  const settingsRef = useRef(settings);
  const configRef = useRef(config);
  const manualConfigRef = useRef(manualConfig);
  const autoRotateRef = useRef(autoRotate);

  useEffect(() => { settingsRef.current = settings; }, [settings]);
  useEffect(() => { configRef.current = config; }, [config]);
  useEffect(() => { manualConfigRef.current = manualConfig; }, [manualConfig]);
  useEffect(() => { autoRotateRef.current = autoRotate; }, [autoRotate]);

  // === æ¨¡æ‹Ÿå™¨å†…éƒ¨çŠ¶æ€ ===
  const fireworksRef = useRef<Firework3D[]>([]);
  const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(30000));
  const timeControllerRef = useRef<TimeController>(new TimeController());

  const lastAutoLaunchRef = useRef<number>(0);
  const lastCarnivalRef = useRef<number>(0);
  const fpsRef = useRef({ frames: 0, lastTime: 0, value: 0 });

  // === é¼ æ ‡äº¤äº’å¼•ç”¨ ===
  const mouseDownPos = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const mouseDownTime = useRef<number>(0);
  const planeRef = useRef<THREE.Plane>(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0));

  /**
   * æ ¸å¿ƒå‘å°„æ–¹æ³•ï¼šæ”¯æŒä»é…ç½®ä¸­éšæœºæˆ–æŒ‡å®šæ ·å¼
   */
  const launchSingle = (s: AppSettings, c: FireworkConfig, overrides?: any) => {
    const targetX = overrides?.targetX ?? (Math.random() - 0.5) * 800;
    const targetZ = overrides?.targetZ ?? (Math.random() - 0.5) * 800;
    const targetY = overrides?.targetY ?? (200 + Math.random() * 150);
    const startX = overrides?.startX ?? (Math.random() - 0.5) * 1000;
    const startZ = overrides?.startZ ?? (Math.random() - 0.5) * 1000;

    // 1. è½¨è¿¹å†³ç­–
    let trajectory = overrides?.trajectory || 'RANDOM';
    if (trajectory === 'RANDOM') {
      const tPool = c.enabledTrajectories || [];
      trajectory = tPool.length > 0 ? tPool[Math.floor(Math.random() * tPool.length)] : undefined;
    }

    // 2. å½¢çŠ¶å†³ç­–
    let shape = overrides?.shape || 'RANDOM';
    if (shape === 'RANDOM') {
      const sPool = [...(c.enabledShape3Ds || []), ...(c.enabledShapes || [])];
      shape = sPool.length > 0 ? sPool[Math.floor(Math.random() * sPool.length)] : undefined;
    }

    // 3. ç»„åˆæŠ€å†³ç­–
    let combo = overrides?.combo || 'RANDOM';
    if (combo === 'RANDOM') {
      const cbPool = c.enabledCombos || [];
      combo = cbPool.length > 0 ? cbPool[Math.floor(Math.random() * cbPool.length)] : undefined;
    }
    
    // 4. ç”Ÿå‘½å‘¨æœŸå†³ç­– (Decay)
    const lifeTimeOverride = overrides?.duration || 0;

    fireworksRef.current.push(new Firework3D(
      {
        startX, startZ,
        targetX, targetY, targetZ,
        hue: Math.random() * 360,
        charge: 1.0,
        trajectoryType: trajectory,
        comboType: combo,
        customShape: shape,
        lifeTimeOverride
      },
      s, c
    ));

    // è¾“å‡ºæ—¥å¿—åˆ° UI
    if (!overrides?.skipLog) {
       const logInfo = `ğŸš€ å‘å°„: [${shape || 'é»˜è®¤'}] - ${trajectory || 'ç›´çº¿'} - ${combo || 'å•çº§'}`;
       onLaunch?.(logInfo);
    }
  };

  /**
   * é˜Ÿå½¢å‘å°„å™¨
   */
  const launchGroup = (
      formation: LaunchFormation, 
      count: number, 
      interval: number, 
      duration: number,
      launchFn: (idx: number, posOffset: THREE.Vector3, targetOffset: THREE.Vector3) => void
  ) => {
      if (count <= 1 || formation === LaunchFormation.SINGLE) {
          launchFn(0, new THREE.Vector3(), new THREE.Vector3());
          return;
      }

      const radius = 150;
      
      for (let i = 0; i < count; i++) {
          const offsetS = new THREE.Vector3(); 
          const offsetT = new THREE.Vector3(); 
          
          const progress = i / count;
          const angle = progress * Math.PI * 2;
          
          switch (formation) {
              case LaunchFormation.CIRCLE:
                  offsetT.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                  offsetS.set(Math.cos(angle) * radius * 0.5, 0, Math.sin(angle) * radius * 0.5); 
                  break;
              case LaunchFormation.LINE:
                  const w = radius * 2;
                  const x = (i - count / 2) * (w / count);
                  offsetT.set(x, 0, 0);
                  offsetS.set(x, 0, 0);
                  break;
              case LaunchFormation.CROSS: // ç®€å•çš„åå­—å¸ƒå±€
                  const arm = i % 4;
                  const dist = Math.floor(i / 4 + 1) * (radius / 2);
                  if (arm === 0) offsetT.set(dist, 0, 0);
                  if (arm === 1) offsetT.set(-dist, 0, 0);
                  if (arm === 2) offsetT.set(0, 0, dist);
                  if (arm === 3) offsetT.set(0, 0, -dist);
                  offsetS.copy(offsetT).multiplyScalar(0.5);
                  break;
              case LaunchFormation.V_SHAPE:
                  const side = i % 2 === 0 ? 1 : -1;
                  const row = Math.floor(i / 2);
                  offsetT.set(side * row * 50, 0, row * 50);
                  offsetS.copy(offsetT);
                  break;
              case LaunchFormation.RANDOM:
              default:
                  offsetT.set((Math.random()-0.5)*radius*2, (Math.random()-0.5)*50, (Math.random()-0.5)*radius*2);
                  offsetS.set((Math.random()-0.5)*radius, 0, (Math.random()-0.5)*radius);
                  break;
          }

          if (interval > 0) {
              setTimeout(() => {
                  launchFn(i, offsetS, offsetT);
              }, i * interval);
          } else {
              launchFn(i, offsetS, offsetT);
          }
      }
  };

  /**
   * å˜‰å¹´ååºåˆ—æ‰§è¡Œé€»è¾‘
   */
  const launchCarnivalWave = (s: AppSettings, c: FireworkConfig) => {
    const sequence = c.carnivalSequence || [];
    
    if (sequence.length === 0) {
      const count = 5 + Math.floor(Math.random() * 8);
      onLaunch?.(`éšæœºæ³¢æ¬¡: ${count} æš`);
      launchGroup(LaunchFormation.RANDOM, count, 150, 0, (i, offS, offT) => {
         launchSingle(s, c);
      });
      return;
    }

    let totalDelay = 0;
    sequence.forEach((stage, sIdx) => {
      totalDelay += stage.delay;
      setTimeout(() => {
        onLaunch?.(`[å¤§ç§€] ${stage.name}`);
        launchGroup(
            stage.formation || LaunchFormation.RANDOM,
            stage.count,
            stage.interval || 0,
            stage.duration || 0,
            (idx, offS, offT) => {
                launchSingle(s, c, {
                    trajectory: stage.trajectory,
                    shape: stage.shape,
                    combo: stage.combo,
                    duration: stage.duration,
                    targetX: offT.x * 1.5, 
                    targetZ: offT.z * 1.5, 
                    startX: offS.x,
                    startZ: offS.z,
                    skipLog: idx > 0 
                });
            }
        );
      }, totalDelay);
    });
  };

  const createBackgroundStars = (scene: THREE.Scene) => {
    const starGeo = new THREE.BufferGeometry();
    const count = 4000;
    const pos = new Float32Array(count * 3);
    const col = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const r = 3000 + Math.random() * 2000;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      pos[i * 3 + 2] = r * Math.cos(phi);
      col[i * 3] = 0.8; col[i * 3 + 1] = 0.8; col[i * 3 + 2] = 1.0;
    }

    starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));

    const starMat = new THREE.PointsMaterial({
      size: 3, vertexColors: true, transparent: true, opacity: 0.5, sizeAttenuation: false
    });
    scene.add(new THREE.Points(starGeo, starMat));
  };

  const createReferenceGround = (scene: THREE.Scene) => {
    const grid = new THREE.GridHelper(8000, 80, 0x223344, 0x05101a);
    const gridMat = grid.material as THREE.Material;
    gridMat.transparent = true;
    gridMat.opacity = 0.1;
    grid.position.y = -10;
    scene.add(grid);
  };

  const updateStarsTwinkle = (time: number) => {
    const stars = sceneRef.current?.children.find(c => c instanceof THREE.Points && !(c.material as any).map);
    if (stars && stars instanceof THREE.Points) {
      const colors = stars.geometry.attributes.color.array as Float32Array;
      for (let i = 0; i < colors.length; i += 3) {
        const f = 0.7 + 0.3 * Math.sin(time + i);
        colors[i] = 0.8 * f;
        colors[i + 1] = 0.8 * f;
        colors[i + 2] = 1.0 * f;
      }
      stars.geometry.attributes.color.needsUpdate = true;
    }
  };

  // === ç”Ÿå‘½å‘¨æœŸï¼šåˆå§‹åŒ–åœºæ™¯ ===
  useEffect(() => {
    if (!containerRef.current) return;

    // 1. åˆå§‹åŒ–åœºæ™¯å®¹å™¨
    containerRef.current.innerHTML = '';

    // 2. åˆ›å»ºåœºæ™¯ (Scene)
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e17);
    scene.fog = new THREE.FogExp2(0x0a0e17, 0.0006);
    sceneRef.current = scene;

    // 3. åˆ›å»ºç›¸æœº (Camera)
    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        10000
    );
    camera.position.set(0, 150, 600);
    cameraRef.current = camera;

    // 4. åˆ›å»ºæ¸²æŸ“å™¨ (Renderer)
    const renderer = new THREE.WebGLRenderer({
      antialias: false,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.8;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // 5. é…ç½®åæœŸå¤„ç† (EffectComposer) å®ç°è¾‰å…‰
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.2, // å¼ºåº¦
        0.4, // åŠå¾„
        0.1  // é˜ˆå€¼
    );
    composer.addPass(renderPass);
    composer.addPass(bloomPass);
    composerRef.current = composer;

    // 6. é…ç½®è½¨é“æ§åˆ¶å™¨ (OrbitControls)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 100;
    controls.maxDistance = 2000;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controlsRef.current = controls;

    // 7. åˆå§‹åŒ–ç²’å­ç³»ç»Ÿå‡ ä½•ä½“
    const maxParticles = 30000;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3).fill(-10000);
    const colors = new Float32Array(maxParticles * 3);
    const sizes = new Float32Array(maxParticles);

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particleMaterial = new THREE.PointsMaterial({
      size: 8,
      map: createDetailedParticleTexture(),
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    const particlePoints = new THREE.Points(particleGeometry, particleMaterial);
    particlePoints.frustumCulled = false;
    scene.add(particlePoints);

    // 8. åˆ›å»ºèƒŒæ™¯å…ƒç´ 
    createBackgroundStars(scene);
    createReferenceGround(scene);

    // 9. å¤„ç†çª—å£ç¼©æ”¾
    const onResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    };
    window.addEventListener('resize', onResize);

    // 10. æ ¸å¿ƒåŠ¨ç”»ä¸»å¾ªç¯
    const renderLoop = () => {
      requestRef.current = requestAnimationFrame(renderLoop);

      const tc = timeControllerRef.current;
      const currentSettings = settingsRef.current;
      const currentConfig = configRef.current;

      // æ›´æ–°æ§åˆ¶å™¨
      if (controlsRef.current) {
        controlsRef.current.autoRotate = autoRotateRef.current;
        controlsRef.current.update();
      }

      // å¦‚æœæœªæš‚åœï¼Œæ‰§è¡Œç‰©ç†æ¨¡æ‹Ÿ
      if (!tc.isPaused) {
        tc.update();
        const dt = tc.deltaTime;
        const virtualNow = tc.virtualTime * 1000;

        // A. è‡ªåŠ¨å˜‰å¹´åæ³¢æ¬¡åˆ¤å®š
        if (currentSettings.enableAutoCarnival) {
          if (virtualNow - lastCarnivalRef.current > currentSettings.carnivalInterval * 1000) {
            launchCarnivalWave(currentSettings, currentConfig);
            lastCarnivalRef.current = virtualNow;
          }
        }

        // B. çƒŸèŠ±ç‰©ç†æ›´æ–°
        for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
          const fw = fireworksRef.current[i];
          fw.update(currentSettings, dt);

          // å‡ç©ºè¿‡ç¨‹ï¼šç”Ÿæˆå°¾ç„°ç²’å­
          if (!fw.exploded) {
            const speed = fw.velocity.length();
            // è§£å†³â€œå¤ªäº®â€é—®é¢˜ï¼šæ ¹æ®é€Ÿåº¦åŠ¨æ€è°ƒèŠ‚é€æ˜åº¦å’Œå¯†åº¦
            const spawnProbability = Math.min(1, speed / 15);
            const alphaValue = Math.min(1, speed / 20);

            if (Math.random() < spawnProbability) {
              const p = particlePoolRef.current.get({
                x: fw.position.x + (Math.random() - 0.5) * 1.5,
                y: fw.position.y - 1,
                z: fw.position.z + (Math.random() - 0.5) * 1.5,
                hue: fw.hue,
                speed: 0,
                size: 5 * (speed / 30 + 0.5),
                decay: 0.08,
                behavior: 'default',
                gravity: 0.02
              });
              if (p) p.alpha = alphaValue;
            }
          }

          // çˆ†ç‚¸é€»è¾‘
          if (fw.exploded) {
            fw.createExplosion(currentSettings, (opts) => particlePoolRef.current.get(opts));
            fireworksRef.current.splice(i, 1);
          }
        }

        // C. å…¨å±€ç²’å­ç‰©ç†æ›´æ–°
        particlePoolRef.current.update(dt);
      }

      // D. åŒæ­¥ç²’å­ Buffer åˆ° GPU
      const activeParticles = particlePoolRef.current.getActiveParticles();
      const posArray = particleGeometry.attributes.position.array as Float32Array;
      const colArray = particleGeometry.attributes.color.array as Float32Array;

      for (let i = 0; i < activeParticles.length; i++) {
        const p = activeParticles[i];
        const idx = i * 3;
        posArray[idx] = p.position.x;
        posArray[idx + 1] = p.position.y;
        posArray[idx + 2] = p.position.z;

        const color = p.getColor();
        colArray[idx] = color.r * p.alpha;
        colArray[idx + 1] = color.g * p.alpha;
        colArray[idx + 2] = color.b * p.alpha;
      }

      // éšè—éæ´»åŠ¨ç²’å­
      for (let i = activeParticles.length; i < maxParticles; i++) {
        const idx = i * 3;
        if (posArray[idx + 1] > -5000) {
          posArray[idx] = 0;
          posArray[idx + 1] = -10000;
          posArray[idx + 2] = 0;
        } else if (i > activeParticles.length + 200) {
          break; // ä¼˜åŒ–ï¼šå¦‚æœå·²ç»æ˜¯ä¸€å—è¿ç»­çš„éšè—åŒºåˆ™åœæ­¢
        }
      }

      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;

      // E. æ›´æ–°æ˜Ÿæ˜Ÿé—ªçƒ
      updateStarsTwinkle(performance.now() * 0.0005);

      // F. FPS ç»Ÿè®¡
      fpsRef.current.frames++;
      if (performance.now() - fpsRef.current.lastTime > 1000) {
        fpsRef.current.value = fpsRef.current.frames;
        fpsRef.current.frames = 0;
        fpsRef.current.lastTime = performance.now();
      }

      // G. æ¸²æŸ“
      composer.render();

      // H. å›è°ƒ
      if (onTimeUpdate) onTimeUpdate(tc);
      if (onStatsUpdate) {
        onStatsUpdate({
          particles: activeParticles.length,
          fireworks: fireworksRef.current.length,
          fps: fpsRef.current.value
        });
      }
    };

    renderLoop();

    return () => {
      window.removeEventListener('resize', onResize);
      cancelAnimationFrame(requestRef.current);
      renderer.dispose();
      controls.dispose();
    };
  }, []);

  // äº¤äº’å‰§æœ¬ç´¢å¼•æŒ‡é’ˆ
  const manualStepIndexRef = useRef<number>(0);

  // === æš´éœ²æ¥å£ç»™çˆ¶ç»„ä»¶ ===
  useImperativeHandle(ref, () => ({
    launchCarnival: () => launchCarnivalWave(settingsRef.current, configRef.current),
    launchAt: (x, y, z) => {
      const mc = manualConfigRef.current;
      const c = configRef.current;
      const settings = settingsRef.current;
      const manualSeq = c.manualSequence || [];

      // å¦‚æœé…ç½®äº†æ‰‹åŠ¨äº¤äº’å‰§æœ¬ï¼Œåˆ™æŒ‰å‰§æœ¬é¡ºåºå‘å°„
      if (manualSeq.length > 0) {
        const stage = manualSeq[manualStepIndexRef.current];
        onLaunch?.(`[å‰§æœ¬] ${stage.name}`);
        
        launchGroup(
            stage.formation || LaunchFormation.SINGLE,
            stage.count,
            stage.interval || 100,
            stage.duration || 0,
            (idx, offS, offT) => {
               launchSingle(settings, c, {
                 trajectory: stage.trajectory,
                 shape: stage.shape,
                 combo: stage.combo,
                 duration: stage.duration,
                 targetX: x + offT.x,
                 targetY: y > 50 ? y : 220,
                 targetZ: z + offT.z,
                 startX: x + (Math.random() - 0.5) * 40 + offS.x,
                 startZ: z + (Math.random() - 0.5) * 40 + offS.z,
                 skipLog: idx > 0
               });
            }
        );

        manualStepIndexRef.current = (manualStepIndexRef.current + 1) % manualSeq.length;
      } else {
        // å›é€€é€»è¾‘ï¼šæ‰‹åŠ¨é…ç½®
        // ä½¿ç”¨æ–°å‚æ•° lockedFormation, lockedCount, lockedDuration
        const formation = mc.lockedFormation || LaunchFormation.SINGLE;
        const count = mc.lockedCount || 1;
        
        launchGroup(
            formation,
            count,
            mc.lockedInterval || 100,
            mc.lockedDuration || 0,
            (idx, offS, offT) => {
                launchSingle(settings, c, {
                  trajectory: mc.lockedTrajectory,
                  shape: mc.lockedShape,
                  combo: mc.lockedCombo,
                  duration: mc.lockedDuration,
                  targetX: x + offT.x,
                  targetY: y > 50 ? y + (Math.random()-0.5)*20 : 200 + (Math.random()-0.5)*20,
                  targetZ: z + offT.z,
                  startX: x + (Math.random() - 0.5) * 50 + offS.x,
                  startZ: z + (Math.random() - 0.5) * 50 + offS.z,
                  skipLog: idx > 0
                });
            }
        );
        
        if (count <= 1) onLaunch?.(`ğŸ¯ æ‰‹åŠ¨å•å‘`);
        else onLaunch?.(`ğŸ¯ æ‰‹åŠ¨é½å°„: ${count}å‘ (${formation})`);
      }
    },
    getTimeController: () => timeControllerRef.current
  }));

  // === é¼ æ ‡äº¤äº’äº‹ä»¶ ===
  const handleInteraction = (e: React.MouseEvent) => {
    if (e.button === 0 && cameraRef.current && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
      );

      const ray = new THREE.Raycaster();
      ray.setFromCamera(mouse, cameraRef.current);
      const targetPoint = new THREE.Vector3();
      ray.ray.intersectPlane(planeRef.current, targetPoint);

      if (targetPoint) {
        // é€šè¿‡ Ref è·å–è‡ªèº«æš´éœ²çš„æ¥å£è¿›è¡Œå‘å°„
        // @ts-ignore
        ref.current?.launchAt(targetPoint.x, targetPoint.y, targetPoint.z);
      }
    }
  };

  return (
      <div
          ref={containerRef}
          className="w-full h-full block cursor-crosshair outline-none"
          onMouseDown={(e) => {
            mouseDownPos.current = { x: e.clientX, y: e.clientY };
            mouseDownTime.current = performance.now();
          }}
          onMouseUp={(e) => {
            const dist = Math.sqrt(Math.pow(e.clientX - mouseDownPos.current.x, 2) + Math.pow(e.clientY - mouseDownPos.current.y, 2));
            if (dist < 5 && (performance.now() - mouseDownTime.current) < 300) {
              handleInteraction(e);
            }
          }}
      />
  );
};

// å°è£…å¯¼å‡º
export const FireworkScene3D = memo(forwardRef(FireworkScene3DInner));

// =============================================================================
// FILE: src\components\ui\CustomSelect.tsx
// =============================================================================

// FILE: src/components/ui/CustomSelect.tsx
// è‡ªå®šä¹‰ä¸‹æ‹‰é€‰æ‹©æ¡† - å½»åº•æ›¿ä»£åŸç”Ÿä¸‘é™‹çš„ select
// è§†è§‰é£æ ¼ï¼šæ¶²æ€ç»ç’ƒï¼Œæ‚¬æµ®èœå•ï¼Œç²¾è‡´åŠ¨ç”»

import React, { useState, useRef, useEffect } from "react";

interface Option {
  label: string;
  value: string;
}

interface CustomSelectProps {
  value: string;
  options: Option[];
  onChange: (value: string) => void;
  icon?: string;
  className?: string;
}

export const CustomSelect: React.FC<CustomSelectProps> = ({
  value,
  options,
  onChange,
  icon,
  className = "",
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // æŸ¥æ‰¾å½“å‰é€‰ä¸­çš„ label
  const selectedLabel = options.find((o) => o.value === value)?.label || value;

  // ç‚¹å‡»å¤–éƒ¨å…³é—­
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  return (
    <div className={`relative group ${className}`} ref={containerRef}>
      {/* è§¦å‘æŒ‰é’® */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          w-full flex items-center justify-between
          px-3 py-2.5 rounded-xl
          bg-white/40 backdrop-blur-md
          border border-white/60
          text-[10px] font-black text-slate-700
          shadow-sm transition-all duration-300
          hover:bg-white/60 hover:border-emerald-300 hover:shadow-emerald-100/30
          focus:outline-none focus:ring-2 focus:ring-emerald-500/20
          ${
            isOpen
              ? "border-emerald-400 bg-white/80 ring-2 ring-emerald-500/20"
              : ""
          }
        `}
      >
        <div className="flex items-center gap-2 truncate">
          {icon && <span className="text-lg opacity-80">{icon}</span>}
          <span className="truncate">{selectedLabel}</span>
        </div>
        <div
          className={`
           text-[8px] text-slate-400 transition-transform duration-300 ml-2
           ${
             isOpen
               ? "rotate-180 text-emerald-500"
               : "group-hover:text-emerald-400"
           }
        `}
        >
          â–¼
        </div>
      </button>

      {/* ä¸‹æ‹‰èœå• (Portal like behavior but simplified for this context, assume z-index is high enough) */}
      <div
        className={`
          absolute left-0 right-0 top-full mt-2
          bg-white/90 backdrop-blur-xl
          border border-white/60 rounded-xl
          shadow-xl shadow-slate-200/50
          max-h-60 overflow-y-auto custom-scrollbar
          z-50 transform origin-top transition-all duration-200 cubic-bezier(0.2, 0.8, 0.2, 1)
          ${
            isOpen
              ? "opacity-100 scale-100 translate-y-0 visible"
              : "opacity-0 scale-95 -translate-y-2 invisible pointer-events-none"
          }
        `}
      >
        <div className="p-1.5 space-y-0.5">
          {options.map((option) => {
            const isSelected = option.value === value;
            return (
              <button
                key={option.value}
                onClick={() => {
                  onChange(option.value);
                  setIsOpen(false);
                }}
                className={`
                  w-full text-left px-3 py-2 rounded-lg text-[10px] font-bold transition-all
                  flex items-center justify-between
                  ${
                    isSelected
                      ? "bg-emerald-50 text-emerald-700"
                      : "text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                  }
                `}
              >
                <span>{option.label}</span>
                {isSelected && <span className="text-emerald-500">âœ“</span>}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\components\ui\HUD.tsx
// =============================================================================


import React from 'react';

export const HUD: React.FC = () => {
  return (
    <>
      {/* å¤´éƒ¨ä¿¡æ¯ */}
      <div className="absolute top-10 left-10 z-10 pointer-events-none">
        <div className="flex items-center gap-4 mb-2">
          <div className="w-1.5 h-12 bg-cyan-500 rounded-full shadow-[0_0_20px_rgba(6,182,212,1)] animate-pulse"></div>
          <div>
            <h1 className="text-5xl font-black tracking-tighter italic leading-none">
              ç’€ç’¨<span className="text-cyan-400">æ˜Ÿè¾°</span> V4
            </h1>
            <p className="text-[10px] text-cyan-500/50 tracking-[0.5em] font-bold uppercase mt-1">
              Deep Space Particle System â€¢ Pro Edition
            </p>
          </div>
        </div>
      </div>

      {/* åº•éƒ¨æµ®æ ‡ */}
      <footer className="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-12 pointer-events-none opacity-20">
        <div className="h-[1px] w-40 bg-gradient-to-r from-transparent via-white/40 to-transparent"></div>
        <div className="text-[10px] text-white uppercase tracking-[1em] font-light flex gap-8">
          <span>è¡Œæ˜Ÿ</span><span>è’²å…¬è‹±</span><span>è¤ç«è™«</span><span>åœŸæ˜Ÿç¯</span><span>æ˜ŸèŠ’</span><span>æ³¢æµª</span>
        </div>
        <div className="h-[1px] w-40 bg-gradient-to-l from-transparent via-white/40 to-transparent"></div>
      </footer>

      {/* äº’åŠ¨æç¤º */}
      <div className="absolute bottom-10 left-10 text-[9px] text-white/30 tracking-[0.2em] font-medium pointer-events-none space-y-1">
        <p>â€¢ ç‚¹å‡»/è§¦æ‘¸å‘å°„</p>
        <p>â€¢ é•¿æŒ‰è“„åŠ›å¤§æ‹›</p>
        <p>â€¢ ç§»åŠ¨é¼ æ ‡äº§ç”Ÿæ˜Ÿå°˜</p>
      </div>

      <div className="absolute inset-0 bg-gradient-to-t from-cyan-950/20 via-transparent to-transparent pointer-events-none"></div>
    </>
  );
};


// =============================================================================
// FILE: src\components\ui\HUD3D.tsx
// =============================================================================

// FILE: src/components/ui/HUD3D.tsx

import React from 'react';

export const HUD3D: React.FC = () => {
    return (
        <>
            {/* å¤´éƒ¨ä¿¡æ¯ - æµ…è‰²æç®€é£æ ¼ */}
            <div className="absolute top-8 left-8 z-10 pointer-events-none select-none">
                <div className="flex items-center gap-4">
                    <div className="w-1.5 h-12 bg-gradient-to-b from-gray-800 to-gray-400 rounded-full"></div>
                    <div>
                        <h1 className="text-4xl font-black tracking-tight text-gray-800">
                            Celestial <span className="text-gray-400 font-light">Fireworks</span>
                        </h1>
                        <p className="text-[10px] text-gray-500 tracking-[0.4em] font-medium uppercase mt-1">
                            Interactive 3D Simulation
                        </p>
                    </div>
                </div>
            </div>

            {/* å³ä¸‹äº’åŠ¨æç¤º - å¡ç‰‡å¼è®¾è®¡ */}
            <div className="absolute bottom-8 right-8 pointer-events-none">
                <div className="bg-white/80 backdrop-blur-md p-5 rounded-2xl shadow-lg border border-white/50 text-gray-600">
                    <p className="text-gray-900 font-bold text-xs mb-3 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-green-400"></span>
                        CONTROL GUIDE
                    </p>
                    <div className="space-y-1.5 text-[10px] font-medium tracking-wide">
                        <div className="flex justify-between w-40">
                            <span>Rotate View</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">LMB / Drag</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Launch</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Click Ground</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Zoom</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Scroll</span>
                        </div>
                        <div className="flex justify-between w-40 mt-2 pt-2 border-t border-gray-200">
                            <span>Pause / Play</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">P</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* åº•éƒ¨è£…é¥°çº¿ */}
            <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-gray-300 to-transparent opacity-50 pointer-events-none"></div>
        </>
    );
};

// END OF FILE: src/components/ui/HUD3D.tsx

// =============================================================================
// FILE: src\components\ui\ModernSettingsPanel.tsx
// =============================================================================

// FILE: src/components/ui/ModernSettingsPanel.tsx
// ç°ä»£åŒ–è®¾ç½®é¢æ¿ - æµ…è‰²ä¸»é¢˜ï¼Œæ•´åˆæ–°ç³»ç»Ÿ - æ¶²æ€ç»ç’ƒé£æ ¼

import React, { useState, useMemo } from 'react';
import { ShapePreviewCard, ShapePreview3D } from './ShapePreviewCard';
import { TrajectoryPreview3D } from './TrajectoryPreview3D';
import { CustomSelect } from './CustomSelect';
import { Shape3DType, SHAPE_3D_INFO, SHAPE_CATEGORIES } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { ComboType } from '../../core/combos/ComboManager';

// å¯¼å…¥ç°æœ‰ç±»å‹ä»¥ä¿æŒå…¼å®¹
import { 
  AppSettings, 
  FireworkConfig, 
  ManualConfig, 
  CarnivalStage,
  LaunchFormation
} from '../../types';

interface ModernSettingsPanelProps {
  show: boolean;
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  onClose: () => void;
  onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
  onUpdateConfig: (config: FireworkConfig) => void;
  onUpdateManual: (config: ManualConfig) => void;
  onRandomize: () => void;
  onReset: () => void;
  onLaunchCarnival: () => void;
}

type TabId = 'shapes' | 'trajectories' | 'manual' | 'carnival' | 'physics';

export const ModernSettingsPanel: React.FC<ModernSettingsPanelProps> = ({
  show,
  settings,
  config,
  manualConfig,
  onClose,
  onUpdate,
  onUpdateConfig,
  onUpdateManual,
  onRandomize,
  onReset,
  onLaunchCarnival
}) => {
  const [activeTab, setActiveTab] = useState<TabId>('shapes');
  const [previewShape, setPreviewShape] = useState<Shape3DType | null>(null);
  const [hoveredTrajectory, setHoveredTrajectory] = useState<TrajectoryType | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<string>(SHAPE_CATEGORIES.BASIC_GEOMETRY);
  
  // çŠ¶æ€åŒæ­¥ä¼˜åŒ–
  const [localSeq, setLocalSeq] = useState<CarnivalStage[]>(config.carnivalSequence || []);
  const [localManualSeq, setLocalManualSeq] = useState<CarnivalStage[]>(config.manualSequence || []); // è™½ç„¶ UI ä¸Šå¯èƒ½ä¸»è¦ç”¨ Locked æ¨¡å¼ï¼Œä½†ä¹Ÿä¿ç•™ Sequence
  const [hasChanges, setHasChanges] = useState(false);
  const [hasManualChanges, setHasManualChanges] = useState(false);

  // å½“å¤–éƒ¨ config å˜åŒ–ä¸”éæœ¬åœ°ç¼–è¾‘å¯¼è‡´æ—¶ï¼ŒåŒæ­¥æ•°æ®
  React.useEffect(() => {
    if (!hasChanges) {
      setLocalSeq(config.carnivalSequence || []);
    }
  }, [config.carnivalSequence, hasChanges]);

  const handleUpdateLocal = (newSeq: CarnivalStage[]) => {
    setLocalSeq(newSeq);
    setHasChanges(true);
  };

  const handleApplySequence = () => {
    onUpdateConfig({ ...config, carnivalSequence: localSeq });
    setHasChanges(false);
  };
  
  // æŒ‰ç±»åˆ«åˆ†ç»„å½¢çŠ¶
  const shapesByCategory = useMemo(() => {
    const groups: Record<string, Shape3DType[]> = {};
    Object.values(Shape3DType).forEach(type => {
      const info = SHAPE_3D_INFO[type];
      if (!groups[info.category]) groups[info.category] = [];
      groups[info.category].push(type);
    });
    return groups;
  }, []);
  
  const [selectedNewShapes, setSelectedNewShapes] = useState<Shape3DType[]>(config.enabledShape3Ds || []);
  const [selectedTrajectories, setSelectedTrajectories] = useState<TrajectoryType[]>(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  
  // åŒæ­¥åˆå§‹åŒ–æ•°æ®ä¸ prop çš„å˜åŒ–
  React.useEffect(() => {
    setSelectedNewShapes(config.enabledShape3Ds || []);
    setSelectedTrajectories(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  }, [config.enabledShape3Ds, config.enabledTrajectories]);

  const toggleNewShape = (type: Shape3DType) => {
    const next = selectedNewShapes.includes(type) 
      ? selectedNewShapes.filter(t => t !== type)
      : [...selectedNewShapes, type];
    setSelectedNewShapes(next);
    onUpdateConfig({ ...config, enabledShape3Ds: next });
  };
  
  const toggleTrajectory = (type: TrajectoryType) => {
    const next = selectedTrajectories.includes(type) 
      ? selectedTrajectories.filter(t => t !== type)
      : [...selectedTrajectories, type];
    setSelectedTrajectories(next);
    onUpdateConfig({ ...config, enabledTrajectories: next });
  };
  
  const tabs = [
    { id: 'shapes' as TabId, label: 'Shape Lab', icon: 'ğŸ¨', title: 'å½¢çŠ¶å®éªŒå®¤' },
    { id: 'trajectories' as TabId, label: 'Path', icon: 'ğŸš€', title: 'è½¨è¿¹è§„åˆ’' },
    { id: 'manual' as TabId, label: 'Interaction', icon: 'ğŸ‘†', title: 'æ‰‹åŠ¨äº¤äº’é…ç½®' },
    { id: 'carnival' as TabId, label: 'Show', icon: 'ğŸ¬', title: 'å¤§ç§€ç¼–æ’' },
    { id: 'physics' as TabId, label: 'Engine', icon: 'âš™ï¸', title: 'ç‰©ç†å¼•æ“' },
  ];

  return (
    <div 
      className={`
        fixed top-0 right-0 h-full w-[480px] 
        bg-white/80 backdrop-blur-3xl 
        shadow-[0_0_50px_rgba(0,0,0,0.1)] z-40 
        transform transition-all duration-500 cubic-bezier(0.2, 0.8, 0.2, 1)
        border-l border-white/60
        flex flex-col
        ${show ? 'translate-x-0' : 'translate-x-full'}
      `}
    >
      {/* ========== Header ========== */}
      <div className="px-6 pt-6 pb-4 border-b border-white/50 bg-gradient-to-b from-white/50 to-transparent">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h2 className="text-2xl font-black text-slate-800 tracking-tight drop-shadow-sm flex items-center gap-2">
              <span className="text-3xl">âœ¨</span>
              Aetheris
            </h2>
            <p className="text-[10px] text-slate-400 font-bold tracking-[0.2em] uppercase ml-1">
              Universal Particle System
            </p>
          </div>
          <button 
            onClick={onClose}
            className="w-10 h-10 rounded-full flex items-center justify-center text-slate-400 hover:text-white hover:bg-slate-800 transition-all shadow-sm border border-white/50"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Tabs */}
        <div className="flex gap-2 bg-slate-100/50 p-1.5 rounded-2xl border border-white/50 shadow-inner overflow-x-auto custom-scrollbar">
          {tabs.map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`
                flex-1 min-w-[70px] py-3 px-2 rounded-xl text-[10px] font-black uppercase tracking-wider
                transition-all relative overflow-hidden group
                ${activeTab === tab.id 
                  ? 'bg-white text-emerald-600 shadow-[0_4px_12px_rgba(16,185,129,0.15)] ring-1 ring-emerald-100' 
                  : 'text-slate-400 hover:text-slate-600 hover:bg-white/40'
                }
              `}
            >
              <div className="flex flex-col items-center gap-1">
                <span className="text-xl filter drop-shadow-sm transition-transform group-hover:scale-110">{tab.icon}</span>
                <span className="scale-90">{tab.label}</span>
              </div>
            </button>
          ))}
        </div>
      </div>
      
      {/* ========== 3D Preview Area (Sticky) ========== */}
      {activeTab === 'shapes' && (
        <ShapePreview3D 
          shapeType={previewShape} 
          className="h-44 border-b border-white/40 bg-gradient-to-b from-slate-50/50 to-white/50"
        />
      )}
      
      {/* ========== Content ========== */}
      <div className="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar bg-white/30">
        
        {/* ===== Tab: Shapes ===== */}
        {activeTab === 'shapes' && (
          <div className="space-y-6">
            <div className="flex flex-wrap gap-2 sticky top-0 bg-white/80 backdrop-blur p-2 -mx-2 rounded-xl z-10 border border-white/50 shadow-sm">
              {Object.values(SHAPE_CATEGORIES).map(cat => (
                <button
                  key={cat}
                  onClick={() => setSelectedCategory(cat)}
                  className={`
                    px-4 py-2 rounded-xl text-[10px] font-bold transition-all border
                    ${selectedCategory === cat 
                      ? 'bg-emerald-500 border-emerald-500 text-white shadow-lg shadow-emerald-500/30' 
                      : 'bg-white border-white text-slate-500 hover:bg-emerald-50 hover:text-emerald-600'
                    }
                  `}
                >
                  {cat}
                </button>
              ))}
            </div>
            
            <div className="grid grid-cols-2 gap-3">
              {shapesByCategory[selectedCategory]?.map(type => (
                <ShapePreviewCard
                  key={type}
                  type={type}
                  active={selectedNewShapes.includes(type)}
                  onClick={() => toggleNewShape(type)}
                  onPreview={setPreviewShape}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Trajectories ===== */}
        {activeTab === 'trajectories' && (
          <div className="space-y-6">
             <div className="h-56 bg-slate-900 rounded-[32px] border-4 border-white shadow-xl overflow-hidden relative group ring-1 ring-slate-900/10">
                <TrajectoryPreview3D 
                   trajectoryType={hoveredTrajectory || (selectedTrajectories.length > 0 ? selectedTrajectories[0] : null)} 
                />
                <div className="absolute top-4 left-4 bg-black/40 backdrop-blur px-3 py-1 rounded-full text-[10px] font-bold text-white/80 border border-white/10">
                   3D Live Preview
                </div>
             </div>

            <div className="grid grid-cols-1 gap-2">
              {Object.values(TrajectoryType).map(type => {
                const info = TRAJECTORY_INFO[type];
                const isSelected = selectedTrajectories.includes(type);
                return (
                  <button
                    key={type}
                    onClick={() => toggleTrajectory(type)}
                    onMouseEnter={() => setHoveredTrajectory(type)}
                    onMouseLeave={() => setHoveredTrajectory(null)}
                    className={`
                      w-full p-4 rounded-2xl border text-left transition-all duration-300 flex items-center justify-between group
                      ${isSelected 
                        ? 'border-emerald-200 bg-white shadow-lg shadow-emerald-100/50 scale-[1.02]' 
                        : 'border-white/60 bg-white/60 hover:bg-white hover:border-emerald-100'
                      }
                    `}
                  >
                    <div className="flex items-center gap-4">
                      <div className={`
                         w-12 h-12 rounded-2xl flex items-center justify-center text-2xl
                         ${isSelected ? 'bg-emerald-50 text-emerald-600' : 'bg-slate-50 text-slate-400 group-hover:bg-emerald-50 group-hover:text-emerald-500'}
                         transition-colors
                      `}>
                         {info.icon}
                      </div>
                      <div>
                        <div className={`text-sm font-black ${isSelected ? 'text-emerald-700' : 'text-slate-600'}`}>
                          {info.name}
                        </div>
                        <p className="text-[10px] text-slate-400 font-medium">{info.description}</p>
                      </div>
                    </div>
                    {isSelected && <div className="text-emerald-500 text-xl">âœ“</div>}
                  </button>
                );
              })}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Manual Interaction ===== */}
        {activeTab === 'manual' && (
          <div className="space-y-8 animate-slideUp">
             {/* Locked Configuration for Manual Click */}
             <div className="bg-white/60 backdrop-blur-xl p-6 rounded-3xl border border-white shadow-sm space-y-5">
                <div className="flex items-center gap-3 mb-2">
                   <div className="p-2 bg-orange-100 text-orange-500 rounded-lg text-lg">ğŸ‘‡</div>
                   <div>
                      <h3 className="text-sm font-black text-slate-800">ç‚¹å‡»äº¤äº’é…ç½®</h3>
                      <p className="text-[10px] text-slate-400 font-bold">é…ç½®é¼ æ ‡ç‚¹å‡»ç©ºç™½å¤„æ—¶çš„å‘å°„è¡Œä¸º</p>
                   </div>
                </div>

                {/* 1. å‘å°„é˜Ÿå½¢ä¸æ•°é‡ */}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="å‘å°„é˜Ÿå½¢" />
                      <CustomSelect 
                         value={manualConfig.lockedFormation || LaunchFormation.SINGLE}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedFormation: v as LaunchFormation })}
                         options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="å•æ¬¡æ•°é‡" />
                      <div className="h-10 flex items-center bg-white/50 rounded-xl px-2 border border-white/50">
                         <input 
                           type="range" min="1" max="20" step="1" 
                           value={manualConfig.lockedCount || 1}
                           onChange={e => onUpdateManual({ ...manualConfig, lockedCount: parseInt(e.target.value) })}
                           className="w-full h-1.5 bg-gray-200 rounded-full appearance-none accent-orange-500 cursor-pointer"
                         />
                         <span className="ml-2 text-xs font-black min-w-[20px] text-right">{manualConfig.lockedCount || 1}</span>
                      </div>
                   </div>
                </div>

                {/* 2. å½¢çŠ¶ä¸è½¨è¿¹é”å®š */}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="é”å®šå½¢çŠ¶" />
                      <CustomSelect 
                         value={manualConfig.lockedShape as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedShape: v as any })}
                         options={[{ label: 'ğŸ² éšæœº', value: 'RANDOM' }, ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))]}
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="é”å®šè½¨è¿¹" />
                      <CustomSelect 
                         value={manualConfig.lockedTrajectory as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedTrajectory: v as any })}
                         options={[{ label: 'ğŸ² éšæœº', value: 'RANDOM' }, ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))]}
                      />
                   </div>
                </div>

                {/* 3. é«˜çº§å‚æ•° */}
                 <div className="space-y-4 pt-4 border-t border-gray-100">
                    <Label text="é«˜çº§å‚æ•° (Advanced)" />
                    <div className="grid grid-cols-2 gap-4">
                       <Slider label="å‘å°„é—´éš” (ms)" value={manualConfig.lockedInterval || 0} min={0} max={500} step={10} onChange={v => onUpdateManual({ ...manualConfig, lockedInterval: v })} color="orange" />
                       <Slider label="å­˜ç»­æ—¶é—´ (s)" value={manualConfig.lockedDuration || 0} min={0} max={10} step={0.5} unit="s" onChange={v => onUpdateManual({ ...manualConfig, lockedDuration: v })} color="orange" />
                    </div>
                </div>
             </div>
             
             {/* Sequence Editor Placeholder */}
             <div className="opacity-50 pointer-events-none filter blur-[1px]">
                 <div className="bg-gray-50 border-2 border-dashed border-gray-200 rounded-3xl p-6 text-center">
                    <p className="text-xs font-black text-gray-400">äº¤äº’å‰§æœ¬ç¼–æ’åŠŸèƒ½ (å¼€å‘ä¸­)</p>
                 </div>
             </div>
          </div>
        )}
        
        {/* ===== Tab: Carnival ===== */}
        {activeTab === 'carnival' && (
          <div className="space-y-6">
            <div className="bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-500 p-6 rounded-[32px] shadow-2xl text-white relative overflow-hidden group">
               {/* Background Glow */}
               <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2 group-hover:bg-white/20 transition-all duration-1000" />
               
               <div className="relative z-10">
                  <div className="flex justify-between items-start mb-6">
                    <div>
                      <h3 className="text-xl font-black tracking-tight">å¤§ç§€ç¼–æ’</h3>
                      <p className="text-[10px] font-bold opacity-60 uppercase tracking-widest mt-1">Direct Your Masterpiece</p>
                    </div>
                   <div className="flex flex-col items-end gap-2">
                      <div className="flex items-center gap-2 bg-black/20 backdrop-blur rounded-full px-1 py-1">
                         <label className="text-[9px] font-black px-3 uppercase opacity-80">Auto Loop</label>
                         <ToggleSwitch checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} color="emerald" customClass="scale-75 origin-right" />
                      </div>
                      {/* è‡ªåŠ¨æ’­æ”¾é—´éš”æ§åˆ¶ */}
                      {settings.enableAutoCarnival && (
                        <div className="flex items-center gap-2 bg-white/10 backdrop-blur rounded-lg px-2 py-1 animate-slideUp">
                           <span className="text-[9px] font-bold opacity-70">Interval</span>
                           <input 
                             type="range" min="1" max="10" step="1" 
                             value={settings.carnivalInterval} 
                             onChange={e => onUpdate('carnivalInterval', parseFloat(e.target.value))}
                             className="w-16 h-1 bg-white/30 rounded-full appearance-none accent-white cursor-pointer"
                           />
                           <span className="text-[9px] font-bold w-4">{settings.carnivalInterval}s</span>
                        </div>
                      )}
                   </div>
                  </div>
                  
                  <div className="flex gap-3">
                     <button 
                       onClick={handleApplySequence}
                       disabled={!hasChanges}
                       className={`
                          flex-1 py-3 rounded-2xl text-xs font-black transition-all border
                          ${hasChanges ? 'bg-white text-indigo-600 border-white shadow-lg' : 'bg-black/20 text-white/40 border-transparent cursor-not-allowed'}
                       `}
                     >
                       {hasChanges ? 'âœ“ åŒæ­¥å‰§æœ¬' : 'å·²åŒæ­¥'}
                     </button>
                     <button 
                       onClick={onLaunchCarnival}
                       className="flex-[2] py-3 bg-white text-slate-900 rounded-2xl text-xs font-black shadow-lg hover:scale-105 active:scale-95 transition-all flex items-center justify-center gap-2"
                     >
                        <span>ğŸ¬</span> ç«‹å³å¯åŠ¨å¤§ç§€
                     </button>
                  </div>
               </div>
            </div>

            <div className="space-y-3 pb-20">
              <div className="flex justify-between items-end px-2">
                 <Label text="WAVE SEQUENCE" />
                 <button
                    onClick={() => {
                      const id = Math.random().toString(36).substr(2, 9);
                      handleUpdateLocal([...localSeq, { id, name: `Wave ${localSeq.length + 1}`, count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.SPHERE, combo: ComboType.SINGLE, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 0 }]);
                    }}
                    className="text-[10px] font-black bg-indigo-50 text-indigo-600 px-3 py-1.5 rounded-lg hover:bg-indigo-100 transition-colors"
                  >
                    + æ·»åŠ æ³¢æ¬¡
                  </button>
              </div>

              {localSeq.map((stage, idx) => (
                <div key={stage.id} className="bg-white p-5 rounded-[24px] border border-gray-100 shadow-sm hover:shadow-md transition-all flex flex-col gap-4 group">
                  <div className="flex justify-between items-center text-[12px] font-black text-slate-700">
                    <div className="flex items-center gap-3 flex-1">
                       <div className="w-6 h-6 rounded-full bg-slate-100 flex items-center justify-center text-[10px] text-slate-400 font-mono">{idx+1}</div>
                       <input 
                          value={stage.name} 
                          onChange={e => {
                            const next = [...localSeq];
                            next[idx] = { ...stage, name: e.target.value };
                            handleUpdateLocal(next);
                          }} 
                          className="bg-transparent outline-none w-full hover:bg-slate-50 focus:bg-slate-50 px-2 rounded transition-colors" 
                       />
                    </div>
                    <button onClick={() => {
                      const next = [...localSeq];
                      next.splice(idx, 1);
                      handleUpdateLocal(next);
                    }} className="text-gray-200 hover:text-red-400 text-lg px-2">Ã—</button>
                  </div>
                  
                  {/* ä¸»è¦å‚æ•° */}
                  <div className="grid grid-cols-2 gap-3">
                     <CustomSelect
                        value={stage.trajectory}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, trajectory: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: 'ğŸ² éšæœºè½¨è¿¹', value: 'RANDOM' },
                          ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))
                        ]}
                     />
                     <CustomSelect
                        value={stage.shape}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, shape: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: 'ğŸ² éšæœºå½¢çŠ¶', value: 'RANDOM' },
                          ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))
                        ]}
                     />
                  </div>
                  
                  {/* è¯¦ç»†å‚æ•°åŒº - é»˜è®¤æ˜¾ç¤ºç®€å•çš„ Grid */}
                  <div className="grid grid-cols-2 gap-x-4 gap-y-3 p-3 bg-slate-50/50 rounded-2xl border border-slate-100">
                      <div className="col-span-2">
                        <Label text="LAUNCH FORMATION" />
                        <CustomSelect
                          value={stage.formation || LaunchFormation.RANDOM}
                          onChange={v => {
                             const next = [...localSeq];
                             next[idx] = { ...stage, formation: v as any };
                             handleUpdateLocal(next);
                          }}
                          options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                        />
                      </div>
                      <Slider label="æ•°é‡" value={stage.count} min={1} max={50} step={1} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, count: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="æ³¢æ¬¡å»¶è¿Ÿ (ms)" value={stage.delay} min={0} max={5000} step={100} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, delay: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="é—´éš” (ms)" value={stage.interval || 0} min={0} max={500} step={10} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, interval: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="å­˜ç»­ (s)" value={stage.duration || 0} min={0} max={10} step={0.5} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, duration: v }; handleUpdateLocal(next);
                      }} />
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Physics ===== */}
        {activeTab === 'physics' && (
          <div className="space-y-6">
            <div className="bg-white/60 p-6 rounded-[32px] border border-white space-y-6">
               <h3 className="text-sm font-black text-slate-800">Global Physics</h3>
               <Slider label="Gravity (é‡åŠ›)" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
               <Slider label="Air Resistance (é˜»åŠ›)" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
               <Slider label="Particle Density (å¯†åº¦)" value={settings.particleCountMultiplier} min={0.1} max={3.0} step={0.1} unit="x" onChange={v => onUpdate('particleCountMultiplier', v)} />
               <Slider label="Explosion Scale (è§„æ¨¡)" value={settings.explosionSizeMultiplier} min={0.5} max={3.0} step={0.1} unit="x" onChange={v => onUpdate('explosionSizeMultiplier', v)} />
            </div>
          </div>
        )}
      </div>

      {/* ========== Footer ========== */}
      <div className="p-4 border-t border-white/60 bg-white/60 backdrop-blur flex gap-3 z-50 shadow-inner">
        <button onClick={onRandomize} className="flex-1 py-3 rounded-xl bg-slate-900 text-white text-xs font-bold hover:bg-emerald-600 transition-all shadow-lg hover:shadow-emerald-500/30">ğŸ² Randomize Physics</button>
        <button onClick={onReset} className="px-6 py-3 rounded-xl bg-white border border-slate-200 text-slate-500 text-xs font-bold hover:bg-red-50 hover:text-red-500 hover:border-red-100 transition-all">Reset All</button>
      </div>
    </div>
  );
};

// ========== Subcomponents ========== //

const Label: React.FC<{ text: string }> = ({ text }) => (
   <div className="text-[9px] font-black text-slate-400 uppercase tracking-wider mb-1.5">{text}</div>
);

const Slider: React.FC<{ label: string, value: number, min: number, max: number, step: number, unit?: string, onChange: (v: number) => void, color?: string }> = ({ label, value, min, max, step, unit = '', onChange, color = 'indigo' }) => (
  <div className="space-y-1.5">
    <div className="flex justify-between items-center text-[10px]">
      <span className="font-bold text-slate-500">{label}</span>
      <span className="font-black text-slate-700 bg-white/50 px-1.5 py-0.5 rounded border border-white">{value.toFixed(step < 1 ? 2 : 0)}{unit}</span>
    </div>
    <input type="range" min={min} max={max} step={step} value={value} onChange={e => onChange(parseFloat(e.target.value))} className={`w-full h-1.5 bg-slate-200 rounded-full appearance-none cursor-pointer accent-${color}-500 hover:accent-${color}-400 transition-all`} />
  </div>
);

const ToggleSwitch: React.FC<{ checked: boolean, onChange: (v: boolean) => void, color?: string, customClass?: string }> = ({ checked, onChange, color = 'emerald', customClass = '' }) => (
  <button onClick={() => onChange(!checked)} className={`w-10 h-6 rounded-full transition-all duration-300 relative border border-transparent ${checked ? `bg-${color}-500 shadow-inner` : 'bg-slate-300'} ${customClass}`}>
    <div className={`absolute top-0.5 w-4 h-4 bg-white rounded-full shadow-md transition-all duration-300 ${checked ? 'left-5' : 'left-1'}`} />
  </button>
);


// =============================================================================
// FILE: src\components\ui\PreviewScene.tsx
// =============================================================================

// FILE: src/components/ui/PreviewScene.tsx

import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { ExplosionType, ColorStyle } from '../../types';
import { Firework3D } from '../../core/Firework3D';
import { ParticlePool3D } from '../../core/ParticlePool3D';

interface PreviewSceneProps {
    shape: ExplosionType;
    colorStyle: ColorStyle;
}

/**
 * ä¸€ä¸ªè¶…è½»é‡çº§çš„ 3D é¢„è§ˆç»„ä»¶ï¼Œç”¨äºåœ¨é…ç½®é¢æ¿ä¸­å±•ç¤ºçƒŸèŠ±æ•ˆæœ
 */
export const PreviewScene: React.FC<PreviewSceneProps> = ({ shape, colorStyle }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
    const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(2000));
    const fireworksRef = useRef<Firework3D[]>([]);

    useEffect(() => {
        if (!containerRef.current) return;

        const width = containerRef.current.clientWidth;
        const height = containerRef.current.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8fafc); // æµ…è‰²èƒŒæ™¯ç¬¦åˆç°ä»£ UI

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
        camera.position.set(0, 0, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // ç®€åŒ–çš„ç²’å­ç³»ç»Ÿ
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            transparent: true,
            blending: THREE.NormalBlending, // é¢„è§ˆä½¿ç”¨æ­£å¸¸æ··åˆä»¥åŒ¹é…æµ…è‰²èƒŒæ™¯
            depthWrite: false
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        let lastSpawn = 0;
        let requestID: number;

        const animate = (time: number) => {
            requestID = requestAnimationFrame(animate);

            // æ¯éš” 1.5 ç§’è‡ªåŠ¨è§¦å‘ä¸€æ¬¡é¢„è§ˆçˆ†ç‚¸
            if (time - lastSpawn > 1500) {
                const fw = new Firework3D(
                    { startX: 0, startZ: 0, targetX: 0, targetY: 0, targetZ: 0, hue: Math.random() * 360, charge: 1.0 },
                    { gravity: 0.1, friction: 0.95, autoLaunchDelay: 1000, particleCountMultiplier: 1, explosionSizeMultiplier: 1, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                    { enabledShapes: [shape], enabledAscensions: [], enabledColors: [colorStyle] }
                );
                fw.exploded = true; // ç›´æ¥è®¾ç½®ä¸ºçˆ†ç‚¸çŠ¶æ€
                fireworksRef.current = [fw];
                lastSpawn = time;
            }

            fireworksRef.current.forEach((fw, i) => {
                if (fw.exploded) {
                    fw.createExplosion(
                        { gravity: 0.05, friction: 0.95, autoLaunchDelay: 0, particleCountMultiplier: 1, explosionSizeMultiplier: 0.8, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                        (opts) => particlePoolRef.current.get(opts)
                    );
                    fireworksRef.current.splice(i, 1);
                }
            });

            particlePoolRef.current.update(0.016);

            // æ›´æ–° Buffer æ•°æ®
            const particles = particlePoolRef.current.getActiveParticles();
            const pos = new Float32Array(particles.length * 3);
            const col = new Float32Array(particles.length * 3);

            particles.forEach((p, i) => {
                pos[i * 3] = p.position.x; pos[i * 3 + 1] = p.position.y; pos[i * 3 + 2] = p.position.z;
                const c = p.getColor();
                col[i * 3] = c.r; col[i * 3 + 1] = c.g; col[i * 3 + 2] = c.b;
            });

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            renderer.render(scene, camera);
        };

        requestID = requestAnimationFrame(animate);

        return () => {
            cancelAnimationFrame(requestID);
            renderer.dispose();
            if (containerRef.current) containerRef.current.innerHTML = '';
        };
    }, [shape, colorStyle]);

    return (
        <div className="w-full h-full relative group">
            <div ref={containerRef} className="w-full h-full" />
            <div className="absolute inset-0 pointer-events-none border-2 border-dashed border-gray-200 rounded-xl m-2 group-hover:border-blue-400 transition-colors" />
            <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-[10px] font-black text-gray-300 uppercase tracking-widest">
                Live 3D Preview
            </div>
        </div>
    );
};

// END OF FILE: src/components/ui/PreviewScene.tsx

// =============================================================================
// FILE: src\components\ui\SettingsPanel.tsx
// =============================================================================

// FILE: src/components/ui/SettingsPanel.tsx

import React, { useState } from 'react';
import { AppSettings, FireworkConfig, ManualConfig, ExplosionType, AscensionType, ColorStyle, SHAPE_ICONS, COLOR_ICONS, ASCENSION_ICONS } from '../../types';
import { PreviewScene } from './PreviewScene';

interface SettingsPanelProps {
    show: boolean;
    settings: AppSettings;
    config: FireworkConfig;
    manualConfig: ManualConfig;
    onClose: () => void;
    onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
    onUpdateConfig: (config: FireworkConfig) => void;
    onUpdateManual: (config: ManualConfig) => void;
    onRandomize: () => void;
    onReset: () => void;
}

export const SettingsPanel: React.FC<SettingsPanelProps> = ({
                                                                show, settings, config, manualConfig, onClose, onUpdate, onUpdateConfig, onUpdateManual, onRandomize, onReset
                                                            }) => {
    const [activeTab, setActiveTab] = useState<'carnival' | 'manual' | 'physics'>('carnival');

    // è·å–å½“å‰é¢„è§ˆçš„å¯¹è±¡
    const previewShape = activeTab === 'manual' && manualConfig.lockedShape !== 'RANDOM'
        ? (manualConfig.lockedShape as ExplosionType)
        : ExplosionType.SPHERE;

    const previewColor = activeTab === 'manual' && manualConfig.lockedColor !== 'RANDOM'
        ? (manualConfig.lockedColor as ColorStyle)
        : ColorStyle.RAINBOW;

    return (
        <div className={`absolute top-0 right-0 h-full w-[450px] bg-white/95 backdrop-blur-3xl shadow-2xl z-40 transform transition-transform duration-500 ease-[cubic-bezier(0.23,1,0.32,1)] border-l border-gray-200 flex flex-col ${show ? 'translate-x-0' : 'translate-x-full'}`}>

            {/* 1. Panel Header */}
            <div className="p-6 pb-2 border-b border-gray-100">
                <div className="flex justify-between items-center mb-6">
                    <div>
                        <h2 className="text-2xl font-black tracking-tighter text-gray-800 italic">DESIGNER <span className="text-blue-600">HUB</span></h2>
                        <p className="text-[10px] text-gray-400 font-bold uppercase tracking-[0.2em] mt-1">Configure & Preview Your Show</p>
                    </div>
                    <button onClick={onClose} className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-50 text-gray-400 hover:bg-red-50 hover:text-red-500 transition-all border border-gray-100">âœ•</button>
                </div>

                {/* 2. Navigation Tabs */}
                <div className="flex p-1 bg-gray-100 rounded-2xl mb-4">
                    {[
                        { id: 'carnival', label: 'å˜‰å¹´åé…ç½®', icon: 'ğŸ¡' },
                        { id: 'manual', label: 'å•å‘è®¾è®¡', icon: 'ğŸ¯' },
                        { id: 'physics', label: 'å¼•æ“æ ¸å¿ƒ', icon: 'âš¡' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id as any)}
                            className={`flex-1 py-3 text-xs font-black rounded-xl transition-all flex items-center justify-center gap-2 ${activeTab === tab.id ? 'bg-white shadow-lg text-blue-600 scale-[1.02]' : 'text-gray-400 hover:text-gray-600'}`}
                        >
                            <span>{tab.icon}</span>{tab.label}
                        </button>
                    ))}
                </div>
            </div>

            {/* 3. Main Content Scroll Area */}
            <div className="flex-1 overflow-y-auto custom-scrollbar p-6 space-y-8">

                {/* === å®æ—¶ 3D é¢„è§ˆçª—å£ === */}
                <div className="h-48 bg-gray-50 rounded-3xl overflow-hidden border border-gray-100 shadow-inner relative">
                    <PreviewScene shape={previewShape} colorStyle={previewColor} />
                </div>

                {/* --- Tab 1: Carnival --- */}
                {activeTab === 'carnival' && (
                    <div className="space-y-8 animate-fadeIn">
                        <section className="bg-gradient-to-br from-blue-50 to-indigo-50 p-5 rounded-3xl border border-blue-100/50">
                            <div className="flex justify-between items-center mb-4">
                                <span className="text-xs font-black text-blue-900 uppercase">è‡ªåŠ¨è½®æ’­å˜‰å¹´å</span>
                                <Toggle checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} />
                            </div>
                            <SettingSlider label="å‘å°„æ³¢æ¬¡é¢‘ç‡" value={settings.carnivalInterval} min={1} max={15} step={1} unit="s" onChange={v => onUpdate('carnivalInterval', v)} />
                        </section>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-300 uppercase tracking-[0.3em] mb-4">å¯ç”¨å½¢çŠ¶é›†</h3>
                            <div className="grid grid-cols-2 gap-3">
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={config.enabledShapes.includes(t)}
                                        onClick={() => onUpdateConfig({...config, enabledShapes: config.enabledShapes.includes(t) ? config.enabledShapes.filter(s => s !== t) : [...config.enabledShapes, t]})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 2: Manual --- */}
                {activeTab === 'manual' && (
                    <div className="space-y-8 animate-fadeIn">
                        <div className="bg-gray-50 p-4 rounded-2xl text-[11px] text-gray-500 font-medium italic border-l-4 border-blue-400">
                            æç¤ºï¼šå•å‘æ¨¡å¼é…ç½®é¼ æ ‡ç‚¹å‡»æ—¶çš„å›ºå®šæ ·å¼ã€‚è‹¥è®¾ä¸ºâ€œéšæœºâ€ï¼Œåˆ™éµå¾ªå˜‰å¹´åç™½åå•ã€‚
                        </div>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-400 uppercase tracking-[0.3em] mb-4">é”å®šå•å‘å½¢çŠ¶</h3>
                            <div className="grid grid-cols-2 gap-3">
                                <div onClick={() => onUpdateManual({...manualConfig, lockedShape: 'RANDOM'})} className={`p-4 rounded-2xl border-2 transition-all cursor-pointer flex items-center gap-4 ${manualConfig.lockedShape === 'RANDOM' ? 'border-blue-500 bg-blue-50/50' : 'border-gray-100 hover:border-gray-200'}`}>
                                    <div className="text-2xl">ğŸ²</div>
                                    <div className="font-black text-xs text-gray-700">éšæœºå½¢çŠ¶</div>
                                </div>
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={manualConfig.lockedShape === t}
                                        onClick={() => onUpdateManual({...manualConfig, lockedShape: t})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 3: Physics --- */}
                {activeTab === 'physics' && (
                    <div className="space-y-6 animate-fadeIn">
                        <SettingSlider label="å…¨å±€é‡åŠ›" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
                        <SettingSlider label="å¤§æ°”ç²˜åº¦" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
                        <SettingSlider label="ç²’å­å¯†åº¦å€ç‡" value={settings.particleCountMultiplier} min={0.2} max={2.0} step={0.1} onChange={v => onUpdate('particleCountMultiplier', v)} />
                    </div>
                )}
            </div>

            {/* 4. Footer Actions */}
            <div className="p-6 border-t border-gray-100 bg-gray-50/30 flex gap-4">
                <button onClick={onRandomize} className="flex-1 py-4 bg-gray-900 text-white rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-blue-600 transition-all shadow-xl active:scale-95">ğŸ² éšæœºåŒ–å‚æ•°</button>
                <button onClick={onReset} className="px-6 py-4 bg-white border border-gray-200 text-gray-400 rounded-2xl text-[10px] font-black uppercase hover:text-red-500 transition-all">é‡ç½®</button>
            </div>
        </div>
    );
};

// --- å­ç»„ä»¶: æ ·å¼åŒ–å¡ç‰‡ ---

const ShapeCard = ({ type, active, onClick }: { type: ExplosionType, active: boolean, onClick: () => void }) => (
    <div
        onClick={onClick}
        className={`group relative p-4 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden ${active ? 'border-blue-500 bg-blue-50/50 shadow-lg scale-[1.02]' : 'border-gray-50 bg-white hover:border-gray-200'}`}
    >
        <div className="flex items-center gap-3">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-lg ${active ? 'bg-white' : 'bg-gray-50'}`}>
                {SHAPE_ICONS[type]}
            </div>
            <div className="flex flex-col">
                <span className={`text-[10px] font-black uppercase tracking-tighter ${active ? 'text-blue-600' : 'text-gray-700'}`}>{type}</span>
                <span className="text-[8px] text-gray-400 font-bold uppercase tracking-widest">FIREWORK</span>
            </div>
        </div>
        {/* CSS è£…é¥°èƒŒæ™¯ */}
        <div className={`absolute -right-2 -bottom-2 w-12 h-12 opacity-[0.03] group-hover:opacity-[0.08] transition-opacity ${active ? 'text-blue-600' : 'text-black'}`}>
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>
        </div>
    </div>
);

const SettingSlider = ({ label, value, min, max, step, unit = '', onChange }: any) => (
    <div className="space-y-3">
        <div className="flex justify-between items-center">
            <span className="text-[10px] font-black text-gray-400 uppercase tracking-widest">{label}</span>
            <span className="bg-gray-100 text-gray-600 px-2 py-0.5 rounded-lg text-[10px] font-mono font-bold">{value.toFixed(2)}{unit}</span>
        </div>
        <input
            type="range" min={min} max={max} step={step} value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="w-full h-1.5 bg-gray-100 rounded-full appearance-none cursor-pointer accent-blue-600"
        />
    </div>
);

const Toggle = ({ checked, onChange }: { checked: boolean, onChange: (v: boolean) => void }) => (
    <button
        onClick={() => onChange(!checked)}
        className={`w-10 h-5 rounded-full transition-colors relative ${checked ? 'bg-blue-600' : 'bg-gray-200'}`}
    >
        <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-transform ${checked ? 'left-6' : 'left-1'}`} />
    </button>
);

// END OF FILE: src/components/ui/SettingsPanel.tsx

// =============================================================================
// FILE: src\components\ui\ShapePreviewCard.tsx
// =============================================================================

// FILE: src/components/ui/ShapePreviewCard.tsx
// å½¢çŠ¶é¢„è§ˆå¡ç‰‡ç»„ä»¶ - ç‚¹å‡»æ—¶åœ¨é¡¶éƒ¨æ˜¾ç¤º3Dé¢„è§ˆ

import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { Shape3DFactory, Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';

interface ShapePreviewCardProps {
  type: Shape3DType;
  active: boolean;
  onClick: () => void;
  onPreview?: (type: Shape3DType) => void;
}

/**
 * å½¢çŠ¶é¢„è§ˆå¡ç‰‡
 * æ”¯æŒæ‚¬åœé¢„è§ˆå’Œç‚¹å‡»é€‰ä¸­
 */
export const ShapePreviewCard: React.FC<ShapePreviewCardProps> = ({
  type,
  active,
  onClick,
  onPreview
}) => {
  const info = SHAPE_3D_INFO[type];
  
  return (
    <div
      onClick={onClick}
      onMouseEnter={() => onPreview?.(type)}
      className={`
        group relative p-3 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden
        ${active 
          ? 'border-emerald-400 bg-gradient-to-br from-emerald-50 to-teal-50 shadow-lg scale-[1.02]' 
          : 'border-gray-100 bg-white/80 hover:border-emerald-200 hover:shadow-md'
        }
      `}
    >
      <div className="flex items-center gap-3">
        {/* å›¾æ ‡ */}
        <div className={`
          w-10 h-10 rounded-xl flex items-center justify-center text-xl
          transition-all
          ${active ? 'bg-white shadow-sm' : 'bg-gray-50 group-hover:bg-emerald-50'}
        `}>
          {info.icon}
        </div>
        
        {/* æ–‡å­— */}
        <div className="flex flex-col flex-1 min-w-0">
          <span className={`
            text-[11px] font-bold truncate
            ${active ? 'text-emerald-700' : 'text-gray-700'}
          `}>
            {info.name}
          </span>
          <span className={`
            text-[9px] truncate
            ${active ? 'text-emerald-500' : 'text-gray-400'}
          `}>
            {info.category}
          </span>
        </div>
        
        {/* é€‰ä¸­æ ‡è®° */}
        {active && (
          <div className="w-5 h-5 rounded-full bg-emerald-400 flex items-center justify-center">
            <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
            </svg>
          </div>
        )}
      </div>
      
      {/* æ‚¬åœæç¤º */}
      <div className="
        absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-1.5
        bg-gray-900 text-white text-[10px] rounded-lg
        opacity-0 group-hover:opacity-100 transition-opacity
        pointer-events-none whitespace-nowrap z-50
      ">
        {info.description}
        <div className="absolute top-full left-1/2 -translate-x-1/2 border-4 border-transparent border-t-gray-900" />
      </div>
    </div>
  );
};

/**
 * 3D å®æ—¶é¢„è§ˆçª—å£
 */
interface ShapePreview3DProps {
  shapeType: Shape3DType | null;
  className?: string;
}

export const ShapePreview3D: React.FC<ShapePreview3DProps> = ({
  shapeType,
  className = ''
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const pointsRef = useRef<THREE.Points | null>(null);
  const frameRef = useRef<number>(0);
  
  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    // åœºæ™¯
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);
    sceneRef.current = scene;
    
    // ç›¸æœº
    const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
    camera.position.set(0, 0, 100);
    cameraRef.current = camera;
    
    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // ç²’å­ç³»ç»Ÿ
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(3000 * 3);
    const colors = new Float32Array(3000 * 3);
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
      size: 3,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true
    });
    
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    pointsRef.current = points;
    
    // åŠ¨ç”»
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (pointsRef.current) {
        pointsRef.current.rotation.y += 0.01;
        pointsRef.current.rotation.x += 0.003;
      }
      
      renderer.render(scene, camera);
    };
    animate();
    
    // æ¸…ç†
    return () => {
      cancelAnimationFrame(frameRef.current);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
      container.removeChild(renderer.domElement);
    };
  }, []);
  
  // æ›´æ–°å½¢çŠ¶
  useEffect(() => {
    if (!pointsRef.current || !shapeType) return;
    
    const shape3DPoints = Shape3DFactory.generate(shapeType, 500, 1, 180);
    const geometry = pointsRef.current.geometry;
    const positions = geometry.attributes.position.array as Float32Array;
    const colors = geometry.attributes.color.array as Float32Array;
    
    // æ¸…ç©º
    positions.fill(0);
    colors.fill(0);
    
    // å¡«å……æ–°ç‚¹
    for (let i = 0; i < Math.min(shape3DPoints.length, 1000); i++) {
      const point = shape3DPoints[i];
      const idx = i * 3;
      
      positions[idx] = point.position.x;
      positions[idx + 1] = point.position.y;
      positions[idx + 2] = point.position.z;
      
      // HSL to RGB
      const h = point.hue / 360;
      const s = 0.7;
      const l = 0.6;
      const { r, g, b } = hslToRgb(h, s, l);
      
      colors[idx] = r;
      colors[idx + 1] = g;
      colors[idx + 2] = b;
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
  }, [shapeType]);
  
  const info = shapeType ? SHAPE_3D_INFO[shapeType] : null;
  
  return (
    <div className={`relative overflow-hidden ${className}`}>
      <div ref={containerRef} className="w-full h-full" />
      
      {/* ä¿¡æ¯è¦†ç›– */}
      {info && (
        <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-white/90 to-transparent">
          <div className="flex items-center gap-2">
            <span className="text-xl">{info.icon}</span>
            <div>
              <div className="text-sm font-bold text-gray-800">{info.name}</div>
              <div className="text-[10px] text-gray-500">{info.description}</div>
            </div>
          </div>
        </div>
      )}
      
      {/* ç©ºçŠ¶æ€ */}
      {!shapeType && (
        <div className="absolute inset-0 flex items-center justify-center text-gray-300">
          <div className="text-center">
            <div className="text-3xl mb-2">âœ¨</div>
            <div className="text-xs font-medium">æ‚¬åœå½¢çŠ¶å¡ç‰‡ä»¥é¢„è§ˆ</div>
          </div>
        </div>
      )}
    </div>
  );
};

// HSL to RGB è½¬æ¢
function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  let r: number, g: number, b: number;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return { r, g, b };
}

// END OF FILE: src/components/ui/ShapePreviewCard.tsx


// =============================================================================
// FILE: src\components\ui\TimeControlPanel.tsx
// =============================================================================

// FILE: src/components/ui/TimeControlPanel.tsx

import React from 'react';
import { TimeController } from '../../core/TimeController';

interface TimeControlPanelProps {
  timeController: TimeController | null;
  stats: {
    particles: number;
    fireworks: number;
    fps: number;
  };
  onTimeScaleChange: (scale: number) => void;
  onTogglePause: () => void;
  autoRotate: boolean;
  onToggleAutoRotate: () => void;
}

export const TimeControlPanel: React.FC<TimeControlPanelProps> = ({
                                                                    timeController,
                                                                    stats,
                                                                    onTimeScaleChange,
                                                                    onTogglePause,
                                                                    autoRotate,
                                                                    onToggleAutoRotate
                                                                  }) => {
  const timeScale = timeController?.timeScale ?? 1;
  const isPaused = timeController?.isPaused ?? false;

  return (
      <div className="absolute bottom-8 left-8 z-30 flex flex-col gap-3">
        {/* ç°ä»£åŒ–æµ…è‰²å¡ç‰‡ */}
        <div className="bg-white/80 backdrop-blur-xl rounded-2xl p-4 shadow-xl border border-white/50 w-64 transition-all hover:shadow-2xl hover:scale-[1.02]">

          {/* æ ‡é¢˜æ  */}
          <div className="flex justify-between items-center mb-4">
          <span className="text-gray-800 text-xs font-bold tracking-wider flex items-center gap-2">
             <span className="text-lg">âš™ï¸</span> ENGINE
          </span>
            <div className="flex gap-2 items-center bg-gray-100 px-2 py-1 rounded-lg">
              <div className={`w-1.5 h-1.5 rounded-full ${isPaused ? 'bg-amber-400 animate-pulse' : 'bg-green-500'}`}></div>
              <span className="text-[10px] font-mono text-gray-500 font-bold">{stats.fps} FPS</span>
            </div>
          </div>

          {/* æ§åˆ¶æŒ‰é’®ç½‘æ ¼ */}
          <div className="grid grid-cols-2 gap-2 mb-4">
            <button
                onClick={onTogglePause}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    isPaused
                        ? 'bg-amber-50 text-amber-600 border-amber-200 hover:bg-amber-100'
                        : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50 hover:text-gray-900'
                }`}
            >
              {isPaused ? 'â–¶ RESUME' : 'â¸ PAUSE'}
            </button>

            <button
                onClick={onToggleAutoRotate}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    autoRotate
                        ? 'bg-blue-50 text-blue-600 border-blue-200 hover:bg-blue-100'
                        : 'bg-white text-gray-400 border-gray-200 hover:bg-gray-50 hover:text-gray-600'
                }`}
            >
              {autoRotate ? 'â†º ROTATING' : 'âŠ˜ STATIC'}
            </button>
          </div>

          {/* é€Ÿåº¦æ»‘å— */}
          <div className="bg-gray-50 rounded-xl p-3 border border-gray-100">
            <div className="flex justify-between text-[10px] text-gray-400 mb-2 font-bold uppercase">
              <span>Time Scale</span>
              <span className="text-gray-800">{timeScale.toFixed(1)}x</span>
            </div>
            <input
                type="range"
                min="0.1"
                max="3"
                step="0.1"
                value={timeScale}
                onChange={(e) => onTimeScaleChange(parseFloat(e.target.value))}
                className="w-full h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer accent-gray-700 hover:accent-blue-600 transition-all"
            />
            <div className="flex justify-between mt-1 text-[8px] text-gray-300 font-mono">
              <span>SLOW</span>
              <span>FAST</span>
            </div>
          </div>

          {/* åº•éƒ¨ç»Ÿè®¡ä¿¡æ¯ */}
          <div className="mt-4 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[9px] text-gray-400 font-mono">
            <div>
              <span className="block text-gray-300 uppercase text-[8px]">Particles</span>
              <span className="font-bold text-gray-600">{(stats.particles/1000).toFixed(1)}k</span>
            </div>
            <div className="text-right">
              <span className="block text-gray-300 uppercase text-[8px]">Fireworks</span>
              <span className="font-bold text-gray-600">{stats.fireworks}</span>
            </div>
          </div>
        </div>
      </div>
  );
};

// END OF FILE: src/components/ui/TimeControlPanel.tsx

// =============================================================================
// FILE: src\components\ui\TrajectoryPreview3D.tsx
// =============================================================================

// FILE: src/components/ui/TrajectoryPreview3D.tsx
// 3D è½¨è¿¹é¢„è§ˆç»„ä»¶ - åŠ¨æ€ç²’å­è·¯å¾„æ¼”ç¤ºç‰ˆæœ¬

import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { TrajectoryType, TrajectoryFactory, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { Vector3 } from '../../core/Vector3';

interface TrajectoryPreview3DProps {
  trajectoryType: TrajectoryType | null;
  className?: string;
}

export const TrajectoryPreview3D: React.FC<TrajectoryPreview3DProps> = ({
  trajectoryType,
  className = ''
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  
  // åŠ¨ç”»çŠ¶æ€å¼•ç”¨
  const projectileRef = useRef<THREE.Mesh | null>(null);
  const trailRef = useRef<THREE.Line | null>(null);
  const trailPointsRef = useRef<THREE.Vector3[]>([]);
  const frameRef = useRef<number>(0);
  const timeRef = useRef<number>(0);
  const calculatorRef = useRef<any>(null); // TrajectoryCalculator
  const currentPosRef = useRef<Vector3>(new Vector3(0, -10, 0));
  const currentVelRef = useRef<Vector3>(new Vector3(0, 15, 0));
  
  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    
    // åœºæ™¯
    const scene = new THREE.Scene();
    sceneRef.current = scene;
    
    // ç›¸æœº (æ­£äº¤ç›¸æœºå¯èƒ½æ›´é€‚åˆç®€å•çš„è·¯å¾„å±•ç¤ºï¼Œä½†é€è§†æ›´çœŸå®)
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 5, 50); // æ‹‰è¿œä¸€ç‚¹
    cameraRef.current = camera;
    
    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // è¾…åŠ©ç½‘æ ¼ (åœ°æ¿)
    const grid = new THREE.GridHelper(30, 20, 0x444444, 0x222222);
    grid.position.y = -15;
    scene.add(grid);

    // åŠ¨ç”»å¾ªç¯
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
         updatePhysics();
         
         // ç®€å•çš„ç›¸æœºæ—‹è½¬
         camera.position.x = Math.sin(Date.now() * 0.0005) * 45;
         camera.position.z = Math.cos(Date.now() * 0.0005) * 45;
         camera.lookAt(0, 5, 0);

         rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };
    animate();
    
    // Resize Observer
    const handleResize = () => {
      if (containerRef.current && cameraRef.current && rendererRef.current) {
        const w = containerRef.current.clientWidth;
        const h = containerRef.current.clientHeight;
        cameraRef.current.aspect = w / h;
        cameraRef.current.updateProjectionMatrix();
        rendererRef.current.setSize(w, h);
      }
    };
    window.addEventListener('resize', handleResize);
    
    return () => {
      cancelAnimationFrame(frameRef.current);
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      if (container.contains(renderer.domElement)) {
        container.removeChild(renderer.domElement);
      }
    };
  }, []);

  const resetSimulation = () => {
      timeRef.current = 0;
      currentPosRef.current = new Vector3(0, -15, 0); // åº•éƒ¨å¼€å§‹
      currentVelRef.current = new Vector3(0, 20, 0); // åˆå§‹å‘ä¸Šé€Ÿåº¦
      trailPointsRef.current = [];
      
      if (calculatorRef.current && projectileRef.current) {
          // Reset projectile pos
          projectileRef.current.position.set(0, -15, 0);
          projectileRef.current.visible = true;
          (projectileRef.current.material as THREE.MeshBasicMaterial).opacity = 1;
      }
      
      // Reset Calculator state
      if (trajectoryType) {
          calculatorRef.current = TrajectoryFactory.create(trajectoryType);
      }
  };
  
  // æ›´æ–°è½¨è¿¹ç±»å‹
  useEffect(() => {
    if (!sceneRef.current) return;
    
    // æ¸…ç†
    if (projectileRef.current) sceneRef.current.remove(projectileRef.current);
    if (trailRef.current) sceneRef.current.remove(trailRef.current);
    
    if (trajectoryType) {
        // åˆ›å»ºæ–°çš„å‘å°„ç‰© (Glowing Orb)
        const geometry = new THREE.SphereGeometry(0.8, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0x4ade80 });
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add Glow Sprite?? Maybe too complex used simplified sphere
        
        sceneRef.current.add(mesh);
        projectileRef.current = mesh;
        
        // åˆ›å»ºæ‹–å°¾çº¿æ¡å¯¹è±¡
        const lineGeo = new THREE.BufferGeometry();
        const lineMat = new THREE.LineBasicMaterial({ 
            color: 0x4ade80, 
            transparent: true, 
            opacity: 0.5,
            linewidth: 2 
        });
        const line = new THREE.Line(lineGeo, lineMat);
        sceneRef.current.add(line);
        trailRef.current = line;

        resetSimulation();
    }
  }, [trajectoryType]);

  const updatePhysics = () => {
      if (!calculatorRef.current || !projectileRef.current || !trailRef.current) return;

      const dt = 0.016; // Fixed step
      timeRef.current += dt;

      // æ¨¡æ‹Ÿé‡åŠ›
      const gravity = 0.1;
      
      // 1. Calculate next velocity
      let oldVel = currentVelRef.current.clone();
      let newVel = calculatorRef.current.calculate(oldVel, gravity, dt); // calculate modifies internal state
      currentVelRef.current = newVel;
      
      // 2. Update position
      // Add some scaling for visualization
      const speedScale = 0.8;
      currentPosRef.current.x += newVel.x * dt * 5 * speedScale;
      currentPosRef.current.y += newVel.y * dt * 5 * speedScale;
      currentPosRef.current.z += newVel.z * dt * 5 * speedScale; // 3D depth

      // 3. Update Visuals
      projectileRef.current.position.set(
          currentPosRef.current.x,
          currentPosRef.current.y,
          currentPosRef.current.z
      );

      // Track trail
      trailPointsRef.current.push(new THREE.Vector3(
          currentPosRef.current.x,
          currentPosRef.current.y,
          currentPosRef.current.z
      ));
      
      // Limit trail length
      if (trailPointsRef.current.length > 100) {
          trailPointsRef.current.shift();
      }
      
      // Update trail geometry
      trailRef.current.geometry.setFromPoints(trailPointsRef.current);
      
      // Reset if too high or too long
      if (currentPosRef.current.y > 20 || timeRef.current > 3.0) {
          // Fade out then reset? Just reset for now
          resetSimulation();
      }
  };
  
  // è·å–å½“å‰è½¨è¿¹ä¿¡æ¯
  const info = trajectoryType ? TRAJECTORY_INFO[trajectoryType] : null;

  return (
    <div className={`relative w-full h-full overflow-hidden ${className}`}>
      {/* 3D Canvas */}
      <div ref={containerRef} className="absolute inset-0 z-0" />
      
      {/* Info Overlay */}
      <div className="absolute inset-0 flex flex-col items-center justify-end pb-4 pointer-events-none z-10">
        {!trajectoryType ? (
           <div className="text-white/40 text-xs font-bold uppercase tracking-widest bg-black/20 px-4 py-2 rounded-full backdrop-blur-sm">
             Select a Path
           </div>
        ) : (
           <div className="flex flex-col items-center gap-1 animate-slideUp">
             <div className="w-1.5 h-1.5 rounded-full bg-emerald-500 animate-ping absolute -top-4" />
             <div className="text-[10px] font-black text-emerald-300 uppercase tracking-[0.2em] drop-shadow-md bg-black/60 backdrop-blur-md px-3 py-1 rounded-full border border-emerald-500/30">
                Simulating: {info?.name}
             </div>
           </div>
        )}
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\components\ui\TutorialOverlay.tsx
// =============================================================================

// FILE: src/components/ui/TutorialOverlay.tsx
// å¼•å¯¼æ•™ç¨‹è¦†ç›–å±‚ - å¸®åŠ©ç”¨æˆ·äº†è§£å¦‚ä½•ä½¿ç”¨æ¨¡æ‹Ÿå™¨ (å¢å¼ºç‰ˆ)

import React, { useState, useEffect } from 'react';

interface TutorialStep {
  id: string;
  title: string;
  description: string;
  icon: string;
  position: 'center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'top-left';
  highlight?: string; // CSS selector to highlight
}

const TUTORIAL_STEPS: TutorialStep[] = [
  {
    id: 'welcome',
    title: 'æ¬¢è¿æ¥åˆ° Aetheris âœ¨',
    description: 'è¿™æ˜¯ä¸€ä¸ªæ¢ç´¢å…‰ä¸ç‰©ç†çš„ 3D ç²’å­å·¥åŠã€‚åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥æŒ‡æŒ¥æ˜Ÿç³»è¯ç”Ÿï¼Œç¼–æ’çƒŸèŠ±å¤§ç§€ï¼Œä½“éªŒçº¯ç²¹çš„è§†è§‰è‰ºæœ¯ã€‚',
    icon: 'ğŸ†',
    position: 'center'
  },
  {
    id: 'basic-nav',
    title: 'åŸºæœ¬äº¤äº’',
    description: 'ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨ï¼šæ—‹è½¬è§†è§’\nğŸ–±ï¸ å³é”®æ‹–åŠ¨ï¼šå¹³ç§»è§†è§’\nğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾è·ç¦»\nğŸ‘† ç‚¹å‡»ä»»æ„ç©ºç™½å¤„ï¼šåœ¨è¯¥ä½ç½®å‘å°„ä¸€æœµçƒŸèŠ±ï¼',
    icon: 'ğŸ®',
    position: 'center'
  },
  {
    id: 'workshop',
    title: 'åˆ›æ„å·¥åŠ (Workshop)',
    description: 'å³ä¸Šè§’çš„ã€åˆ›æ„å·¥åŠã€‘æ˜¯æ‚¨çš„åˆ›é€ ä¸­å¿ƒã€‚åœ¨è¿™é‡Œæ‚¨å¯ä»¥ï¼š\n- æŒ‘é€‰å‡ åç§é«˜çº§ 3D å½¢çŠ¶ (å…‹è±å› ç“¶ã€çˆ±å¿ƒã€èºæ—‹...)\n- é¢„è§ˆå¹¶é€‰æ‹©ç‹¬ç‰¹çš„ä¸Šå‡è½¨è¿¹\n- ç¼–æ’è‡ªåŠ¨åŒ–çš„çƒŸèŠ±å¤§ç§€å‰§æœ¬',
    icon: 'ğŸ¨',
    position: 'top-right'
  },
  {
    id: 'trajectory-preview',
    title: 'å…¨æ–°ï¼è½¨è¿¹é¢„è§ˆ',
    description: 'è¿›å…¥åˆ›æ„å·¥åŠçš„â€œä¸Šå‡è½¨è¿¹â€é¢æ¿ï¼Œå°†é¼ æ ‡æ‚¬æµ®åœ¨è½¨è¿¹å¡ç‰‡ä¸Šï¼Œå³å¯çœ‹åˆ°é€¼çœŸçš„ 3D è·¯å¾„åŠ¨æ€é¢„è§ˆï¼æ‰€è§å³æ‰€å¾—ã€‚',
    icon: 'ğŸš€',
    position: 'top-right'
  },
  {
    id: 'time-control',
    title: 'æ—¶ç©ºæ§åˆ¶å°',
    description: 'åº•éƒ¨çš„æ§åˆ¶é¢æ¿è®©æ‚¨æˆä¸ºæ—¶é—´çš„é­”æ³•å¸ˆã€‚\nâ¸ï¸ æš‚åœæ—¶é—´ï¼šå®šæ ¼çˆ†ç‚¸ç¬é—´\nâª æ…¢åŠ¨ä½œï¼šä»¥ 0.1x é€Ÿåº¦æ¬£èµæ¯ä¸€ä¸ªç²’å­çš„ç»½æ”¾\nğŸ”„ è‡ªåŠ¨æ—‹è½¬ï¼šå¼€å¯æ²‰æµ¸å¼ç¯ç»•è§†è§’',
    icon: 'â³',
    position: 'bottom-center'
  },
  {
    id: 'carnival',
    title: 'å¤§ç§€ä¸äº¤äº’',
    description: 'æƒ³è¦æ›´éœ‡æ’¼çš„ä½“éªŒï¼Ÿåœ¨å·¥åŠä¸­æŸ¥æ‰¾â€œå¤§ç§€ç¼–æ’â€ï¼Œä¸€é”®å¯åŠ¨ç»è¿‡ç²¾å¿ƒè®¾è®¡çš„çƒŸèŠ±äº¤å“ä¹ã€‚æ‚¨ä¹Ÿå¯ä»¥è‡ªå®šä¹‰äº¤äº’å‰§æœ¬ï¼Œè®©æ¯ä¸€æ¬¡ç‚¹å‡»éƒ½å……æ»¡æƒŠå–œã€‚',
    icon: 'ğŸ­',
    position: 'top-right'
  },
  {
    id: 'ready',
    title: 'å¼€å§‹åˆ›é€ ï¼',
    description: 'èˆå°å·²ä¸ºæ‚¨å°±ç»ªã€‚å»ç‚¹äº®è¿™ç‰‡å¤œç©ºå§ï¼\n(æç¤ºï¼šç‚¹å‡»è®¾ç½®é¢æ¿å¤–éƒ¨çš„ç©ºç™½åŒºåŸŸå¯å¿«é€Ÿå…³é—­é¢æ¿)',
    icon: 'âœ¨',
    position: 'center'
  }
];

interface TutorialOverlayProps {
  onComplete: () => void;
}

export const useTutorial = () => {
  const [showTutorial, setShowTutorial] = useState(false);

  useEffect(() => {
    const hasSeenTutorial = localStorage.getItem('aetheris_tutorial_seen_v2');
    if (!hasSeenTutorial) {
      setShowTutorial(true);
    }
  }, []);

  const completeTutorial = () => {
    localStorage.setItem('aetheris_tutorial_seen_v2', 'true');
    setShowTutorial(false);
  };

  const resetTutorial = () => {
    localStorage.removeItem('aetheris_tutorial_seen_v2');
    setShowTutorial(true);
  };

  return { showTutorial, completeTutorial, resetTutorial };
};

export const TutorialOverlay: React.FC<TutorialOverlayProps> = ({ onComplete }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [isVisible, setIsVisible] = useState(true);
  
  const step = TUTORIAL_STEPS[currentStep];
  const isLastStep = currentStep === TUTORIAL_STEPS.length - 1;
  const progress = ((currentStep + 1) / TUTORIAL_STEPS.length) * 100;
  
  const handleNext = () => {
    if (isLastStep) {
      setIsVisible(false);
      setTimeout(onComplete, 300);
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };
  
  const handleSkip = () => {
    setIsVisible(false);
    setTimeout(onComplete, 300);
  };
  
  const handlePrev = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };
  
  // è·å–ä½ç½®æ ·å¼
  const getPositionStyles = () => {
    switch (step.position) {
      case 'top-right':
        return 'top-24 right-8';
      case 'top-left':
        return 'top-24 left-8';
      case 'bottom-left':
        return 'bottom-24 left-8';
      case 'bottom-center':
        return 'bottom-32 left-1/2 -translate-x-1/2';
      default:
        return 'top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
    }
  };
  
  return (
    <div 
      className={`
        fixed inset-0 z-[100] transition-opacity duration-300
        ${isVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}
      `}
    >
      {/* èƒŒæ™¯é®ç½© */}
      <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm" />
      
      {/* æ•™ç¨‹å¡ç‰‡ */}
      <div className={`absolute ${getPositionStyles()} w-[420px] max-w-[90vw] transition-all duration-500 ease-out`}>
        <div className="bg-white/90 backdrop-blur-xl rounded-[32px] shadow-2xl overflow-hidden border border-white/40 ring-1 ring-white/50 animate-slideUp">
          {/* è¿›åº¦æ¡ */}
          <div className="h-1.5 bg-gray-100/50">
            <div 
              className="h-full bg-gradient-to-r from-emerald-400 to-teal-500 transition-all duration-500 shadow-[0_0_10px_rgba(16,185,129,0.5)]"
              style={{ width: `${progress}%` }}
            />
          </div>
          
          {/* å†…å®¹ */}
          <div className="p-8">
            {/* å›¾æ ‡å’Œæ ‡é¢˜ */}
            <div className="flex items-start gap-5 mb-6">
              <div className="w-16 h-16 shrink-0 rounded-2xl bg-gradient-to-br from-white to-emerald-50 border border-emerald-100/50 flex items-center justify-center text-4xl shadow-lg shadow-emerald-100">
                {step.icon}
              </div>
              <div>
                <h3 className="text-xl font-black text-gray-800 tracking-tight mb-1">{step.title}</h3>
                <p className="text-xs font-bold text-gray-400 uppercase tracking-widest">Step {currentStep + 1} of {TUTORIAL_STEPS.length}</p>
              </div>
            </div>
            
            {/* æè¿° */}
            <div className="text-gray-600 text-sm leading-relaxed mb-8 whitespace-pre-line font-medium p-4 bg-white/50 rounded-2xl border border-white/50">
              {step.description}
            </div>
            
            {/* æ­¥éª¤æŒ‡ç¤ºå™¨ */}
            <div className="flex justify-center gap-2 mb-8">
              {TUTORIAL_STEPS.map((_, idx) => (
                <div
                  key={idx}
                  className={`
                    h-2 rounded-full transition-all duration-300
                    ${idx === currentStep 
                      ? 'bg-emerald-500 w-8 shadow-sm' 
                      : idx < currentStep 
                        ? 'bg-emerald-200 w-2' 
                        : 'bg-gray-200 w-2'
                    }
                  `}
                />
              ))}
            </div>
            
            {/* æŒ‰é’® */}
            <div className="flex gap-3">
              {currentStep > 0 && (
                <button
                  onClick={handlePrev}
                  className="px-5 py-3 rounded-xl bg-gray-100 text-gray-500 text-xs font-bold hover:bg-gray-200 transition-all"
                >
                  â† è¿”å›
                </button>
              )}
              
              <button
                onClick={handleSkip}
                className="px-5 py-3 rounded-xl text-gray-400 text-xs font-bold hover:text-gray-600 hover:bg-gray-50 transition-all ml-auto"
              >
                è·³è¿‡
              </button>
              
              <button
                onClick={handleNext}
                className="
                  px-8 py-3 rounded-xl text-xs font-black
                  bg-gradient-to-r from-emerald-500 to-teal-500 text-white
                  hover:from-emerald-600 hover:to-teal-600
                  shadow-lg shadow-emerald-200/50
                  transition-all hover:scale-105 active:scale-95
                  flex items-center gap-2
                "
              >
                {isLastStep ? 'å¼€å§‹ä½“éªŒ ğŸ‰' : 'ä¸‹ä¸€æ­¥ â†’'}
              </button>
            </div>
          </div>
        </div>
        
        {/* æŒ‡ç¤ºå…‰æ™• - ä»…ä½œä¸ºè£…é¥° */}
        <div className="absolute -inset-4 bg-emerald-500/20 blur-3xl -z-10 rounded-full opacity-0 animate-pulse" />
      </div>
      
      {/* å¿«æ·é”®æç¤ºæ¡ */}
      <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-6 text-white/50 text-[10px] font-mono tracking-wider backdrop-blur px-6 py-2 rounded-full bg-black/20 border border-white/10">
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Left Click</kbd>
          <span>Rotate</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Right Click</kbd>
          <span>Pan</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Scroll</kbd>
          <span>Zoom</span>
        </span>
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\core\combos\ComboManager.ts
// =============================================================================

// FILE: src/core/combos/ComboManager.ts
// ç»„åˆæŠ€ç³»ç»Ÿï¼šå®šä¹‰å¤šé˜¶æ®µçˆ†ç‚¸å’Œå¤æ‚ç‰¹æ•ˆç»„åˆ

import { Shape3DType } from '../shapes/Shape3DFactory';
import { TrajectoryType } from '../trajectories/TrajectoryFactory';

/**
 * ç»„åˆæŠ€ç±»å‹
 */
export enum ComboType {
  // === ç»å…¸ç»„åˆ ===
  SINGLE = 'single',                    // å•æ¬¡çˆ†ç‚¸ï¼ˆé»˜è®¤ï¼‰
  STAGED = 'staged',                    // å­æ¯è¿çˆ†ï¼ˆ2-3é˜¶æ®µï¼‰
  DELAYED_BURST = 'delayed_burst',      // å»¶è¿Ÿçˆ†å‘
  MULTI_WAVE = 'multi_wave',            // å¤šæ³¢æ¬¡æ‰©æ•£
  
  // === å½¢å˜ç»„åˆ ===
  MORPH = 'morph',                      // å½¢æ€å˜åŒ–ï¼ˆçƒ->å¿ƒç­‰ï¼‰
  SPLIT = 'split',                      // åˆ†è£‚æ•ˆæœ
  CONVERGE = 'converge',                // æ±‡èšæ•ˆæœ
  EXPAND_CONTRACT = 'expand_contract',  // æ‰©å¼ æ”¶ç¼©
  
  // === ç‰¹æ•ˆç»„åˆ ===
  TRAIL_EXPLOSION = 'trail_explosion',  // å°¾è¿¹çˆ†ç‚¸
  RAIN_DOWN = 'rain_down',              // é›¨è½æ•ˆæœ
  SPIRAL_SCATTER = 'spiral_scatter',    // èºæ—‹æ•£å°„
  PHOENIX_RISE = 'phoenix_rise',        // å‡¤å‡°é‡ç”Ÿ
  
  // === é«˜çº§ç»„åˆ ===
  CASCADE_CHAIN = 'cascade_chain',      // è¿é”ç€‘å¸ƒ
  GALAXY_BIRTH = 'galaxy_birth',        // é“¶æ²³è¯ç”Ÿ
  SUPERNOVA_COLLAPSE = 'supernova_collapse', // è¶…æ–°æ˜Ÿå¡Œç¼©
  FIREWORK_SYMPHONY = 'firework_symphony', // çƒŸèŠ±äº¤å“æ›²
}

/**
 * ç»„åˆæŠ€ä¿¡æ¯
 */
export interface ComboInfo {
  name: string;
  icon: string;
  description: string;
  stages: number;
  duration: number; // æ€»æŒç»­æ—¶é—´(ç§’)
}

/**
 * ç»„åˆæŠ€ä¿¡æ¯æ˜ å°„
 */
export const COMBO_INFO: Record<ComboType, ComboInfo> = {
  [ComboType.SINGLE]: { name: 'å•æ¬¡çˆ†ç‚¸', icon: 'ğŸ’¥', description: 'ç»å…¸å•æ¬¡ç‚¸å¼€', stages: 1, duration: 0 },
  [ComboType.STAGED]: { name: 'å­æ¯è¿çˆ†', icon: 'ğŸ†', description: 'å…ˆç‚¸å¼€å†äºŒæ¬¡çˆ†ç‚¸', stages: 2, duration: 0.8 },
  [ComboType.DELAYED_BURST]: { name: 'å»¶è¿Ÿçˆ†å‘', icon: 'â±ï¸', description: 'æ‚¬åœåçªç„¶ç‚¸å¼€', stages: 2, duration: 1.2 },
  [ComboType.MULTI_WAVE]: { name: 'å¤šæ³¢æ‰©æ•£', icon: 'ã€°ï¸', description: 'ä¸‰æ³¢ä¾æ¬¡æ‰©æ•£', stages: 3, duration: 1.5 },
  
  [ComboType.MORPH]: { name: 'å½¢æ€å˜åŒ–', icon: 'ğŸ”„', description: 'çƒå½¢å˜å¿ƒå½¢', stages: 2, duration: 1.0 },
  [ComboType.SPLIT]: { name: 'åˆ†è£‚æ•ˆæœ', icon: 'âœ‚ï¸', description: 'ä¸€åˆ†ä¸ºå¤š', stages: 2, duration: 0.6 },
  [ComboType.CONVERGE]: { name: 'æ±‡èšæ•ˆæœ', icon: 'ğŸ¯', description: 'å››æ•£åæ±‡èš', stages: 2, duration: 1.5 },
  [ComboType.EXPAND_CONTRACT]: { name: 'å‘¼å¸è„‰åŠ¨', icon: 'ğŸ’“', description: 'æ‰©å¼ å†æ”¶ç¼©', stages: 3, duration: 2.0 },
  
  [ComboType.TRAIL_EXPLOSION]: { name: 'å°¾è¿¹çˆ†ç‚¸', icon: 'â˜„ï¸', description: 'è½¨è¿¹ä¸Šè¿ç»­å°çˆ†ç‚¸', stages: 5, duration: 1.0 },
  [ComboType.RAIN_DOWN]: { name: 'é›¨è½æ•ˆæœ', icon: 'ğŸŒ§ï¸', description: 'ç‚¸å¼€åå¦‚é›¨ä¸‹è½', stages: 2, duration: 2.0 },
  [ComboType.SPIRAL_SCATTER]: { name: 'èºæ—‹æ•£å°„', icon: 'ğŸŒ€', description: 'èºæ—‹é£å‡º', stages: 1, duration: 0.5 },
  [ComboType.PHOENIX_RISE]: { name: 'å‡¤å‡°æ¶…æ§ƒ', icon: 'ğŸ”¥', description: 'ä¸‹è½åé‡æ–°å‡èµ·', stages: 3, duration: 3.0 },
  
  [ComboType.CASCADE_CHAIN]: { name: 'è¿é”ç€‘å¸ƒ', icon: 'ğŸŒŠ', description: 'å±‚å±‚ä¸‹è½', stages: 5, duration: 2.5 },
  [ComboType.GALAXY_BIRTH]: { name: 'é“¶æ²³è¯ç”Ÿ', icon: 'ğŸŒŒ', description: 'ä»ç‚¹åˆ°é“¶æ²³', stages: 4, duration: 3.0 },
  [ComboType.SUPERNOVA_COLLAPSE]: { name: 'è¶…æ–°æ˜Ÿå¡Œç¼©', icon: 'ğŸ’«', description: 'çˆ†ç‚¸åå¡Œç¼©', stages: 3, duration: 2.0 },
  [ComboType.FIREWORK_SYMPHONY]: { name: 'çƒŸèŠ±äº¤å“', icon: 'ğŸµ', description: 'å¤šç§æ•ˆæœåå¥', stages: 6, duration: 4.0 },
};

/**
 * é˜¶æ®µé…ç½®
 */
export interface StageConfig {
  delay: number;          // å»¶è¿Ÿæ—¶é—´(ç§’)
  shape: Shape3DType;     // å½¢çŠ¶
  scale: number;          // ç¼©æ”¾
  particleCount: number;  // ç²’å­æ•°é‡å€ç‡
  hueShift: number;       // è‰²ç›¸åç§»
  behavior?: string;      // ç²’å­è¡Œä¸º
  velocityScale?: number; // é€Ÿåº¦ç¼©æ”¾
  gravity?: number;       // é‡åŠ›è¦†ç›–
  decay?: number;         // è¡°å‡è¦†ç›–
  spawnOffset?: { x: number; y: number; z: number }; // ç”Ÿæˆä½ç½®åç§»
}

/**
 * ç»„åˆæŠ€é…ç½®
 */
export interface ComboConfig {
  type: ComboType;
  trajectory: TrajectoryType;
  stages: StageConfig[];
}

/**
 * ç»„åˆæŠ€ç”Ÿæˆå™¨
 */
export class ComboGenerator {
  /**
   * ç”Ÿæˆç»„åˆæŠ€é…ç½®
   */
  static generate(type: ComboType, baseShape: Shape3DType = Shape3DType.SPHERE): ComboConfig {
    const stages: StageConfig[] = [];
    let trajectory = TrajectoryType.LINEAR;
    
    switch (type) {
      case ComboType.SINGLE:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        break;
        
      case ComboType.STAGED:
        // ç¬¬ä¸€é˜¶æ®µï¼šå°çˆ†ç‚¸
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 0,
          decay: 0.05
        });
        // ç¬¬äºŒé˜¶æ®µï¼šä¸»çˆ†ç‚¸
        stages.push({
          delay: 0.8,
          shape: baseShape,
          scale: 1.2,
          particleCount: 1,
          hueShift: 60
        });
        break;
        
      case ComboType.DELAYED_BURST:
        // ç¬¬ä¸€é˜¶æ®µï¼šæ‚¬åœé—ªçƒ
        stages.push({
          delay: 0,
          shape: Shape3DType.SPARKLE_CLOUD,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter',
          velocityScale: 0.1
        });
        // ç¬¬äºŒé˜¶æ®µï¼šçªç„¶çˆ†å‘
        stages.push({
          delay: 1.2,
          shape: baseShape,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0
        });
        break;
        
      case ComboType.MULTI_WAVE:
        // ä¸‰æ³¢æ‰©æ•£
        for (let i = 0; i < 3; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 0.8 + i * 0.3,
            particleCount: 0.5,
            hueShift: i * 40
          });
        }
        break;
        
      case ComboType.MORPH:
        // çƒå½¢
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 0,
          decay: 0.03
        });
        // å˜å¿ƒå½¢
        stages.push({
          delay: 1.0,
          shape: Shape3DType.HEART_3D,
          scale: 1.2,
          particleCount: 1,
          hueShift: 330 // ç²‰çº¢
        });
        break;
        
      case ComboType.SPLIT:
        // ä¸»ä½“
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.6,
          particleCount: 0.3,
          hueShift: 0
        });
        // å››ä¸ªåˆ†è£‚ç‚¹
        const splitOffsets = [
          { x: 40, y: 0, z: 0 },
          { x: -40, y: 0, z: 0 },
          { x: 0, y: 0, z: 40 },
          { x: 0, y: 0, z: -40 }
        ];
        for (const offset of splitOffsets) {
          stages.push({
            delay: 0.6,
            shape: baseShape,
            scale: 0.5,
            particleCount: 0.3,
            hueShift: Math.random() * 60,
            spawnOffset: offset
          });
        }
        break;
        
      case ComboType.TRAIL_EXPLOSION:
        // æ²¿è½¨è¿¹çš„å°çˆ†ç‚¸
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.2,
            shape: Shape3DType.EXPLOSION_BURST,
            scale: 0.4,
            particleCount: 0.2,
            hueShift: i * 30,
            spawnOffset: { x: 0, y: -i * 30, z: 0 }
          });
        }
        trajectory = TrajectoryType.LINEAR;
        break;
        
      case ComboType.RAIN_DOWN:
        // çˆ†ç‚¸
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        // é›¨è½
        stages.push({
          delay: 0.8,
          shape: Shape3DType.CASCADE,
          scale: 1.5,
          particleCount: 0.8,
          hueShift: 30,
          behavior: 'falling',
          gravity: 0.15
        });
        break;
        
      case ComboType.SPIRAL_SCATTER:
        stages.push({
          delay: 0,
          shape: Shape3DType.VORTEX,
          scale: 1.2,
          particleCount: 1,
          hueShift: 0
        });
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      case ComboType.PHOENIX_RISE:
        // ä¸‹è½ç«ç„°
        stages.push({
          delay: 0,
          shape: Shape3DType.FIREWORK_WILLOW,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 30,
          gravity: 0.2
        });
        // åº•éƒ¨æ±‡èš
        stages.push({
          delay: 1.5,
          shape: Shape3DType.VORTEX,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 15,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        // å‡¤å‡°å‡èµ·
        stages.push({
          delay: 3.0,
          shape: Shape3DType.PHOENIX,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0,
          velocityScale: 1.5,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        trajectory = TrajectoryType.FALL_RISE;
        break;
        
      case ComboType.CASCADE_CHAIN:
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 1 - i * 0.15,
            particleCount: 0.4,
            hueShift: i * 20,
            spawnOffset: { x: 0, y: -i * 25, z: 0 }
          });
        }
        break;
        
      case ComboType.GALAXY_BIRTH:
        // ä¸­å¿ƒé—ªå…‰
        stages.push({
          delay: 0,
          shape: Shape3DType.EXPLOSION_BURST,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter'
        });
        // æ‰©æ•£
        stages.push({
          delay: 0.8,
          shape: Shape3DType.NEBULA,
          scale: 0.6,
          particleCount: 0.4,
          hueShift: 200
        });
        // æ—‹è‡‚å½¢æˆ
        stages.push({
          delay: 1.8,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1,
          particleCount: 0.8,
          hueShift: 240
        });
        // å®Œæ•´é“¶æ²³
        stages.push({
          delay: 3.0,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1.5,
          particleCount: 1,
          hueShift: 260
        });
        break;
        
      case ComboType.SUPERNOVA_COLLAPSE:
        // çˆ†å‘
        stages.push({
          delay: 0,
          shape: Shape3DType.SUPERNOVA,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 30
        });
        // æ‰©æ•£
        stages.push({
          delay: 0.8,
          shape: Shape3DType.SHOCKWAVE,
          scale: 2,
          particleCount: 0.5,
          hueShift: 200
        });
        // å¡Œç¼©æˆç‚¹
        stages.push({
          delay: 2.0,
          shape: Shape3DType.BLACK_HOLE,
          scale: 0.3,
          particleCount: 0.3,
          hueShift: 270,
          velocityScale: -0.5 // å‘å†…
        });
        break;
        
      case ComboType.FIREWORK_SYMPHONY:
        const symphonyShapes = [
          Shape3DType.SPHERE,
          Shape3DType.RING_WAVE,
          Shape3DType.HEART_3D,
          Shape3DType.STAR_3D,
          Shape3DType.FLOWER_3D,
          Shape3DType.EXPLOSION_BURST
        ];
        for (let i = 0; i < symphonyShapes.length; i++) {
          stages.push({
            delay: i * 0.6,
            shape: symphonyShapes[i],
            scale: 0.7 + Math.random() * 0.4,
            particleCount: 0.5,
            hueShift: (i / symphonyShapes.length) * 360
          });
        }
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      default:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
    }
    
    return { type, trajectory, stages };
  }
}

/**
 * ç»„åˆæŠ€ç®¡ç†å™¨
 */
export class ComboManager {
  private static allTypes: ComboType[] = Object.values(ComboType);
  
  /**
   * è·å–æ‰€æœ‰ç»„åˆæŠ€ç±»å‹
   */
  static getAllTypes(): ComboType[] {
    return [...this.allTypes];
  }
  
  /**
   * éšæœºè·å–ä¸€ä¸ªç»„åˆæŠ€ç±»å‹
   */
  static getRandomType(): ComboType {
    return this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
  }
  
  /**
   * è·å–ç»„åˆæŠ€ä¿¡æ¯
   */
  static getInfo(type: ComboType): ComboInfo {
    return COMBO_INFO[type];
  }
  
  /**
   * ç”Ÿæˆç»„åˆæŠ€é…ç½®
   */
  static generateConfig(type: ComboType, baseShape?: Shape3DType): ComboConfig {
    return ComboGenerator.generate(type, baseShape);
  }
  
  /**
   * è·å–ç®€å•ç»„åˆæŠ€ï¼ˆé€‚åˆè‡ªåŠ¨å‘å°„ï¼‰
   */
  static getSimpleTypes(): ComboType[] {
    return [
      ComboType.SINGLE,
      ComboType.STAGED,
      ComboType.MULTI_WAVE,
      ComboType.SPLIT
    ];
  }
  
  /**
   * è·å–é«˜çº§ç»„åˆæŠ€ï¼ˆé€‚åˆæ‰‹åŠ¨è§¦å‘ï¼‰
   */
  static getAdvancedTypes(): ComboType[] {
    return [
      ComboType.PHOENIX_RISE,
      ComboType.GALAXY_BIRTH,
      ComboType.SUPERNOVA_COLLAPSE,
      ComboType.FIREWORK_SYMPHONY
    ];
  }
}

// END OF FILE: src/core/combos/ComboManager.ts


// =============================================================================
// FILE: src\core\Firework.ts
// =============================================================================


import { Vector2 } from './Vector2';
import { FireworkOptions, ExplosionType, AppSettings, ParticleOptions } from '../types';
import { Particle } from './Particle';

export class Firework {
  pos: Vector2;
  target: Vector2;
  vel: Vector2;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector2[] = [];
  trailLength: number;

  constructor(options: FireworkOptions, settings: AppSettings) {
    this.pos = new Vector2(options.startX, window.innerHeight);
    this.target = new Vector2(options.targetX, options.targetY);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;

    const distanceY = this.pos.y - this.target.y;
    const gravity = settings.gravity;
    const initialVelY = -Math.sqrt(2 * gravity * Math.max(10, distanceY)) * (0.85 + Math.random() * 0.3);
    const timeToApex = -initialVelY / gravity;
    const initialVelX = (this.target.x - this.pos.x) / timeToApex;

    this.vel = new Vector2(initialVelX, initialVelY);
  }

  update(settings: AppSettings): void {
    this.trail.push(this.pos.clone());
    if (this.trail.length > this.trailLength) {
      this.trail.shift();
    }
    this.vel.y += settings.gravity;
    this.pos.add(this.vel);
    
    if (this.vel.y >= -0.2) {
      this.exploded = true;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.strokeStyle = `hsl(${this.hue}, 100%, 75%)`;
    ctx.lineWidth = 1.2;
    for (let i = 0; i < this.trail.length; i++) {
      const p = this.trail[i];
      const alpha = i / this.trail.length;
      ctx.globalAlpha = alpha * 0.8;
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  createExplosion(settings: AppSettings, spawnParticle: (opts: ParticleOptions) => Particle): void {
    const types = Object.values(ExplosionType);
    const type = types[Math.floor(Math.random() * types.length)] as ExplosionType;
    
    let baseCount = Math.floor((180 + this.charge * 450) * settings.particleCountMultiplier);
    const sizeScale = settings.explosionSizeMultiplier;

    const spawn = (angle: number, speed: number, extraHue = 0, behavior: any = 'default', decay?: number) => {
      spawnParticle({
        x: this.pos.x, y: this.pos.y,
        originX: this.pos.x,
        originY: this.pos.y,
        hue: (this.hue + extraHue) % 360,
        angle,
        speed: speed * sizeScale,
        gravity: settings.gravity,
        friction: settings.friction,
        behavior,
        decay
      });
    };

    switch (type) {
      case ExplosionType.HEART:
        const heartCount = baseCount * 1.5;
        for (let i = 0; i < heartCount; i++) {
          const t = (i / heartCount) * Math.PI * 2;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          const speed = (Math.sqrt(x*x + y*y) / 8) * (6 + this.charge * 8);
          spawn(Math.atan2(y, x), speed, 0, 'default', 0.012);
        }
        break;

      case ExplosionType.STAR:
        const pts = 5;
        const starCount = baseCount * 1.3;
        for (let i = 0; i < starCount; i++) {
          const ang = (i / starCount) * Math.PI * 2;
          const mod = (Math.abs(Math.cos(ang * pts / 2)) * 0.7 + 0.3);
          spawn(ang, mod * (14 + this.charge * 18));
        }
        break;

      case ExplosionType.GALAXY:
        const arms = 4 + Math.floor(this.charge * 4);
        for (let a = 0; a < arms; a++) {
          const armBaseAngle = (a / arms) * Math.PI * 2;
          for (let i = 0; i < baseCount / arms; i++) {
            const prog = i / (baseCount / arms);
            const angle = armBaseAngle + prog * Math.PI * 2.5;
            const speed = prog * (15 + this.charge * 15);
            spawn(angle, speed, prog * 80, 'galaxy');
          }
        }
        break;

      case ExplosionType.SPIRAL:
        const sArms = 4 + Math.floor(this.charge * 4);
        const pPerArm = Math.floor(baseCount / sArms);
        for (let a = 0; a < sArms; a++) {
          const armBaseAngle = (a / sArms) * Math.PI * 2;
          for (let i = 0; i < pPerArm; i++) {
            const prog = i / pPerArm;
            const swirlAngle = armBaseAngle + (prog * Math.PI * 8);
            const speed = (0.2 + prog * 0.8) * (20 + this.charge * 15);
            spawn(swirlAngle, speed, prog * 60);
          }
        }
        break;

      case ExplosionType.BUTTERFLY:
        const bfCount = baseCount * 1.5;
        for (let i = 0; i < bfCount; i++) {
          const t = (i / bfCount) * Math.PI * 2;
          const r = Math.exp(Math.sin(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin((2 * t - Math.PI) / 24), 5);
          const x = Math.sin(t) * r;
          const y = -Math.cos(t) * r;
          spawn(Math.atan2(y, x), Math.sqrt(x*x + y*y) * (8 + this.charge * 10), Math.sin(t) * 40);
        }
        break;

      case ExplosionType.DOUBLE_RING:
        const ringCount = Math.floor(baseCount * 0.6);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2, 22 + this.charge * 12);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2 + 0.2, 14 + this.charge * 8, 40);
        break;

      case ExplosionType.GLITTER:
        for (let i = 0; i < baseCount; i++) spawn(Math.random() * Math.PI * 2, Math.random() * (22 + this.charge * 18), 0, 'glitter');
        break;

      default:
        for (let i = 0; i < baseCount; i++) {
          const angle = (i / baseCount) * Math.PI * 2;
          spawn(angle, Math.random() * (20 + this.charge * 24));
        }
        break;
    }
  }
}


// =============================================================================
// FILE: src\core\Firework3D.ts
// =============================================================================

import { Vector3 } from './Vector3';
import { ExplosionType, AscensionType, ColorStyle, AppSettings, ParticleOptions3D, FireworkConfig } from '../types';
import { Particle3D } from './Particle3D';
import { TrajectoryFactory, TrajectoryCalculator, TrajectoryType } from './trajectories/TrajectoryFactory';
import { Shape3DFactory, Shape3DType } from './shapes/Shape3DFactory';
import { ComboManager, ComboConfig, ComboType } from './combos/ComboManager';

export interface Firework3DOptions {
  startX: number;
  startZ: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  hue: number;
  charge: number;
  // æ–°å‘åå…¼å®¹å­—æ®µ
  trajectoryType?: TrajectoryType;
  comboType?: ComboType;
  customShape?: Shape3DType;
  lifeTimeOverride?: number; // è¦†ç›–æŒç»­æ—¶é—´ (ç§’)
}

/**
 * 3D Firework class
 */
export class Firework3D {
  position: Vector3;
  target: Vector3;
  velocity: Vector3;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector3[] = [];
  trailLength: number;
  
  public lifeTimeOverride: number = 0;

  public type: ExplosionType;
  public ascension: AscensionType;
  public colorStyle: ColorStyle;
  public lifeTime: number = 0;

  private trajectoryCalculator: TrajectoryCalculator;
  private comboConfig: ComboConfig;
  private currentStageIndex: number = 0;
  private lastStageTime: number = 0;

  constructor(options: Firework3DOptions, settings: AppSettings, config: FireworkConfig) {
    this.position = new Vector3(options.startX, 0, options.startZ);
    this.target = new Vector3(options.targetX, options.targetY, options.targetZ);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;
    this.lifeTimeOverride = options.lifeTimeOverride || 0;

    // ... (rest of constructor logic) ... 
    // I need to be careful with replace_file_content to not delete the logic I'm not showing.
    // The replace tool requires REPLACEMENT of the block.
    
    // 1. ç¡®å®šç»„åˆæŠ€å’Œè½¨è¿¹
    const cType = options.comboType || ComboType.SINGLE;
    
    // ä¿®å¤æ ·å¼åº”ç”¨é—®é¢˜ï¼šå¤„ç† legacy ExplosionType çš„è½¬æ¢
    const rawShape = options.customShape as any;
    const baseShape = this.mapToShape3D(rawShape);
    
    this.comboConfig = ComboManager.generateConfig(cType, baseShape);

    const tType = options.trajectoryType || this.comboConfig.trajectory;
    this.trajectoryCalculator = TrajectoryFactory.create(tType);

    // 2. ä¿æŒå¯¹æ—§æœ‰ç±»å‹çš„å…¼å®¹æ€§ï¼ˆç”¨äº UI æ˜¾ç¤ºç­‰ï¼‰
    const ascList = config.enabledAscensions.length > 0 ? config.enabledAscensions : [AscensionType.LINEAR];
    this.ascension = ascList[Math.floor(Math.random() * ascList.length)];
    this.colorStyle = config.enabledColors[Math.floor(Math.random() * config.enabledColors.length)] || ColorStyle.SINGLE;
    this.type = rawShape in ExplosionType ? (rawShape as ExplosionType) : ExplosionType.SPHERE;
    // 3. è®¡ç®—åˆå§‹é€Ÿåº¦
    const distanceY = this.target.y - this.position.y;
    const gravity = settings.gravity * 1.5;
    const timeToApex = Math.sqrt(2 * Math.max(10, distanceY) / gravity);
    const initialVelY = gravity * timeToApex;
    const initialVelX = (this.target.x - this.position.x) / timeToApex;
    const initialVelZ = (this.target.z - this.position.z) / timeToApex;

    this.velocity = new Vector3(initialVelX, initialVelY, initialVelZ);
  }

  private mapToShape3D(shape: any): Shape3DType {
    if (!shape) return Shape3DType.SPHERE;
    if (Object.values(Shape3DType).includes(shape as Shape3DType)) return shape as Shape3DType;
    
    // æ˜ å°„æ—§ç‰ˆåˆ°æ–°ç‰ˆ
    const mapping: Record<string, Shape3DType> = {
      [ExplosionType.SPHERE]: Shape3DType.SPHERE,
      [ExplosionType.BURST]: Shape3DType.EXPLOSION_BURST,
      [ExplosionType.RING]: Shape3DType.RING_WAVE,
      [ExplosionType.DOUBLE_RING]: Shape3DType.DOUBLE_RING,
      [ExplosionType.WILLOW]: Shape3DType.FIREWORK_WILLOW,
      [ExplosionType.CUBE]: Shape3DType.CUBE,
      [ExplosionType.PYRAMID]: Shape3DType.PYRAMID,
      [ExplosionType.STAR]: Shape3DType.STAR_3D,
      [ExplosionType.GALAXY]: Shape3DType.GALAXY_SPIRAL,
      [ExplosionType.HEART]: Shape3DType.HEART_3D,
      [ExplosionType.HEART_BEAT]: Shape3DType.HEART_3D,
      [ExplosionType.SNOWFLAKE]: Shape3DType.SNOWFLAKE_3D,
      [ExplosionType.BUTTERFLY]: Shape3DType.BUTTERFLY_3D,
      [ExplosionType.FLOWER]: Shape3DType.FLOWER_3D,
      [ExplosionType.FISH]: Shape3DType.FISH_3D,
      [ExplosionType.SATURN]: Shape3DType.PLANET_RINGS,
      [ExplosionType.HELIX]: Shape3DType.HELIX_TUBE,
      [ExplosionType.WATERFALL]: Shape3DType.WATERFALL_3D,
    };
    
    return mapping[shape] || Shape3DType.SPHERE;
  }


  update(settings: AppSettings, deltaTime: number): void {
    if (deltaTime <= 0) return;

    const dt = deltaTime * 60;
    
    // ä½¿ç”¨æ–°çš„è½¨è¿¹è®¡ç®—å™¨æ›´æ–°ç‰©ç†
    if (!this.exploded) {
      this.velocity = this.trajectoryCalculator.calculate(this.velocity, settings.gravity, deltaTime);
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.position.z += this.velocity.z * dt;
      this.lifeTime = this.trajectoryCalculator.getLifeTime();

      if (this.velocity.y <= -2.5) {
        this.exploded = true;
        this.lastStageTime = this.lifeTime;
      }
    } else {
      // çˆ†ç‚¸åçš„é€»è¾‘ï¼šå¤„ç†å¤šé˜¶æ®µç»„åˆæŠ€
      this.handleComboStages(settings, (opts) => this.spawnParticleCallback?.(opts) as any);
    }
  }

  // ä¸´æ—¶å­˜å‚¨å›è°ƒï¼Œä»¥ä¾¿åœ¨ update ä¸­è°ƒç”¨
  private spawnParticleCallback: ((opts: ParticleOptions3D) => Particle3D) | null = null;

  createExplosion(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    this.spawnParticleCallback = spawnParticle;
    // ç«‹å³è§¦å‘ç¬¬ä¸€é˜¶æ®µï¼ˆå¦‚æœæœ‰å»¶è¿Ÿä¸º0çš„é˜¶æ®µï¼‰
    this.handleComboStages(settings, spawnParticle);
  }

  private handleComboStages(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    if (!this.comboConfig || this.currentStageIndex >= this.comboConfig.stages.length) return;

    const timeSinceExplosion = this.lifeTime - this.lastStageTime;
    const currentStage = this.comboConfig.stages[this.currentStageIndex];

    if (timeSinceExplosion >= currentStage.delay) {
      this.executeStage(currentStage, settings, spawnParticle);
      this.currentStageIndex++;
    }
  }

  private executeStage(
    stage: any,
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    const baseCount = Math.floor((200 + this.charge * 400) * settings.particleCountMultiplier * stage.particleCount);
    const scale = settings.explosionSizeMultiplier * stage.scale;
    const hue = (this.hue + stage.hueShift) % 360;

    // è·å–çœŸ3Då½¢çŠ¶ç‚¹åˆ†å¸ƒ
    const points = Shape3DFactory.generate(stage.shape, baseCount, scale, hue);
    
    // è®¡ç®— decay: å¦‚æœæœ‰ overrideï¼Œåæ¨ decay
    let finalDecay = stage.decay ?? (0.01 + Math.random() * 0.015);
    if (this.lifeTimeOverride > 0) {
      finalDecay = 1 / (this.lifeTimeOverride * 60);
    }

    points.forEach(p => {
      const pos = p.position.clone();
      if (stage.spawnOffset) {
        pos.x += stage.spawnOffset.x;
        pos.y += stage.spawnOffset.y;
        pos.z += stage.spawnOffset.z;
      }

      const particle = spawnParticle({
        x: this.position.x + pos.x,
        y: this.position.y + pos.y,
        z: this.position.z + pos.z,
        originX: this.position.x,
        originY: this.position.y,
        originZ: this.position.z,
        hue: p.hue,
        // åˆå§‹åŠ¨é‡ä¸å†æ˜¯éšæœºä¹±è·³ï¼Œè€Œæ˜¯ç»§æ‰¿ä¸€éƒ¨åˆ†å½¢çŠ¶åŠ¨é‡
        speed: (stage.velocityScale || 1.0) * (1 + Math.random() * 2), 
        gravity: stage.gravity ?? settings.gravity,
        friction: settings.friction,
        behavior: (p.behavior || stage.behavior || 'default') as any,
        size: p.size || 5,
        decay: finalDecay
      });

      // æ ¸å¿ƒä¿®å¤ï¼šåŸºäºè·ç¦»çš„æ‰©å¼ é€Ÿåº¦ (Spherical Expansion)
      // åªæœ‰è¿™æ ·ï¼Œå¤æ‚çš„ 3D å½¢çŠ¶æ‰èƒ½åœ¨è†¨èƒ€æ—¶ä¿æŒâ€œå½¢çŠ¶â€ï¼Œè€Œä¸æ˜¯è¿…é€Ÿå˜æˆä¸€ä¸ªçƒå£³
      if (particle) {
        const dist = p.position.length();
        if (dist > 0) {
          const dir = p.position.clone().normalize();
          // è®©æ‰©æ•£é€Ÿåº¦ä¸å…¶åœ¨å½¢çŠ¶ä¸­çš„è·ç¦»æˆæ­£æ¯”ï¼Œå®ç°æŒ‰æ¯”ä¾‹ç¼©æ”¾è†¨èƒ€
          const expandSpeed = (stage.velocityScale || 1.0) * (dist * 0.5); 
          particle.velocity.x = dir.x * expandSpeed;
          particle.velocity.y = dir.y * expandSpeed;
          particle.velocity.z = dir.z * expandSpeed;
        }
      }
    });
  }

  getColor(): { r: number; g: number; b: number } {
    const h = this.hue / 360; const s = 1; const l = 0.6;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q;
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    };
    return { r: hue2rgb(p, q, h + 1/3), g: hue2rgb(p, q, h), b: hue2rgb(p, q, h - 1/3) };
  }
}

// END OF FILE: src/core/Firework3D.ts

// =============================================================================
// FILE: src\core\Particle.ts
// =============================================================================


import { ParticleOptions, ParticleBehavior } from '../types';

/**
 * Performance-optimized Particle class.
 */
export class Particle {
  public x: number = 0;
  public y: number = 0;
  public vx: number = 0;
  public vy: number = 0;
  public originX: number = 0;
  public originY: number = 0;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public color: string = '';
  public rotationSpeed: number = 0;

  constructor() {}

  init(options: ParticleOptions): void {
    this.x = options.x;
    this.y = options.y;
    this.originX = options.originX ?? options.x;
    this.originY = options.originY ?? options.y;
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();

    const angle = options.angle ?? Math.random() * Math.PI * 2;
    const speed = options.speed ?? Math.random() * 10 + 2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;

    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
    this.color = `hsl(${this.hue % 360}, 100%, 75%)`;
  }

  update(): void {
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.vx += Math.sin(now) * 0.05;
      this.vy += Math.cos(now) * 0.05;
    } else if (this.behavior === 'galaxy') {
      const dx = this.x - this.originX;
      const dy = this.y - this.originY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) + this.rotationSpeed;
      
      const targetX = this.originX + Math.cos(angle) * (dist + this.vx);
      const targetY = this.originY + Math.sin(angle) * (dist + this.vy);
      
      this.vx = targetX - this.x;
      this.vy = targetY - this.y;
    }

    const speedSq = this.vx * this.vx + this.vy * this.vy;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance;
      this.vx -= (this.vx / speed) * drag;
      this.vy -= (this.vy / speed) * drag;
    }

    this.vx *= this.friction;
    this.vy = this.vy * this.friction + this.gravity;
    
    this.x += this.vx;
    this.y += this.vy;

    this.life -= this.decay;
    
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }
    
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15) % 1;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    if (this.alpha <= 0) return;

    let currentAlpha = this.alpha;
    if (this.behavior === 'glitter' && this.twinkleFactor > 0.5) {
      currentAlpha *= 0.2;
    }

    ctx.globalAlpha = currentAlpha;
    ctx.fillStyle = this.color;
    
    if (this.behavior === 'willow' || this.behavior === 'comet') {
      ctx.beginPath();
      const trailLen = this.behavior === 'comet' ? 8 : 3;
      ctx.lineWidth = this.behavior === 'comet' ? this.size * this.life : this.size;
      ctx.strokeStyle = this.color;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * trailLen, this.y - this.vy * trailLen);
      ctx.stroke();
      
      if (this.behavior === 'comet') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, 6.28);
        ctx.fill();
      }
    } else if (this.behavior === 'galaxy') {
      ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
    } else {
      if (this.size < 2) {
        ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
      } else {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 6.28);
        ctx.fill();
      }
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }
}


// =============================================================================
// FILE: src\core\Particle3D.ts
// =============================================================================

import { Vector3 } from './Vector3';
import { ParticleBehavior, ParticleOptions3D } from '../types';

/**
 * 3D Particle class for the firework system
 * Uses Three.js coordinate system (Y-up)
 */
export class Particle3D {
  public position: Vector3;
  public velocity: Vector3;
  public origin: Vector3;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public rotationSpeed: number = 0;

  // Trail for comet/willow effects
  public trail: Vector3[] = [];
  public maxTrailLength: number = 10;

  constructor() {
    this.position = new Vector3();
    this.velocity = new Vector3();
    this.origin = new Vector3();
  }

  init(options: ParticleOptions3D): void {
    this.position = new Vector3(options.x, options.y, options.z);
    this.origin = new Vector3(
      options.originX ?? options.x,
      options.originY ?? options.y,
      options.originZ ?? options.z
    );
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();
    this.trail = [];

    // Calculate velocity from spherical coordinates
    const theta = options.theta ?? Math.random() * Math.PI * 2;
    const phi = options.phi ?? Math.random() * Math.PI;
    const speed = options.speed ?? Math.random() * 10 + 2;

    this.velocity = new Vector3(
      speed * Math.sin(phi) * Math.cos(theta),
      speed * Math.cos(phi),
      speed * Math.sin(phi) * Math.sin(theta)
    );

    // Apply behavior-specific settings
    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
      this.maxTrailLength = 15;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
      this.maxTrailLength = 20;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
  }

  update(deltaTime: number): void {
    // Use a minimum dt to prevent division by zero and ensure smooth updates
    const dt = Math.max(deltaTime * 60, 0.001); // Normalize to 60fps with minimum
    
    // Skip update if effectively paused
    if (deltaTime <= 0) return;

    // Store trail position
    if (this.behavior === 'comet' || this.behavior === 'willow') {
      this.trail.push(this.position.clone());
      if (this.trail.length > this.maxTrailLength) {
        this.trail.shift();
      }
    }

    // Behavior-specific updates
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.velocity.x += Math.sin(now) * 0.05 * dt;
      this.velocity.y += Math.cos(now * 0.7) * 0.05 * dt;
      this.velocity.z += Math.sin(now * 1.3) * 0.05 * dt;
    } else if (this.behavior === 'galaxy') {
      const dx = this.position.x - this.origin.x;
      const dz = this.position.z - this.origin.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const angle = Math.atan2(dz, dx) + this.rotationSpeed * dt;

      const targetX = this.origin.x + Math.cos(angle) * (dist + this.velocity.x * dt);
      const targetZ = this.origin.z + Math.sin(angle) * (dist + this.velocity.z * dt);

      // Safe division
      if (dt > 0.001) {
        this.velocity.x = (targetX - this.position.x) / dt;
        this.velocity.z = (targetZ - this.position.z) / dt;
      }
    }

    // Apply air resistance
    const speedSq = this.velocity.x * this.velocity.x +
                    this.velocity.y * this.velocity.y +
                    this.velocity.z * this.velocity.z;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance * dt;
      this.velocity.x -= (this.velocity.x / speed) * drag;
      this.velocity.y -= (this.velocity.y / speed) * drag;
      this.velocity.z -= (this.velocity.z / speed) * drag;
    }

    // Apply friction
    const frictionPower = Math.pow(this.friction, dt);
    this.velocity.x *= frictionPower;
    this.velocity.y *= frictionPower;
    this.velocity.z *= frictionPower;

    // Apply gravity (Y-up in Three.js)
    this.velocity.y -= this.gravity * dt;

    // Update position
    this.position.x += this.velocity.x * dt;
    this.position.y += this.velocity.y * dt;
    this.position.z += this.velocity.z * dt;

    // Update life
    this.life -= this.decay * dt;

    // Update alpha based on behavior
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }

    // Glitter twinkle
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15 * dt) % 1;
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }

  getColor(): { r: number; g: number; b: number } {
    // HSL to RGB conversion
    const h = this.hue / 360;
    const s = 1;
    const l = 0.75;

    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    return {
      r: hue2rgb(p, q, h + 1/3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1/3)
    };
  }
}


// =============================================================================
// FILE: src\core\ParticlePool.ts
// =============================================================================


import { Particle } from './Particle';
import { ParticleOptions } from '../types';

/**
 * Performance-optimized Particle Pool
 */
export class ParticlePool {
  private pool: Particle[] = [];
  private active: Particle[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle());
    }
  }

  /**
   * Get a particle: recycle the oldest active one if limit reached.
   */
  get(options: ParticleOptions): Particle {
    let p: Particle;
    
    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle();
    }
    
    p.init(options);
    this.active.push(p);
    return p;
  }

  updateAndDraw(ctx: CanvasRenderingContext2D): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update();
      p.draw(ctx);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  get activeCount() { return this.active.length; }
}


// =============================================================================
// FILE: src\core\ParticlePool3D.ts
// =============================================================================

import { Particle3D } from './Particle3D';
import { ParticleOptions3D } from '../types';

/**
 * Performance-optimized 3D Particle Pool
 * Manages particle lifecycle with object pooling to minimize GC
 */
export class ParticlePool3D {
  private pool: Particle3D[] = [];
  private active: Particle3D[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle3D());
    }
  }

  /**
   * Get a particle from the pool
   * Recycles the oldest active particle if limit is reached
   */
  get(options: ParticleOptions3D): Particle3D {
    let p: Particle3D;

    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle3D();
    }

    p.init(options);
    this.active.push(p);
    return p;
  }

  /**
   * Update all active particles
   */
  update(deltaTime: number): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update(deltaTime);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  /**
   * Get all active particles for rendering
   */
  getActiveParticles(): Particle3D[] {
    return this.active;
  }

  /**
   * Get the count of active particles
   */
  get activeCount(): number {
    return this.active.length;
  }

  /**
   * Clear all active particles
   */
  clear(): void {
    while (this.active.length > 0) {
      const p = this.active.pop()!;
      this.pool.push(p);
    }
  }
}


// =============================================================================
// FILE: src\core\shapes\Shape3DFactory.ts
// =============================================================================

// FILE: src/core/shapes/Shape3DFactory.ts
// çœŸ3Då½¢çŠ¶å·¥å‚ï¼šå®šä¹‰50+ç§çœŸæ­£çš„ä¸‰ç»´å½¢çŠ¶

import { Vector3 } from '../Vector3';

/**
 * 3Då½¢çŠ¶ç±»å‹æšä¸¾
 * åˆ†ç±»ï¼šåŸºç¡€å‡ ä½•ã€è‡ªç„¶ç”Ÿç‰©ã€æŠ½è±¡è‰ºæœ¯ã€å®‡å®™å¤©ä½“ã€æ–‡åŒ–ç¬¦å·ã€ç‰¹æ•ˆç±»
 */
export enum Shape3DType {
  // === åŸºç¡€å‡ ä½• (10ç§) ===
  SPHERE = 'sphere',
  CUBE = 'cube',
  PYRAMID = 'pyramid',
  OCTAHEDRON = 'octahedron',
  DODECAHEDRON = 'dodecahedron',
  ICOSAHEDRON = 'icosahedron',
  CYLINDER = 'cylinder',
  CONE = 'cone',
  TORUS = 'torus',
  TORUS_KNOT = 'torus_knot',
  
  // === é«˜çº§å‡ ä½• (10ç§) ===
  CAPSULE = 'capsule',
  PRISM = 'prism',
  STAR_3D = 'star_3d',
  CROSS_3D = 'cross_3d',
  DIAMOND = 'diamond',
  MOBIUS = 'mobius',
  KLEIN_BOTTLE = 'klein_bottle',
  HELIX_TUBE = 'helix_tube',
  SPRING = 'spring',
  NESTED_SPHERES = 'nested_spheres',
  
  // === è‡ªç„¶ç”Ÿç‰© (10ç§) ===
  BUTTERFLY_3D = 'butterfly_3d',
  FLOWER_3D = 'flower_3d',
  TREE = 'tree',
  FISH_3D = 'fish_3d',
  BIRD = 'bird',
  JELLYFISH = 'jellyfish',
  SHELL = 'shell',
  SNOWFLAKE_3D = 'snowflake_3d',
  LEAF = 'leaf',
  MUSHROOM = 'mushroom',
  
  // === å®‡å®™å¤©ä½“ (10ç§) ===
  GALAXY_SPIRAL = 'galaxy_spiral',
  PLANET_RINGS = 'planet_rings',
  NEBULA = 'nebula',
  BLACK_HOLE = 'black_hole',
  SUPERNOVA = 'supernova',
  COMET = 'comet',
  ASTEROID_BELT = 'asteroid_belt',
  CONSTELLATION = 'constellation',
  PULSAR = 'pulsar',
  WORMHOLE = 'wormhole',
  
  // === æ–‡åŒ–ç¬¦å· (10ç§) ===
  HEART_3D = 'heart_3d',
  CROWN_3D = 'crown_3d',
  DRAGON_3D = 'dragon_3d',
  PHOENIX = 'phoenix',
  YIN_YANG = 'yin_yang',
  LOTUS = 'lotus',
  LANTERN = 'lantern',
  FIREWORK_CLASSIC = 'firework_classic',
  RIBBON = 'ribbon',
  FIREWORK_WILLOW = 'firework_willow',
  
  // === ç‰¹æ•ˆç±» (10ç§) ===
  EXPLOSION_BURST = 'explosion_burst',
  RING_WAVE = 'ring_wave',
  DOUBLE_RING = 'double_ring',
  CASCADE = 'cascade',
  WATERFALL_3D = 'waterfall_3d',
  FOUNTAIN = 'fountain',
  VORTEX = 'vortex',
  SHOCKWAVE = 'shockwave',
  SPARKLE_CLOUD = 'sparkle_cloud',
  CHAOS_SCATTER = 'chaos_scatter',
}

/**
 * å½¢çŠ¶ä¿¡æ¯
 */
export interface Shape3DInfo {
  name: string;
  icon: string;
  category: string;
  description: string;
}

/**
 * å½¢çŠ¶åˆ†ç±»
 */
export const SHAPE_CATEGORIES = {
  BASIC_GEOMETRY: 'åŸºç¡€å‡ ä½•',
  ADVANCED_GEOMETRY: 'é«˜çº§å‡ ä½•',
  NATURE: 'è‡ªç„¶ç”Ÿç‰©',
  COSMOS: 'å®‡å®™å¤©ä½“',
  CULTURE: 'æ–‡åŒ–ç¬¦å·',
  EFFECTS: 'ç‰¹æ•ˆç±»',
};

/**
 * å½¢çŠ¶ä¿¡æ¯æ˜ å°„
 */
export const SHAPE_3D_INFO: Record<Shape3DType, Shape3DInfo> = {
  // åŸºç¡€å‡ ä½•
  [Shape3DType.SPHERE]: { name: 'æ ‡å‡†çƒå½¢', icon: 'ğŸ”®', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å®Œç¾çš„çƒå½¢çˆ†ç‚¸' },
  [Shape3DType.CUBE]: { name: 'é‡å­ç«‹æ–¹', icon: 'ğŸ§Š', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å…­é¢ä½“ç»“æ„' },
  [Shape3DType.PYRAMID]: { name: 'é‡‘å­—å¡”', icon: 'ğŸ”º', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å››é¢ä½“é‡‘å­—å¡”' },
  [Shape3DType.OCTAHEDRON]: { name: 'å…«é¢ä½“', icon: 'ğŸ’', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å…«ä¸ªä¸‰è§’é¢' },
  [Shape3DType.DODECAHEDRON]: { name: 'åäºŒé¢ä½“', icon: 'â¬¡', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'åäºŒä¸ªäº”è¾¹å½¢é¢' },
  [Shape3DType.ICOSAHEDRON]: { name: 'äºŒåé¢ä½“', icon: 'ğŸ²', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'äºŒåä¸ªä¸‰è§’é¢' },
  [Shape3DType.CYLINDER]: { name: 'åœ†æŸ±ä½“', icon: 'ğŸ›¢ï¸', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'åœ†æŸ±å½¢çŠ¶' },
  [Shape3DType.CONE]: { name: 'åœ†é”¥ä½“', icon: 'ğŸ“', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'é”¥å½¢ç»“æ„' },
  [Shape3DType.TORUS]: { name: 'åœ†ç¯ä½“', icon: 'â­•', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'ç”œç”œåœˆå½¢çŠ¶' },
  [Shape3DType.TORUS_KNOT]: { name: 'ç¯å½¢ç»“', icon: 'ğŸ”—', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'æ‰­æ›²çš„ç¯å½¢' },
  
  // é«˜çº§å‡ ä½•
  [Shape3DType.CAPSULE]: { name: 'èƒ¶å›Šä½“', icon: 'ğŸ’Š', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ä¸¤ç«¯åœ†æ¶¦çš„æŸ±ä½“' },
  [Shape3DType.PRISM]: { name: 'æ£±é•œ', icon: 'ğŸ”·', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ä¸‰è§’æ£±é•œ' },
  [Shape3DType.STAR_3D]: { name: '3Dæ˜Ÿå½¢', icon: 'â­', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç«‹ä½“äº”è§’æ˜Ÿ' },
  [Shape3DType.CROSS_3D]: { name: '3Dåå­—', icon: 'âœï¸', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç«‹ä½“åå­—æ¶' },
  [Shape3DType.DIAMOND]: { name: 'é’»çŸ³', icon: 'ğŸ’ ', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'é—ªè€€é’»çŸ³' },
  [Shape3DType.MOBIUS]: { name: 'è«æ¯”ä¹Œæ–¯å¸¦', icon: 'â™¾ï¸', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'æ— é™å¾ªç¯' },
  [Shape3DType.KLEIN_BOTTLE]: { name: 'å…‹è±å› ç“¶', icon: 'ğŸ¾', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'æ‹“æ‰‘å­¦å¥‡è¿¹' },
  [Shape3DType.HELIX_TUBE]: { name: 'DNAåŒèºæ—‹', icon: 'ğŸ§¬', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç”Ÿå‘½å¯†ç ' },
  [Shape3DType.SPRING]: { name: 'å¼¹ç°§', icon: 'ğŸ”„', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'èºæ—‹å¼¹ç°§' },
  [Shape3DType.NESTED_SPHERES]: { name: 'åŒå¿ƒçƒ', icon: 'ğŸ¯', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'å±‚å±‚åµŒå¥—' },
  
  // è‡ªç„¶ç”Ÿç‰©
  [Shape3DType.BUTTERFLY_3D]: { name: 'å¹»å½©è´è¶', icon: 'ğŸ¦‹', category: SHAPE_CATEGORIES.NATURE, description: 'ç¿©ç¿©èµ·èˆ' },
  [Shape3DType.FLOWER_3D]: { name: 'ç››ä¸–ç‰¡ä¸¹', icon: 'ğŸŒº', category: SHAPE_CATEGORIES.NATURE, description: 'å±‚å±‚èŠ±ç“£' },
  [Shape3DType.TREE]: { name: 'ç”Ÿå‘½ä¹‹æ ‘', icon: 'ğŸŒ³', category: SHAPE_CATEGORIES.NATURE, description: 'æç¹å¶èŒ‚' },
  [Shape3DType.FISH_3D]: { name: 'é”¦é²¤æ¸¸åŠ¨', icon: 'ğŸŸ', category: SHAPE_CATEGORIES.NATURE, description: 'å¹´å¹´æœ‰ä½™' },
  [Shape3DType.BIRD]: { name: 'é£é¸Ÿ', icon: 'ğŸ•Šï¸', category: SHAPE_CATEGORIES.NATURE, description: 'å±•ç¿…é«˜é£' },
  [Shape3DType.JELLYFISH]: { name: 'æ°´æ¯', icon: 'ğŸª¼', category: SHAPE_CATEGORIES.NATURE, description: 'é£˜é€¸çµåŠ¨' },
  [Shape3DType.SHELL]: { name: 'æµ·èº', icon: 'ğŸš', category: SHAPE_CATEGORIES.NATURE, description: 'èºæ—‹è´å£³' },
  [Shape3DType.SNOWFLAKE_3D]: { name: 'å…­è§’é›ªèŠ±', icon: 'â„ï¸', category: SHAPE_CATEGORIES.NATURE, description: 'å†°æ™¶ç»½æ”¾' },
  [Shape3DType.LEAF]: { name: 'è½å¶', icon: 'ğŸ‚', category: SHAPE_CATEGORIES.NATURE, description: 'ç§‹é£è½å¶' },
  [Shape3DType.MUSHROOM]: { name: 'è˜‘è‡', icon: 'ğŸ„', category: SHAPE_CATEGORIES.NATURE, description: 'ç«¥è¯è˜‘è‡' },
  
  // å®‡å®™å¤©ä½“
  [Shape3DType.GALAXY_SPIRAL]: { name: 'é“¶æ²³ç³»', icon: 'ğŸŒŒ', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—‹è‡‚é“¶æ²³' },
  [Shape3DType.PLANET_RINGS]: { name: 'åœŸæ˜Ÿç¯', icon: 'ğŸª', category: SHAPE_CATEGORIES.COSMOS, description: 'è¡Œæ˜Ÿå…‰ç¯' },
  [Shape3DType.NEBULA]: { name: 'æ˜Ÿäº‘', icon: 'â˜ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'ç»šä¸½æ˜Ÿäº‘' },
  [Shape3DType.BLACK_HOLE]: { name: 'é»‘æ´', icon: 'ğŸ•³ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—¶ç©ºæ¼©æ¶¡' },
  [Shape3DType.SUPERNOVA]: { name: 'è¶…æ–°æ˜Ÿ', icon: 'ğŸ’¥', category: SHAPE_CATEGORIES.COSMOS, description: 'æ’æ˜Ÿçˆ†å‘' },
  [Shape3DType.COMET]: { name: 'å½—æ˜Ÿ', icon: 'â˜„ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'æ‹–å°¾å½—æ˜Ÿ' },
  [Shape3DType.ASTEROID_BELT]: { name: 'å°è¡Œæ˜Ÿå¸¦', icon: 'ğŸŒ‘', category: SHAPE_CATEGORIES.COSMOS, description: 'å²©çŸ³ç¯å¸¦' },
  [Shape3DType.CONSTELLATION]: { name: 'æ˜Ÿåº§', icon: 'âœ¨', category: SHAPE_CATEGORIES.COSMOS, description: 'æ˜Ÿåº§è¿çº¿' },
  [Shape3DType.PULSAR]: { name: 'è„‰å†²æ˜Ÿ', icon: 'ğŸ“¡', category: SHAPE_CATEGORIES.COSMOS, description: 'å°„ç”µè„‰å†²' },
  [Shape3DType.WORMHOLE]: { name: 'è™«æ´', icon: 'ğŸŒ€', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—¶ç©ºéš§é“' },
  
  // æ–‡åŒ–ç¬¦å·
  [Shape3DType.HEART_3D]: { name: 'è·³åŠ¨ä¹‹å¿ƒ', icon: 'â¤ï¸', category: SHAPE_CATEGORIES.CULTURE, description: 'ç«‹ä½“çˆ±å¿ƒ' },
  [Shape3DType.CROWN_3D]: { name: 'çš‡å† ', icon: 'ğŸ‘‘', category: SHAPE_CATEGORIES.CULTURE, description: 'ç‹è€…ä¹‹å† ' },
  [Shape3DType.DRAGON_3D]: { name: 'æ¸¸é¾™æˆç ', icon: 'ğŸ‰', category: SHAPE_CATEGORIES.CULTURE, description: 'ä¸œæ–¹ç¥é¾™' },
  [Shape3DType.PHOENIX]: { name: 'å‡¤å‡°æ¶…æ§ƒ', icon: 'ğŸ”¥', category: SHAPE_CATEGORIES.CULTURE, description: 'æµ´ç«é‡ç”Ÿ' },
  [Shape3DType.YIN_YANG]: { name: 'å¤ªæ', icon: 'â˜¯ï¸', category: SHAPE_CATEGORIES.CULTURE, description: 'é˜´é˜³è°ƒå’Œ' },
  [Shape3DType.LOTUS]: { name: 'è²èŠ±', icon: 'ğŸª·', category: SHAPE_CATEGORIES.CULTURE, description: 'å‡ºæ·¤æ³¥è€Œä¸æŸ“' },
  [Shape3DType.LANTERN]: { name: 'ç¯ç¬¼', icon: 'ğŸ®', category: SHAPE_CATEGORIES.CULTURE, description: 'å–œåº†ç¯ç¬¼' },
  [Shape3DType.FIREWORK_CLASSIC]: { name: 'ç»å…¸çƒŸèŠ±', icon: 'ğŸ†', category: SHAPE_CATEGORIES.CULTURE, description: 'ä¼ ç»Ÿçˆ†ç‚¸' },
  [Shape3DType.RIBBON]: { name: 'å½©å¸¦', icon: 'ğŸ€', category: SHAPE_CATEGORIES.CULTURE, description: 'é£˜é€¸å½©å¸¦' },
  [Shape3DType.FIREWORK_WILLOW]: { name: 'é‡‘æŸ³å‚ä¸', icon: 'ğŸ‹', category: SHAPE_CATEGORIES.CULTURE, description: 'å‚è½ä¸çº¿' },
  
  // ç‰¹æ•ˆç±»
  [Shape3DType.EXPLOSION_BURST]: { name: 'é«˜äº®çˆ†å‘', icon: 'ğŸ’«', category: SHAPE_CATEGORIES.EFFECTS, description: 'è€€çœ¼é—ªå…‰' },
  [Shape3DType.RING_WAVE]: { name: 'ç¯å½¢æ³¢', icon: 'â—', category: SHAPE_CATEGORIES.EFFECTS, description: 'æ‰©æ•£å…‰ç¯' },
  [Shape3DType.DOUBLE_RING]: { name: 'åŒå±‚ç¯', icon: 'âŠ›', category: SHAPE_CATEGORIES.EFFECTS, description: 'å†…å¤–åŒç¯' },
  [Shape3DType.CASCADE]: { name: 'é˜¶æ¢¯ç€‘å¸ƒ', icon: 'ğŸŒŠ', category: SHAPE_CATEGORIES.EFFECTS, description: 'å±‚å ä¸‹è½' },
  [Shape3DType.WATERFALL_3D]: { name: 'ä¹å¤©ç€‘å¸ƒ', icon: 'ğŸ’§', category: SHAPE_CATEGORIES.EFFECTS, description: 'é£æµç›´ä¸‹' },
  [Shape3DType.FOUNTAIN]: { name: 'å–·æ³‰', icon: 'â›²', category: SHAPE_CATEGORIES.EFFECTS, description: 'å‘ä¸Šå–·æ¶Œ' },
  [Shape3DType.VORTEX]: { name: 'æ¼©æ¶¡', icon: 'ğŸŒªï¸', category: SHAPE_CATEGORIES.EFFECTS, description: 'å¿«é€Ÿæ—‹è½¬' },
  [Shape3DType.SHOCKWAVE]: { name: 'å†²å‡»æ³¢', icon: 'ã€œ', category: SHAPE_CATEGORIES.EFFECTS, description: 'éœ‡è¡æ‰©æ•£' },
  [Shape3DType.SPARKLE_CLOUD]: { name: 'é—ªçƒäº‘', icon: 'âœ¨', category: SHAPE_CATEGORIES.EFFECTS, description: 'éšæœºé—ªçƒ' },
  [Shape3DType.CHAOS_SCATTER]: { name: 'æ··æ²Œæ•£å°„', icon: 'ğŸ²', category: SHAPE_CATEGORIES.EFFECTS, description: 'éšæœºå››æ•£' },
};

/**
 * 3Dç‚¹ç”Ÿæˆç»“æœ
 */
export interface Shape3DPoint {
  position: Vector3;
  hue: number;
  size?: number;
  behavior?: string;
  decay?: number;
  friction?: number;
}

/**
 * 3Då½¢çŠ¶ç”Ÿæˆå™¨
 * ç”ŸæˆçœŸæ­£çš„3Dç‚¹åˆ†å¸ƒ
 */
export class Shape3DGenerator {
  /**
   * ç”Ÿæˆå½¢çŠ¶çš„ç‚¹åˆ†å¸ƒ
   * @param type å½¢çŠ¶ç±»å‹
   * @param count ç‚¹æ•°é‡
   * @param scale ç¼©æ”¾æ¯”ä¾‹
   * @param baseHue åŸºç¡€è‰²ç›¸
   * @returns ç‚¹æ•°ç»„
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale: number = 1,
    baseHue: number = 0
  ): Shape3DPoint[] {
    const points: Shape3DPoint[] = [];
    const s = scale;
    
    switch (type) {
      // === åŸºç¡€å‡ ä½• ===
      case Shape3DType.SPHERE:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 30 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue + (i / count) * 60
          });
        }
        break;
        
      case Shape3DType.CUBE: {
        const side = 25 * s;
        // åˆ†é…ç‚¹ï¼šè¾¹ç¼˜çº¿ 40%ï¼Œé¢ 60%
        const edgeCount = Math.floor(count * 0.4);
        const faceCount = count - edgeCount;

        // 1. å¼ºåŒ–è¾¹ç¼˜çº¿ (12æ¡è¾¹)
        for (let i = 0; i < edgeCount; i++) {
          const edge = Math.floor(Math.random() * 12);
          const t = Math.random() * 2 - 1;
          let p: Vector3;
          switch(edge) {
            case 0: p = new Vector3(side, side, t * side); break;
            case 1: p = new Vector3(side, -side, t * side); break;
            case 2: p = new Vector3(-side, side, t * side); break;
            case 3: p = new Vector3(-side, -side, t * side); break;
            case 4: p = new Vector3(side, t * side, side); break;
            case 5: p = new Vector3(side, t * side, -side); break;
            case 6: p = new Vector3(-side, t * side, side); break;
            case 7: p = new Vector3(-side, t * side, -side); break;
            case 8: p = new Vector3(t * side, side, side); break;
            case 9: p = new Vector3(t * side, side, -side); break;
            case 10: p = new Vector3(t * side, -side, side); break;
            default: p = new Vector3(t * side, -side, -side);
          }
          points.push({ position: p, hue: baseHue + (t + 1) * 30, size: 4 });
        }

        // 2. å¡«å……é¢ (6ä¸ªé¢)
        for (let i = 0; i < faceCount; i++) {
          const face = Math.floor(Math.random() * 6);
          const u = Math.random() * 2 - 1;
          const v = Math.random() * 2 - 1;
          let p: Vector3;
          switch(face) {
            case 0: p = new Vector3(side, u * side, v * side); break;
            case 1: p = new Vector3(-side, u * side, v * side); break;
            case 2: p = new Vector3(u * side, side, v * side); break;
            case 3: p = new Vector3(u * side, -side, v * side); break;
            case 4: p = new Vector3(u * side, v * side, side); break;
            default: p = new Vector3(u * side, v * side, -side);
          }
          // å¢åŠ è‰²å½©æ·±åº¦å’Œå‘å…‰æ„Ÿ
          points.push({ 
            position: p, 
            hue: baseHue + (u + v + 2) * 20,
            size: 3,
            decay: 0.008 // æ­£æ–¹å½¢å­˜ç•™æ—¶é—´ç¨é•¿
          });
        }
        break;
      }

      case Shape3DType.PYRAMID: {
        const h = 40 * s;
        const side = 30 * s;
        // 5ä¸ªé¢ï¼š1ä¸ªåº•é¢(æ­£æ–¹å½¢)ï¼Œ4ä¸ªä¾§é¢(ä¸‰è§’å½¢)
        for (let i = 0; i < count; i++) {
          const part = Math.floor(Math.random() * 5);
          let u = Math.random();
          let v = Math.random();
          let p: Vector3;

          if (part === 0) { // åº•é¢
            p = new Vector3((u - 0.5) * 2 * side, 0, (v - 0.5) * 2 * side);
          } else { // ä¾§é¢
            if (u + v > 1) { u = 1 - u; v = 1 - v; } // ä¿æŒåœ¨ä¸‰è§’å½¢å†…
            const tip = new Vector3(0, h, 0);
            const corners = [
              new Vector3(side, 0, side), new Vector3(-side, 0, side),
              new Vector3(-side, 0, -side), new Vector3(side, 0, -side)
            ];
            const c1 = corners[part - 1];
            const c2 = corners[part % 4];
            p = tip.clone().multiplyScalar(1 - u - v).add(c1.clone().multiplyScalar(u)).add(c2.clone().multiplyScalar(v));
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 60 });
        }
        break;
      }
        
      case Shape3DType.OCTAHEDRON: {
        const r = 35 * s;
        // 8ä¸ªé¢ (å…¨ç­‰ä¸‰è§’å½¢)
        for (let i = 0; i < count; i++) {
          const face = Math.floor(Math.random() * 8);
          // é¡¶ç‚¹ï¼š(Â±r, 0, 0), (0, Â±r, 0), (0, 0, Â±r)
          const vertices = [
            new Vector3(r, 0, 0), new Vector3(-r, 0, 0),
            new Vector3(0, r, 0), new Vector3(0, -r, 0),
            new Vector3(0, 0, r), new Vector3(0, 0, -r)
          ];
          // å®šä¹‰8ä¸ªé¢çš„é¡¶ç‚¹ç»„åˆ
          const faceMap = [
            [0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5],
            [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5]
          ];
          const [v1, v2, v3] = faceMap[face].map(idx => vertices[idx]);
          let u = Math.random(), v = Math.random();
          if (u + v > 1) { u = 1 - u; v = 1 - v; }
          const p = v1.clone().multiplyScalar(1 - u - v).add(v2.clone().multiplyScalar(u)).add(v3.clone().multiplyScalar(v));
          points.push({ position: p, hue: baseHue + (p.y / r) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.DODECAHEDRON: {
        const r = 30 * s;
        const phi = (1 + Math.sqrt(5)) / 2;
        // é¡¶ç‚¹å®šä¹‰ (20å¯¹)
        const v = [
          [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
          [0, 1/phi, phi], [0, 1/phi, -phi], [0, -1/phi, phi], [0, -1/phi, -phi],
          [1/phi, phi, 0], [1/phi, -phi, 0], [-1/phi, phi, 0], [-1/phi, -phi, 0],
          [phi, 0, 1/phi], [phi, 0, -1/phi], [-phi, 0, 1/phi], [-phi, 0, -1/phi]
        ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));

        for (let i = 0; i < count; i++) {
          const vIdx = Math.floor(Math.random() * v.length);
          const p = v[vIdx].clone();
          // åœ¨é¡¶ç‚¹åŠå…¶ä¸´è¿‘åŒºåŸŸé‡‡æ ·
          const jitter = (Math.random() - 0.5) * 5 * s;
          p.x += jitter; p.y += jitter; p.z += jitter;
          points.push({ position: p, hue: baseHue + (p.length() / r) * 100, size: 4 });
        }
        break;
      }
      
      case Shape3DType.ICOSAHEDRON: {
        const t = (1 + Math.sqrt(5)) / 2;
        const r = 35 * s;
        // 20ä¸ªé¢ï¼Œé‡‡æ ·ç‚¹åˆ†å¸ƒåœ¨é¢ä¸Š
        for (let i = 0; i < count; i++) {
          const vertices = [
            [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
            [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
            [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
          ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));
          
          const faceIdx = Math.floor(Math.random() * 20);
          // è¿™é‡Œæœ¬åº”å®šä¹‰20ä¸ªé¢ï¼Œç®€åŒ–ä¸ºåœ¨çƒé¢ä¸ŠåŸºäºå¤§åœ†æ­¥è¿›
          const angle = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          // å¢åŠ  icos ç‹¬æœ‰çš„â€œå‡ ä½•æŠ–åŠ¨â€ï¼Œä½¿å…¶æ˜¾å¾—æ£±è§’ç¡¬æœ—
          const p = new Vector3(Math.sin(phi)*Math.cos(angle)*r, Math.sin(phi)*Math.sin(angle)*r, Math.cos(phi)*r);
          p.x=Math.round(p.x/5)*5; p.y=Math.round(p.y/5)*5; p.z=Math.round(p.z/5)*5;
          points.push({ position: p, hue: baseHue + 200, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CYLINDER: {
        const h = 60 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.2) { // é¡¶ç›–
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, h/2, Math.sin(angle) * dist);
          } else if (part < 0.4) { // åº•ç›–
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, -h/2, Math.sin(angle) * dist);
          } else { // ä¾§å£
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * h;
            p = new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
          }
          points.push({ position: p, hue: baseHue + (p.y / h + 0.5) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CONE: {
        const h = 60 * s;
        const r = 30 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.3) { // åº•åº§
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
          } else { // é”¥é¢
            const y = Math.random() * h;
            const currentR = r * (1 - y / h);
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 + (p.x/r)*20, size: 3 });
        }
        break;
      }
      
      case Shape3DType.TORUS: {
        const R = 30 * s; 
        const r = 10 * s;
        // åœ†ç¯ä¸‰å±‚é‡‡æ ·ï¼šå†…åœˆã€å¤–åœˆã€ç®¡å£é¢
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // å¢åŠ è‰²å½©æ¸å˜å¯¹å‘¨é•¿çš„ä¾èµ–
          const hueOffset = (theta / (Math.PI * 2)) * 60;
          points.push({
            position: new Vector3(
              (R + r * Math.cos(phi)) * Math.cos(theta),
              r * Math.sin(phi),
              (R + r * Math.cos(phi)) * Math.sin(theta)
            ),
            hue: (baseHue + hueOffset) % 360,
            size: 4
          });
        }
        break;
      }
      
      case Shape3DType.TORUS_KNOT: {
        const R = 20 * s;
        const r = 6 * s;
        const p = 2, q = 3;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2 * 3;
          const x = (R + r * Math.cos(q * t)) * Math.cos(p * t);
          const y = r * Math.sin(q * t);
          const z = (R + r * Math.cos(q * t)) * Math.sin(p * t);
          points.push({ position: new Vector3(x, y, z), hue: baseHue + (i / count) * 360 });
        }
        break;
      }
      
      // === é«˜çº§å‡ ä½• ===
      case Shape3DType.CAPSULE: {
        const h = 40 * s;
        const r = 15 * s;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const v = Math.random();
          let y: number, currentR: number;
          if (v < 0.3) { // åº•éƒ¨åŠçƒ
            const phi = Math.PI / 2 + Math.random() * Math.PI / 2;
            y = -h / 2 + r * Math.cos(phi - Math.PI / 2);
            currentR = r * Math.sin(phi);
          } else if (v > 0.7) { // é¡¶éƒ¨åŠçƒ
            const phi = Math.random() * Math.PI / 2;
            y = h / 2 + r * Math.sin(phi);
            currentR = r * Math.cos(phi);
          } else { // ä¸­é—´åœ†æŸ±
            y = (v - 0.5) * h;
            currentR = r;
          }
          points.push({
            position: new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR),
            hue: baseHue + (y / h + 0.5) * 60
          });
        }
        break;
      }
      
      case Shape3DType.STAR_3D: {
        const outerR = 30 * s;
        const innerR = 12 * s;
        const pts = 5;
        const depth = 5 * s; // å¢åŠ  3D åšåº¦
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const angle = t * Math.PI * 2;
          const isOuter = Math.floor(t * pts * 2) % 2 === 0;
          const r = isOuter ? outerR : innerR;
          const z = (Math.random() - 0.5) * depth;
          points.push({
            position: new Vector3(Math.cos(angle) * r, Math.sin(angle) * r, z),
            hue: baseHue + (isOuter ? 0 : 40),
            size: isOuter ? 8 : 4
          });
        }
        break;
      }
      
      case Shape3DType.PRISM: {
        const h = 50 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const part = Math.floor(Math.random() * 5); // 2ä¸ªåº•é¢ï¼Œ3ä¸ªä¾§é¢
          let p: Vector3;
          if (part < 2) { // åº•é¢ (ä¸‰è§’å½¢)
             let u = Math.random(), v = Math.random();
             if (u + v > 1) { u = 1 - u; v = 1 - v; }
             const y = part === 0 ? h / 2 : -h / 2;
             // æ­£ä¸‰è§’å½¢åæ ‡
             const v1 = new Vector3(0, y, r);
             const v2 = new Vector3(r * 0.866, y, -r * 0.5);
             const v3 = new Vector3(-r * 0.866, y, -r * 0.5);
             p = v1.multiplyScalar(1 - u - v).add(v2.multiplyScalar(u)).add(v3.multiplyScalar(v));
          } else { // ä¾§é¢
             const side = part - 2;
             const angle1 = (side / 3) * Math.PI * 2;
             const angle2 = ((side + 1) / 3) * Math.PI * 2;
             const u = Math.random();
             const y = (Math.random() - 0.5) * h;
             const x = Math.cos(angle1) * r * (1 - u) + Math.cos(angle2) * r * u;
             const z = Math.sin(angle1) * r * (1 - u) + Math.sin(angle2) * r * u;
             p = new Vector3(x, y, z);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 });
        }
        break;
      }

      case Shape3DType.CROSS_3D: {
        const len = 40 * s;
        const thick = 10 * s;
        for (let i = 0; i < count; i++) {
          const axis = Math.floor(Math.random() * 3);
          const t = (Math.random() - 0.5) * 2 * len;
          const u = (Math.random() - 0.5) * thick;
          const v = (Math.random() - 0.5) * thick;
          let p: Vector3;
          if (axis === 0) p = new Vector3(t, u, v);
          else if (axis === 1) p = new Vector3(u, t, v);
          else p = new Vector3(u, v, t);
          points.push({ position: p, hue: baseHue + (t / len) * 50 });
        }
        break;
      }

      case Shape3DType.DIAMOND: {
        const r = 35 * s;
        const h = 40 * s;
        for (let i = 0; i < count; i++) {
          const v = Math.random();
          const angle = Math.random() * Math.PI * 2;
          let y: number, curR: number;
          if (v < 0.4) { // ä¸Šéƒ¨å°é¢åŠæ–œé¢
             y = (1 - v / 0.4) * h * 0.4;
             curR = r * (0.6 + (v / 0.4) * 0.4);
          } else { // ä¸‹éƒ¨å°–è§’
             y = -(v - 0.4) / 0.6 * h * 1.5;
             curR = r * (1 - (v - 0.4) / 0.6);
          }
          // å¯¹ angle è¿›è¡Œ stepped å¤„ç†æ¨¡æ‹Ÿåˆ‡é¢æ„Ÿ
          const stepAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
          points.push({ position: new Vector3(Math.cos(stepAngle)*curR, y, Math.sin(stepAngle)*curR), hue: 200, size: 2 });
        }
        break;
      }

      case Shape3DType.MOBIUS: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const u = (i / count) * Math.PI * 2;
          const v = (Math.random() - 0.5) * 15 * s;
          const x = (R + v * Math.cos(u/2)) * Math.cos(u);
          const y = (R + v * Math.cos(u/2)) * Math.sin(u);
          const z = v * Math.sin(u/2);
          points.push({ position: new Vector3(x, z, y), hue: baseHue + (u/Math.PI)*60 });
        }
        break;
      }

      case Shape3DType.KLEIN_BOTTLE: {
        for (let i = 0; i < count; i++) {
          const u = Math.random() * Math.PI;
          const v = Math.random() * Math.PI * 2;
          const x = -2/15 * Math.cos(u) * (3*Math.cos(v) - 30*Math.sin(u) + 90*Math.pow(Math.cos(u),4)*Math.sin(u) - 60*Math.pow(Math.cos(u),6)*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u));
          const y = -1/15 * Math.sin(u) * (3*Math.cos(v) - 3*Math.pow(Math.cos(u),2)*Math.cos(v) - 48*Math.pow(Math.cos(u),4)*Math.cos(v) + 48*Math.pow(Math.cos(u),6)*Math.cos(v) - 60*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u) - 5*Math.pow(Math.cos(u),3)*Math.cos(v)*Math.sin(u) - 80*Math.pow(Math.cos(u),5)*Math.cos(v)*Math.sin(u) + 80*Math.pow(Math.cos(u),7)*Math.cos(v)*Math.sin(u));
          const z = 2/15 * (3 + 5*Math.cos(u)*Math.sin(u)) * Math.sin(v);
          points.push({ position: new Vector3(x*15*s, y*15*s, z*15*s), hue: 280 + (u/Math.PI)*80 });
        }
        break;
      }

      case Shape3DType.SPRING: {
        const r = 15 * s;
        const R = 30 * s;
        const turns = 5;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const angle = t * Math.PI * 2 * turns;
          const y = (t - 0.5) * 80 * s;
          const x = Math.cos(angle) * R + (Math.random()-0.5)*5*s;
          const z = Math.sin(angle) * R + (Math.random()-0.5)*5*s;
          points.push({ position: new Vector3(x, y, z), hue: baseHue + t * 360 });
        }
        break;
      }

      case Shape3DType.HELIX_TUBE: {
        const h = 80 * s;
        const r = 20 * s;
        const turns = 3;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const y = (t - 0.5) * h;
          const angle = t * Math.PI * 2 * turns;
          // åŒèºæ—‹
          points.push({
            position: new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle + Math.PI) * r, y, Math.sin(angle + Math.PI) * r),
            hue: (baseHue + 180) % 360
          });
        }
        break;
      }
      
      case Shape3DType.NESTED_SPHERES: {
        const layers = 3;
        for (let layer = 1; layer <= layers; layer++) {
          const r = (layer / layers) * 35 * s;
          const layerCount = Math.floor(count / layers);
          for (let i = 0; i < layerCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            points.push({
              position: new Vector3(
                Math.sin(phi) * Math.cos(theta) * r,
                Math.sin(phi) * Math.sin(theta) * r,
                Math.cos(phi) * r
              ),
              hue: baseHue + (layer - 1) * 60, // æ¯ä¸€å±‚ä½¿ç”¨æˆªç„¶ä¸åŒçš„è‰²ç›¸
              size: 2 + (layers - layer) * 2 // å¤–å±‚ç²’å­æ›´å°æ›´å¯†ï¼Œå†…å±‚æ›´å¤§
            });
          }
        }
        break;
      }
      
      // === è‡ªç„¶ç”Ÿç‰© ===
      case Shape3DType.BUTTERFLY_3D: {
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2;
          const h = (Math.random() - 0.5) * 2;
          // 3D è´è¶æ›²é¢ (åŸºäºæåæ ‡å˜æ¢)
          const m = (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t/12), 5)) * 10 * s;
          const x = Math.sin(t) * m;
          const y = Math.cos(t) * m;
          // ç¿…è†€å¼€åˆ 3D æ„Ÿ
          const wingAngle = Math.abs(Math.sin(t)) * 0.5;
          const z = Math.abs(x) * wingAngle + (Math.random() - 0.5) * 5 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: baseHue + (Math.abs(x) / (20 * s)) * 200 // ç¿…è†€è¾¹ç¼˜å˜è‰²
          });
        }
        break;
      }
      
      case Shape3DType.FLOWER_3D: {
        const petals = 6;
        const layers = 3;
        for (let layer = 0; layer < layers; layer++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + layer * 8) * s;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const petalMod = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.3);
            const y = layer * 5 * s - 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta) * r * petalMod, y, Math.sin(theta) * r * petalMod),
              hue: baseHue + layer * 40
            });
          }
        }
        break;
      }
      
      case Shape3DType.HEART_3D: {
        // çœŸ 3D ä½“ç§¯é‡‡æ ·çˆ±å¿ƒ - Taubin Surface å˜ä½“
        for (let i = 0; i < count; i++) {
          const t = Math.random() * Math.PI * 2;
          const p = Math.acos(2 * Math.random() - 1);
          // ä½¿ç”¨å‚æ•°åŒ–çƒåæ ‡å¹¶è¿›è¡Œå¿ƒè„æ˜ å°„å˜æ¢
          const sinP = Math.sin(p), cosP = Math.cos(p), sinT = Math.sin(t), cosT = Math.cos(t);
          
          let x = 1.2 * sinP * sinT;
          let y = 1.2 * sinP * cosT;
          let z = cosP;
          
          // ç»™çƒä½“æ–½åŠ â€œå¿ƒå½¢æ‹‰ä¼¸â€
          // y å‘ä¸‹å‡¹é™·ï¼Œé¡¶éƒ¨å‘ä¸Šéš†èµ·
          y += Math.pow(Math.abs(x), 0.6) * 0.5;
          // ä¿®æ­£åæ ‡ä½¿å…¶å°–ç«¯å‘ä¸‹ï¼šåè½¬ y çš„æ‹‰ä¼¸æ–¹å‘
          const finalX = x * 25 * s;
          const finalY = y * 22 * s - 10 * s; // ä¿®æ­£åçš„å°–ç«¯å‘ä¸‹é€»è¾‘
          const finalZ = z * 18 * s * Math.pow(Math.abs(sinT), 0.3); // å¢åŠ ä¾§å‘é¥±æ»¡åº¦
          
          points.push({
            position: new Vector3(finalX, finalY, finalZ),
            hue: 340 + Math.random() * 40,
            size: 5 + Math.random() * 3,
            decay: 0.006 // çˆ±å¿ƒå­˜ç•™æ›´ä¹…
          });
        }
        break;
      }
      
      case Shape3DType.SNOWFLAKE_3D: {
        const arms = 6;
        const r = 35 * s;
        for (let i = 0; i < count; i++) {
          const arm = Math.floor(Math.random() * arms);
          const t = Math.random();
          const angle = (arm / arms) * Math.PI * 2;
          // ä¸»è½´
          let pX = Math.cos(angle) * t * r;
          let pY = (Math.random() - 0.5) * 2 * s; // æ‰å¹³ 3D
          let pZ = Math.sin(angle) * t * r;
          // æ”¯å‰
          if (t > 0.4) {
             const subT = Math.random() * 0.3 * t;
             const subAngle = angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3;
             pX += Math.cos(subAngle) * subT * r;
             pZ += Math.sin(subAngle) * subT * r;
          }
          points.push({ position: new Vector3(pX, pY, pZ), hue: 180 + Math.random() * 40 });
        }
        break;
      }
      case Shape3DType.TREE: {
        const h = 50 * s;
        // 1. æ ‘å¹² (20%)
        for (let i = 0; i < count * 0.2; i++) {
          const y = Math.random() * h * 0.4;
          points.push({ position: new Vector3((Math.random()-0.5)*2, y, (Math.random()-0.5)*2), hue: 30, size: 4 });
        }
        // 2. æ ‘å†  (80%) - å¤šä¸ªåˆ†å±‚çƒä½“ç»„æˆçš„äº‘å›¢
        for (let i = 0; i < count * 0.8; i++) {
          const layer = Math.floor(Math.random() * 3);
          const r = (15 + Math.random() * 10) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const center = new Vector3(0, h * 0.6 + layer * 10 * s, 0);
          points.push({
            position: new Vector3(
              center.x + Math.sin(phi) * Math.cos(theta) * r,
              center.y + Math.cos(phi) * r,
              center.z + Math.sin(phi) * Math.sin(theta) * r
            ),
            hue: 120 + Math.random() * 40 // ç»¿è‰²è°ƒ
          });
        }
        break;
      }

      case Shape3DType.BIRD: 
      case Shape3DType.PHOENIX: {
        const isPhoenix = type === Shape3DType.PHOENIX;
        const wingSpan = 50 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * 2 - 1; // -1 to 1
          const x = t * wingSpan;
          // ç¿¼å±•å¼§åº¦: M å‹
          const y = Math.abs(t) * 10 * s + Math.sin(Math.abs(t) * Math.PI) * 15 * s;
          const z = Math.cos(t * Math.PI) * 10 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: isPhoenix ? 20 + Math.random() * 40 : baseHue,
            size: isPhoenix ? 6 : 4,
            behavior: isPhoenix ? 'fire' : undefined
          });

          // å‡¤å‡°å°¾ç¾½
          if (isPhoenix && i % 5 === 0) {
            for(let j=1; j<5; j++) {
              points.push({
                position: new Vector3(x*0.2, -j*15*s, -j*5*s),
                hue: 10,
                behavior: 'willow'
              });
            }
          }
        }
        break;
      }

      case Shape3DType.JELLYFISH: {
        const r = 25 * s;
        // 1. ä¼ç›– (åŠçƒ)
        for (let i = 0; i < count * 0.5; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 0.5; // åªå–ä¸ŠåŠçƒ
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.cos(phi)*r, Math.sin(phi)*Math.sin(theta)*r),
            hue: baseHue + 200,
            behavior: 'glitter'
          });
        }
        // 2. è§¦é¡» (å‚çº¿)
        for (let i = 0; i < count * 0.5; i++) {
          const leg = Math.floor(Math.random() * 8);
          const angle = (leg / 8) * Math.PI * 2;
          const length = Math.random() * 40 * s;
          points.push({
            position: new Vector3(Math.cos(angle)*r*0.6, -length, Math.sin(angle)*r*0.6),
            hue: baseHue + 180,
            behavior: 'willow'
          });
        }
        break;
      }

      case Shape3DType.FISH_3D: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * len;
          // é±¼èº«: æ¤­çƒ
          const r = Math.sin(t * Math.PI) * 12 * s;
          const angle = Math.random() * Math.PI * 2;
          // é±¼å°¾: ä¸‰è§’å½¢ (tæ¥è¿‘1æ—¶)
          let y = Math.cos(angle) * r;
          let z = Math.sin(angle) * r;
          if (t > 0.8) {
             const tailW = (t - 0.8) * 50 * s;
             y = (Math.random() - 0.5) * tailW;
          }
          points.push({ position: new Vector3(x, y, z), hue: 40 + t * 40 });
        }
        break;
      }

      case Shape3DType.SHELL: {
        for (let i = 0; i < count; i++) {
          const t = i / count * Math.PI * 8; // 4åœˆ
          const r = 2 * Math.exp(0.1 * t) * s;
          const angle = t;
          const spiralX = r * Math.cos(angle);
          const spiralY = r * Math.sin(angle);
          const spiralZ = t * 2 * s;
          // ç»™èºæ—‹çº¿åŠ ç‚¹å®½åº¦
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(spiralX + offset, spiralY, spiralZ), hue: 200 + (t/30)*100 });
        }
        break;
      }

      case Shape3DType.LEAF: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const u = Math.random();
          const v = (Math.random() - 0.5) * 2;
          const x = u * len;
          // å¶å½¢: sinæ›²çº¿
          const w = Math.sin(u * Math.PI) * 15 * s;
          const y = v * w;
          const z = Math.sin(u * Math.PI * 2) * 5 * s; // å·æ›²æ„Ÿ
          points.push({ position: new Vector3(x - len/2, y, z), hue: 100 + u * 60 });
        }
        break;
      }

      case Shape3DType.MUSHROOM: {
        const rCap = 30 * s;
        const hStem = 30 * s;
        for (let i = 0; i < count; i++) {
          if (i < count * 0.7) { // èŒç›–
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.4;
            points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*rCap, Math.cos(phi)*rCap*0.5 + hStem, Math.sin(phi)*Math.sin(theta)*rCap), hue: 0 });
          } else { // èŒæŸ„
            const y = Math.random() * hStem;
            const angle = Math.random() * Math.PI * 2;
            const rs = 8 * s;
            points.push({ position: new Vector3(Math.cos(angle)*rs, y, Math.sin(angle)*rs), hue: 40 });
          }
        }
        break;
      }

      // === å®‡å®™å¤©ä½“ (è¡¥å…¨å®ç°) ===
      case Shape3DType.BLACK_HOLE: {
        // 1. å¸ç§¯ç›˜ (æ‰å¹³æ—‹è½¬)
        for (let i = 0; i < count * 0.8; i++) {
          const dist = (15 + Math.random() * 45) * s;
          const angle = Math.random() * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*2, Math.sin(angle)*dist),
            hue: 280 + (dist/60)*80,
            behavior: 'vortex'
          });
        }
        // 2. è§†ç•Œ (æ ¸å¿ƒé»‘ç )
        for (let i = 0; i < count * 0.2; i++) {
          const r = 10 * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: 0,
            size: 2
          });
        }
        break;
      }

      case Shape3DType.PULSAR: {
        const r = 15 * s;
        // 1. æ ¸å¿ƒ
        for (let i = 0; i < count * 0.4; i++) {
           const theta = Math.random()*Math.PI*2;
           const phi = Math.acos(2*Math.random()-1);
           points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r), hue: 200, behavior: 'glitter' });
        }
        // 2. ç£æå–·æµ (ä¸¤ç«¯é«˜èƒ½æŸ±)
        for (let i = 0; i < count * 0.6; i++) {
           const side = Math.random() > 0.5 ? 1 : -1;
           const len = Math.random() * 80 * s;
           const spread = (len / (80*s)) * 5 * s;
           points.push({
             position: new Vector3((Math.random()-0.5)*spread, side * len, (Math.random()-0.5)*spread),
             hue: 240,
             behavior: 'glitter',
             size: 5
           });
        }
        break;
      }

      case Shape3DType.SUPERNOVA: {
        // å¤§çˆ†å‘ï¼šå†…çˆ†ç¬é—´çš„å¤–æ‰©
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isRay = Math.random() > 0.7;
          const r = isRay ? (40 + Math.random() * 60) * s : (20 + Math.random() * 20) * s;
          
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: isRay ? 0 : 40 + Math.random() * 40,
            size: isRay ? 8 : 4,
            behavior: isRay ? 'glitter' : 'fire'
          });
        }
        break;
      }

      case Shape3DType.ASTEROID_BELT: {
        const R = 40 * s;
        const r = 8 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // å—çŠ¶é‡‡æ ·
          const dist = R + (Math.random() - 0.5) * r * 2;
          points.push({
            position: new Vector3(Math.cos(theta)*dist, (Math.random()-0.5)*r, Math.sin(theta)*dist),
            hue: 30 + Math.random() * 20,
            size: Math.random() * 5 + 2,
            friction: 0.98
          });
        }
        break;
      }

      case Shape3DType.COMET: {
        const len = 100 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.pow(Math.random(), 2); // å°¾éƒ¨æ›´ç¨€ç–
          const dist = t * len;
          const spread = t * 20 * s;
          points.push({
            position: new Vector3((Math.random()-0.5)*spread, -dist, (Math.random()-0.5)*spread),
            hue: 180 + t * 60,
            behavior: 'willow',
            size: (1-t) * 8
          });
        }
        break;
      }

      // === æ–‡åŒ–ç¬¦å· (è¡¥å…¨å®ç°) ===
      case Shape3DType.LOTUS: {
        const layers = 4;
        for (let l = 0; l < layers; l++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + l * 10) * s;
          const petals = 8 + l * 4;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const phiLocal = (i / layerCount) * Math.PI * 2; // å±€éƒ¨å˜é‡ç”¨äºæ¨¡æ‹ŸèŠ±ç“£å¼ å¼€åº¦
            const petalCurve = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.5);
            const y = Math.sin(phiLocal * 0.5) * 10 * s + l * 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta)*r*petalCurve, y, Math.sin(theta)*r*petalCurve),
              hue: 330 + l * 20
            });
          }
        }
        break;
      }

      case Shape3DType.CROWN_3D: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const theta = (i / count) * Math.PI * 2;
          const isPoint = Math.floor(theta * 6 / Math.PI) % 2 === 0;
          const y = isPoint ? Math.sin(theta * 6) * 20 * s + 10 * s : 0;
          points.push({
            position: new Vector3(Math.cos(theta)*R, y, Math.sin(theta)*R),
            hue: 50,
            size: 6
          });
        }
        break;
      }

      case Shape3DType.YIN_YANG: {
        const R = 35 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * R;
          const x = Math.cos(theta) * r;
          const z = Math.sin(theta) * r;
          const isWhite = x > 0; // ç®€åŒ–å®ç°
          points.push({ position: new Vector3(x, 0, z), hue: isWhite ? 0 : 200, size: isWhite ? 6 : 4 });
        }
        break;
      }

      case Shape3DType.GALAXY_SPIRAL: {
        const arms = 4;
        const armDensity = 0.8;
        for (let i = 0; i < count; i++) {
          const arm = i % arms;
          const dist = Math.pow(Math.random(), 0.7) * 60 * s;
          const angle = (arm / arms) * Math.PI * 2 + dist * 0.15;
          const scatter = (Math.random() - 0.5) * (60 * s / (dist + 5)) * 5;
          
          const p = new Vector3(
            Math.cos(angle) * dist + (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 8 * s * (1 - dist / (60 * s)),
            Math.sin(angle) * dist + (Math.random() - 0.5) * 5
          );
          
          points.push({
            position: p,
            hue: baseHue + (dist / (60 * s)) * 100,
            size: Math.random() > 0.8 ? 8 : 4,
            behavior: 'glitter'
          });
        }
        break;
      }
      
      case Shape3DType.PLANET_RINGS: {
        // è¡Œæ˜Ÿæœ¬ä½“
        for (let i = 0; i < count * 0.3; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 15 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: 30
          });
        }
        // å…‰ç¯
        for (let i = 0; i < count * 0.7; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 25 + Math.random() * 15;
          points.push({
            position: new Vector3(
              Math.cos(angle) * dist * s,
              Math.cos(angle) * dist * 0.3 * s,
              Math.sin(angle) * dist * s
            ),
            hue: 200
          });
        }
        break;
      }
      
      case Shape3DType.NEBULA: {
        for (let i = 0; i < count; i++) {
          const r = (20 + Math.random() * 30) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const scatter = Math.pow(Math.random(), 2) * 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi)*Math.cos(theta)*r + (Math.random()-0.5)*scatter,
              Math.sin(phi)*Math.sin(theta)*r + (Math.random()-0.5)*scatter,
              Math.cos(phi)*r + (Math.random()-0.5)*scatter
            ),
            hue: baseHue + Math.random() * 80,
            behavior: 'glitter',
            size: Math.random() * 6
          });
        }
        break;
      }

      case Shape3DType.WORMHOLE: {
        for (let i = 0; i < count; i++) {
          const t = (Math.random() - 0.5) * 2;
          const y = t * 60 * s;
          const r = (Math.abs(t) * 20 + 5) * s;
          const angle = (i / count) * Math.PI * 2 + t * 4;
          points.push({
            position: new Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r),
            hue: 240 + t * 60
          });
        }
        break;
      }

      case Shape3DType.CONSTELLATION: {
        const r = 50 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isStar = Math.random() > 0.9;
          const dist = isStar ? r : Math.random() * r;
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*dist, Math.sin(phi)*Math.sin(theta)*dist, Math.cos(phi)*dist),
            hue: isStar ? 0 : 200,
            size: isStar ? 8 : 2,
            behavior: isStar ? 'glitter' : undefined
          });
        }
        break;
      }

      case Shape3DType.LANTERN: {
        const h = 40 * s;
        const r = 20 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const angle = Math.random() * Math.PI * 2;
          const currentR = Math.sin(t * Math.PI) * r + 5 * s;
          const y = (t - 0.5) * h;
          points.push({ position: new Vector3(Math.cos(angle)*currentR, y, Math.sin(angle)*currentR), hue: 0 });
          if (t < 0.1) {
             const tassLen = Math.random() * 20 * s;
             points.push({ position: new Vector3(Math.cos(angle)*r*0.5, -h/2 - tassLen, Math.sin(angle)*r*0.5), hue: 45, behavior: 'willow' });
          }
        }
        break;
      }

      case Shape3DType.RIBBON: {
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * 100 * s;
          const y = Math.sin(t * Math.PI * 2) * 20 * s;
          const z = Math.cos(t * Math.PI * 2) * 20 * s;
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(x, y + offset, z), hue: t * 360, size: 4 });
        }
        break;
      }

      // === ç‰¹æ•ˆç±» ===
      case Shape3DType.EXPLOSION_BURST:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = (20 + Math.random() * 15) * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'glitter'
          });
        }
        break;
        
      case Shape3DType.RING_WAVE:
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const r = 30 * s;
          points.push({
            position: new Vector3(Math.cos(angle) * r, 0, Math.sin(angle) * r),
            hue: baseHue + (i / count) * 360
          });
        }
        break;
        
      case Shape3DType.DOUBLE_RING:
        for (let i = 0; i < count / 2; i++) {
          const angle = (i / (count / 2)) * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle) * 35 * s, 0, Math.sin(angle) * 35 * s),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle) * 20 * s, 0, Math.sin(angle) * 20 * s),
            hue: (baseHue + 180) % 360
          });
        }
        break;
        
      case Shape3DType.FIREWORK_WILLOW:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const r = 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'willow',
            decay: 0.008
          });
        }
        break;
        
      case Shape3DType.CHAOS_SCATTER:
        for (let i = 0; i < count; i++) {
          points.push({
            position: new Vector3(
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s
            ),
            hue: Math.random() * 360
          });
        }
        break;
        
      // é»˜è®¤ï¼šçƒå½¢
      default:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 25 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue
          });
        }
    }
    
    return points;
  }
}

/**
 * Shape3Då·¥å‚
 */
export class Shape3DFactory {
  private static allTypes: Shape3DType[] = Object.values(Shape3DType);
  
  /**
   * ç”ŸæˆæŒ‡å®šå½¢çŠ¶
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale?: number,
    baseHue?: number
  ): Shape3DPoint[] {
    return Shape3DGenerator.generate(type, count, scale, baseHue);
  }
  
  /**
   * æŒ‰æƒé‡éšæœºé€‰æ‹©ä¸€ä¸ªå½¢çŠ¶ç±»å‹ (å¢åŠ å¤æ‚å½¢çŠ¶æƒé‡)
   */
  static getRandomType(): Shape3DType {
    // é™ä½æ™®é€šçƒå½¢å‡ºç°çš„æƒé‡
    const weights: Record<string, number> = {
      [Shape3DType.SPHERE]: 0.1,
      [Shape3DType.NESTED_SPHERES]: 0.1,
      [Shape3DType.HEART_3D]: 1.5,
      [Shape3DType.BUTTERFLY_3D]: 1.5,
      [Shape3DType.GALAXY_SPIRAL]: 2.0,
      [Shape3DType.PLANET_RINGS]: 1.5,
    };
    
    // åŠ¨æ€ç”ŸæˆåŠ æƒåˆ—è¡¨
    const pool: Shape3DType[] = [];
    this.allTypes.forEach(t => {
      const w = weights[t] || 1.0;
      for(let i=0; i<w*10; i++) pool.push(t);
    });
    
    return pool[Math.floor(Math.random() * pool.length)];
  }
  
  /**
   * ä»åˆ—è¡¨ä¸­éšæœºé€‰æ‹©
   */
  static getRandomTypeFrom(types: Shape3DType[]): Shape3DType {
    if (types.length === 0) return Shape3DType.SPHERE;
    return types[Math.floor(Math.random() * types.length)];
  }
  
  /**
   * è·å–æ‰€æœ‰å½¢çŠ¶ç±»å‹
   */
  static getAllTypes(): Shape3DType[] {
    return [...this.allTypes];
  }
  
  /**
   * æŒ‰ç±»åˆ«è·å–å½¢çŠ¶
   */
  static getTypesByCategory(category: string): Shape3DType[] {
    return this.allTypes.filter(type => SHAPE_3D_INFO[type].category === category);
  }
  
  /**
   * è·å–å½¢çŠ¶ä¿¡æ¯
   */
  static getInfo(type: Shape3DType): Shape3DInfo {
    return SHAPE_3D_INFO[type];
  }
  
  /**
   * è·å–æ‰€æœ‰åˆ†ç±»
   */
  static getCategories(): string[] {
    return Object.values(SHAPE_CATEGORIES);
  }
}

// END OF FILE: src/core/shapes/Shape3DFactory.ts


// =============================================================================
// FILE: src\core\TimeController.ts
// =============================================================================

/**
 * TimeController - Controls the flow of time in the 3D world
 * Allows pausing, slow motion, and time acceleration
 */
export class TimeController {
  private _timeScale: number = 1;
  private _isPaused: boolean = false;
  private _lastRealTime: number = 0;
  private _virtualTime: number = 0;
  private _deltaTime: number = 0;

  // Preset time scales
  static readonly PAUSED = 0;
  static readonly SLOW_MOTION = 0.2;
  static readonly NORMAL = 1;
  static readonly FAST = 2;
  static readonly ULTRA_FAST = 5;

  constructor() {
    this._lastRealTime = performance.now();
  }

  /**
   * Update the time controller - call this every frame
   */
  update(): void {
    const currentRealTime = performance.now();
    const realDelta = (currentRealTime - this._lastRealTime) / 1000; // Convert to seconds
    this._lastRealTime = currentRealTime;

    if (this._isPaused) {
      this._deltaTime = 0;
    } else {
      this._deltaTime = realDelta * this._timeScale;
      this._virtualTime += this._deltaTime;
    }
  }

  /**
   * Get the delta time adjusted for time scale
   */
  get deltaTime(): number {
    return this._deltaTime;
  }

  /**
   * Get the virtual time in the simulation
   */
  get virtualTime(): number {
    return this._virtualTime;
  }

  /**
   * Get the current time scale
   */
  get timeScale(): number {
    return this._timeScale;
  }

  /**
   * Set the time scale (0 = paused, 1 = normal, 2 = double speed, etc.)
   */
  set timeScale(value: number) {
    this._timeScale = Math.max(0, Math.min(10, value));
    if (this._timeScale === 0) {
      this._isPaused = true;
    } else {
      this._isPaused = false;
    }
  }

  /**
   * Check if the simulation is paused
   */
  get isPaused(): boolean {
    return this._isPaused;
  }

  /**
   * Pause the simulation
   */
  pause(): void {
    this._isPaused = true;
  }

  /**
   * Resume the simulation
   */
  resume(): void {
    this._isPaused = false;
    this._lastRealTime = performance.now();
  }

  /**
   * Toggle pause state
   */
  togglePause(): void {
    if (this._isPaused) {
      this.resume();
    } else {
      this.pause();
    }
  }

  /**
   * Set to slow motion
   */
  setSlowMotion(): void {
    this._timeScale = TimeController.SLOW_MOTION;
    this._isPaused = false;
  }

  /**
   * Set to normal speed
   */
  setNormal(): void {
    this._timeScale = TimeController.NORMAL;
    this._isPaused = false;
  }

  /**
   * Set to fast forward
   */
  setFast(): void {
    this._timeScale = TimeController.FAST;
    this._isPaused = false;
  }

  /**
   * Increase time scale by a step
   */
  speedUp(step: number = 0.25): void {
    this.timeScale = Math.min(10, this._timeScale + step);
  }

  /**
   * Decrease time scale by a step
   */
  slowDown(step: number = 0.25): void {
    this.timeScale = Math.max(0.1, this._timeScale - step);
  }

  /**
   * Get a formatted string of the current time state
   */
  getStatusText(): string {
    if (this._isPaused) return 'â¸ å·²æš‚åœ';
    if (this._timeScale < 0.5) return `ğŸ¢ ${this._timeScale.toFixed(2)}x æ…¢åŠ¨ä½œ`;
    if (this._timeScale === 1) return 'â–¶ 1x æ­£å¸¸';
    if (this._timeScale <= 2) return `â© ${this._timeScale.toFixed(2)}x`;
    return `ğŸš€ ${this._timeScale.toFixed(2)}x è¶…é€Ÿ`;
  }
}


// =============================================================================
// FILE: src\core\trajectories\TrajectoryFactory.ts
// =============================================================================

// FILE: src/core/trajectories/TrajectoryFactory.ts
// è½¨è¿¹å·¥å‚ï¼šå®šä¹‰10+ç§çƒŸèŠ±ä¸Šå‡è½¨è¿¹

import { Vector3 } from '../Vector3';

/**
 * è½¨è¿¹ç±»å‹æšä¸¾
 * å®šä¹‰å„ç§ä¸Šå‡æ–¹å¼
 */
export enum TrajectoryType {
  // === åŸºç¡€è½¨è¿¹ ===
  LINEAR = 'linear',                     // ç›´çº¿ä¸Šå‡
  SPIRAL = 'spiral',                     // èºæ—‹ç›˜æ—‹
  ZIGZAG = 'zigzag',                     // Så‹æ‘‡æ‘†
  
  // === åŠ é€Ÿç±» ===
  ACCELERATE = 'accelerate',             // å•æ¬¡åŠ é€Ÿ
  DOUBLE_ACCELERATE = 'double_accelerate', // äºŒæ¬¡åŠ é€Ÿ
  TRIPLE_ACCELERATE = 'triple_accelerate', // ä¸‰æ¬¡åŠ é€Ÿ
  DECELERATE = 'decelerate',             // å‡é€Ÿ
  MIXED_SPEED = 'mixed_speed',           // æ··åˆå˜é€Ÿ
  
  // === æ›²çº¿ç±» ===
  BEZIER_CURVE = 'bezier_curve',         // è´å¡å°”æ›²çº¿
  PARABOLA = 'parabola',                 // æŠ›ç‰©çº¿
  SINE_WAVE = 'sine_wave',               // æ­£å¼¦æ³¢
  HELIX = 'helix',                       // èºæ—‹çº¿
  
  // === ç»„åˆç±» ===
  LINEAR_TO_CURVE = 'linear_to_curve',   // ç›´çº¿å˜æ›²çº¿
  CURVE_TO_LINEAR = 'curve_to_linear',   // æ›²çº¿å˜ç›´çº¿
  MULTI_SEGMENT = 'multi_segment',       // å¤šæ®µè½¨è¿¹
  
  // === ç‰¹æ®Šç±» ===
  WOBBLE = 'wobble',                     // éšæœºæ‰°åŠ¨
  FALL_RISE = 'fall_rise',               // å…ˆè½åå‡
  ORBIT = 'orbit',                       // ç»•åœˆä¸Šå‡
}

/**
 * è½¨è¿¹æ˜¾ç¤ºä¿¡æ¯
 */
export const TRAJECTORY_INFO: Record<TrajectoryType, { name: string; icon: string; description: string }> = {
  [TrajectoryType.LINEAR]: { name: 'ç›´çº¿å‡ç©º', icon: 'â¬†ï¸', description: 'ç¬”ç›´å‘ä¸Šé£è¡Œ' },
  [TrajectoryType.SPIRAL]: { name: 'èºæ—‹ç›˜æ—‹', icon: 'ğŸŒ€', description: 'æ—‹è½¬ä¸Šå‡å¦‚é¾™å·é£' },
  [TrajectoryType.ZIGZAG]: { name: 'Så‹æ‘‡æ‘†', icon: 'ã€°ï¸', description: 'å·¦å³æ‘†åŠ¨ä¸Šå‡' },
  
  [TrajectoryType.ACCELERATE]: { name: 'æé€Ÿæ¨è¿›', icon: 'ğŸš€', description: 'ä¸­é€”çªç„¶åŠ é€Ÿ' },
  [TrajectoryType.DOUBLE_ACCELERATE]: { name: 'äºŒæ¬¡åŠ é€Ÿ', icon: 'âš¡âš¡', description: 'ä¸¤æ¬¡çˆ†å‘åŠ é€Ÿ' },
  [TrajectoryType.TRIPLE_ACCELERATE]: { name: 'ä¸‰æ¬¡åŠ é€Ÿ', icon: 'âš¡âš¡âš¡', description: 'ä¸‰çº§ç«ç®­æ¨è¿›' },
  [TrajectoryType.DECELERATE]: { name: 'æ¸è¡Œæ¸ç¼“', icon: 'ğŸ¢', description: 'è¶Šæ¥è¶Šæ…¢ç„¶åçˆ†ç‚¸' },
  [TrajectoryType.MIXED_SPEED]: { name: 'æ··åˆå˜é€Ÿ', icon: 'ğŸ¢', description: 'åŠ é€Ÿå‡é€Ÿäº¤æ›¿' },
  
  [TrajectoryType.BEZIER_CURVE]: { name: 'è´å¡å°”æ›²çº¿', icon: 'ğŸ“', description: 'å¹³æ»‘å¼§çº¿è½¨è¿¹' },
  [TrajectoryType.PARABOLA]: { name: 'æŠ›ç‰©çº¿', icon: 'ğŸ¹', description: 'æ–œæŠ›+ä¸Šå‡' },
  [TrajectoryType.SINE_WAVE]: { name: 'æ­£å¼¦æ³¢', icon: 'ğŸ“Š', description: 'æ­£å¼¦æ³¢åŠ¨ä¸Šå‡' },
  [TrajectoryType.HELIX]: { name: '3Dèºæ—‹', icon: 'ğŸ§¬', description: 'DNAåŒèºæ—‹ä¸Šå‡' },
  
  [TrajectoryType.LINEAR_TO_CURVE]: { name: 'ç›´åå¼¯', icon: 'â†—ï¸', description: 'ç›´çº¿åè½¬å¼¯' },
  [TrajectoryType.CURVE_TO_LINEAR]: { name: 'å¼¯åç›´', icon: 'â†–ï¸', description: 'å¼¯æ›²åå˜ç›´' },
  [TrajectoryType.MULTI_SEGMENT]: { name: 'å¤šæ®µæŠ˜çº¿', icon: 'ğŸ“ˆ', description: 'å¤šç‚¹è½¬æŠ˜' },
  
  [TrajectoryType.WOBBLE]: { name: 'éšæœºæ‰°åŠ¨', icon: 'ğŸ«¨', description: 'ä¸è§„åˆ™æŠ–åŠ¨' },
  [TrajectoryType.FALL_RISE]: { name: 'å…ˆè½åèµ·', icon: 'â¤µï¸', description: 'å…ˆä¸‹å å†æ€¥å‡' },
  [TrajectoryType.ORBIT]: { name: 'ç»•åœˆä¸Šå‡', icon: 'ğŸ”„', description: 'å›´ç»•ä¸­å¿ƒèºæ—‹' },
};

/**
 * è½¨è¿¹çŠ¶æ€
 */
export interface TrajectoryState {
  lifeTime: number;
  phase: number;        // å½“å‰é˜¶æ®µ(0-1)
  segmentIndex: number; // å¤šæ®µè½¨è¿¹æ®µç´¢å¼•
}

/**
 * è½¨è¿¹è®¡ç®—å™¨
 * æ ¹æ®è½¨è¿¹ç±»å‹è®¡ç®—é€Ÿåº¦ä¿®æ­£
 */
export class TrajectoryCalculator {
  private type: TrajectoryType;
  private state: TrajectoryState;
  
  // è½¨è¿¹å‚æ•°
  private spiralFrequency: number = 10;
  private spiralAmplitude: number = 0.6;
  private waveFrequency: number = 8;
  private waveAmplitude: number = 0.8;
  
  constructor(type: TrajectoryType) {
    this.type = type;
    this.state = {
      lifeTime: 0,
      phase: 0,
      segmentIndex: 0
    };
  }
  
  /**
   * è®¡ç®—å½“å‰å¸§çš„é€Ÿåº¦ä¿®æ­£
   * @param velocity å½“å‰é€Ÿåº¦
   * @param gravity é‡åŠ›ç³»æ•°
   * @param deltaTime æ—¶é—´å¢é‡
   * @returns ä¿®æ­£åçš„é€Ÿåº¦
   */
  calculate(
    velocity: Vector3,
    gravity: number,
    deltaTime: number
  ): Vector3 {
    const dt = deltaTime * 60;
    this.state.lifeTime += deltaTime;
    const t = this.state.lifeTime;
    
    const result = velocity.clone();
    
    switch (this.type) {
      // === åŸºç¡€è½¨è¿¹ ===
      case TrajectoryType.LINEAR:
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.SPIRAL: {
        const angle = t * this.spiralFrequency;
        result.x += Math.cos(angle) * this.spiralAmplitude;
        result.z += Math.sin(angle) * this.spiralAmplitude;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.ZIGZAG: {
        result.x += Math.cos(t * this.waveFrequency) * this.waveAmplitude;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === åŠ é€Ÿç±» ===
      case TrajectoryType.ACCELERATE:
        if (t < 0.5) result.y -= gravity * 1.5 * dt;
        else if (t < 1.0) result.y += 0.3 * dt;
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DOUBLE_ACCELERATE:
        if (t < 0.3) result.y -= gravity * 1.2 * dt;
        else if (t < 0.5) result.y += 0.4 * dt;  // ç¬¬ä¸€æ¬¡åŠ é€Ÿ
        else if (t < 0.8) result.y -= gravity * 1.0 * dt;
        else if (t < 1.0) result.y += 0.5 * dt;  // ç¬¬äºŒæ¬¡åŠ é€Ÿ
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.TRIPLE_ACCELERATE:
        if (t < 0.2) result.y -= gravity * 1.0 * dt;
        else if (t < 0.3) result.y += 0.3 * dt;  // 1st
        else if (t < 0.5) result.y -= gravity * 0.8 * dt;
        else if (t < 0.6) result.y += 0.4 * dt;  // 2nd
        else if (t < 0.8) result.y -= gravity * 0.6 * dt;
        else if (t < 0.9) result.y += 0.5 * dt;  // 3rd
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DECELERATE: {
        const decel = Math.max(0.3, 1 - t * 0.5);
        result.y -= gravity * 1.5 * dt;
        result.x *= decel;
        result.z *= decel;
        break;
      }
      
      case TrajectoryType.MIXED_SPEED: {
        const cycle = Math.sin(t * 4) * 0.5 + 0.5;
        result.y -= gravity * (0.8 + cycle * 0.8) * dt;
        if (cycle > 0.7) result.y += 0.2 * dt;
        break;
      }
      
      // === æ›²çº¿ç±» ===
      case TrajectoryType.BEZIER_CURVE: {
        // ç®€åŒ–è´å¡å°”: æ·»åŠ æ¸å˜æ¨ªå‘åç§»
        const bezierT = Math.min(1, t / 2);
        const curveOffset = Math.sin(bezierT * Math.PI) * 2;
        result.x += curveOffset * 0.1;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.PARABOLA: {
        const paraT = Math.min(1, t / 1.5);
        result.x += (1 - paraT) * 0.3;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.SINE_WAVE: {
        const sinOffset = Math.sin(t * 6) * 1.5;
        result.x += sinOffset * 0.1;
        result.z += Math.cos(t * 6) * 0.8 * 0.1;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.HELIX: {
        const helixAngle = t * 8;
        const helixRadius = 0.4 + t * 0.1;
        result.x += Math.cos(helixAngle) * helixRadius;
        result.z += Math.sin(helixAngle) * helixRadius;
        result.y -= gravity * 1.2 * dt;
        break;
      }
      
      // === ç»„åˆç±» ===
      case TrajectoryType.LINEAR_TO_CURVE:
        if (t < 1.0) {
          result.y -= gravity * 1.5 * dt;
        } else {
          const curveAngle = (t - 1.0) * 5;
          result.x += Math.sin(curveAngle) * 0.5;
          result.z += Math.cos(curveAngle) * 0.3;
          result.y -= gravity * 1.8 * dt;
        }
        break;
        
      case TrajectoryType.CURVE_TO_LINEAR:
        if (t < 1.0) {
          const curveAngle = t * 5;
          result.x += Math.sin(curveAngle) * 0.5;
          result.z += Math.cos(curveAngle) * 0.3;
          result.y -= gravity * 1.2 * dt;
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.MULTI_SEGMENT: {
        const segment = Math.floor(t / 0.5);
        const angles = [0, Math.PI/4, -Math.PI/4, Math.PI/2, 0];
        const idx = Math.min(segment, angles.length - 1);
        result.x += Math.sin(angles[idx]) * 0.3;
        result.z += Math.cos(angles[idx]) * 0.2;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === ç‰¹æ®Šç±» ===
      case TrajectoryType.WOBBLE:
        result.x += (Math.random() - 0.5) * 1.0;
        result.z += (Math.random() - 0.5) * 1.0;
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.FALL_RISE:
        if (t < 0.3) {
          result.y -= gravity * 2.5 * dt; // å¿«é€Ÿä¸‹è½
        } else if (t < 0.6) {
          result.y += 0.8 * dt; // æ€¥é€Ÿä¸Šå‡
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.ORBIT: {
        const orbitAngle = t * 6;
        const orbitRadius = 0.6;
        result.x = Math.cos(orbitAngle) * orbitRadius * result.y * 0.02;
        result.z = Math.sin(orbitAngle) * orbitRadius * result.y * 0.02;
        result.y -= gravity * 1.3 * dt;
        break;
      }
      
      default:
        result.y -= gravity * 1.5 * dt;
    }
    
    return result;
  }
  
  /**
   * è·å–è½¨è¿¹ç±»å‹
   */
  getType(): TrajectoryType {
    return this.type;
  }
  
  /**
   * è·å–å½“å‰è¿è¡Œæ—¶é—´
   */
  getLifeTime(): number {
    return this.state.lifeTime;
  }
}

/**
 * è½¨è¿¹å·¥å‚
 * åˆ›å»ºå’Œç®¡ç†è½¨è¿¹è®¡ç®—å™¨
 */
export class TrajectoryFactory {
  private static allTypes: TrajectoryType[] = Object.values(TrajectoryType);
  
  /**
   * åˆ›å»ºæŒ‡å®šç±»å‹çš„è½¨è¿¹è®¡ç®—å™¨
   */
  static create(type: TrajectoryType): TrajectoryCalculator {
    return new TrajectoryCalculator(type);
  }
  
  /**
   * åˆ›å»ºéšæœºç±»å‹çš„è½¨è¿¹è®¡ç®—å™¨
   */
  static createRandom(): TrajectoryCalculator {
    const randomType = this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * ä»ç»™å®šåˆ—è¡¨ä¸­éšæœºåˆ›å»º
   */
  static createFromList(types: TrajectoryType[]): TrajectoryCalculator {
    if (types.length === 0) return this.create(TrajectoryType.LINEAR);
    const randomType = types[Math.floor(Math.random() * types.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * è·å–æ‰€æœ‰è½¨è¿¹ç±»å‹
   */
  static getAllTypes(): TrajectoryType[] {
    return [...this.allTypes];
  }
  
  /**
   * è·å–è½¨è¿¹ä¿¡æ¯
   */
  static getInfo(type: TrajectoryType): { name: string; icon: string; description: string } {
    return TRAJECTORY_INFO[type];
  }
}

// END OF FILE: src/core/trajectories/TrajectoryFactory.ts


// =============================================================================
// FILE: src\core\Vector2.ts
// =============================================================================


export class Vector2 {
  constructor(public x: number = 0, public y: number = 0) {}

  add(v: Vector2): Vector2 {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  multiply(scalar: number): Vector2 {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  static fromAngle(angle: number, length: number): Vector2 {
    return new Vector2(Math.cos(angle) * length, Math.sin(angle) * length);
  }

  clone(): Vector2 {
    return new Vector2(this.x, this.y);
  }
}


// =============================================================================
// FILE: src\core\Vector3.ts
// =============================================================================

/**
 * 3D Vector class for the 3D firework system
 */
export class Vector3 {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  add(v: Vector3): Vector3 {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  sub(v: Vector3): Vector3 {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  multiply(scalar: number): Vector3 {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  // Alias for compatibility with THREE.js-like APIs
  multiplyScalar(scalar: number): Vector3 {
    return this.multiply(scalar);
  }

  length(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  normalize(): Vector3 {
    const len = this.length();
    if (len > 0) {
      this.x /= len;
      this.y /= len;
      this.z /= len;
    }
    return this;
  }

  distanceTo(v: Vector3): number {
    const dx = this.x - v.x;
    const dy = this.y - v.y;
    const dz = this.z - v.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  static fromSpherical(theta: number, phi: number, radius: number): Vector3 {
    return new Vector3(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  clone(): Vector3 {
    return new Vector3(this.x, this.y, this.z);
  }

  toArray(): [number, number, number] {
    return [this.x, this.y, this.z];
  }
}


// =============================================================================
// FILE: src\main.tsx
// =============================================================================


import React from 'react';
import ReactDOM from 'react-dom/client';
import App3D from './App3D';
import './styles/index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App3D />
  </React.StrictMode>
);


// =============================================================================
// FILE: src\styles\index.css
// =============================================================================

/* Main styles for Celestial Fireworks Pro */
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #050505;
  user-select: none;
}

.custom-scrollbar::-webkit-scrollbar { width: 4px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }


// =============================================================================
// FILE: src\three-examples.d.ts
// =============================================================================

declare module 'three/examples/jsm/controls/OrbitControls' {
    import { Camera, EventDispatcher, MOUSE, TOUCH, Vector3 } from 'three';
    export class OrbitControls extends EventDispatcher {
        constructor(camera: Camera, domElement?: HTMLElement);
        object: Camera;
        domElement: HTMLElement | HTMLDocument;
        enabled: boolean;
        target: Vector3;
        minDistance: number;
        maxDistance: number;
        minZoom: number;
        maxZoom: number;
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        enableDamping: boolean;
        dampingFactor: number;
        enableZoom: boolean;
        zoomSpeed: number;
        enableRotate: boolean;
        rotateSpeed: number;
        enablePan: boolean;
        panSpeed: number;
        screenSpacePanning: boolean;
        keyPanSpeed: number;
        autoRotate: boolean;
        autoRotateSpeed: number;
        enableKeys: boolean;
        keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number };
        mouseButtons: { LEFT: MOUSE; MIDDLE: MOUSE; RIGHT: MOUSE };
        touches: { ONE: TOUCH; TWO: TOUCH };
        update(): boolean;
        saveState(): void;
        reset(): void;
        dispose(): void;
        getPolarAngle(): number;
        getAzimuthalAngle(): number;
        // EventDispatcher mixins
        addEventListener(type: string, listener: (event: any) => void): void;
        hasEventListener(type: string, listener: (event: any) => void): boolean;
        removeEventListener(type: string, listener: (event: any) => void): void;
        dispatchEvent(event: { type: string; [key: string]: any }): void;
    }
}

declare module 'three/examples/jsm/postprocessing/EffectComposer' {
    import { WebGLRenderer, WebGLRenderTarget, Scene, Camera } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class EffectComposer {
        constructor(renderer: WebGLRenderer, renderTarget?: WebGLRenderTarget);
        renderTarget1: WebGLRenderTarget;
        renderTarget2: WebGLRenderTarget;
        writeBuffer: WebGLRenderTarget;
        readBuffer: WebGLRenderTarget;
        passes: Pass[];
        copyPass: Pass;
        clock: any;
        renderToScreen: boolean;
        addPass(pass: Pass): void;
        insertPass(pass: Pass, index: number): void;
        removePass(pass: Pass): void;
        render(deltaTime?: number): void;
        reset(renderTarget?: WebGLRenderTarget): void;
        setSize(width: number, height: number): void;
        setPixelRatio(pixelRatio: number): void;
    }
}

declare module 'three/examples/jsm/postprocessing/RenderPass' {
    import { Scene, Camera, Color, Material } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class RenderPass extends Pass {
        constructor(scene: Scene, camera: Camera, overrideMaterial?: Material, clearColor?: Color, clearAlpha?: number);
        scene: Scene;
        camera: Camera;
        overrideMaterial: Material;
        clearColor: Color;
        clearAlpha: number;
        clear: boolean;
    }
}

declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
    import { Vector2, Color } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class UnrealBloomPass extends Pass {
        constructor(resolution: Vector2, strength: number, radius: number, threshold: number);
        resolution: Vector2;
        strength: number;
        radius: number;
        threshold: number;
        compositeMaterial: any;
        bloomTintColors: Color[];
        copyUniforms: any;
        materialCopy: any;
        oldClearColor: Color;
        oldClearAlpha: number;
    }
}

declare module 'three/examples/jsm/postprocessing/Pass' {
    import { WebGLRenderer, WebGLRenderTarget } from 'three';
    export class Pass {
        constructor();
        enabled: boolean;
        needsSwap: boolean;
        clear: boolean;
        renderToScreen: boolean;
        setSize(width: number, height: number): void;
        render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    }
}


// =============================================================================
// FILE: src\types\index.ts
// =============================================================================

// FILE: src/types/index.ts

export enum ExplosionType {
  // === ç»å…¸ ===
  SPHERE = 'æ ‡å‡†çƒå½¢',
  BURST = 'é«˜äº®çˆ†å‘',
  RING = 'æ˜Ÿç¯',
  DOUBLE_RING = 'åŒå±‚ç¯',
  WILLOW = 'é‡‘æŸ³å‚ä¸',
  STAGED = 'å­æ¯è¿çˆ†',
  FLASH = 'é›·éœ†é—ªå…‰',
  GLITTER = 'ç’€ç’¨æ˜Ÿå°˜',

  // === è‡ªç„¶ ===
  FLOWER = 'ç››ä¸–ç‰¡ä¸¹',
  BUTTERFLY = 'å¹»å½©è´è¶',
  FALLING_LEAVES = 'æ¼«å¤©è½å¶',
  SNOWFLAKE = 'å…­è§’é›ªèŠ±',
  FISH = 'é”¦é²¤æ¸¸åŠ¨',
  CAT_FACE = 'çŒ«å’ªç¬‘è„¸',

  // === å‡ ä½•/æŠ½è±¡ ===
  CUBE = 'é‡å­ç«‹æ–¹',
  PYRAMID = 'é‡‘å­—å¡”',
  STAR = 'äº”è§’æ˜Ÿ',
  HEART = 'çˆ±å¿ƒ',
  HEART_BEAT = 'è·³åŠ¨ä¹‹å¿ƒ',
  SMILE = 'ç¬‘è„¸',
  SPIRAL = 'é˜¿åŸºç±³å¾·',

  // === å®å¤§ ===
  GALAXY = 'é“¶æ²³ç³»',
  SATURN = 'åœŸæ˜Ÿç¯',
  HELIX = 'DNAåŒèºæ—‹',
  DRAGON = 'æ¸¸é¾™æˆç ',
  GREAT_WALL = 'ä¸‡é‡Œé•¿åŸ',
  ZODIAC = 'çµè›‡ç‹‚èˆ',
  GHOST = 'å¹½çµé­…å½±',
  CROSS_STEP = 'åå­—å˜è‰²',

  // === åˆ›æ„ ===
  ATOM = 'åŸå­ç»“æ„',
  FAN = 'å­”é›€å¼€å±',
  WATERFALL = 'ä¹å¤©ç€‘å¸ƒ',
  CHAOS = 'æ··æ²Œç†è®º',
  TEXT_HI = 'å­—å½¢:Hi',
  CROWN = 'çš‡å† '
}

// å›¾æ ‡æ˜ å°„ï¼šå®ç°"å›¾æ–‡å¹¶èŒ‚"
export const SHAPE_ICONS: Record<ExplosionType, string> = {
  [ExplosionType.SPHERE]: 'ğŸ’¥', [ExplosionType.BURST]: 'âœ¨',
  [ExplosionType.RING]: 'â­•', [ExplosionType.DOUBLE_RING]: 'â—',
  [ExplosionType.WILLOW]: 'ğŸ‹', [ExplosionType.STAGED]: 'ğŸ†',
  [ExplosionType.FLASH]: 'âš¡', [ExplosionType.GLITTER]: 'âœ¨', [ExplosionType.FLOWER]: 'ğŸŒº',
  [ExplosionType.BUTTERFLY]: 'ğŸ¦‹', [ExplosionType.FALLING_LEAVES]: 'ğŸ‚',
  [ExplosionType.SNOWFLAKE]: 'â„ï¸', [ExplosionType.FISH]: 'ğŸŸ',
  [ExplosionType.CAT_FACE]: 'ğŸ±', [ExplosionType.CUBE]: 'ğŸ§Š',
  [ExplosionType.PYRAMID]: 'ğŸ”º', [ExplosionType.STAR]: 'â­',
  [ExplosionType.SMILE]: 'ğŸ™‚', [ExplosionType.SPIRAL]: 'ğŸ¥',
  [ExplosionType.HEART]: 'â¤ï¸', [ExplosionType.HEART_BEAT]: 'ğŸ’“',
  [ExplosionType.GALAXY]: 'ğŸŒŒ', [ExplosionType.SATURN]: 'ğŸª', [ExplosionType.HELIX]: 'ğŸ§¬',
  [ExplosionType.DRAGON]: 'ğŸ‰', [ExplosionType.GREAT_WALL]: 'ğŸ§±',
  [ExplosionType.ZODIAC]: 'ğŸ', [ExplosionType.GHOST]: 'ğŸ‘»',
  [ExplosionType.CROSS_STEP]: 'âœ¥', [ExplosionType.ATOM]: 'âš›ï¸',
  [ExplosionType.FAN]: 'ğŸª­', [ExplosionType.WATERFALL]: 'ğŸŒŠ',
  [ExplosionType.CHAOS]: 'ğŸ²', [ExplosionType.TEXT_HI]: 'H',
  [ExplosionType.CROWN]: 'ğŸ‘‘'
};

export enum AscensionType {
  LINEAR = 'ç›´çº¿å‡ç©º',
  SPIRAL = 'èºæ—‹ç›˜æ—‹',
  ZIGZAG = 'Så‹æ‘‡æ‘†',
  ACCELERATE = 'æé€Ÿæ¨è¿›',
  DRAWING = 'ç©ºä¸­ç»˜å›¾',
  WOBBLE = 'éšæœºæ‰°åŠ¨'
}

export const ASCENSION_ICONS: Record<AscensionType, string> = {
  [AscensionType.LINEAR]: 'â¬†ï¸',
  [AscensionType.SPIRAL]: 'ğŸŒ€',
  [AscensionType.ZIGZAG]: 'ã€°ï¸',
  [AscensionType.ACCELERATE]: 'ğŸš€',
  [AscensionType.DRAWING]: 'ğŸ–Œï¸',
  [AscensionType.WOBBLE]: 'ğŸ«¨'
};

export enum ColorStyle {
  SINGLE = 'çº¯å‡€å•è‰²',
  DUAL = 'åŒè‰²äº’è¡¥',
  RAINBOW = 'ä¸ƒå½©è™¹å…‰',
  GRADIENT = 'åŒç³»æ¸å˜',
  GOLDEN = 'æµé‡‘å²æœˆ',
  PASTEL = 'é©¬å¡é¾™è‰²'
}

export const COLOR_ICONS: Record<ColorStyle, string> = {
  [ColorStyle.SINGLE]: 'ğŸ”´',
  [ColorStyle.DUAL]: 'ğŸŒ—',
  [ColorStyle.RAINBOW]: 'ğŸŒˆ',
  [ColorStyle.GRADIENT]: 'ğŸ§',
  [ColorStyle.GOLDEN]: 'ğŸ†',
  [ColorStyle.PASTEL]: 'ğŸ¬'
};

export type ParticleBehavior = 'default' | 'willow' | 'glitter' | 'ghost' | 'firefly' | 'comet' | 'galaxy' | 'stationary' | 'falling';

export type CameraMode = 'orbit' | 'firstPerson';

// 2D Particle Options (for legacy 2D canvas version)
export interface ParticleOptions {
  x: number;
  y: number;
  hue: number;
  angle?: number;
  speed?: number;
  friction?: number;
  gravity?: number;
  resistance?: number;
  size?: number;
  decay?: number;
  behavior?: ParticleBehavior;
  originX?: number;
  originY?: number;
}

// 2D Firework Options (for legacy 2D canvas version)
export interface FireworkOptions {
  startX: number;
  targetX: number;
  targetY: number;
  hue: number;
  charge: number;
}

// 3D Particle Options
export interface ParticleOptions3D {
  x: number; y: number; z: number;
  hue: number; speed?: number;
  theta?: number; phi?: number;
  friction?: number; gravity?: number;
  resistance?: number; size?: number;
  decay?: number; behavior?: ParticleBehavior;
  originX?: number; originY?: number; originZ?: number;
}

export interface AppSettings {
  gravity: number;
  friction: number;
  autoLaunchDelay: number; // åŸºç¡€éšæœºé—´éš”
  particleCountMultiplier: number;
  explosionSizeMultiplier: number;
  starBlinkSpeed: number;
  trailLength: number;
  // æ–°å¢ï¼šå˜‰å¹´åæ§åˆ¶
  enableAutoCarnival: boolean; // æ˜¯å¦å¼€å¯è‡ªåŠ¨å¾ªç¯
  carnivalInterval: number;    // è‡ªåŠ¨å¾ªç¯é—´éš”(ç§’)
}

// å˜‰å¹´åé…ç½® (ç™½åå•)
import { Shape3DType } from '../core/shapes/Shape3DFactory';
import { TrajectoryType } from '../core/trajectories/TrajectoryFactory';
import { ComboType } from '../core/combos/ComboManager';

export enum LaunchFormation {
  SINGLE = 'å•ç‚¹å‘å°„',
  RANDOM = 'éšæœºæ•£å¸ƒ',
  CIRCLE = 'åœ†å½¢é½å°„',
  LINE = 'ä¸€å­—æ’å¼€',
  CROSS = 'åå­—äº¤å‰',
  V_SHAPE = 'Vå­—ç¼–é˜Ÿ'
}

export interface CarnivalStage {
  id: string;
  name: string;
  count: number;
  trajectory: TrajectoryType | 'RANDOM';
  shape: Shape3DType | ExplosionType | 'RANDOM';
  combo: ComboType | 'RANDOM';
  delay: number; // è·ç¦»ä¸Šä¸€é˜¶æ®µçš„å»¶è¿Ÿ(ms)
  
  // æ–°å¢é«˜çº§å‚æ•°
  formation?: LaunchFormation;
  interval?: number; // è¯¥æ³¢æ¬¡å†…æ¯å‘çƒŸèŠ±çš„é—´éš” (ms), 0è¡¨ç¤ºå®Œå…¨åŒæ—¶
  duration?: number; // çƒŸèŠ±åœç•™æ—¶é—´ (s), 0è¡¨ç¤ºé»˜è®¤
}

export interface FireworkConfig {
  enabledShapes: ExplosionType[];
  enabledAscensions: AscensionType[];
  enabledColors: ColorStyle[];
  // æ–°æ¶æ„æ”¯æŒ
  enabledShape3Ds?: Shape3DType[];
  enabledTrajectories?: TrajectoryType[];
  enabledCombos?: ComboType[];
  carnivalSequence?: CarnivalStage[];
  manualSequence?: CarnivalStage[]; // æ‰‹åŠ¨äº¤äº’å‰§æœ¬æ¸…å• (ä¿ç•™ç”¨äºå¤æ‚äº¤äº’)
}

// å•å‘é…ç½® (æŒ‡å®šæ ·å¼)
export interface ManualConfig {
  lockedShape: ExplosionType | Shape3DType | 'RANDOM';
  lockedColor: ColorStyle | 'RANDOM';
  lockedTrajectory?: TrajectoryType | 'RANDOM';
  lockedCombo?: ComboType | 'RANDOM';
  
  // æ–°å¢æ‰‹åŠ¨å‚æ•°
  lockedFormation: LaunchFormation; // å‘å°„é˜Ÿå½¢
  lockedCount: number; // æ¯æ¬¡ç‚¹å‡»å‘å°„æ•°é‡
  lockedDuration: number; // çƒŸèŠ±å­˜ç»­æ—¶é—´ (s)
  lockedInterval: number; // å‘å°„é—´éš” (ms)

  currentStepIndex?: number; // å½“å‰æ‰‹åŠ¨å‰§æœ¬è¿›åº¦
}

export const DEFAULT_SETTINGS: AppSettings = {
  gravity: 0.12,
  friction: 0.96,
  autoLaunchDelay: 2000,
  particleCountMultiplier: 1.0,
  explosionSizeMultiplier: 1.0,
  starBlinkSpeed: 0.001,
  trailLength: 15,
  enableAutoCarnival: false,
  carnivalInterval: 5
};

export const DEFAULT_CONFIG: FireworkConfig = {
  enabledShapes: Object.values(ExplosionType),
  enabledAscensions: Object.values(AscensionType),
  enabledColors: Object.values(ColorStyle),
  enabledShape3Ds: Object.values(Shape3DType),
  enabledTrajectories: Object.values(TrajectoryType),
  enabledCombos: Object.values(ComboType),
  carnivalSequence: [
    { id: '1', name: 'åºå¹•: ç¹æ˜Ÿç‚¹ç‚¹', count: 5, trajectory: TrajectoryType.LINEAR, shape: Shape3DType.SPARKLE_CLOUD, combo: ComboType.SINGLE, delay: 0, formation: LaunchFormation.RANDOM, interval: 300, duration: 3 },
    { id: '2', name: 'è¿‡æ¸¡: èºæ—‹å‡å', count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.RING_WAVE, combo: ComboType.STAGED, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 4 },
    { id: '3', name: 'é«˜æ½®: é“¶æ²³è¯ç”Ÿ', count: 1, trajectory: TrajectoryType.ACCELERATE, shape: Shape3DType.GALAXY_SPIRAL, combo: ComboType.GALAXY_BIRTH, delay: 3000, formation: LaunchFormation.SINGLE, interval: 0, duration: 8 }
  ],
  manualSequence: []
};

export const DEFAULT_MANUAL_CONFIG: ManualConfig = {
  lockedShape: 'RANDOM',
  lockedColor: 'RANDOM',
  lockedTrajectory: 'RANDOM',
  lockedCombo: 'RANDOM',
  lockedFormation: LaunchFormation.SINGLE,
  lockedCount: 1,
  lockedDuration: 0,
  lockedInterval: 100,
  currentStepIndex: 0
};

// END OF FILE: src/types/index.ts