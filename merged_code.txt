

// =============================================================================
// FILE: src\App.tsx
// =============================================================================


import React, { useState, useEffect, useRef } from 'react';
import { FireworkCanvas, FireworkCanvasHandle } from './components/FireworkCanvas';
import { SettingsPanel } from './components/ui/SettingsPanel';
import { HUD } from './components/ui/HUD';
import { AppSettings, DEFAULT_SETTINGS } from './types';

const STORAGE_KEY = 'celestial_fireworks_v4_settings';

const App: React.FC = () => {
  const canvasRef = useRef<FireworkCanvasHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<AppSettings>(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        if (parsed && typeof parsed === 'object' && 'gravity' in parsed) {
          return { ...DEFAULT_SETTINGS, ...parsed };
        }
      }
    } catch (e) {
      console.error('Failed to load settings from localStorage', e);
    }
    return DEFAULT_SETTINGS;
  });

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  }, [settings]);

  const updateSetting = (key: keyof AppSettings, value: number) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const randomizeSettings = () => {
    setSettings({
      gravity: Number((Math.random() * 0.12 + 0.04).toFixed(3)),
      friction: Number((0.92 + Math.random() * 0.07).toFixed(3)),
      autoLaunchDelay: Math.floor(1000 + Math.random() * 6000),
      particleCountMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      explosionSizeMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      starBlinkSpeed: Number((0.0003 + Math.random() * 0.002).toFixed(5)),
      trailLength: Math.floor(5 + Math.random() * 30)
    });
  };

  return (
    <div className="relative w-screen h-screen bg-black overflow-hidden font-sans text-white select-none">
      <style>{`
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }
      `}</style>

      <HUD />

      {/* ä¸»æ§æŒ‰é’® */}
      <div className="absolute top-10 right-10 z-20 flex flex-col gap-5 items-end">
        <button 
          onClick={() => canvasRef.current?.launchCarnival()}
          className="group relative px-10 py-5 bg-gradient-to-br from-amber-400 via-orange-500 to-rose-600 rounded-2xl font-black text-sm tracking-[0.3em] hover:scale-105 active:scale-95 transition-all shadow-2xl shadow-orange-500/40 overflow-hidden border border-white/10"
        >
          <span className="relative z-10 flex items-center gap-3">
            <span className="animate-bounce">ğŸ®</span> å¼€å¯ç››å¤§å˜‰å¹´å ğŸ®
          </span>
          <div className="absolute inset-0 bg-white/20 -translate-x-full group-hover:translate-x-0 transition-transform duration-500"></div>
        </button>
        <button 
          onClick={() => setShowSettings(!showSettings)}
          className="p-4 bg-white/5 hover:bg-white/15 rounded-2xl border border-white/10 transition-all backdrop-blur-xl shadow-2xl flex items-center gap-2 group"
        >
          <SettingsIcon className="w-6 h-6 text-cyan-400 group-hover:rotate-90 transition-transform" />
          <span className="text-xs font-bold tracking-widest text-cyan-400/80 pr-1">å¼•æ“é…ç½®</span>
        </button>
      </div>

      <FireworkCanvas ref={canvasRef} settings={settings} />

      <SettingsPanel 
        show={showSettings} 
        settings={settings} 
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onRandomize={randomizeSettings}
        onReset={() => setSettings(DEFAULT_SETTINGS)}
      />
    </div>
  );
};

const SettingsIcon = ({ className }: { className?: string }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);

export default App;


// =============================================================================
// FILE: src\App3D.tsx
// =============================================================================

// FILE: src/App3D.tsx

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { FireworkScene3D, FireworkScene3DHandle } from './components/FireworkScene3D';
import { SettingsPanel } from './components/ui/SettingsPanel';
import { TimeControlPanel } from './components/ui/TimeControlPanel';
import { HUD3D } from './components/ui/HUD3D';
import { AppSettings, DEFAULT_SETTINGS, FireworkConfig, DEFAULT_CONFIG, ManualConfig, DEFAULT_MANUAL_CONFIG } from './types';
import { TimeController } from './core/TimeController';

const SETTINGS_KEY = 'celestial_fireworks_v6_settings';
const CONFIG_KEY = 'celestial_fireworks_v6_config';
const MANUAL_KEY = 'celestial_fireworks_v6_manual';

const App3D: React.FC = () => {
    const sceneRef = useRef<FireworkScene3DHandle>(null);
    const [showSettings, setShowSettings] = useState(false);

    const [timeController, setTimeController] = useState<TimeController | null>(null);
    const [stats, setStats] = useState({ particles: 0, fireworks: 0, fps: 0 });
    const [autoRotate, setAutoRotate] = useState(true);

    // ç‰©ç†ä¸å˜‰å¹´åè®¾ç½®
    const [settings, setSettings] = useState<AppSettings>(() => {
        try {
            const saved = localStorage.getItem(SETTINGS_KEY);
            if (saved) return { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
        } catch (e) {}
        return DEFAULT_SETTINGS;
    });

    // å˜‰å¹´åæ ·å¼åº“
    const [config, setConfig] = useState<FireworkConfig>(() => {
        try {
            const saved = localStorage.getItem(CONFIG_KEY);
            if (saved) return { ...DEFAULT_CONFIG, ...JSON.parse(saved) };
        } catch (e) {}
        return DEFAULT_CONFIG;
    });

    // å•å‘ï¼ˆé¼ æ ‡ç‚¹å‡»ï¼‰é…ç½®
    const [manualConfig, setManualConfig] = useState<ManualConfig>(() => {
        try {
            const saved = localStorage.getItem(MANUAL_KEY);
            if (saved) return { ...DEFAULT_MANUAL_CONFIG, ...JSON.parse(saved) };
        } catch (e) {}
        return DEFAULT_MANUAL_CONFIG;
    });

    useEffect(() => { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }, [settings]);
    useEffect(() => { localStorage.setItem(CONFIG_KEY, JSON.stringify(config)); }, [config]);
    useEffect(() => { localStorage.setItem(MANUAL_KEY, JSON.stringify(manualConfig)); }, [manualConfig]);

    const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
        setSettings(prev => ({ ...prev, [key]: value }));
    };

    const handleTimeUpdate = useCallback((tc: TimeController) => {
        setTimeController(tc);
    }, []);

    const handleStatsUpdate = useCallback((newStats: { particles: number; fireworks: number; fps: number }) => {
        setStats(newStats);
    }, []);

    return (
        <div className="relative w-screen h-screen bg-gray-50 overflow-hidden font-sans text-gray-800 select-none">
            <style>{`
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 14px; height: 14px; border-radius: 50%; background: #4B5563;
          cursor: pointer; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #CBD5E1; border-radius: 10px; }
      `}</style>

            <HUD3D />

            <div className="absolute top-8 right-8 z-20 flex flex-col gap-4 items-end">
                <button
                    onClick={() => sceneRef.current?.launchCarnival()}
                    className="group relative px-6 py-3 bg-white/80 backdrop-blur-md rounded-xl font-bold text-xs tracking-[0.15em] hover:scale-105 active:scale-95 transition-all shadow-lg shadow-gray-200 border border-white/50 overflow-hidden"
                >
                    <div className="absolute inset-0 bg-gradient-to-r from-purple-100 to-blue-100 opacity-0 group-hover:opacity-100 transition-opacity"></div>
                    <span className="relative z-10 flex items-center gap-2 text-gray-800 group-hover:text-purple-700">
            <span>ğŸ‰</span> GRAND CARNIVAL
          </span>
                </button>
                <button
                    onClick={() => setShowSettings(!showSettings)}
                    className="p-3 bg-white/80 hover:bg-white rounded-xl shadow-lg border border-white/50 transition-all text-gray-500 hover:text-blue-600 active:scale-95"
                >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
            </div>

            <FireworkScene3D
                ref={sceneRef}
                settings={settings}
                config={config}
                manualConfig={manualConfig}
                autoRotate={autoRotate}
                onTimeUpdate={handleTimeUpdate}
                onStatsUpdate={handleStatsUpdate}
            />

            <TimeControlPanel
                timeController={timeController}
                stats={stats}
                onTimeScaleChange={(s) => {
                    // ä¿®å¤ TS2779: ä½¿ç”¨æ˜ç¡®çš„ if æ£€æŸ¥æ›¿ä»£å¯é€‰é“¾èµ‹å€¼
                    const handle = sceneRef.current;
                    if (handle) {
                        handle.getTimeController().timeScale = s;
                    }
                }}
                onTogglePause={() => {
                    sceneRef.current?.getTimeController().togglePause();
                }}
                autoRotate={autoRotate}
                onToggleAutoRotate={() => setAutoRotate(!autoRotate)}
            />

            <SettingsPanel
                show={showSettings}
                settings={settings}
                config={config}
                manualConfig={manualConfig}
                onClose={() => setShowSettings(false)}
                onUpdate={updateSetting}
                onUpdateConfig={setConfig}
                onUpdateManual={setManualConfig}
                onRandomize={() => {}}
                onReset={() => {
                    setSettings(DEFAULT_SETTINGS);
                    setConfig(DEFAULT_CONFIG);
                    setManualConfig(DEFAULT_MANUAL_CONFIG);
                }}
            />
        </div>
    );
};

export default App3D;

// END OF FILE: src/App3D.tsx

// =============================================================================
// FILE: src\components\FireworkCanvas.tsx
// =============================================================================


import React, { useEffect, useRef, useState, useCallback, useMemo, useImperativeHandle, forwardRef } from 'react';
import { ParticlePool } from '../core/ParticlePool';
import { Firework } from '../core/Firework';
import { AppSettings } from '../types';

interface Star {
  x: number;
  y: number;
  size: number;
  blinkSpeed: number;
  phase: number;
  layer: number;
}

interface FireworkCanvasProps {
  settings: AppSettings;
}

export interface FireworkCanvasHandle {
  launchCarnival: () => void;
}

export const FireworkCanvas = forwardRef<FireworkCanvasHandle, FireworkCanvasProps>(({ settings }, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fireworksRef = useRef<Firework[]>([]);
  
  const particlePoolRef = useRef<ParticlePool | null>(null);
  const sparklersPoolRef = useRef<ParticlePool | null>(null);
  
  if (!particlePoolRef.current) particlePoolRef.current = new ParticlePool(15000);
  if (!sparklersPoolRef.current) sparklersPoolRef.current = new ParticlePool(1000);

  const getParticlePool = () => particlePoolRef.current!;
  const getSparklersPool = () => sparklersPoolRef.current!;

  const shockwavesRef = useRef<{ x: number, y: number, r: number, a: number }[]>([]);
  
  const [isCharging, setIsCharging] = useState(false);
  const chargeLevelRef = useRef(0);
  const mousePos = useRef({ x: 0, y: 0 });
  const requestRef = useRef<number | undefined>(undefined);
  const lastAutoLaunch = useRef<number>(0);

  const stars = useMemo<Star[]>(() => {
    const s: Star[] = [];
    for (let i = 0; i < 400; i++) {
      s.push({
        x: Math.random() * 4000, 
        y: Math.random() * 3000,
        size: Math.random() * 1.2,
        blinkSpeed: (0.002 + Math.random() * 0.008) * (settings.starBlinkSpeed / 0.0008),
        phase: Math.random() * Math.PI * 2,
        layer: Math.floor(Math.random() * 3)
      });
    }
    return s;
  }, [settings.starBlinkSpeed]);

  const handleResize = useCallback(() => {
    if (canvasRef.current) {
      const dpr = window.devicePixelRatio || 1;
      canvasRef.current.width = window.innerWidth * dpr;
      canvasRef.current.height = window.innerHeight * dpr;
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }
  }, []);

  useEffect(() => {
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);

  const launchFireworkAt = (x: number, y: number, hue?: number, charge?: number) => {
    const startXVariation = (Math.random() - 0.5) * 100;
    const startX = Math.max(0, Math.min(window.innerWidth, x + startXVariation));
    
    fireworksRef.current.push(new Firework({
      startX,
      targetX: x,
      targetY: y,
      hue: hue ?? Math.random() * 360,
      charge: charge ?? 0.2 + Math.random() * 0.5
    }, settings));
  };

  useImperativeHandle(ref, () => ({
    launchCarnival: () => {
      const launch = (count: number, delay: number) => {
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const x = (window.innerWidth * 0.1) + (window.innerWidth * 0.8 * Math.random());
            const y = window.innerHeight * (0.1 + Math.random() * 0.4);
            launchFireworkAt(x, y, Math.random() * 360, 0.4 + Math.random() * 0.4);
          }, delay + i * 180);
        }
      };
      launch(8, 0); 
      launch(12, 1200);
    }
  }));

  const animate = useCallback((time: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    if (!ctx) return;

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#020205';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.fillStyle = '#fff';
    const oxB = (mousePos.current.x - window.innerWidth/2) * 0.005;
    const oyB = (mousePos.current.y - window.innerHeight/2) * 0.005;
    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];
      const opacity = 0.05 + Math.abs(Math.sin(time * s.blinkSpeed + s.phase)) * 0.6;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc((s.x + oxB * s.layer) % window.innerWidth, (s.y + oyB * s.layer) % window.innerHeight, s.size, 0, 6.28);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.22)';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    if (time - lastAutoLaunch.current > settings.autoLaunchDelay && !isCharging) {
      launchFireworkAt(Math.random() * window.innerWidth, 50 + Math.random() * (window.innerHeight * 0.4));
      lastAutoLaunch.current = time;
    }

    ctx.globalCompositeOperation = 'lighter';
    getSparklersPool().updateAndDraw(ctx);

    for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
      const f = fireworksRef.current[i];
      f.update(settings);
      f.draw(ctx);
      if (f.exploded) {
        f.createExplosion(settings, (opts) => getParticlePool().get(opts));
        if (f.charge > 0.5) {
          shockwavesRef.current.push({ x: f.pos.x, y: f.pos.y, r: 0, a: 0.25 });
        }
        fireworksRef.current.splice(i, 1);
      }
    }

    getParticlePool().updateAndDraw(ctx);

    for (let i = shockwavesRef.current.length - 1; i >= 0; i--) {
      const sw = shockwavesRef.current[i];
      sw.r += 16; sw.a -= 0.01;
      ctx.globalAlpha = sw.a;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.r, 0, 6.28);
      ctx.stroke();
      if (sw.a <= 0) shockwavesRef.current.splice(i, 1);
    }

    ctx.globalAlpha = 1;

    if (isCharging) {
      const increment = 0.025 * (1 - chargeLevelRef.current * 0.4);
      chargeLevelRef.current = Math.min(chargeLevelRef.current + increment, 1);
      
      const { x, y } = mousePos.current;
      const hue = (x / window.innerWidth) * 360;
      
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.4 + chargeLevelRef.current * 0.4})`;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, 40 + chargeLevelRef.current * 100, time * 0.003, time * 0.003 + 6.28);
      ctx.stroke();
      
      if (Math.random() > 0.5) {
        const ang = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 50;
        getSparklersPool().get({
          x: x + Math.cos(ang) * dist,
          y: y + Math.sin(ang) * dist,
          hue: (hue + 40) % 360,
          speed: -4 - chargeLevelRef.current * 4,
          angle: ang,
          size: 1,
          decay: 0.1,
          behavior: 'glitter'
        });
      }

      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${0.1 + chargeLevelRef.current * 0.4})`;
      ctx.beginPath();
      ctx.arc(x, y, chargeLevelRef.current * 50, 0, 6.28);
      ctx.fill();
      ctx.restore();
    }

    requestRef.current = requestAnimationFrame(animate);
  }, [isCharging, stars, settings]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [animate]);

  const updateMousePos = (e: React.MouseEvent | React.TouchEvent) => {
    const x = 'touches' in e ? (e as React.TouchEvent).touches[0].clientX : (e as React.MouseEvent).clientX;
    const y = 'touches' in e ? (e as React.TouchEvent).touches[0].clientY : (e as React.MouseEvent).clientY;
    mousePos.current = { x, y };
    
    if (Math.random() > 0.8) {
      getSparklersPool().get({
        x, y,
        hue: (performance.now() / 15) % 360,
        speed: Math.random() * 2,
        size: 0.7,
        decay: 0.06
      });
    }
  };

  const handleMouseDown = (e: React.MouseEvent | React.TouchEvent) => {
    setIsCharging(true);
    chargeLevelRef.current = 0;
    updateMousePos(e);
  };

  const handleMouseUp = () => {
    if (!isCharging) return;
    const xRatio = mousePos.current.x / window.innerWidth;
    const h = xRatio < 0.5 ? 170 + xRatio * 180 : (xRatio - 0.5) * 120;
    launchFireworkAt(mousePos.current.x, mousePos.current.y, h, chargeLevelRef.current + 0.1);
    setIsCharging(false);
    chargeLevelRef.current = 0;
  };

  return (
    <canvas
      ref={canvasRef}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onMouseMove={updateMousePos}
      onTouchStart={handleMouseDown}
      onTouchEnd={handleMouseUp}
      onTouchMove={updateMousePos}
      className="cursor-crosshair w-full h-full block touch-none"
    />
  );
});


// =============================================================================
// FILE: src\components\FireworkScene3D.tsx
// =============================================================================

// FILE: src/components/FireworkScene3D.tsx

import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

import { ParticlePool3D } from '../core/ParticlePool3D';
import { Firework3D } from '../core/Firework3D';
import { TimeController } from '../core/TimeController';
import { AppSettings, CameraMode, ExplosionType, AscensionType, FireworkConfig, ManualConfig, ColorStyle } from '../types';

const createSoftParticleTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  if (!ctx) return new THREE.Texture();
  const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
  grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
  grad.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)');
  grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
  const texture = new THREE.CanvasTexture(canvas);
  texture.premultiplyAlpha = true; return texture;
};

// ä¿®å¤ TS é”™è¯¯ï¼šæ˜ç¡®å®šä¹‰ Props
interface FireworkScene3DProps {
  settings: AppSettings;
  config: FireworkConfig; // å˜‰å¹´åç™½åå•
  manualConfig: ManualConfig; // å•å‘é…ç½®
  autoRotate: boolean;
  onTimeUpdate?: (timeController: TimeController) => void;
  onStatsUpdate?: (stats: { particles: number; fireworks: number; fps: number }) => void;
}

export interface FireworkScene3DHandle {
  launchCarnival: () => void;
  launchAt: (x: number, y: number, z: number) => void;
  getTimeController: () => TimeController;
  setCameraMode: (mode: CameraMode) => void;
}

export const FireworkScene3D = forwardRef(
    ({ settings, config, manualConfig, autoRotate, onTimeUpdate, onStatsUpdate }: FireworkScene3DProps, ref: React.Ref<FireworkScene3DHandle>) => {
      const containerRef = useRef<HTMLDivElement>(null);
      const sceneRef = useRef<THREE.Scene | null>(null);
      const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
      const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
      const controlsRef = useRef<OrbitControls | null>(null);
      const requestRef = useRef<number | undefined>(undefined);

      const settingsRef = useRef(settings);
      const configRef = useRef(config);
      const manualConfigRef = useRef(manualConfig);
      const autoRotateRef = useRef(autoRotate);
      const onTimeUpdateRef = useRef(onTimeUpdate);
      const onStatsUpdateRef = useRef(onStatsUpdate);

      useEffect(() => { settingsRef.current = settings; }, [settings]);
      useEffect(() => { configRef.current = config; }, [config]);
      useEffect(() => { manualConfigRef.current = manualConfig; }, [manualConfig]);
      useEffect(() => { autoRotateRef.current = autoRotate; }, [autoRotate]);
      useEffect(() => { onTimeUpdateRef.current = onTimeUpdate; }, [onTimeUpdate]);
      useEffect(() => { onStatsUpdateRef.current = onStatsUpdate; }, [onStatsUpdate]);

      const fireworksRef = useRef<Firework3D[]>([]);
      const particlePoolRef = useRef<ParticlePool3D | null>(null);
      const timeControllerRef = useRef<TimeController>(new TimeController());

      const particleGeometryRef = useRef<THREE.BufferGeometry | null>(null);
      const starsRef = useRef<THREE.Points | null>(null);

      const lastAutoLaunchRef = useRef<number>(0);
      const lastCarnivalRef = useRef<number>(0); // å˜‰å¹´åè‡ªåŠ¨è®¡æ—¶
      const fpsRef = useRef({ frames: 0, lastTime: 0, fps: 0 });
      const raycasterRef = useRef(new THREE.Raycaster());
      const planeRef = useRef(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0));
      const mouseDownPos = useRef({ x: 0, y: 0 });
      const mouseDownTime = useRef(0);

      useEffect(() => {
        if (!containerRef.current) return;
        containerRef.current.innerHTML = '';

        const scene = new THREE.Scene();
        const bgColor = new THREE.Color(0x0a0e17);
        scene.background = bgColor;
        scene.fog = new THREE.FogExp2(0x0a0e17, 0.0006);
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 150, 600);
        cameraRef.current = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance', stencil: false, depth: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.8;
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.1);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene); composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 100; controls.maxDistance = 1500;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; controls.minPolarAngle = 0.2;
        controls.autoRotate = autoRotateRef.current; controls.autoRotateSpeed = 0.8;
        controlsRef.current = controls;

        particlePoolRef.current = new ParticlePool3D(25000);

        const particleGeometry = new THREE.BufferGeometry();
        const maxParticles = 25000;
        const positions = new Float32Array(maxParticles * 3);
        const colors = new Float32Array(maxParticles * 3);
        const sizes = new Float32Array(maxParticles);
        for(let i=0; i<maxParticles * 3; i++) positions[i] = 0;
        for(let i=1; i<maxParticles * 3; i+=3) positions[i] = -10000;
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        particleGeometryRef.current = particleGeometry;

        const particleMaterial = new THREE.PointsMaterial({
          size: 8, map: createSoftParticleTexture(), vertexColors: true,
          transparent: true, opacity: 1, blending: THREE.AdditiveBlending,
          depthWrite: false, sizeAttenuation: true
        });
        const particlePoints = new THREE.Points(particleGeometry, particleMaterial);
        particlePoints.frustumCulled = false;
        scene.add(particlePoints);

        createStars(scene); createGround(scene);

        const handleResize = () => {
          if (!cameraRef.current || !rendererRef.current) return;
          const w = window.innerWidth, h = window.innerHeight;
          cameraRef.current.aspect = w / h; cameraRef.current.updateProjectionMatrix();
          rendererRef.current.setSize(w, h); composer.setSize(w, h);
        };
        window.addEventListener('resize', handleResize);

        const animate = () => {
          requestRef.current = requestAnimationFrame(animate);
          const timeController = timeControllerRef.current;
          const currentSettings = settingsRef.current;
          const currentConfig = configRef.current;

          if (controlsRef.current) {
            controlsRef.current.autoRotate = autoRotateRef.current;
            controlsRef.current.update();
          }

          if (!timeController.isPaused) {
            timeController.update();
            const deltaTime = timeController.deltaTime;
            const virtualTime = timeController.virtualTime * 1000;

            // 1. åŸºç¡€è‡ªåŠ¨å‘å°„ (Random single shots) - å¦‚æœå¼€å¯äº†è‡ªåŠ¨å˜‰å¹´åï¼Œè¿™é‡Œå…¶å®å¯ä»¥å…³æ‰ï¼Œæˆ–è€…ä½œä¸ºèƒŒæ™¯å™ªéŸ³
            // ä¸ºäº†é¿å…è¿‡äºæ··ä¹±ï¼Œå¦‚æœå¼€å¯äº†å˜‰å¹´åï¼Œè¿™é‡Œé™ä½é¢‘ç‡
            const delay = currentSettings.enableAutoCarnival ? currentSettings.autoLaunchDelay * 2 : currentSettings.autoLaunchDelay;
            if (virtualTime - lastAutoLaunchRef.current > delay) {
              // ä½¿ç”¨å˜‰å¹´åç™½åå•é…ç½®
              launchFireworkInternal(
                  (Math.random() - 0.5) * 500, 180 + Math.random() * 120, (Math.random() - 0.5) * 500,
                  undefined, undefined, currentSettings, currentConfig
              );
              lastAutoLaunchRef.current = virtualTime;
            }

            // 2. å˜‰å¹´åè‡ªåŠ¨å¾ªç¯ (Auto Carnival Loop)
            if (currentSettings.enableAutoCarnival) {
              if (virtualTime - lastCarnivalRef.current > currentSettings.carnivalInterval * 1000) {
                launchCarnivalWave(currentSettings, currentConfig);
                lastCarnivalRef.current = virtualTime;
              }
            }

            for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
              const fw = fireworksRef.current[i];
              fw.update(currentSettings, deltaTime);

              if (!fw.exploded) {
                const speed = fw.velocity.length();
                const spawnProb = Math.min(1, speed / 15);
                const alphaMod = Math.min(1, speed / 25);
                const trailHue = fw.hue;

                if (Math.random() < spawnProb) {
                  if (fw.ascension === AscensionType.DRAWING) {
                    particlePoolRef.current?.get({
                      x: fw.position.x, y: fw.position.y, z: fw.position.z,
                      hue: trailHue, speed: 0, size: 5, decay: 0.005, behavior: 'stationary', gravity: 0
                    });
                  }
                  else if (fw.ascension === AscensionType.SPIRAL) {
                    particlePoolRef.current?.get({
                      x: fw.position.x, y: fw.position.y, z: fw.position.z,
                      hue: trailHue, speed: 0, size: 4, decay: 0.08, behavior: 'glitter'
                    });
                  }
                  else if (fw.ascension === AscensionType.ACCELERATE) {
                    particlePoolRef.current?.get({
                      x: fw.position.x + (Math.random()-0.5), y: fw.position.y - 1, z: fw.position.z + (Math.random()-0.5),
                      hue: (trailHue + 30) % 360, speed: 0, size: 7, decay: 0.1, gravity: 0.01
                    });
                  }
                  else {
                    const p = particlePoolRef.current?.get({
                      x: fw.position.x + (Math.random()-0.5) * 1.5, y: fw.position.y - 1, z: fw.position.z + (Math.random()-0.5) * 1.5,
                      hue: trailHue, speed: 0, size: 5, decay: 0.08, behavior: 'default', gravity: 0.02
                    });
                    if (p) p.alpha = alphaMod;
                  }
                }
              }

              if (fw.exploded) {
                fw.createExplosion(currentSettings, (opts) => particlePoolRef.current!.get(opts));
                fireworksRef.current.splice(i, 1);
              }
            }
            particlePoolRef.current?.update(deltaTime);
          }

          updateParticleGeometry();
          updateStars(performance.now() * 0.0005);

          fpsRef.current.frames++;
          const now = performance.now();
          if (now - fpsRef.current.lastTime >= 1000) {
            fpsRef.current.fps = fpsRef.current.frames;
            fpsRef.current.frames = 0;
            fpsRef.current.lastTime = now;
          }
          composer.render();

          if (onTimeUpdateRef.current) onTimeUpdateRef.current(timeController);
          if (onStatsUpdateRef.current) {
            onStatsUpdateRef.current({
              particles: particlePoolRef.current?.activeCount ?? 0,
              fireworks: fireworksRef.current.length,
              fps: fpsRef.current.fps
            });
          }
        };
        requestRef.current = requestAnimationFrame(animate);

        return () => {
          window.removeEventListener('resize', handleResize);
          if (requestRef.current) cancelAnimationFrame(requestRef.current);
          if (controlsRef.current) controlsRef.current.dispose();
          if (rendererRef.current) {
            rendererRef.current.dispose(); rendererRef.current.forceContextLoss();
            if(containerRef.current && rendererRef.current.domElement && containerRef.current.contains(rendererRef.current.domElement)) containerRef.current.removeChild(rendererRef.current.domElement);
          }
        };
      }, []);

      // å†…éƒ¨: å‘å°„å˜‰å¹´åæ³¢æ¬¡
      const launchCarnivalWave = (settings: AppSettings, config: FireworkConfig) => {
        const count = 5 + Math.floor(Math.random() * 5); // 5-10ä¸ª
        for(let i=0; i<count; i++) {
          setTimeout(() => {
            launchFireworkInternal(
                (Math.random()-0.5)*800, 200+Math.random()*200, (Math.random()-0.5)*800,
                undefined, undefined, settings, config
            );
          }, i * 100);
        }
      };

      // å†…éƒ¨: å‘å°„å•ä¸ªçƒŸèŠ±
      const launchFireworkInternal = (
          x: number, y: number, z: number,
          hue?: number, charge?: number,
          currentSettings?: AppSettings,
          currentConfig?: FireworkConfig,
          // æ–°å¢ï¼šå¼ºåˆ¶æŒ‡å®šç±»å‹ (ç”¨äºå•å‘é…ç½®)
          forcedShape?: ExplosionType,
          forcedColor?: ColorStyle
      ) => {
        const s = currentSettings || settingsRef.current;
        const c = currentConfig || configRef.current;
        const startX = (Math.random() - 0.5) * 400;
        const startZ = (Math.random() - 0.5) * 400;

        // å¦‚æœæœ‰å¼ºåˆ¶é…ç½®ï¼Œåˆ›å»ºä¸€ä¸ªä¸´æ—¶ Config
        let activeConfig = c;
        if (forcedShape || forcedColor) {
          activeConfig = {
            ...c,
            enabledShapes: forcedShape ? [forcedShape] : c.enabledShapes,
            enabledColors: forcedColor ? [forcedColor] : c.enabledColors
          };
        }

        fireworksRef.current.push(new Firework3D({
          startX, startZ, targetX: x, targetY: y, targetZ: z,
          hue: hue ?? Math.random() * 360,
          charge: charge ?? 0.4 + Math.random() * 0.6
        }, s, activeConfig));
      };

      const createStars = (scene: THREE.Scene) => {
        const geo = new THREE.BufferGeometry();
        const count = 3000;
        const pos = new Float32Array(count * 3); const col = new Float32Array(count * 3); const sz = new Float32Array(count);
        for (let i = 0; i < count; i++) {
          const r = 2000 + Math.random() * 3000;
          const theta = Math.random() * 6.28; const phi = Math.acos(2 * Math.random() - 1);
          pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
          pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
          pos[i*3+2] = r * Math.cos(phi);
          col[i*3] = 0.8; col[i*3+1] = 0.9; col[i*3+2] = 1.0;
          sz[i] = Math.random() * 2;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sz, 1));
        scene.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 3, vertexColors: true, transparent: true, opacity: 0.6, sizeAttenuation: false })));
        starsRef.current = scene.children[scene.children.length-1] as THREE.Points;
      };

      const createGround = (scene: THREE.Scene) => {
        const grid = new THREE.GridHelper(6000, 60, 0x334455, 0x111e2f);
        (grid.material as THREE.Material).transparent = true; (grid.material as THREE.Material).opacity = 0.15;
        grid.position.y = -5; scene.add(grid);
      };

      const updateParticleGeometry = () => {
        if (!particleGeometryRef.current || !particlePoolRef.current) return;
        const particles = particlePoolRef.current.getActiveParticles();
        const pos = particleGeometryRef.current.attributes.position.array as Float32Array;
        const col = particleGeometryRef.current.attributes.color.array as Float32Array;
        const sz = particleGeometryRef.current.attributes.size.array as Float32Array;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i]; const i3 = i * 3;
          pos[i3] = p.position.x; pos[i3+1] = p.position.y; pos[i3+2] = p.position.z;
          const c = p.getColor();
          col[i3] = c.r * p.alpha; col[i3+1] = c.g * p.alpha; col[i3+2] = c.b * p.alpha;
          sz[i] = p.size * (p.behavior === 'glitter' && p.twinkleFactor > 0.5 ? 0.3 : 1);
        }
        for (let i = particles.length; i < 25000; i++) {
          if (pos[i*3+1] > -5000) { pos[i*3] = 0; pos[i*3+1] = -10000; pos[i*3+2] = 0; sz[i] = 0; }
          else if (i > particles.length + 500) break;
        }
        particleGeometryRef.current.attributes.position.needsUpdate = true;
        particleGeometryRef.current.attributes.color.needsUpdate = true;
        particleGeometryRef.current.attributes.size.needsUpdate = true;
      };

      const updateStars = (time: number) => {
        if (!starsRef.current) return;
        const colors = starsRef.current.geometry.attributes.color.array as Float32Array;
        for(let i=0; i<colors.length; i+=3) {
          const f = 0.8 + 0.2 * Math.sin(time + i);
          colors[i] = 0.8 * f; colors[i+1] = 0.9 * f; colors[i+2] = 1.0 * f;
        }
        starsRef.current.geometry.attributes.color.needsUpdate = true;
      };

      useImperativeHandle(ref, () => ({
        launchCarnival: () => launchCarnivalWave(settingsRef.current, configRef.current),
        launchAt: (x, y, z) => launchFireworkInternal(x, y, z),
        getTimeController: () => timeControllerRef.current,
        setCameraMode: () => {}
      }));

      const handleMouseDown = (e: React.MouseEvent) => {
        if (e.button === 0) {
          mouseDownPos.current = { x: e.clientX, y: e.clientY };
          mouseDownTime.current = performance.now();
        }
      };

      const handleMouseUp = (e: React.MouseEvent) => {
        if (e.button === 0 && cameraRef.current) {
          const dist = Math.sqrt(Math.pow(e.clientX - mouseDownPos.current.x, 2) + Math.pow(e.clientY - mouseDownPos.current.y, 2));
          if (dist < 5 && performance.now() - mouseDownTime.current < 300) {
            const rect = containerRef.current?.getBoundingClientRect(); if (!rect) return;
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            raycasterRef.current.setFromCamera(mouse, cameraRef.current);
            const target = new THREE.Vector3();
            raycasterRef.current.ray.intersectPlane(planeRef.current, target);
            if (target) {
              // è¯»å–å•å‘é…ç½®
              const mConf = manualConfigRef.current;
              const shape = mConf.lockedShape === 'RANDOM' ? undefined : mConf.lockedShape;
              const color = mConf.lockedColor === 'RANDOM' ? undefined : mConf.lockedColor;

              launchFireworkInternal(
                  target.x, 200, target.z,
                  undefined, 0.8,
                  settingsRef.current, configRef.current,
                  shape, color // ä¼ å…¥å¼ºåˆ¶ç±»å‹
              );
            }
          }
        }
      };

      return (
          <div
              ref={containerRef}
              className="w-full h-full block cursor-pointer outline-none"
              onMouseDown={handleMouseDown} onMouseUp={handleMouseUp}
              title="Left Click: Launch | Drag: Rotate"
          />
      );
    }
);

// END OF FILE: src/components/FireworkScene3D.tsx

// =============================================================================
// FILE: src\components\ui\HUD.tsx
// =============================================================================


import React from 'react';

export const HUD: React.FC = () => {
  return (
    <>
      {/* å¤´éƒ¨ä¿¡æ¯ */}
      <div className="absolute top-10 left-10 z-10 pointer-events-none">
        <div className="flex items-center gap-4 mb-2">
          <div className="w-1.5 h-12 bg-cyan-500 rounded-full shadow-[0_0_20px_rgba(6,182,212,1)] animate-pulse"></div>
          <div>
            <h1 className="text-5xl font-black tracking-tighter italic leading-none">
              ç’€ç’¨<span className="text-cyan-400">æ˜Ÿè¾°</span> V4
            </h1>
            <p className="text-[10px] text-cyan-500/50 tracking-[0.5em] font-bold uppercase mt-1">
              Deep Space Particle System â€¢ Pro Edition
            </p>
          </div>
        </div>
      </div>

      {/* åº•éƒ¨æµ®æ ‡ */}
      <footer className="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-12 pointer-events-none opacity-20">
        <div className="h-[1px] w-40 bg-gradient-to-r from-transparent via-white/40 to-transparent"></div>
        <div className="text-[10px] text-white uppercase tracking-[1em] font-light flex gap-8">
          <span>è¡Œæ˜Ÿ</span><span>è’²å…¬è‹±</span><span>è¤ç«è™«</span><span>åœŸæ˜Ÿç¯</span><span>æ˜ŸèŠ’</span><span>æ³¢æµª</span>
        </div>
        <div className="h-[1px] w-40 bg-gradient-to-l from-transparent via-white/40 to-transparent"></div>
      </footer>

      {/* äº’åŠ¨æç¤º */}
      <div className="absolute bottom-10 left-10 text-[9px] text-white/30 tracking-[0.2em] font-medium pointer-events-none space-y-1">
        <p>â€¢ ç‚¹å‡»/è§¦æ‘¸å‘å°„</p>
        <p>â€¢ é•¿æŒ‰è“„åŠ›å¤§æ‹›</p>
        <p>â€¢ ç§»åŠ¨é¼ æ ‡äº§ç”Ÿæ˜Ÿå°˜</p>
      </div>

      <div className="absolute inset-0 bg-gradient-to-t from-cyan-950/20 via-transparent to-transparent pointer-events-none"></div>
    </>
  );
};


// =============================================================================
// FILE: src\components\ui\HUD3D.tsx
// =============================================================================

// FILE: src/components/ui/HUD3D.tsx

import React from 'react';

export const HUD3D: React.FC = () => {
    return (
        <>
            {/* å¤´éƒ¨ä¿¡æ¯ - æµ…è‰²æç®€é£æ ¼ */}
            <div className="absolute top-8 left-8 z-10 pointer-events-none select-none">
                <div className="flex items-center gap-4">
                    <div className="w-1.5 h-12 bg-gradient-to-b from-gray-800 to-gray-400 rounded-full"></div>
                    <div>
                        <h1 className="text-4xl font-black tracking-tight text-gray-800">
                            Celestial <span className="text-gray-400 font-light">Fireworks</span>
                        </h1>
                        <p className="text-[10px] text-gray-500 tracking-[0.4em] font-medium uppercase mt-1">
                            Interactive 3D Simulation
                        </p>
                    </div>
                </div>
            </div>

            {/* å³ä¸‹äº’åŠ¨æç¤º - å¡ç‰‡å¼è®¾è®¡ */}
            <div className="absolute bottom-8 right-8 pointer-events-none">
                <div className="bg-white/80 backdrop-blur-md p-5 rounded-2xl shadow-lg border border-white/50 text-gray-600">
                    <p className="text-gray-900 font-bold text-xs mb-3 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-green-400"></span>
                        CONTROL GUIDE
                    </p>
                    <div className="space-y-1.5 text-[10px] font-medium tracking-wide">
                        <div className="flex justify-between w-40">
                            <span>Rotate View</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">LMB / Drag</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Launch</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Click Ground</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Zoom</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Scroll</span>
                        </div>
                        <div className="flex justify-between w-40 mt-2 pt-2 border-t border-gray-200">
                            <span>Pause / Play</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">P</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* åº•éƒ¨è£…é¥°çº¿ */}
            <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-gray-300 to-transparent opacity-50 pointer-events-none"></div>
        </>
    );
};

// END OF FILE: src/components/ui/HUD3D.tsx

// =============================================================================
// FILE: src\components\ui\SettingsPanel.tsx
// =============================================================================

// FILE: src/components/ui/SettingsPanel.tsx

import React, { useState } from 'react';
import { AppSettings, FireworkConfig, ManualConfig, ExplosionType, AscensionType, ColorStyle, SHAPE_ICONS, COLOR_ICONS, ASCENSION_ICONS } from '../../types';

interface SettingsPanelProps {
    show: boolean;
    settings: AppSettings;
    config: FireworkConfig;
    manualConfig: ManualConfig;
    onClose: () => void;
    onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
    onUpdateConfig: (config: FireworkConfig) => void;
    onUpdateManual: (config: ManualConfig) => void;
    onRandomize: () => void;
    onReset: () => void;
}

export const SettingsPanel: React.FC<SettingsPanelProps> = ({
                                                                show, settings, config, manualConfig, onClose, onUpdate, onUpdateConfig, onUpdateManual, onRandomize, onReset
                                                            }) => {
    const [activeTab, setActiveTab] = useState<'carnival' | 'manual' | 'physics'>('carnival');

    // --- Helpers for Whitelist (Carnival) ---
    const toggleShape = (shape: ExplosionType) => {
        const newShapes = config.enabledShapes.includes(shape)
            ? config.enabledShapes.filter(s => s !== shape)
            : [...config.enabledShapes, shape];
        if (newShapes.length === 0) return; // Prevent empty
        onUpdateConfig({ ...config, enabledShapes: newShapes });
    };

    const toggleAscension = (type: AscensionType) => {
        const newTypes = config.enabledAscensions.includes(type)
            ? config.enabledAscensions.filter(t => t !== type)
            : [...config.enabledAscensions, type];
        if (newTypes.length === 0) return;
        onUpdateConfig({ ...config, enabledAscensions: newTypes });
    };

    const toggleColor = (style: ColorStyle) => {
        const newStyles = config.enabledColors.includes(style)
            ? config.enabledColors.filter(s => s !== style)
            : [...config.enabledColors, style];
        if (newStyles.length === 0) return;
        onUpdateConfig({ ...config, enabledColors: newStyles });
    };

    const toggleAll = (type: 'shapes' | 'colors' | 'ascensions', enable: boolean) => {
        const update = { ...config };
        if (type === 'shapes') update.enabledShapes = enable ? Object.values(ExplosionType) : [ExplosionType.SPHERE];
        if (type === 'colors') update.enabledColors = enable ? Object.values(ColorStyle) : [ColorStyle.SINGLE];
        if (type === 'ascensions') update.enabledAscensions = enable ? Object.values(AscensionType) : [AscensionType.LINEAR];
        onUpdateConfig(update);
    };

    return (
        <div className={`absolute top-0 right-0 h-full w-[420px] bg-white/95 backdrop-blur-3xl shadow-2xl z-40 transform transition-transform duration-500 ease-[cubic-bezier(0.23,1,0.32,1)] border-l border-gray-200 flex flex-col ${show ? 'translate-x-0' : 'translate-x-full'}`}>

            {/* Header */}
            <div className="p-6 pb-2 border-b border-gray-100 bg-white/50">
                <div className="flex justify-between items-center mb-6">
                    <div>
                        <h2 className="text-2xl font-black tracking-tighter text-gray-800">
                            <span className="text-blue-600">FIREWORK</span> EDITOR
                        </h2>
                        <p className="text-[10px] text-gray-400 font-bold uppercase tracking-[0.2em] mt-1">Professional Control Suite</p>
                    </div>
                    <button onClick={onClose} className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-100 text-gray-500 hover:bg-red-50 hover:text-red-500 transition-colors">
                        âœ•
                    </button>
                </div>

                {/* Tabs */}
                <div className="flex p-1 bg-gray-100 rounded-xl mb-2">
                    {[
                        { id: 'carnival', icon: 'ğŸ¡', label: 'å˜‰å¹´å' },
                        { id: 'manual', icon: 'ğŸ‘†', label: 'å•å‘é…ç½®' },
                        { id: 'physics', icon: 'âš™ï¸', label: 'ç‰©ç†å¼•æ“' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id as any)}
                            className={`flex-1 py-2.5 text-xs font-bold rounded-lg transition-all flex items-center justify-center gap-2 ${
                                activeTab === tab.id
                                    ? 'bg-white shadow-sm text-blue-600 ring-1 ring-black/5'
                                    : 'text-gray-500 hover:text-gray-700 hover:bg-gray-200/50'
                            }`}
                        >
                            <span className="text-sm">{tab.icon}</span> {tab.label}
                        </button>
                    ))}
                </div>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-y-auto custom-scrollbar p-6">

                {/* === Tab 1: Carnival === */}
                {activeTab === 'carnival' && (
                    <div className="space-y-8 animate-fadeIn">
                        {/* Auto Control */}
                        <section className="bg-blue-50/50 p-4 rounded-2xl border border-blue-100">
                            <div className="flex justify-between items-center mb-4">
                                <h3 className="text-xs font-black text-blue-800 uppercase tracking-widest flex items-center gap-2">
                                    <span>ğŸ¤–</span> è‡ªåŠ¨å·¡æ¼”æ§åˆ¶
                                </h3>
                                <label className="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" className="sr-only peer" checked={settings.enableAutoCarnival} onChange={e => onUpdate('enableAutoCarnival', e.target.checked)} />
                                    <div className="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                </label>
                            </div>
                            <SettingSlider label="æ¯æ³¢é—´éš” (ç§’)" value={settings.carnivalInterval} min={1} max={10} step={0.5} onChange={v => onUpdate('carnivalInterval', v)} />
                        </section>

                        {/* Whitelist: Shapes */}
                        <section>
                            <SectionHeader title="å½¢çŠ¶æ±  (Whitelist)" onAll={() => toggleAll('shapes', true)} onNone={() => toggleAll('shapes', false)} />
                            <div className="grid grid-cols-4 gap-2">
                                {Object.values(ExplosionType).map(t => (
                                    <VisualToggle key={t} label={t} icon={SHAPE_ICONS[t]} active={config.enabledShapes.includes(t)} onClick={() => toggleShape(t)} />
                                ))}
                            </div>
                        </section>

                        {/* Whitelist: Colors */}
                        <section>
                            <SectionHeader title="è‰²å½©é£æ ¼" onAll={() => toggleAll('colors', true)} onNone={() => toggleAll('colors', false)} />
                            <div className="grid grid-cols-3 gap-2">
                                {Object.values(ColorStyle).map(t => (
                                    <VisualToggle key={t} label={t} icon={COLOR_ICONS[t]} active={config.enabledColors.includes(t)} onClick={() => toggleColor(t)} />
                                ))}
                            </div>
                        </section>

                        {/* Whitelist: Ascension */}
                        <section>
                            <SectionHeader title="å‡ç©ºè½¨è¿¹" onAll={() => toggleAll('ascensions', true)} onNone={() => toggleAll('ascensions', false)} />
                            <div className="grid grid-cols-3 gap-2">
                                {Object.values(AscensionType).map(t => (
                                    <VisualToggle key={t} label={t} icon={ASCENSION_ICONS[t]} active={config.enabledAscensions.includes(t)} onClick={() => toggleAscension(t)} />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* === Tab 2: Manual === */}
                {activeTab === 'manual' && (
                    <div className="space-y-6 animate-fadeIn">
                        <div className="bg-gray-50 p-4 rounded-xl text-gray-500 text-[10px] leading-relaxed mb-4">
                            åœ¨æ­¤é…ç½®<b>é¼ æ ‡ç‚¹å‡»</b>å‘å°„çš„çƒŸèŠ±æ ·å¼ã€‚é€‰æ‹© "éšæœº" åˆ™ä¼šä»å˜‰å¹´åçš„ç™½åå•ä¸­éšæœºæŠ½å–ã€‚
                        </div>

                        <section>
                            <h3 className="text-xs font-black text-gray-400 uppercase tracking-widest mb-3">é”å®šå½¢çŠ¶ (Click Shape)</h3>
                            <div className="grid grid-cols-3 gap-2">
                                <VisualToggle
                                    label="éšæœº (Random)" icon="ğŸ²"
                                    active={manualConfig.lockedShape === 'RANDOM'}
                                    onClick={() => onUpdateManual({ ...manualConfig, lockedShape: 'RANDOM' })}
                                    primary
                                />
                                {Object.values(ExplosionType).map(t => (
                                    <VisualToggle
                                        key={t} label={t} icon={SHAPE_ICONS[t]}
                                        active={manualConfig.lockedShape === t}
                                        onClick={() => onUpdateManual({ ...manualConfig, lockedShape: t })}
                                    />
                                ))}
                            </div>
                        </section>

                        <section>
                            <h3 className="text-xs font-black text-gray-400 uppercase tracking-widest mb-3">é”å®šé¢œè‰² (Click Color)</h3>
                            <div className="grid grid-cols-3 gap-2">
                                <VisualToggle
                                    label="éšæœº (Random)" icon="ğŸ²"
                                    active={manualConfig.lockedColor === 'RANDOM'}
                                    onClick={() => onUpdateManual({ ...manualConfig, lockedColor: 'RANDOM' })}
                                    primary
                                />
                                {Object.values(ColorStyle).map(t => (
                                    <VisualToggle
                                        key={t} label={t} icon={COLOR_ICONS[t]}
                                        active={manualConfig.lockedColor === t}
                                        onClick={() => onUpdateManual({ ...manualConfig, lockedColor: t })}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* === Tab 3: Physics === */}
                {activeTab === 'physics' && (
                    <div className="space-y-8 animate-fadeIn">
                        <SettingSlider label="Gravity (å¼•åŠ›)" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
                        <SettingSlider label="Air Friction (é˜»åŠ›)" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
                        <SettingSlider label="Launch Interval (éšæœºå¾®è°ƒ)" value={settings.autoLaunchDelay} min={200} max={3000} step={100} unit="ms" onChange={v => onUpdate('autoLaunchDelay', v)} />
                        <SettingSlider label="Density (ç²’å­å¯†åº¦)" value={settings.particleCountMultiplier} min={0.5} max={2.0} step={0.1} onChange={v => onUpdate('particleCountMultiplier', v)} />
                        <SettingSlider label="Explosion Size (èŒƒå›´)" value={settings.explosionSizeMultiplier} min={0.5} max={2.0} step={0.1} onChange={v => onUpdate('explosionSizeMultiplier', v)} />
                        <SettingSlider label="Trail Length (å°¾è¿¹)" value={settings.trailLength} min={2} max={30} step={1} onChange={v => onUpdate('trailLength', v)} />
                    </div>
                )}
            </div>

            {/* Footer Actions */}
            <div className="p-6 border-t border-gray-100 bg-gray-50/50">
                <div className="flex gap-3">
                    <button
                        onClick={onRandomize}
                        className="flex-1 py-3 bg-gray-800 text-white rounded-xl text-xs font-bold uppercase tracking-widest hover:bg-gray-700 active:scale-95 transition-all shadow-lg shadow-gray-300"
                    >
                        ğŸ² Randomize
                    </button>
                    <button
                        onClick={onReset}
                        className="flex-1 py-3 text-gray-500 bg-white border border-gray-200 hover:bg-gray-50 rounded-xl text-xs font-bold uppercase tracking-widest transition-all"
                    >
                        Reset
                    </button>
                </div>
            </div>
        </div>
    );
};

// --- Sub Components ---

const SectionHeader = ({ title, onAll, onNone }: { title: string, onAll: () => void, onNone: () => void }) => (
    <div className="flex justify-between items-center mb-3">
        <h3 className="text-xs font-black text-gray-400 uppercase tracking-widest">{title}</h3>
        <div className="flex gap-2">
            <button onClick={onAll} className="text-[10px] text-blue-500 font-bold hover:underline bg-blue-50 px-2 py-0.5 rounded">All</button>
            <button onClick={onNone} className="text-[10px] text-gray-400 font-bold hover:underline bg-gray-100 px-2 py-0.5 rounded">None</button>
        </div>
    </div>
);

const VisualToggle = ({ label, icon, active, onClick, primary = false }: { label: string, icon: string, active: boolean, onClick: () => void, primary?: boolean }) => (
    <button
        onClick={onClick}
        className={`p-2 rounded-xl text-[10px] font-medium transition-all border flex flex-col items-center justify-center gap-1 min-h-[60px] relative overflow-hidden group ${
            active
                ? (primary ? 'bg-purple-50 border-purple-200 text-purple-700' : 'bg-blue-50 border-blue-200 text-blue-700')
                : 'bg-white border-gray-100 text-gray-400 hover:border-gray-300 hover:scale-[1.02]'
        }`}
    >
        <span className="text-xl mb-0.5 transform group-hover:scale-110 transition-transform">{icon}</span>
        <span className="text-center leading-tight scale-90">{label}</span>
        {active && <div className={`absolute top-1 right-1 w-1.5 h-1.5 rounded-full ${primary ? 'bg-purple-500' : 'bg-blue-500'}`}></div>}
    </button>
);

const SettingSlider = ({ label, value, min, max, step, unit = '', onChange }: any) => (
    <div className="group">
        <div className="flex justify-between items-center mb-2">
            <span className="text-[11px] font-bold text-gray-500 uppercase tracking-wider group-hover:text-blue-600 transition-colors">{label}</span>
            <span className="font-mono text-[10px] font-bold bg-gray-100 text-gray-600 px-2 py-1 rounded">
        {value.toFixed(label.includes('Interval') || label.includes('Length') ? 0 : 2)}{unit}
      </span>
        </div>
        <input
            type="range" min={min} max={max} step={step} value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="w-full h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer accent-blue-600 hover:bg-gray-300 transition-colors"
        />
    </div>
);

// END OF FILE: src/components/ui/SettingsPanel.tsx

// =============================================================================
// FILE: src\components\ui\TimeControlPanel.tsx
// =============================================================================

// FILE: src/components/ui/TimeControlPanel.tsx

import React from 'react';
import { TimeController } from '../../core/TimeController';

interface TimeControlPanelProps {
  timeController: TimeController | null;
  stats: {
    particles: number;
    fireworks: number;
    fps: number;
  };
  onTimeScaleChange: (scale: number) => void;
  onTogglePause: () => void;
  autoRotate: boolean;
  onToggleAutoRotate: () => void;
}

export const TimeControlPanel: React.FC<TimeControlPanelProps> = ({
                                                                    timeController,
                                                                    stats,
                                                                    onTimeScaleChange,
                                                                    onTogglePause,
                                                                    autoRotate,
                                                                    onToggleAutoRotate
                                                                  }) => {
  const timeScale = timeController?.timeScale ?? 1;
  const isPaused = timeController?.isPaused ?? false;

  return (
      <div className="absolute bottom-8 left-8 z-30 flex flex-col gap-3">
        {/* ç°ä»£åŒ–æµ…è‰²å¡ç‰‡ */}
        <div className="bg-white/80 backdrop-blur-xl rounded-2xl p-4 shadow-xl border border-white/50 w-64 transition-all hover:shadow-2xl hover:scale-[1.02]">

          {/* æ ‡é¢˜æ  */}
          <div className="flex justify-between items-center mb-4">
          <span className="text-gray-800 text-xs font-bold tracking-wider flex items-center gap-2">
             <span className="text-lg">âš™ï¸</span> ENGINE
          </span>
            <div className="flex gap-2 items-center bg-gray-100 px-2 py-1 rounded-lg">
              <div className={`w-1.5 h-1.5 rounded-full ${isPaused ? 'bg-amber-400 animate-pulse' : 'bg-green-500'}`}></div>
              <span className="text-[10px] font-mono text-gray-500 font-bold">{stats.fps} FPS</span>
            </div>
          </div>

          {/* æ§åˆ¶æŒ‰é’®ç½‘æ ¼ */}
          <div className="grid grid-cols-2 gap-2 mb-4">
            <button
                onClick={onTogglePause}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    isPaused
                        ? 'bg-amber-50 text-amber-600 border-amber-200 hover:bg-amber-100'
                        : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50 hover:text-gray-900'
                }`}
            >
              {isPaused ? 'â–¶ RESUME' : 'â¸ PAUSE'}
            </button>

            <button
                onClick={onToggleAutoRotate}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    autoRotate
                        ? 'bg-blue-50 text-blue-600 border-blue-200 hover:bg-blue-100'
                        : 'bg-white text-gray-400 border-gray-200 hover:bg-gray-50 hover:text-gray-600'
                }`}
            >
              {autoRotate ? 'â†º ROTATING' : 'âŠ˜ STATIC'}
            </button>
          </div>

          {/* é€Ÿåº¦æ»‘å— */}
          <div className="bg-gray-50 rounded-xl p-3 border border-gray-100">
            <div className="flex justify-between text-[10px] text-gray-400 mb-2 font-bold uppercase">
              <span>Time Scale</span>
              <span className="text-gray-800">{timeScale.toFixed(1)}x</span>
            </div>
            <input
                type="range"
                min="0.1"
                max="3"
                step="0.1"
                value={timeScale}
                onChange={(e) => onTimeScaleChange(parseFloat(e.target.value))}
                className="w-full h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer accent-gray-700 hover:accent-blue-600 transition-all"
            />
            <div className="flex justify-between mt-1 text-[8px] text-gray-300 font-mono">
              <span>SLOW</span>
              <span>FAST</span>
            </div>
          </div>

          {/* åº•éƒ¨ç»Ÿè®¡ä¿¡æ¯ */}
          <div className="mt-4 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[9px] text-gray-400 font-mono">
            <div>
              <span className="block text-gray-300 uppercase text-[8px]">Particles</span>
              <span className="font-bold text-gray-600">{(stats.particles/1000).toFixed(1)}k</span>
            </div>
            <div className="text-right">
              <span className="block text-gray-300 uppercase text-[8px]">Fireworks</span>
              <span className="font-bold text-gray-600">{stats.fireworks}</span>
            </div>
          </div>
        </div>
      </div>
  );
};

// END OF FILE: src/components/ui/TimeControlPanel.tsx

// =============================================================================
// FILE: src\core\Firework.ts
// =============================================================================


import { Vector2 } from './Vector2';
import { FireworkOptions, ExplosionType, AppSettings, ParticleOptions } from '../types';
import { Particle } from './Particle';

export class Firework {
  pos: Vector2;
  target: Vector2;
  vel: Vector2;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector2[] = [];
  trailLength: number;

  constructor(options: FireworkOptions, settings: AppSettings) {
    this.pos = new Vector2(options.startX, window.innerHeight);
    this.target = new Vector2(options.targetX, options.targetY);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;

    const distanceY = this.pos.y - this.target.y;
    const gravity = settings.gravity;
    const initialVelY = -Math.sqrt(2 * gravity * Math.max(10, distanceY)) * (0.85 + Math.random() * 0.3);
    const timeToApex = -initialVelY / gravity;
    const initialVelX = (this.target.x - this.pos.x) / timeToApex;

    this.vel = new Vector2(initialVelX, initialVelY);
  }

  update(settings: AppSettings): void {
    this.trail.push(this.pos.clone());
    if (this.trail.length > this.trailLength) {
      this.trail.shift();
    }
    this.vel.y += settings.gravity;
    this.pos.add(this.vel);
    
    if (this.vel.y >= -0.2) {
      this.exploded = true;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.strokeStyle = `hsl(${this.hue}, 100%, 75%)`;
    ctx.lineWidth = 1.2;
    for (let i = 0; i < this.trail.length; i++) {
      const p = this.trail[i];
      const alpha = i / this.trail.length;
      ctx.globalAlpha = alpha * 0.8;
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  createExplosion(settings: AppSettings, spawnParticle: (opts: ParticleOptions) => Particle): void {
    const types = Object.values(ExplosionType);
    const type = types[Math.floor(Math.random() * types.length)] as ExplosionType;
    
    let baseCount = Math.floor((180 + this.charge * 450) * settings.particleCountMultiplier);
    const sizeScale = settings.explosionSizeMultiplier;

    const spawn = (angle: number, speed: number, extraHue = 0, behavior: any = 'default', decay?: number) => {
      spawnParticle({
        x: this.pos.x, y: this.pos.y,
        originX: this.pos.x,
        originY: this.pos.y,
        hue: (this.hue + extraHue) % 360,
        angle,
        speed: speed * sizeScale,
        gravity: settings.gravity,
        friction: settings.friction,
        behavior,
        decay
      });
    };

    switch (type) {
      case ExplosionType.HEART:
        const heartCount = baseCount * 1.5;
        for (let i = 0; i < heartCount; i++) {
          const t = (i / heartCount) * Math.PI * 2;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          const speed = (Math.sqrt(x*x + y*y) / 8) * (6 + this.charge * 8);
          spawn(Math.atan2(y, x), speed, 0, 'default', 0.012);
        }
        break;

      case ExplosionType.STAR:
        const pts = 5;
        const starCount = baseCount * 1.3;
        for (let i = 0; i < starCount; i++) {
          const ang = (i / starCount) * Math.PI * 2;
          const mod = (Math.abs(Math.cos(ang * pts / 2)) * 0.7 + 0.3);
          spawn(ang, mod * (14 + this.charge * 18));
        }
        break;

      case ExplosionType.GALAXY:
        const arms = 4 + Math.floor(this.charge * 4);
        for (let a = 0; a < arms; a++) {
          const armBaseAngle = (a / arms) * Math.PI * 2;
          for (let i = 0; i < baseCount / arms; i++) {
            const prog = i / (baseCount / arms);
            const angle = armBaseAngle + prog * Math.PI * 2.5;
            const speed = prog * (15 + this.charge * 15);
            spawn(angle, speed, prog * 80, 'galaxy');
          }
        }
        break;

      case ExplosionType.SPIRAL:
        const sArms = 4 + Math.floor(this.charge * 4);
        const pPerArm = Math.floor(baseCount / sArms);
        for (let a = 0; a < sArms; a++) {
          const armBaseAngle = (a / sArms) * Math.PI * 2;
          for (let i = 0; i < pPerArm; i++) {
            const prog = i / pPerArm;
            const swirlAngle = armBaseAngle + (prog * Math.PI * 8);
            const speed = (0.2 + prog * 0.8) * (20 + this.charge * 15);
            spawn(swirlAngle, speed, prog * 60);
          }
        }
        break;

      case ExplosionType.BUTTERFLY:
        const bfCount = baseCount * 1.5;
        for (let i = 0; i < bfCount; i++) {
          const t = (i / bfCount) * Math.PI * 2;
          const r = Math.exp(Math.sin(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin((2 * t - Math.PI) / 24), 5);
          const x = Math.sin(t) * r;
          const y = -Math.cos(t) * r;
          spawn(Math.atan2(y, x), Math.sqrt(x*x + y*y) * (8 + this.charge * 10), Math.sin(t) * 40);
        }
        break;

      case ExplosionType.DOUBLE_RING:
        const ringCount = Math.floor(baseCount * 0.6);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2, 22 + this.charge * 12);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2 + 0.2, 14 + this.charge * 8, 40);
        break;

      case ExplosionType.GLITTER:
        for (let i = 0; i < baseCount; i++) spawn(Math.random() * Math.PI * 2, Math.random() * (22 + this.charge * 18), 0, 'glitter');
        break;

      default:
        for (let i = 0; i < baseCount; i++) {
          const angle = (i / baseCount) * Math.PI * 2;
          spawn(angle, Math.random() * (20 + this.charge * 24));
        }
        break;
    }
  }
}


// =============================================================================
// FILE: src\core\Firework3D.ts
// =============================================================================

// FILE: src/core/Firework3D.ts

import { Vector3 } from './Vector3';
import { ExplosionType, AscensionType, ColorStyle, AppSettings, ParticleOptions3D, FireworkConfig } from '../types';
import { Particle3D } from './Particle3D';

export interface Firework3DOptions {
  startX: number;
  startZ: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  hue: number;
  charge: number;
}

/**
 * 3D Firework class
 */
export class Firework3D {
  position: Vector3;
  target: Vector3;
  velocity: Vector3;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector3[] = [];
  trailLength: number;

  public type: ExplosionType;
  public ascension: AscensionType;
  public colorStyle: ColorStyle;
  public lifeTime: number = 0;

  private initialX: number;
  private initialZ: number;

  constructor(options: Firework3DOptions, settings: AppSettings, config: FireworkConfig) {
    this.initialX = options.startX;
    this.initialZ = options.startZ;
    this.position = new Vector3(options.startX, 0, options.startZ);
    this.target = new Vector3(options.targetX, options.targetY, options.targetZ);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;

    // 1. ä»é…ç½®ä¸­éšæœºé€‰æ‹©å‡ç©ºæ–¹å¼
    const ascList = config.enabledAscensions.length > 0 ? config.enabledAscensions : [AscensionType.LINEAR];
    this.ascension = ascList[Math.floor(Math.random() * ascList.length)];

    // 2. ä»é…ç½®ä¸­éšæœºé€‰æ‹©é¢œè‰²é£æ ¼
    const colList = config.enabledColors.length > 0 ? config.enabledColors : [ColorStyle.SINGLE];
    this.colorStyle = colList[Math.floor(Math.random() * colList.length)];

    // 3. ä»é…ç½®ä¸­éšæœºé€‰æ‹©çˆ†ç‚¸ç±»å‹
    const typeList = config.enabledShapes.length > 0 ? config.enabledShapes : [ExplosionType.SPHERE];
    this.type = typeList[Math.floor(Math.random() * typeList.length)];

    // 4. è®¡ç®—åˆå§‹é€Ÿåº¦
    const distanceY = this.target.y - this.position.y;
    let gravity = settings.gravity * 1.5;

    if (this.ascension === AscensionType.ACCELERATE) {
      gravity *= 0.8;
    }

    const timeToApex = Math.sqrt(2 * Math.max(10, distanceY) / gravity);
    const initialVelY = gravity * timeToApex;

    const initialVelX = (this.target.x - this.position.x) / timeToApex;
    const initialVelZ = (this.target.z - this.position.z) / timeToApex;

    this.velocity = new Vector3(initialVelX, initialVelY, initialVelZ);
  }

  update(settings: AppSettings, deltaTime: number): void {
    if (deltaTime <= 0) return;

    const dt = deltaTime * 60;
    this.lifeTime += deltaTime;

    // === å‡ç©ºç‰©ç†æ¨¡æ‹Ÿ ===
    switch (this.ascension) {
      case AscensionType.SPIRAL: {
        const freq = 10;
        const angle = this.lifeTime * freq;
        this.velocity.x += Math.cos(angle) * 0.6;
        this.velocity.z += Math.sin(angle) * 0.6;
        this.velocity.y -= settings.gravity * 1.5 * dt;
        break;
      }
      case AscensionType.ZIGZAG: {
        const freq = 8;
        this.velocity.x += Math.cos(this.lifeTime * freq) * 0.8;
        this.velocity.y -= settings.gravity * 1.5 * dt;
        break;
      }
      case AscensionType.ACCELERATE: {
        if (this.lifeTime < 0.5) this.velocity.y -= settings.gravity * 1.5 * dt;
        else if (this.lifeTime < 1.0) this.velocity.y += 0.3 * dt;
        else this.velocity.y -= settings.gravity * 2.0 * dt;
        break;
      }
      case AscensionType.DRAWING: {
        this.velocity.y -= settings.gravity * 1.2 * dt;
        break;
      }
      case AscensionType.WOBBLE: {
        this.velocity.x += (Math.random()-0.5) * 1.0;
        this.velocity.z += (Math.random()-0.5) * 1.0;
        this.velocity.y -= settings.gravity * 1.5 * dt;
        break;
      }
      default: // LINEAR
        this.velocity.y -= settings.gravity * 1.5 * dt;
        break;
    }

    this.position.x += this.velocity.x * dt;
    this.position.y += this.velocity.y * dt;
    this.position.z += this.velocity.z * dt;

    if (this.velocity.y <= -2.5) {
      this.exploded = true;
    }
  }

  createExplosion(
      settings: AppSettings,
      spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    let baseCount = Math.min(800, Math.floor((150 + this.charge * 300) * settings.particleCountMultiplier));
    const sizeScale = settings.explosionSizeMultiplier;

    // === é¢œè‰²ç”Ÿæˆå™¨ ===
    const getParticleHue = (index: number, total: number): number => {
      switch (this.colorStyle) {
        case ColorStyle.RAINBOW: return (index / total) * 360;
        case ColorStyle.DUAL: return index % 2 === 0 ? this.hue : (this.hue + 180) % 360;
        case ColorStyle.GRADIENT: return this.hue + (index / total) * 60 - 30;
        case ColorStyle.GOLDEN: return 45 + Math.random() * 10;
        case ColorStyle.PASTEL: return this.hue; // åœ¨æ¸²æŸ“å±‚å¤„ç†é¥±å’Œåº¦æ›´å¥½ï¼Œè¿™é‡Œæš‚ä¸”ç”¨åŸè‰²
        default: return this.hue;
      }
    };

    // === å‘å°„å™¨å·¥å‚ ===
    const spawn = (theta: number, phi: number, speed: number, hueOverride?: number, behavior: any = 'default', decay?: number, friction?: number, size?: number) => {
      spawnParticle({
        x: this.position.x, y: this.position.y, z: this.position.z,
        originX: this.position.x, originY: this.position.y, originZ: this.position.z,
        hue: hueOverride ?? this.hue,
        theta, phi, speed: speed * sizeScale,
        gravity: settings.gravity,
        friction: friction ?? settings.friction,
        behavior, size,
        decay: decay ?? (0.01 + Math.random() * 0.015)
      });
    };

    const spawnToShape = (x: number, y: number, z: number, hue: number) => {
      const speedMod = 15 * sizeScale;
      const len = Math.sqrt(x*x + y*y + z*z);
      if (len === 0) return;
      const p = spawnParticle({
        x: this.position.x, y: this.position.y, z: this.position.z,
        hue: hue, speed: 0,
        friction: 0.88, gravity: 0.02, decay: 0.005 + Math.random() * 0.008,
        behavior: 'stationary'
      });
      p.velocity = new Vector3(
          (x/len)*speedMod*(len*0.1), (y/len)*speedMod*(len*0.1), (z/len)*speedMod*(len*0.1)
      );
    };

    // === 32ç§çƒŸèŠ±é€»è¾‘å®ç° ===
    switch (this.type) {
        // --- åŸºç¡€ç±» ---
      case ExplosionType.SPHERE:
      case ExplosionType.BURST: {
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          spawn(theta, phi, 20 + Math.random() * 10, getParticleHue(i, baseCount));
        }
        break;
      }
      case ExplosionType.RING: {
        for (let i = 0; i < baseCount; i++) {
          spawn(Math.random() * Math.PI * 2, Math.PI / 2, 25, getParticleHue(i, baseCount));
        }
        break;
      }
      case ExplosionType.DOUBLE_RING: {
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          spawn(theta, Math.PI/2, 30, this.hue); // å¤–
          spawn(theta, Math.PI/2, 15, (this.hue+180)%360); // å†…
        }
        break;
      }
      case ExplosionType.WILLOW: {
        for (let i = 0; i < baseCount; i++) {
          spawn(Math.random() * Math.PI * 2, Math.random() * Math.PI, 15, getParticleHue(i, baseCount), 'willow', 0.008);
        }
        break;
      }
      case ExplosionType.STAGED: {
        for (let i = 0; i < baseCount*0.5; i++) spawn(Math.random()*6.28, Math.acos(2*Math.random()-1), 35, this.hue, 'default', 0.05);
        for (let i = 0; i < baseCount*0.5; i++) spawn(Math.random()*6.28, Math.acos(2*Math.random()-1), 8, (this.hue+60)%360, 'glitter', 0.008, 0.92);
        break;
      }
      case ExplosionType.FLASH: {
        for (let i = 0; i < baseCount; i++) {
          spawn(Math.random()*6.28, Math.acos(2*Math.random()-1), 25, 0, 'glitter', 0.03, 0.9); // ç™½é—ª
        }
        break;
      }

        // --- è‡ªç„¶/ç”Ÿç‰© ---
      case ExplosionType.FLOWER: {
        // èŠ±ç“£ç®—æ³•
        const petals = 6;
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = (Math.sin(theta * petals) + 1) * 0.5 * Math.PI; // èŠ±ç“£å½¢çŠ¶
          spawn(theta, phi * 0.5, 20, getParticleHue(i, baseCount));
        }
        break;
      }
      case ExplosionType.BUTTERFLY: {
        const count = baseCount * 1.2;
        for (let i = 0; i < count; i++) {
          const t = i * 0.1;
          const m = (Math.exp(Math.cos(t)) - 2*Math.cos(4*t) - Math.pow(Math.sin(t/12), 5)) * 12;
          spawnToShape(Math.sin(t)*m, Math.cos(t)*m, (Math.random()-0.5)*4, getParticleHue(i, count));
        }
        break;
      }
      case ExplosionType.FALLING_LEAVES: {
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * 6.28;
          const r = Math.random() * 40;
          const p = spawnParticle({
            x: this.position.x, y: this.position.y, z: this.position.z,
            hue: getParticleHue(i, baseCount), speed: 0, gravity: 0.03, friction: 0.85, decay: 0.006, behavior: 'falling'
          });
          p.velocity = new Vector3(Math.cos(theta)*r, 10 + (Math.random()-0.5)*15, Math.sin(theta)*r);
        }
        break;
      }
      case ExplosionType.SNOWFLAKE: {
        const arms = 6;
        for(let i=0; i<arms; i++) {
          const angle = (i/arms) * Math.PI * 2;
          for(let j=0; j<20; j++) {
            // ä¸»å¹²
            spawnToShape(Math.cos(angle)*j*2, Math.sin(angle)*j*2, 0, 200); // è“è‰²ç³»
            // åˆ†å‰
            if(j > 10 && j % 3 === 0) {
              spawnToShape(Math.cos(angle+0.5)*j*2, Math.sin(angle+0.5)*j*2, 0, 200);
              spawnToShape(Math.cos(angle-0.5)*j*2, Math.sin(angle-0.5)*j*2, 0, 200);
            }
          }
        }
        break;
      }
      case ExplosionType.FISH: {
        // ç®€å•é±¼å½¢ (ä¾§é¢)
        for(let i=0; i<baseCount; i++) {
          const t = (i/baseCount) * Math.PI * 2;
          const x = 30 * Math.cos(t) - 15 * Math.sin(t) * Math.sin(t);
          const y = 30 * Math.cos(t) * Math.sin(t);
          spawnToShape(x, y, (Math.random()-0.5)*5, 10); // çº¢è‰²é”¦é²¤
        }
        break;
      }
      case ExplosionType.CAT_FACE: {
        // è„¸åœ†
        for(let i=0; i<50; i++) {
          const t = (i/50)*6.28;
          spawnToShape(Math.cos(t)*20, Math.sin(t)*15, 0, 30);
        }
        // è€³æœµ
        for(let i=0; i<20; i++) {
          const x = 10 + i * 0.5; const y = 10 + i * 1.5;
          spawnToShape(x, y, 0, 30); spawnToShape(-x, y, 0, 30);
        }
        // çœ¼ç›å˜´å·´ (ç•¥)
        spawnToShape(-8, 5, 0, 120); spawnToShape(8, 5, 0, 120);
        break;
      }

        // --- å‡ ä½• ---
      case ExplosionType.CUBE: {
        const side = 20;
        const step = 5;
        for(let x=-side; x<=side; x+=step) {
          for(let y=-side; y<=side; y+=step) {
            for(let z=-side; z<=side; z+=step) {
              if (Math.abs(x)===side || Math.abs(y)===side || Math.abs(z)===side) {
                spawnToShape(x, y, z, getParticleHue(x+y+z, side*3));
              }
            }
          }
        }
        break;
      }
      case ExplosionType.PYRAMID: {
        // å››é¢ä½“
        const h = 30;
        for(let i=0; i<100; i++) {
          const t = i/100;
          // è¾¹ç¼˜
          spawnToShape(t*h, -h/2, t*h, this.hue);
          spawnToShape(-t*h, -h/2, t*h, this.hue);
          // é¡¶ç‚¹è¿çº¿
          spawnToShape(t*h, -h/2 + (1-t)*h, t*h, this.hue); // ç²—ç•¥æ¨¡æ‹Ÿ
        }
        break;
      }
      case ExplosionType.STAR: {
        const pts = 5;
        for(let i=0; i<baseCount; i++) {
          const ang = (i / baseCount) * Math.PI * 2;
          const r = 30 * (Math.abs(Math.cos(ang * pts / 2)) * 0.5 + 0.5); // ç®€å•çš„æ˜Ÿå½¢æåæ ‡
          // æ›´å¥½çš„æ˜Ÿå½¢ï¼š
          // const r = 30 * (Math.sin(ang * 5 / 2 + Math.PI/2) * 0.5 + 0.8);
          spawnToShape(Math.cos(ang)*r, Math.sin(ang)*r, 0, this.hue);
        }
        break;
      }
      case ExplosionType.HEART_BEAT: {
        const count = Math.floor(baseCount * 1.2);
        for (let i = 0; i < count; i++) {
          const t = Math.random() * Math.PI * 2;
          const scale = 2.0;
          const hx = 16 * Math.pow(Math.sin(t), 3) * scale;
          const hy = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * scale;
          spawnToShape(hx, hy, (Math.random() - 0.5) * 8, 330 + Math.random() * 30);
        }
        break;
      }
      case ExplosionType.SMILE: {
        const r = 25;
        // è„¸
        for(let i=0; i<60; i++) {
          const t = (i/60)*6.28;
          spawnToShape(Math.cos(t)*r, Math.sin(t)*r, 0, 50); // é»„è„¸
        }
        // çœ¼
        spawnToShape(-8, 8, 0, 0); spawnToShape(8, 8, 0, 0);
        // å˜´
        for(let i=0; i<30; i++) {
          const t = Math.PI + (i/30)*Math.PI;
          spawnToShape(Math.cos(t)*15, Math.sin(t)*15 - 5, 0, 0);
        }
        break;
      }
      case ExplosionType.SPIRAL: {
        // é˜¿åŸºç±³å¾·èºæ—‹
        for(let i=0; i<baseCount; i++) {
          const t = i * 0.1;
          const r = 1 + t * 0.5;
          spawnToShape(r*Math.cos(t), r*Math.sin(t), 0, getParticleHue(i, baseCount));
        }
        break;
      }

        // --- å®å¤§ ---
      case ExplosionType.GALAXY: {
        const arms = 5;
        for(let i=0; i<baseCount; i++) {
          const arm = Math.floor(Math.random() * arms);
          const dist = Math.random() * 40;
          const angle = (arm / arms) * 6.28 + dist * 0.1;
          spawnToShape(Math.cos(angle)*dist, (Math.random()-0.5)*5, Math.sin(angle)*dist, getParticleHue(dist, 40));
        }
        break;
      }
      case ExplosionType.SATURN: {
        for(let i=0; i<baseCount/2; i++) { // æœ¬ä½“
          const theta = Math.random()*6.28, phi = Math.acos(2*Math.random()-1);
          spawn(theta, phi, Math.random()*15, 40);
        }
        for(let i=0; i<baseCount; i++) { // ç¯
          const angle = Math.random()*6.28, dist = 30+Math.random()*10;
          spawnToShape(Math.cos(angle)*dist, Math.cos(angle)*dist*0.3, Math.sin(angle)*dist, 200);
        }
        break;
      }
      case ExplosionType.HELIX: {
        const h = 100, turns = 3;
        for(let i=0; i<baseCount; i++) {
          const y = (i/baseCount - 0.5) * h;
          const angle = (i/baseCount) * 6.28 * turns;
          spawnToShape(Math.cos(angle)*20, y, Math.sin(angle)*20, this.hue);
          spawnToShape(Math.cos(angle+Math.PI)*20, y, Math.sin(angle+Math.PI)*20, (this.hue+180)%360);
        }
        break;
      }
      case ExplosionType.DRAGON: {
        const segments = 50;
        for (let i = 0; i < segments; i++) {
          const p = i / segments;
          const a = p * 6.28 * 2;
          const r = (10 + p * 30);
          spawnToShape(Math.cos(a)*r, (p-0.5)*200, Math.sin(a)*r, 45);
        }
        break;
      }
      case ExplosionType.GREAT_WALL: {
        const len = 300, h = 40;
        for (let i = 0; i < 300; i++) {
          const x = (i/300 - 0.5) * len;
          const tower = Math.sin(x*0.15) > 0.8;
          const y = tower ? h*1.5 : h*Math.abs(Math.sin(x*0.05));
          spawnToShape(x, y, Math.sin(x*0.05)*20, 30);
        }
        break;
      }
      case ExplosionType.ZODIAC: {
        // è›‡
        for(let i=0; i<300; i++) {
          const t = i * 0.15;
          spawnToShape((t - 300*0.15/2)*10, Math.cos(t*0.5)*15, Math.sin(t)*30, 120);
        }
        break;
      }
      case ExplosionType.GHOST: {
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * 6.28, phi = Math.acos(2 * Math.random() - 1);
          spawn(theta, phi, 10 + Math.random() * 25, 260, 'ghost', 0.01, 0.94);
        }
        break;
      }
      case ExplosionType.CROSS_STEP: {
        for(let j=0; j<4; j++) {
          const baseTheta = (j/4)*6.28, basePhi = Math.PI/2;
          for(let k=0; k<40; k++) spawn(baseTheta, basePhi, 10+k, (this.hue+k*5)%360, 'glitter', 0.015);
        }
        break;
      }

        // --- æ–°å¢åˆ›æ„ ---
      case ExplosionType.ATOM: {
        // æ ¸
        for(let i=0; i<50; i++) spawnToShape((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10, 0);
        // ç”µå­è½¨é“
        const orbits = 3;
        for(let o=0; o<orbits; o++) {
          const rotX = Math.random()*3, rotY = Math.random()*3;
          for(let i=0; i<100; i++) {
            const a = (i/100)*6.28;
            const r = 30;
            let x = Math.cos(a)*r, y = Math.sin(a)*r, z = 0;
            // 3D æ—‹è½¬çŸ©é˜µç®€åŒ–
            // ...è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªåšå¹³é¢åœ†
            if (o===0) spawnToShape(x, y, z, 200);
            else if (o===1) spawnToShape(x, z, y, 200);
            else spawnToShape(z, x, y, 200);
          }
        }
        break;
      }
      case ExplosionType.FAN: {
        // æ‰‡å½¢å‘ä¸Š
        for(let i=0; i<baseCount; i++) {
          const a = (i/baseCount) * Math.PI; // 0 to PI
          const r = 10 + Math.random() * 30;
          spawnToShape(Math.cos(a)*r, Math.sin(a)*r, 0, getParticleHue(i, baseCount));
        }
        break;
      }
      case ExplosionType.WATERFALL: {
        // é¡¶éƒ¨æ°´å¹³å–·å‘ï¼Œç„¶åé‡åŠ›æ¥ç®¡
        for(let i=0; i<baseCount; i++) {
          const theta = Math.random() * 6.28;
          const r = Math.random() * 20;
          const p = spawnParticle({
            x: this.position.x, y: this.position.y, z: this.position.z,
            hue: 200, speed: 0, gravity: 0.05, friction: 0.95, decay: 0.005, behavior: 'default'
          });
          p.velocity = new Vector3(Math.cos(theta)*r, 5, Math.sin(theta)*r);
        }
        break;
      }
      case ExplosionType.CHAOS: {
        for(let i=0; i<baseCount; i++) {
          spawn(Math.random()*6.28, Math.random()*3.14, Math.random()*40, Math.random()*360);
        }
        break;
      }
      case ExplosionType.TEXT_HI: {
        // H
        for(let y=-20; y<=20; y+=2) { spawnToShape(-15, y, 0, this.hue); spawnToShape(-5, y, 0, this.hue); }
        for(let x=-15; x<=-5; x+=2) spawnToShape(x, 0, 0, this.hue);
        // I
        for(let y=-20; y<=20; y+=2) spawnToShape(10, y, 0, this.hue);
        break;
      }
      case ExplosionType.CROWN: {
        for(let i=0; i<baseCount; i++) {
          const a = (i/baseCount)*6.28;
          const r = 30;
          const h = 20 * Math.abs(Math.sin(a*3)); // çš‡å† æ³¢æµª
          spawnToShape(Math.cos(a)*r, h, Math.sin(a)*r, 50);
        }
        break;
      }

      default:
        for (let i = 0; i < baseCount; i++) {
          const theta = Math.random() * 6.28, phi = Math.acos(2*Math.random()-1);
          spawn(theta, phi, 10+Math.random()*20, this.hue);
        }
        break;
    }
  }

  getColor(): { r: number; g: number; b: number } {
    const h = this.hue / 360; const s = 1; const l = 0.6;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q;
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    };
    return { r: hue2rgb(p, q, h + 1/3), g: hue2rgb(p, q, h), b: hue2rgb(p, q, h - 1/3) };
  }
}

// END OF FILE: src/core/Firework3D.ts

// =============================================================================
// FILE: src\core\Particle.ts
// =============================================================================


import { ParticleOptions, ParticleBehavior } from '../types';

/**
 * Performance-optimized Particle class.
 */
export class Particle {
  public x: number = 0;
  public y: number = 0;
  public vx: number = 0;
  public vy: number = 0;
  public originX: number = 0;
  public originY: number = 0;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public color: string = '';
  public rotationSpeed: number = 0;

  constructor() {}

  init(options: ParticleOptions): void {
    this.x = options.x;
    this.y = options.y;
    this.originX = options.originX ?? options.x;
    this.originY = options.originY ?? options.y;
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();

    const angle = options.angle ?? Math.random() * Math.PI * 2;
    const speed = options.speed ?? Math.random() * 10 + 2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;

    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
    this.color = `hsl(${this.hue % 360}, 100%, 75%)`;
  }

  update(): void {
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.vx += Math.sin(now) * 0.05;
      this.vy += Math.cos(now) * 0.05;
    } else if (this.behavior === 'galaxy') {
      const dx = this.x - this.originX;
      const dy = this.y - this.originY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) + this.rotationSpeed;
      
      const targetX = this.originX + Math.cos(angle) * (dist + this.vx);
      const targetY = this.originY + Math.sin(angle) * (dist + this.vy);
      
      this.vx = targetX - this.x;
      this.vy = targetY - this.y;
    }

    const speedSq = this.vx * this.vx + this.vy * this.vy;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance;
      this.vx -= (this.vx / speed) * drag;
      this.vy -= (this.vy / speed) * drag;
    }

    this.vx *= this.friction;
    this.vy = this.vy * this.friction + this.gravity;
    
    this.x += this.vx;
    this.y += this.vy;

    this.life -= this.decay;
    
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }
    
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15) % 1;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    if (this.alpha <= 0) return;

    let currentAlpha = this.alpha;
    if (this.behavior === 'glitter' && this.twinkleFactor > 0.5) {
      currentAlpha *= 0.2;
    }

    ctx.globalAlpha = currentAlpha;
    ctx.fillStyle = this.color;
    
    if (this.behavior === 'willow' || this.behavior === 'comet') {
      ctx.beginPath();
      const trailLen = this.behavior === 'comet' ? 8 : 3;
      ctx.lineWidth = this.behavior === 'comet' ? this.size * this.life : this.size;
      ctx.strokeStyle = this.color;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * trailLen, this.y - this.vy * trailLen);
      ctx.stroke();
      
      if (this.behavior === 'comet') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, 6.28);
        ctx.fill();
      }
    } else if (this.behavior === 'galaxy') {
      ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
    } else {
      if (this.size < 2) {
        ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
      } else {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 6.28);
        ctx.fill();
      }
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }
}


// =============================================================================
// FILE: src\core\Particle3D.ts
// =============================================================================

import { Vector3 } from './Vector3';
import { ParticleBehavior, ParticleOptions3D } from '../types';

/**
 * 3D Particle class for the firework system
 * Uses Three.js coordinate system (Y-up)
 */
export class Particle3D {
  public position: Vector3;
  public velocity: Vector3;
  public origin: Vector3;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public rotationSpeed: number = 0;

  // Trail for comet/willow effects
  public trail: Vector3[] = [];
  public maxTrailLength: number = 10;

  constructor() {
    this.position = new Vector3();
    this.velocity = new Vector3();
    this.origin = new Vector3();
  }

  init(options: ParticleOptions3D): void {
    this.position = new Vector3(options.x, options.y, options.z);
    this.origin = new Vector3(
      options.originX ?? options.x,
      options.originY ?? options.y,
      options.originZ ?? options.z
    );
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();
    this.trail = [];

    // Calculate velocity from spherical coordinates
    const theta = options.theta ?? Math.random() * Math.PI * 2;
    const phi = options.phi ?? Math.random() * Math.PI;
    const speed = options.speed ?? Math.random() * 10 + 2;

    this.velocity = new Vector3(
      speed * Math.sin(phi) * Math.cos(theta),
      speed * Math.cos(phi),
      speed * Math.sin(phi) * Math.sin(theta)
    );

    // Apply behavior-specific settings
    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
      this.maxTrailLength = 15;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
      this.maxTrailLength = 20;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
  }

  update(deltaTime: number): void {
    // Use a minimum dt to prevent division by zero and ensure smooth updates
    const dt = Math.max(deltaTime * 60, 0.001); // Normalize to 60fps with minimum
    
    // Skip update if effectively paused
    if (deltaTime <= 0) return;

    // Store trail position
    if (this.behavior === 'comet' || this.behavior === 'willow') {
      this.trail.push(this.position.clone());
      if (this.trail.length > this.maxTrailLength) {
        this.trail.shift();
      }
    }

    // Behavior-specific updates
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.velocity.x += Math.sin(now) * 0.05 * dt;
      this.velocity.y += Math.cos(now * 0.7) * 0.05 * dt;
      this.velocity.z += Math.sin(now * 1.3) * 0.05 * dt;
    } else if (this.behavior === 'galaxy') {
      const dx = this.position.x - this.origin.x;
      const dz = this.position.z - this.origin.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const angle = Math.atan2(dz, dx) + this.rotationSpeed * dt;

      const targetX = this.origin.x + Math.cos(angle) * (dist + this.velocity.x * dt);
      const targetZ = this.origin.z + Math.sin(angle) * (dist + this.velocity.z * dt);

      // Safe division
      if (dt > 0.001) {
        this.velocity.x = (targetX - this.position.x) / dt;
        this.velocity.z = (targetZ - this.position.z) / dt;
      }
    }

    // Apply air resistance
    const speedSq = this.velocity.x * this.velocity.x +
                    this.velocity.y * this.velocity.y +
                    this.velocity.z * this.velocity.z;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance * dt;
      this.velocity.x -= (this.velocity.x / speed) * drag;
      this.velocity.y -= (this.velocity.y / speed) * drag;
      this.velocity.z -= (this.velocity.z / speed) * drag;
    }

    // Apply friction
    const frictionPower = Math.pow(this.friction, dt);
    this.velocity.x *= frictionPower;
    this.velocity.y *= frictionPower;
    this.velocity.z *= frictionPower;

    // Apply gravity (Y-up in Three.js)
    this.velocity.y -= this.gravity * dt;

    // Update position
    this.position.x += this.velocity.x * dt;
    this.position.y += this.velocity.y * dt;
    this.position.z += this.velocity.z * dt;

    // Update life
    this.life -= this.decay * dt;

    // Update alpha based on behavior
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }

    // Glitter twinkle
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15 * dt) % 1;
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }

  getColor(): { r: number; g: number; b: number } {
    // HSL to RGB conversion
    const h = this.hue / 360;
    const s = 1;
    const l = 0.75;

    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    return {
      r: hue2rgb(p, q, h + 1/3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1/3)
    };
  }
}


// =============================================================================
// FILE: src\core\ParticlePool.ts
// =============================================================================


import { Particle } from './Particle';
import { ParticleOptions } from '../types';

/**
 * Performance-optimized Particle Pool
 */
export class ParticlePool {
  private pool: Particle[] = [];
  private active: Particle[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle());
    }
  }

  /**
   * Get a particle: recycle the oldest active one if limit reached.
   */
  get(options: ParticleOptions): Particle {
    let p: Particle;
    
    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle();
    }
    
    p.init(options);
    this.active.push(p);
    return p;
  }

  updateAndDraw(ctx: CanvasRenderingContext2D): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update();
      p.draw(ctx);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  get activeCount() { return this.active.length; }
}


// =============================================================================
// FILE: src\core\ParticlePool3D.ts
// =============================================================================

import { Particle3D } from './Particle3D';
import { ParticleOptions3D } from '../types';

/**
 * Performance-optimized 3D Particle Pool
 * Manages particle lifecycle with object pooling to minimize GC
 */
export class ParticlePool3D {
  private pool: Particle3D[] = [];
  private active: Particle3D[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle3D());
    }
  }

  /**
   * Get a particle from the pool
   * Recycles the oldest active particle if limit is reached
   */
  get(options: ParticleOptions3D): Particle3D {
    let p: Particle3D;

    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle3D();
    }

    p.init(options);
    this.active.push(p);
    return p;
  }

  /**
   * Update all active particles
   */
  update(deltaTime: number): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update(deltaTime);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  /**
   * Get all active particles for rendering
   */
  getActiveParticles(): Particle3D[] {
    return this.active;
  }

  /**
   * Get the count of active particles
   */
  get activeCount(): number {
    return this.active.length;
  }

  /**
   * Clear all active particles
   */
  clear(): void {
    while (this.active.length > 0) {
      const p = this.active.pop()!;
      this.pool.push(p);
    }
  }
}


// =============================================================================
// FILE: src\core\TimeController.ts
// =============================================================================

/**
 * TimeController - Controls the flow of time in the 3D world
 * Allows pausing, slow motion, and time acceleration
 */
export class TimeController {
  private _timeScale: number = 1;
  private _isPaused: boolean = false;
  private _lastRealTime: number = 0;
  private _virtualTime: number = 0;
  private _deltaTime: number = 0;

  // Preset time scales
  static readonly PAUSED = 0;
  static readonly SLOW_MOTION = 0.2;
  static readonly NORMAL = 1;
  static readonly FAST = 2;
  static readonly ULTRA_FAST = 5;

  constructor() {
    this._lastRealTime = performance.now();
  }

  /**
   * Update the time controller - call this every frame
   */
  update(): void {
    const currentRealTime = performance.now();
    const realDelta = (currentRealTime - this._lastRealTime) / 1000; // Convert to seconds
    this._lastRealTime = currentRealTime;

    if (this._isPaused) {
      this._deltaTime = 0;
    } else {
      this._deltaTime = realDelta * this._timeScale;
      this._virtualTime += this._deltaTime;
    }
  }

  /**
   * Get the delta time adjusted for time scale
   */
  get deltaTime(): number {
    return this._deltaTime;
  }

  /**
   * Get the virtual time in the simulation
   */
  get virtualTime(): number {
    return this._virtualTime;
  }

  /**
   * Get the current time scale
   */
  get timeScale(): number {
    return this._timeScale;
  }

  /**
   * Set the time scale (0 = paused, 1 = normal, 2 = double speed, etc.)
   */
  set timeScale(value: number) {
    this._timeScale = Math.max(0, Math.min(10, value));
    if (this._timeScale === 0) {
      this._isPaused = true;
    } else {
      this._isPaused = false;
    }
  }

  /**
   * Check if the simulation is paused
   */
  get isPaused(): boolean {
    return this._isPaused;
  }

  /**
   * Pause the simulation
   */
  pause(): void {
    this._isPaused = true;
  }

  /**
   * Resume the simulation
   */
  resume(): void {
    this._isPaused = false;
    this._lastRealTime = performance.now();
  }

  /**
   * Toggle pause state
   */
  togglePause(): void {
    if (this._isPaused) {
      this.resume();
    } else {
      this.pause();
    }
  }

  /**
   * Set to slow motion
   */
  setSlowMotion(): void {
    this._timeScale = TimeController.SLOW_MOTION;
    this._isPaused = false;
  }

  /**
   * Set to normal speed
   */
  setNormal(): void {
    this._timeScale = TimeController.NORMAL;
    this._isPaused = false;
  }

  /**
   * Set to fast forward
   */
  setFast(): void {
    this._timeScale = TimeController.FAST;
    this._isPaused = false;
  }

  /**
   * Increase time scale by a step
   */
  speedUp(step: number = 0.25): void {
    this.timeScale = Math.min(10, this._timeScale + step);
  }

  /**
   * Decrease time scale by a step
   */
  slowDown(step: number = 0.25): void {
    this.timeScale = Math.max(0.1, this._timeScale - step);
  }

  /**
   * Get a formatted string of the current time state
   */
  getStatusText(): string {
    if (this._isPaused) return 'â¸ å·²æš‚åœ';
    if (this._timeScale < 0.5) return `ğŸ¢ ${this._timeScale.toFixed(2)}x æ…¢åŠ¨ä½œ`;
    if (this._timeScale === 1) return 'â–¶ 1x æ­£å¸¸';
    if (this._timeScale <= 2) return `â© ${this._timeScale.toFixed(2)}x`;
    return `ğŸš€ ${this._timeScale.toFixed(2)}x è¶…é€Ÿ`;
  }
}


// =============================================================================
// FILE: src\core\Vector2.ts
// =============================================================================


export class Vector2 {
  constructor(public x: number = 0, public y: number = 0) {}

  add(v: Vector2): Vector2 {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  multiply(scalar: number): Vector2 {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  static fromAngle(angle: number, length: number): Vector2 {
    return new Vector2(Math.cos(angle) * length, Math.sin(angle) * length);
  }

  clone(): Vector2 {
    return new Vector2(this.x, this.y);
  }
}


// =============================================================================
// FILE: src\core\Vector3.ts
// =============================================================================

/**
 * 3D Vector class for the 3D firework system
 */
export class Vector3 {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  add(v: Vector3): Vector3 {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  sub(v: Vector3): Vector3 {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  multiply(scalar: number): Vector3 {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  length(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  normalize(): Vector3 {
    const len = this.length();
    if (len > 0) {
      this.x /= len;
      this.y /= len;
      this.z /= len;
    }
    return this;
  }

  distanceTo(v: Vector3): number {
    const dx = this.x - v.x;
    const dy = this.y - v.y;
    const dz = this.z - v.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  static fromSpherical(theta: number, phi: number, radius: number): Vector3 {
    return new Vector3(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  clone(): Vector3 {
    return new Vector3(this.x, this.y, this.z);
  }

  toArray(): [number, number, number] {
    return [this.x, this.y, this.z];
  }
}


// =============================================================================
// FILE: src\main.tsx
// =============================================================================


import React from 'react';
import ReactDOM from 'react-dom/client';
import App3D from './App3D';
import './styles/index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App3D />
  </React.StrictMode>
);


// =============================================================================
// FILE: src\styles\index.css
// =============================================================================

/* Main styles for Celestial Fireworks Pro */
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #050505;
  user-select: none;
}

.custom-scrollbar::-webkit-scrollbar { width: 4px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }


// =============================================================================
// FILE: src\types\index.ts
// =============================================================================

// FILE: src/types/index.ts

export enum ExplosionType {
  // === ç»å…¸ ===
  SPHERE = 'æ ‡å‡†çƒå½¢',
  BURST = 'é«˜äº®çˆ†å‘',
  RING = 'æ˜Ÿç¯',
  DOUBLE_RING = 'åŒå±‚ç¯',
  WILLOW = 'é‡‘æŸ³å‚ä¸',
  STAGED = 'å­æ¯è¿çˆ†',
  FLASH = 'é›·éœ†é—ªå…‰',

  // === è‡ªç„¶ ===
  FLOWER = 'ç››ä¸–ç‰¡ä¸¹',
  BUTTERFLY = 'å¹»å½©è´è¶',
  FALLING_LEAVES = 'æ¼«å¤©è½å¶',
  SNOWFLAKE = 'å…­è§’é›ªèŠ±',
  FISH = 'é”¦é²¤æ¸¸åŠ¨',
  CAT_FACE = 'çŒ«å’ªç¬‘è„¸',

  // === å‡ ä½•/æŠ½è±¡ ===
  CUBE = 'é‡å­ç«‹æ–¹',
  PYRAMID = 'é‡‘å­—å¡”',
  STAR = 'äº”è§’æ˜Ÿ',
  HEART_BEAT = 'è·³åŠ¨ä¹‹å¿ƒ',
  SMILE = 'ç¬‘è„¸',
  SPIRAL = 'é˜¿åŸºç±³å¾·',

  // === å®å¤§ ===
  GALAXY = 'é“¶æ²³ç³»',
  SATURN = 'åœŸæ˜Ÿç¯',
  HELIX = 'DNAåŒèºæ—‹',
  DRAGON = 'æ¸¸é¾™æˆç ',
  GREAT_WALL = 'ä¸‡é‡Œé•¿åŸ',
  ZODIAC = 'çµè›‡ç‹‚èˆ',
  GHOST = 'å¹½çµé­…å½±',
  CROSS_STEP = 'åå­—å˜è‰²',

  // === åˆ›æ„ ===
  ATOM = 'åŸå­ç»“æ„',
  FAN = 'å­”é›€å¼€å±',
  WATERFALL = 'ä¹å¤©ç€‘å¸ƒ',
  CHAOS = 'æ··æ²Œç†è®º',
  TEXT_HI = 'å­—å½¢:Hi',
  CROWN = 'çš‡å† '
}

// å›¾æ ‡æ˜ å°„ï¼šå®ç°"å›¾æ–‡å¹¶èŒ‚"
export const SHAPE_ICONS: Record<ExplosionType, string> = {
  [ExplosionType.SPHERE]: 'ğŸ’¥', [ExplosionType.BURST]: 'âœ¨',
  [ExplosionType.RING]: 'â­•', [ExplosionType.DOUBLE_RING]: 'â—',
  [ExplosionType.WILLOW]: 'ğŸ‹', [ExplosionType.STAGED]: 'ğŸ†',
  [ExplosionType.FLASH]: 'âš¡', [ExplosionType.FLOWER]: 'ğŸŒº',
  [ExplosionType.BUTTERFLY]: 'ğŸ¦‹', [ExplosionType.FALLING_LEAVES]: 'ğŸ‚',
  [ExplosionType.SNOWFLAKE]: 'â„ï¸', [ExplosionType.FISH]: 'ğŸŸ',
  [ExplosionType.CAT_FACE]: 'ğŸ±', [ExplosionType.CUBE]: 'ğŸ§Š',
  [ExplosionType.PYRAMID]: 'ğŸ”º', [ExplosionType.STAR]: 'â­',
  [ExplosionType.HEART_BEAT]: 'â¤ï¸', [ExplosionType.SMILE]: 'ğŸ™‚',
  [ExplosionType.SPIRAL]: 'ğŸ¥', [ExplosionType.GALAXY]: 'ğŸŒŒ',
  [ExplosionType.SATURN]: 'ğŸª', [ExplosionType.HELIX]: 'ğŸ§¬',
  [ExplosionType.DRAGON]: 'ğŸ‰', [ExplosionType.GREAT_WALL]: 'ğŸ§±',
  [ExplosionType.ZODIAC]: 'ğŸ', [ExplosionType.GHOST]: 'ğŸ‘»',
  [ExplosionType.CROSS_STEP]: 'âœ¥', [ExplosionType.ATOM]: 'âš›ï¸',
  [ExplosionType.FAN]: 'ğŸª­', [ExplosionType.WATERFALL]: 'ğŸŒŠ',
  [ExplosionType.CHAOS]: 'ğŸ²', [ExplosionType.TEXT_HI]: 'H',
  [ExplosionType.CROWN]: 'ğŸ‘‘'
};

export enum AscensionType {
  LINEAR = 'ç›´çº¿å‡ç©º',
  SPIRAL = 'èºæ—‹ç›˜æ—‹',
  ZIGZAG = 'Så‹æ‘‡æ‘†',
  ACCELERATE = 'æé€Ÿæ¨è¿›',
  DRAWING = 'ç©ºä¸­ç»˜å›¾',
  WOBBLE = 'éšæœºæ‰°åŠ¨'
}

export const ASCENSION_ICONS: Record<AscensionType, string> = {
  [AscensionType.LINEAR]: 'â¬†ï¸',
  [AscensionType.SPIRAL]: 'ğŸŒ€',
  [AscensionType.ZIGZAG]: 'ã€°ï¸',
  [AscensionType.ACCELERATE]: 'ğŸš€',
  [AscensionType.DRAWING]: 'ğŸ–Œï¸',
  [AscensionType.WOBBLE]: 'ğŸ«¨'
};

export enum ColorStyle {
  SINGLE = 'çº¯å‡€å•è‰²',
  DUAL = 'åŒè‰²äº’è¡¥',
  RAINBOW = 'ä¸ƒå½©è™¹å…‰',
  GRADIENT = 'åŒç³»æ¸å˜',
  GOLDEN = 'æµé‡‘å²æœˆ',
  PASTEL = 'é©¬å¡é¾™è‰²'
}

export const COLOR_ICONS: Record<ColorStyle, string> = {
  [ColorStyle.SINGLE]: 'ğŸ”´',
  [ColorStyle.DUAL]: 'ğŸŒ—',
  [ColorStyle.RAINBOW]: 'ğŸŒˆ',
  [ColorStyle.GRADIENT]: 'ğŸ§',
  [ColorStyle.GOLDEN]: 'ğŸ†',
  [ColorStyle.PASTEL]: 'ğŸ¬'
};

export type ParticleBehavior = 'default' | 'willow' | 'glitter' | 'ghost' | 'firefly' | 'comet' | 'galaxy' | 'stationary' | 'falling';

export type CameraMode = 'orbit' | 'firstPerson';

export interface ParticleOptions3D {
  x: number; y: number; z: number;
  hue: number; speed?: number;
  theta?: number; phi?: number;
  friction?: number; gravity?: number;
  resistance?: number; size?: number;
  decay?: number; behavior?: ParticleBehavior;
  originX?: number; originY?: number; originZ?: number;
}

export interface AppSettings {
  gravity: number;
  friction: number;
  autoLaunchDelay: number; // åŸºç¡€éšæœºé—´éš”
  particleCountMultiplier: number;
  explosionSizeMultiplier: number;
  starBlinkSpeed: number;
  trailLength: number;
  // æ–°å¢ï¼šå˜‰å¹´åæ§åˆ¶
  enableAutoCarnival: boolean; // æ˜¯å¦å¼€å¯è‡ªåŠ¨å¾ªç¯
  carnivalInterval: number;    // è‡ªåŠ¨å¾ªç¯é—´éš”(ç§’)
}

// å˜‰å¹´åé…ç½® (ç™½åå•)
export interface FireworkConfig {
  enabledShapes: ExplosionType[];
  enabledAscensions: AscensionType[];
  enabledColors: ColorStyle[];
}

// å•å‘é…ç½® (æŒ‡å®šæ ·å¼)
export interface ManualConfig {
  lockedShape: ExplosionType | 'RANDOM';
  lockedColor: ColorStyle | 'RANDOM';
}

export const DEFAULT_SETTINGS: AppSettings = {
  gravity: 0.12,
  friction: 0.96,
  autoLaunchDelay: 2000,
  particleCountMultiplier: 1.0,
  explosionSizeMultiplier: 1.0,
  starBlinkSpeed: 0.001,
  trailLength: 15,
  enableAutoCarnival: false,
  carnivalInterval: 5
};

export const DEFAULT_CONFIG: FireworkConfig = {
  enabledShapes: Object.values(ExplosionType),
  enabledAscensions: Object.values(AscensionType),
  enabledColors: Object.values(ColorStyle)
};

export const DEFAULT_MANUAL_CONFIG: ManualConfig = {
  lockedShape: 'RANDOM',
  lockedColor: 'RANDOM'
};

// END OF FILE: src/types/index.ts