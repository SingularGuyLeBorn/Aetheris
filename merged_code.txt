

// =============================================================================
// FILE: src\App.tsx
// =============================================================================

/**
 * App.tsx - ä¸»åº”ç”¨å…¥å£
 * 
 * ä½¿ç”¨ Stream Architecture ("ä¸€åˆ‡çš†æµ") çƒŸèŠ±å¼•æ“
 * é…åˆæš—è‰²ç³»äº”é˜¶æ®µç”Ÿå‘½å‘¨æœŸé…ç½®å™¨
 */

import React, { useState, useRef, useCallback } from 'react';
import { StreamFireworkScene, StreamFireworkSceneHandle } from './components/StreamFireworkScene';
import { LifecycleConfigPanel } from './components/ui/LifecycleConfigPanel';
import {
  FireworkLifecycleConfig,
  DEFAULT_LIFECYCLE_CONFIG,
  LIFECYCLE_PRESETS,
} from './types/lifecycle';

// ============================================================================
// ä¸»ç»„ä»¶
// ============================================================================

const App: React.FC = () => {
  const sceneRef = useRef<StreamFireworkSceneHandle>(null);
  
  // ç”Ÿå‘½å‘¨æœŸé…ç½®çŠ¶æ€
  const [lifecycleConfig, setLifecycleConfig] = useState<FireworkLifecycleConfig>(
    DEFAULT_LIFECYCLE_CONFIG
  );

  // ç»Ÿè®¡ä¿¡æ¯çŠ¶æ€
  const [stats, setStats] = useState({
    particles: 0,
    fireworks: 0,
    fps: 60,
  });

  // æ§åˆ¶çŠ¶æ€
  const [isPaused, setIsPaused] = useState(false);
  const [isAutoRotate, setIsAutoRotate] = useState(true);

  // å‘å°„é¢„è§ˆ
  const handleLaunch = useCallback(() => {
    sceneRef.current?.launch();
  }, []);

  // å‘å°„å˜‰å¹´å
  const handleLaunchCarnival = useCallback(() => {
    sceneRef.current?.launchCarnival();
  }, []);

  // æš‚åœåˆ‡æ¢
  const handlePauseToggle = useCallback(() => {
    setIsPaused(prev => {
      sceneRef.current?.togglePause?.();
      return !prev;
    });
  }, []);

  // æ—‹è½¬åˆ‡æ¢
  const handleRotateToggle = useCallback(() => {
    setIsAutoRotate(prev => {
      sceneRef.current?.toggleAutoRotate?.();
      return !prev;
    });
  }, []);

  return (
    <div className="relative w-screen h-screen bg-slate-950 overflow-hidden font-sans">
      {/* 3D çƒŸèŠ±åœºæ™¯ */}
      <StreamFireworkScene
        ref={sceneRef}
        lifecycleConfig={lifecycleConfig}
        onStatsUpdate={setStats}
        isPaused={isPaused}
        isAutoRotate={isAutoRotate}
      />

      {/* é¡¶éƒ¨æ ‡é¢˜æ  */}
      <header className="absolute top-0 left-0 right-0 z-40 pointer-events-none">
        <div className="flex items-center justify-between px-6 py-4">
          <div className="pointer-events-auto">
            <h1 className="text-xl font-black text-white tracking-tight">
              <span className="bg-gradient-to-r from-cyan-400 via-violet-400 to-rose-400 bg-clip-text text-transparent">
                Aetheris
              </span>
            </h1>
            <p className="text-[10px] text-slate-500 mt-0.5">Stream Architecture Engine</p>
          </div>

          {/* å˜‰å¹´åæŒ‰é’® */}
          <button
            onClick={handleLaunchCarnival}
            className="
              pointer-events-auto
              group relative px-6 py-3
              bg-gradient-to-br from-amber-500 via-orange-500 to-rose-500
              rounded-xl font-bold text-xs text-white tracking-wider
              hover:scale-105 active:scale-95
              transition-all duration-200
              shadow-lg shadow-orange-500/30
              border border-white/10
              overflow-hidden
            "
          >
            <span className="relative z-10 flex items-center gap-2">
              <span className="text-base">ğŸ†</span>
              å˜‰å¹´å
            </span>
            <div className="absolute inset-0 bg-white/20 -translate-x-full group-hover:translate-x-0 transition-transform duration-500" />
          </button>
        </div>
      </header>

      {/* å·¦ä¾§é¢„è®¾å¿«æ·åˆ‡æ¢ */}
      <div className="absolute top-20 left-6 z-30 flex flex-col gap-1.5">
        {LIFECYCLE_PRESETS.map((preset) => (
          <button
            key={preset.id}
            onClick={() => setLifecycleConfig(preset)}
            className={`
              px-3 py-1.5 rounded-lg text-[11px] font-medium
              backdrop-blur-md border transition-all duration-200
              ${lifecycleConfig.id === preset.id
                ? 'bg-cyan-500/20 border-cyan-500/40 text-cyan-300 shadow-lg shadow-cyan-500/10'
                : 'bg-slate-900/50 border-slate-700/30 text-slate-400 hover:bg-slate-800/50 hover:text-slate-300'
              }
            `}
          >
            {preset.name}
          </button>
        ))}
      </div>

      {/* å³ä¸Šè§’å¿«æ·é”®æç¤º */}
      <div className="absolute top-20 right-6 z-30 space-y-1.5 text-right">
        <div className="text-[10px] text-slate-600">
          <span className="inline-block px-1.5 py-0.5 bg-slate-800/50 rounded text-slate-500 font-mono mr-1.5 text-[9px]">ç‚¹å‡»</span>
          å‘å°„çƒŸèŠ±
        </div>
        <div className="text-[10px] text-slate-600">
          <span className="inline-block px-1.5 py-0.5 bg-slate-800/50 rounded text-slate-500 font-mono mr-1.5 text-[9px]">æ‹–æ‹½</span>
          æ—‹è½¬è§†è§’
        </div>
        <div className="text-[10px] text-slate-600">
          <span className="inline-block px-1.5 py-0.5 bg-slate-800/50 rounded text-slate-500 font-mono mr-1.5 text-[9px]">æ»šè½®</span>
          ç¼©æ”¾è§†å›¾
        </div>
      </div>

      {/* æš‚åœæŒ‡ç¤ºå™¨ */}
      {isPaused && (
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 pointer-events-none">
          <div className="px-6 py-3 bg-slate-900/80 backdrop-blur-sm border border-slate-700/50 rounded-2xl">
            <span className="text-lg font-bold text-slate-300">â¸ï¸ å·²æš‚åœ</span>
          </div>
        </div>
      )}

      {/* åº•éƒ¨ç”Ÿå‘½å‘¨æœŸé…ç½®é¢æ¿ */}
      <LifecycleConfigPanel
        config={lifecycleConfig}
        onConfigChange={setLifecycleConfig}
        onLaunch={handleLaunch}
        onPauseToggle={handlePauseToggle}
        onRotateToggle={handleRotateToggle}
        isPaused={isPaused}
        isAutoRotate={isAutoRotate}
        stats={stats}
      />

      {/* å…¨å±€æ ·å¼ */}
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
        
        * {
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        ::-webkit-scrollbar {
          width: 4px;
          height: 4px;
        }
        ::-webkit-scrollbar-track {
          background: transparent;
        }
        ::-webkit-scrollbar-thumb {
          background: rgba(100, 116, 139, 0.3);
          border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
          background: rgba(100, 116, 139, 0.5);
        }

        .select-none {
          user-select: none;
          -webkit-user-select: none;
        }
      `}</style>
    </div>
  );
};

export default App;


// =============================================================================
// FILE: src\App3D.tsx
// =============================================================================

// FILE: src/App3D.tsx
// ä¸»åº”ç”¨å…¥å£ - æ•´åˆæ–°æ¶æ„çš„ç²’å­æ¨¡æ‹Ÿå™¨

import React, { useState, useRef } from 'react';
import { FireworkScene3D, FireworkScene3DHandle } from './components/FireworkScene3D';
import { ModernSettingsPanel } from './components/ui/ModernSettingsPanel';
import { TimeControlPanel } from './components/ui/TimeControlPanel';
import { HUD3D } from './components/ui/HUD3D';
import { DirectionIndicator } from './components/ui/DirectionIndicator';
import { TutorialOverlay, useTutorial } from './components/ui/TutorialOverlay';
import {
  AppSettings,
  DEFAULT_SETTINGS,
  FireworkConfig,
  DEFAULT_CONFIG,
  ManualConfig,
  DEFAULT_MANUAL_CONFIG,
  LaunchFormation
} from './types';
import { TimeController } from './core/TimeController';

const App3D: React.FC = () => {
  const sceneRef = useRef<FireworkScene3DHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [timeController, setTimeController] = useState<TimeController | null>(null);
  const [stats, setStats] = useState({ particles: 0, fireworks: 0, fps: 0 });
  const [autoRotate, setAutoRotate] = useState(true);

  // --- çŠ¶æ€ç®¡ç† ---
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [config, setConfig] = useState<FireworkConfig>(DEFAULT_CONFIG);
  const [manualConfig, setManualConfig] = useState<ManualConfig>(DEFAULT_MANUAL_CONFIG);
  const [logs, setLogs] = useState<string[]>([]);
  const [isLogCollapsed, setIsLogCollapsed] = useState(true);
  
  // --- æ•™ç¨‹ç³»ç»Ÿ ---
  const { showTutorial, completeTutorial, resetTutorial } = useTutorial();

  // --- é€»è¾‘å¤„ç† ---
  const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const handleTimeScaleChange = (scale: number) => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      const tc = currentScene.getTimeController();
      tc.timeScale = scale;
    }
  };

  const handleTogglePause = () => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      currentScene.getTimeController().togglePause();
    }
  };

  const handleRandomize = () => {
    // éšæœºç‰©ç†å‚æ•°
    setSettings(prev => ({
      ...prev,
      gravity: 0.05 + Math.random() * 0.15,
      friction: 0.90 + Math.random() * 0.08,
      particleCountMultiplier: 0.5 + Math.random() * 1.5,
      explosionSizeMultiplier: 0.8 + Math.random() * 0.8,
    }));

    // é‡ç½®é”å®šæ ·å¼ä¸ºéšæœº
    setManualConfig({
      lockedShape: 'RANDOM',
      lockedColor: 'RANDOM',
      lockedTrajectory: 'RANDOM',
      lockedCombo: 'RANDOM',
      lockedFormation: LaunchFormation.RANDOM,
      lockedCount: 1,
      lockedDuration: 0,
      lockedInterval: 100
    });
  };

  const handleReset = () => {
    setSettings(DEFAULT_SETTINGS);
    setConfig(DEFAULT_CONFIG);
    setManualConfig(DEFAULT_MANUAL_CONFIG);
    setLogs([]);
  };

  const handleLaunchLog = (log: string) => {
    setLogs(prev => [log, ...prev].slice(0, 10));
  };

  const handleLaunchCarnival = () => {
    sceneRef.current?.launchCarnival();
  };

  return (
    <div className="relative w-screen h-screen bg-slate-50 overflow-hidden font-sans text-gray-800 select-none">
      {/* å…¨å±€æ ·å¼ */}
      <style>{`
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          background: #10b981;
          cursor: pointer;
          border: 2px solid white;
          box-shadow: 0 2px 6px rgba(16, 185, 129, 0.3);
        }
        
        .custom-scrollbar::-webkit-scrollbar {
          width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: #e2e8f0;
          border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: #cbd5e1;
        }
        
        @keyframes slideUp {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-slideUp {
          animation: slideUp 0.4s ease-out;
        }
      `}</style>

      {/* HUD ä¿¡æ¯æ˜¾ç¤º */}
      <HUD3D />
      
      {/* åæ ‡è½´æ–¹å‘æŒ‡ç¤ºå™¨ */}
      <DirectionIndicator />

      {/* å‘å°„æ—¥å¿—æ˜¾ç¤º (å“åº”ç”¨æˆ·éœ€æ±‚: é»˜è®¤æŠ˜å ï¼Œè§†è§‰ç²¾ç®€) */}
      <div className="absolute bottom-10 left-6 z-50 pointer-events-none flex flex-col gap-2 max-w-sm">
        <div 
          className="pointer-events-auto flex items-center gap-2 mb-1 group cursor-pointer"
          onClick={() => setIsLogCollapsed(!isLogCollapsed)}
        >
          <div className={`px-2 py-1 rounded bg-black/20 backdrop-blur-sm text-[9px] font-bold text-white/50 transition-all ${isLogCollapsed ? 'opacity-100' : 'opacity-0'}`}>
            {logs.length} æ¡è®°å½•
          </div>
          <button className="w-6 h-6 rounded-full bg-slate-800/80 text-white/80 border border-white/10 flex items-center justify-center text-[10px] hover:bg-emerald-600 transition-all">
            {isLogCollapsed ? 'ï¼‹' : 'Ã—'}
          </button>
        </div>

        {!isLogCollapsed && logs.slice(0, 5).map((log, i) => (
          <div 
            key={`${i}-${log}`} 
            className="
              px-4 py-2
              bg-white/90 backdrop-blur-xl
              border border-emerald-100/50 
              rounded-2xl shadow-lg
              text-[11px] font-black text-emerald-800
              animate-slideUp
            "
            style={{ 
              opacity: 1 - i * 0.18,
              transform: `scale(${1 - i * 0.05})`,
              boxShadow: '0 4px 12px rgba(16, 185, 129, 0.1)'
            }}
          >
            <span className="mr-2 text-emerald-500">â—†</span>
            {log}
          </div>
        ))}
      </div>

      {/* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */}
      <div className="absolute top-6 right-6 z-20 flex flex-col gap-3 items-end">
        {/* åªä¿ç•™åˆ›æ„å·¥åŠå…¥å£ï¼Œå˜‰å¹´åæŒ‰é’®ç§»å…¥å†…éƒ¨ */}
        <button
          onClick={() => setShowSettings(true)}
          className="
            group flex items-center gap-3 px-5 py-3.5 
            bg-white/90 backdrop-blur-xl border border-white/20
            rounded-2xl shadow-xl hover:shadow-emerald-200/40 
            hover:-translate-y-0.5 active:scale-95 transition-all
          "
        >
          <div className="text-right">
            <div className="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-none mb-1">Workshop</div>
            <div className="text-sm font-black text-gray-800 leading-none">åˆ›æ„å·¥åŠ</div>
          </div>
          <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-emerald-500 to-teal-600 flex items-center justify-center text-white shadow-lg shadow-emerald-500/30 group-hover:rotate-12 transition-all">
            ğŸ¨
          </div>
        </button>
        
        {/* å·¥å…·æŒ‰é’®ç»„ */}
        <div className="flex gap-2">
          {/* æ•™ç¨‹æŒ‰é’® */}
          <button
            onClick={resetTutorial}
            className="
              p-3.5 rounded-xl
              bg-white/90 backdrop-blur
              text-gray-600 hover:text-blue-600
              shadow-lg border border-gray-100
              transition-all
            "
            title="æŸ¥çœ‹æ•™ç¨‹"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </button>
        </div>
      </div>

      {/* 3D çƒŸèŠ±åœºæ™¯ */}
      <FireworkScene3D
        ref={sceneRef}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        autoRotate={autoRotate}
        onTimeUpdate={(tc) => setTimeController(tc)}
        onStatsUpdate={(st) => setStats(st)}
        onLaunch={handleLaunchLog}
      />

      {/* æ—¶é—´æ§åˆ¶é¢æ¿ */}
      <TimeControlPanel
        timeController={timeController}
        stats={stats}
        onTimeScaleChange={handleTimeScaleChange}
        onTogglePause={handleTogglePause}
        autoRotate={autoRotate}
        onToggleAutoRotate={() => setAutoRotate(!autoRotate)}
      />

      {/* è®¾ç½®é¢æ¿ & ç‚¹å‡»å¤–éƒ¨å…³é—­é®ç½© */}
      {showSettings && (
        <div 
          className="fixed inset-0 z-30 bg-black/5 backdrop-blur-[1px]"
          onClick={() => setShowSettings(false)}
        />
      )}

      <ModernSettingsPanel
        show={showSettings}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onUpdateConfig={setConfig}
        onUpdateManual={setManualConfig}
        onRandomize={handleRandomize}
        onReset={handleReset}
        onLaunchCarnival={handleLaunchCarnival}
      />
      
      {/* å¼•å¯¼æ•™ç¨‹ */}
      {showTutorial && (
        <TutorialOverlay onComplete={completeTutorial} />
      )}

      {/* åº•éƒ¨å“ç‰Œæ ‡è¯† */}
      <div className="absolute bottom-4 right-4 text-[10px] text-gray-300 font-medium">
        <span className="font-bold text-gray-400">AETHERIS</span>
        <span className="mx-2 opacity-50">/</span>
        UNIVERSAL PARTICLE ENGINE v2.0
      </div>
    </div>
  );
};

export default App3D;

// END OF FILE: src/App3D.tsx

// =============================================================================
// FILE: src\components\FireworkCanvas.tsx
// =============================================================================


import React, { useEffect, useRef, useState, useCallback, useMemo, useImperativeHandle, forwardRef } from 'react';
import { ParticlePool } from '../core/ParticlePool';
import { Firework } from '../core/Firework';
import { AppSettings } from '../types';

interface Star {
  x: number;
  y: number;
  size: number;
  blinkSpeed: number;
  phase: number;
  layer: number;
}

interface FireworkCanvasProps {
  settings: AppSettings;
}

export interface FireworkCanvasHandle {
  launchCarnival: () => void;
}

export const FireworkCanvas = forwardRef<FireworkCanvasHandle, FireworkCanvasProps>(({ settings }, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fireworksRef = useRef<Firework[]>([]);
  
  const particlePoolRef = useRef<ParticlePool | null>(null);
  const sparklersPoolRef = useRef<ParticlePool | null>(null);
  
  if (!particlePoolRef.current) particlePoolRef.current = new ParticlePool(15000);
  if (!sparklersPoolRef.current) sparklersPoolRef.current = new ParticlePool(1000);

  const getParticlePool = () => particlePoolRef.current!;
  const getSparklersPool = () => sparklersPoolRef.current!;

  const shockwavesRef = useRef<{ x: number, y: number, r: number, a: number }[]>([]);
  
  const [isCharging, setIsCharging] = useState(false);
  const chargeLevelRef = useRef(0);
  const mousePos = useRef({ x: 0, y: 0 });
  const requestRef = useRef<number | undefined>(undefined);
  const lastAutoLaunch = useRef<number>(0);

  const stars = useMemo<Star[]>(() => {
    const s: Star[] = [];
    for (let i = 0; i < 400; i++) {
      s.push({
        x: Math.random() * 4000, 
        y: Math.random() * 3000,
        size: Math.random() * 1.2,
        blinkSpeed: (0.002 + Math.random() * 0.008) * (settings.starBlinkSpeed / 0.0008),
        phase: Math.random() * Math.PI * 2,
        layer: Math.floor(Math.random() * 3)
      });
    }
    return s;
  }, [settings.starBlinkSpeed]);

  const handleResize = useCallback(() => {
    if (canvasRef.current) {
      const dpr = window.devicePixelRatio || 1;
      canvasRef.current.width = window.innerWidth * dpr;
      canvasRef.current.height = window.innerHeight * dpr;
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }
  }, []);

  useEffect(() => {
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);

  const launchFireworkAt = (x: number, y: number, hue?: number, charge?: number) => {
    const startXVariation = (Math.random() - 0.5) * 100;
    const startX = Math.max(0, Math.min(window.innerWidth, x + startXVariation));
    
    fireworksRef.current.push(new Firework({
      startX,
      targetX: x,
      targetY: y,
      hue: hue ?? Math.random() * 360,
      charge: charge ?? 0.2 + Math.random() * 0.5
    }, settings));
  };

  useImperativeHandle(ref, () => ({
    launchCarnival: () => {
      const launch = (count: number, delay: number) => {
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const x = (window.innerWidth * 0.1) + (window.innerWidth * 0.8 * Math.random());
            const y = window.innerHeight * (0.1 + Math.random() * 0.4);
            launchFireworkAt(x, y, Math.random() * 360, 0.4 + Math.random() * 0.4);
          }, delay + i * 180);
        }
      };
      launch(8, 0); 
      launch(12, 1200);
    }
  }));

  const animate = useCallback((time: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    if (!ctx) return;

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#020205';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.fillStyle = '#fff';
    const oxB = (mousePos.current.x - window.innerWidth/2) * 0.005;
    const oyB = (mousePos.current.y - window.innerHeight/2) * 0.005;
    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];
      const opacity = 0.05 + Math.abs(Math.sin(time * s.blinkSpeed + s.phase)) * 0.6;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc((s.x + oxB * s.layer) % window.innerWidth, (s.y + oyB * s.layer) % window.innerHeight, s.size, 0, 6.28);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.22)';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    if (time - lastAutoLaunch.current > settings.autoLaunchDelay && !isCharging) {
      launchFireworkAt(Math.random() * window.innerWidth, 50 + Math.random() * (window.innerHeight * 0.4));
      lastAutoLaunch.current = time;
    }

    ctx.globalCompositeOperation = 'lighter';
    getSparklersPool().updateAndDraw(ctx);

    for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
      const f = fireworksRef.current[i];
      f.update(settings);
      f.draw(ctx);
      if (f.exploded) {
        f.createExplosion(settings, (opts) => getParticlePool().get(opts));
        if (f.charge > 0.5) {
          shockwavesRef.current.push({ x: f.pos.x, y: f.pos.y, r: 0, a: 0.25 });
        }
        fireworksRef.current.splice(i, 1);
      }
    }

    getParticlePool().updateAndDraw(ctx);

    for (let i = shockwavesRef.current.length - 1; i >= 0; i--) {
      const sw = shockwavesRef.current[i];
      sw.r += 16; sw.a -= 0.01;
      ctx.globalAlpha = sw.a;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.r, 0, 6.28);
      ctx.stroke();
      if (sw.a <= 0) shockwavesRef.current.splice(i, 1);
    }

    ctx.globalAlpha = 1;

    if (isCharging) {
      const increment = 0.025 * (1 - chargeLevelRef.current * 0.4);
      chargeLevelRef.current = Math.min(chargeLevelRef.current + increment, 1);
      
      const { x, y } = mousePos.current;
      const hue = (x / window.innerWidth) * 360;
      
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.4 + chargeLevelRef.current * 0.4})`;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, 40 + chargeLevelRef.current * 100, time * 0.003, time * 0.003 + 6.28);
      ctx.stroke();
      
      if (Math.random() > 0.5) {
        const ang = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 50;
        getSparklersPool().get({
          x: x + Math.cos(ang) * dist,
          y: y + Math.sin(ang) * dist,
          hue: (hue + 40) % 360,
          speed: -4 - chargeLevelRef.current * 4,
          angle: ang,
          size: 1,
          decay: 0.1,
          behavior: 'glitter'
        });
      }

      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${0.1 + chargeLevelRef.current * 0.4})`;
      ctx.beginPath();
      ctx.arc(x, y, chargeLevelRef.current * 50, 0, 6.28);
      ctx.fill();
      ctx.restore();
    }

    requestRef.current = requestAnimationFrame(animate);
  }, [isCharging, stars, settings]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [animate]);

  const updateMousePos = (e: React.MouseEvent | React.TouchEvent) => {
    const x = 'touches' in e ? (e as React.TouchEvent).touches[0].clientX : (e as React.MouseEvent).clientX;
    const y = 'touches' in e ? (e as React.TouchEvent).touches[0].clientY : (e as React.MouseEvent).clientY;
    mousePos.current = { x, y };
    
    if (Math.random() > 0.8) {
      getSparklersPool().get({
        x, y,
        hue: (performance.now() / 15) % 360,
        speed: Math.random() * 2,
        size: 0.7,
        decay: 0.06
      });
    }
  };

  const handleMouseDown = (e: React.MouseEvent | React.TouchEvent) => {
    setIsCharging(true);
    chargeLevelRef.current = 0;
    updateMousePos(e);
  };

  const handleMouseUp = () => {
    if (!isCharging) return;
    const xRatio = mousePos.current.x / window.innerWidth;
    const h = xRatio < 0.5 ? 170 + xRatio * 180 : (xRatio - 0.5) * 120;
    launchFireworkAt(mousePos.current.x, mousePos.current.y, h, chargeLevelRef.current + 0.1);
    setIsCharging(false);
    chargeLevelRef.current = 0;
  };

  return (
    <canvas
      ref={canvasRef}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onMouseMove={updateMousePos}
      onTouchStart={handleMouseDown}
      onTouchEnd={handleMouseUp}
      onTouchMove={updateMousePos}
      className="cursor-crosshair w-full h-full block touch-none"
    />
  );
});


// =============================================================================
// FILE: src\components\FireworkScene3D.tsx
// =============================================================================

// FILE: src/components/FireworkScene3D.tsx
// å‡çº§ç‰ˆ - æ”¯æŒ PBR æè´¨ã€ç”µå½±çº§åæœŸå¤„ç†ã€Verlet ç§¯åˆ†ç‰©ç†

import React, { useEffect, useRef, useImperativeHandle, forwardRef, memo } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

import { ParticlePool3D } from '../core/ParticlePool3D';
import { Firework3D } from '../core/Firework3D';
import { TimeController } from '../core/TimeController';
import { PostProcessingStack, DEFAULT_POST_PROCESSING_CONFIG, PostProcessingConfig } from '../core/PostProcessingStack';
import { PhysicsEngine, DEFAULT_PHYSICS_CONFIG, IntegratorType } from '../core/PhysicsEngine';
import { getPBRMaterialManager, createPBRParticleTexture } from '../core/PBRMaterial';
import {
  AppSettings,
  CameraMode,
  ExplosionType,
  AscensionType,
  FireworkConfig,
  ManualConfig,
  ColorStyle,
  LaunchFormation
} from '../types';

/**
 * æ˜¾å¼å®šä¹‰ Props æ¥å£ï¼Œç¡®ä¿ TypeScript åœ¨çˆ¶ç»„ä»¶å¼•ç”¨æ—¶ä¸ä¼šæŠ¥é”™
 */
export interface FireworkScene3DProps {
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  autoRotate: boolean;
  onTimeUpdate?: (timeController: TimeController) => void;
  onStatsUpdate?: (stats: { particles: number; fireworks: number; fps: number }) => void;
  onLaunch?: (log: string) => void;
}

/**
 * å®šä¹‰ç»„ä»¶æš´éœ²ç»™å¤–éƒ¨çš„æ“ä½œæ¥å£
 */
export interface FireworkScene3DHandle {
  launchCarnival: () => void;
  launchAt: (x: number, y: number, z: number) => void;
  getTimeController: () => TimeController;
}

/**
 * å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼šåˆ›å»º PBR çº§åˆ«çš„å‘å…‰ç²’å­è´´å›¾
 * å¤šå±‚æ¸å˜å®ç° HDR æ•ˆæœï¼Œæ ¸å¿ƒå…‰æ™• + æŸ”å’Œè¾¹ç¼˜
 */
const createDetailedParticleTexture = () => {
  const canvas = document.createElement('canvas');
  const resolution = 128;
  canvas.width = resolution;
  canvas.height = resolution;
  const ctx = canvas.getContext('2d')!;
  
  const center = resolution / 2;

  // ç¬¬ä¸€å±‚ï¼šæ ¸å¿ƒå…‰æ™• (è¶…é«˜å¼ºåº¦ HDR)
  const coreGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.3);
  coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
  coreGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.95)');
  coreGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)');
  coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = coreGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  // ç¬¬äºŒå±‚ï¼šä¸»å…‰æ™• (ä¸­ç­‰å¼ºåº¦)
  const mainGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.7);
  mainGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  mainGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.25)');
  mainGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.08)');
  mainGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = mainGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  // ç¬¬ä¸‰å±‚ï¼šå¤–å±‚æŸ”å’Œè¾¹ç¼˜ (è¥é€ çœŸå®æ„Ÿ)
  const outerGradient = ctx.createRadialGradient(center, center, 0, center, center, center);
  outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
  outerGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.03)');
  outerGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.01)');
  outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = outerGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

/**
 * FireworkScene3D æ ¸å¿ƒç»„ä»¶
 * ä½¿ç”¨ React.ForwardRefRenderFunction æ˜¾å¼å£°æ˜ä»¥è·å¾—æœ€ä½³ TS æ”¯æŒ
 */
const FireworkScene3DInner: React.ForwardRefRenderFunction<FireworkScene3DHandle, FireworkScene3DProps> = (
    { settings, config, manualConfig, autoRotate, onTimeUpdate, onStatsUpdate, onLaunch },
    ref
) => {
  // === åŸºç¡€å¼•ç”¨ ===
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const composerRef = useRef<EffectComposer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const requestRef = useRef<number>(0);

  // === ä¸šåŠ¡é€»è¾‘å¼•ç”¨ (ç”¨äºåœ¨ä¸è§¦å‘ useEffect çš„æƒ…å†µä¸‹åŒæ­¥çŠ¶æ€) ===
  const settingsRef = useRef(settings);
  const configRef = useRef(config);
  const manualConfigRef = useRef(manualConfig);
  const autoRotateRef = useRef(autoRotate);

  useEffect(() => { settingsRef.current = settings; }, [settings]);
  useEffect(() => { configRef.current = config; }, [config]);
  useEffect(() => { manualConfigRef.current = manualConfig; }, [manualConfig]);
  useEffect(() => { autoRotateRef.current = autoRotate; }, [autoRotate]);

  // === æ¨¡æ‹Ÿå™¨å†…éƒ¨çŠ¶æ€ ===
  const fireworksRef = useRef<Firework3D[]>([]);
  const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(30000));
  const timeControllerRef = useRef<TimeController>(new TimeController());

  const lastAutoLaunchRef = useRef<number>(0);
  const lastCarnivalRef = useRef<number>(0);
  const fpsRef = useRef({ frames: 0, lastTime: 0, value: 0 });

  // === é¼ æ ‡äº¤äº’å¼•ç”¨ ===
  const mouseDownPos = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const mouseDownTime = useRef<number>(0);
  const planeRef = useRef<THREE.Plane>(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0));

  /**
   * æ ¸å¿ƒå‘å°„æ–¹æ³•ï¼šæ”¯æŒä»é…ç½®ä¸­éšæœºæˆ–æŒ‡å®šæ ·å¼
   */
  const launchSingle = (s: AppSettings, c: FireworkConfig, overrides?: any) => {
    const targetX = overrides?.targetX ?? (Math.random() - 0.5) * 800;
    const targetZ = overrides?.targetZ ?? (Math.random() - 0.5) * 800;
    const targetY = overrides?.targetY ?? (200 + Math.random() * 150);
    const startX = overrides?.startX ?? (Math.random() - 0.5) * 1000;
    const startZ = overrides?.startZ ?? (Math.random() - 0.5) * 1000;

    // 1. è½¨è¿¹å†³ç­–
    let trajectory = overrides?.trajectory || 'RANDOM';
    if (trajectory === 'RANDOM') {
      const tPool = c.enabledTrajectories || [];
      trajectory = tPool.length > 0 ? tPool[Math.floor(Math.random() * tPool.length)] : undefined;
    }

    // 2. å½¢çŠ¶å†³ç­–
    let shape = overrides?.shape || 'RANDOM';
    if (shape === 'RANDOM') {
      const sPool = [...(c.enabledShape3Ds || []), ...(c.enabledShapes || [])];
      shape = sPool.length > 0 ? sPool[Math.floor(Math.random() * sPool.length)] : undefined;
    }

    // 3. ç»„åˆæŠ€å†³ç­–
    let combo = overrides?.combo || 'RANDOM';
    if (combo === 'RANDOM') {
      const cbPool = c.enabledCombos || [];
      combo = cbPool.length > 0 ? cbPool[Math.floor(Math.random() * cbPool.length)] : undefined;
    }
    
    // 4. ç”Ÿå‘½å‘¨æœŸå†³ç­– (Decay)
    const lifeTimeOverride = overrides?.duration || 0;

    fireworksRef.current.push(new Firework3D(
      {
        startX, startZ,
        targetX, targetY, targetZ,
        hue: Math.random() * 360,
        charge: 1.0,
        trajectoryType: trajectory,
        comboType: combo,
        customShape: shape,
        lifeTimeOverride
      },
      s, c
    ));

    // è¾“å‡ºæ—¥å¿—åˆ° UI
    if (!overrides?.skipLog) {
       const logInfo = `ğŸš€ å‘å°„: [${shape || 'é»˜è®¤'}] - ${trajectory || 'ç›´çº¿'} - ${combo || 'å•çº§'}`;
       onLaunch?.(logInfo);
    }
  };

  /**
   * é˜Ÿå½¢å‘å°„å™¨
   */
  const launchGroup = (
      formation: LaunchFormation, 
      count: number, 
      interval: number, 
      duration: number,
      launchFn: (idx: number, posOffset: THREE.Vector3, targetOffset: THREE.Vector3) => void
  ) => {
      if (count <= 1 || formation === LaunchFormation.SINGLE) {
          launchFn(0, new THREE.Vector3(), new THREE.Vector3());
          return;
      }

      const radius = 150;
      
      for (let i = 0; i < count; i++) {
          const offsetS = new THREE.Vector3(); 
          const offsetT = new THREE.Vector3(); 
          
          const progress = i / count;
          const angle = progress * Math.PI * 2;
          
          switch (formation) {
              case LaunchFormation.CIRCLE:
                  offsetT.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                  offsetS.set(Math.cos(angle) * radius * 0.5, 0, Math.sin(angle) * radius * 0.5); 
                  break;
              case LaunchFormation.LINE:
                  const w = radius * 2;
                  const x = (i - count / 2) * (w / count);
                  offsetT.set(x, 0, 0);
                  offsetS.set(x, 0, 0);
                  break;
              case LaunchFormation.CROSS: // ç®€å•çš„åå­—å¸ƒå±€
                  const arm = i % 4;
                  const dist = Math.floor(i / 4 + 1) * (radius / 2);
                  if (arm === 0) offsetT.set(dist, 0, 0);
                  if (arm === 1) offsetT.set(-dist, 0, 0);
                  if (arm === 2) offsetT.set(0, 0, dist);
                  if (arm === 3) offsetT.set(0, 0, -dist);
                  offsetS.copy(offsetT).multiplyScalar(0.5);
                  break;
              case LaunchFormation.V_SHAPE:
                  const side = i % 2 === 0 ? 1 : -1;
                  const row = Math.floor(i / 2);
                  offsetT.set(side * row * 50, 0, row * 50);
                  offsetS.copy(offsetT);
                  break;
              case LaunchFormation.RANDOM:
              default:
                  offsetT.set((Math.random()-0.5)*radius*2, (Math.random()-0.5)*50, (Math.random()-0.5)*radius*2);
                  offsetS.set((Math.random()-0.5)*radius, 0, (Math.random()-0.5)*radius);
                  break;
          }

          if (interval > 0) {
              setTimeout(() => {
                  launchFn(i, offsetS, offsetT);
              }, i * interval);
          } else {
              launchFn(i, offsetS, offsetT);
          }
      }
  };

  /**
   * å˜‰å¹´ååºåˆ—æ‰§è¡Œé€»è¾‘
   */
  const launchCarnivalWave = (s: AppSettings, c: FireworkConfig) => {
    const sequence = c.carnivalSequence || [];
    
    if (sequence.length === 0) {
      const count = 5 + Math.floor(Math.random() * 8);
      onLaunch?.(`éšæœºæ³¢æ¬¡: ${count} æš`);
      launchGroup(LaunchFormation.RANDOM, count, 150, 0, (i, offS, offT) => {
         launchSingle(s, c);
      });
      return;
    }

    let totalDelay = 0;
    sequence.forEach((stage, sIdx) => {
      totalDelay += stage.delay;
      setTimeout(() => {
        onLaunch?.(`[å¤§ç§€] ${stage.name}`);
        launchGroup(
            stage.formation || LaunchFormation.RANDOM,
            stage.count,
            stage.interval || 0,
            stage.duration || 0,
            (idx, offS, offT) => {
                launchSingle(s, c, {
                    trajectory: stage.trajectory,
                    shape: stage.shape,
                    combo: stage.combo,
                    duration: stage.duration,
                    targetX: offT.x * 1.5, 
                    targetZ: offT.z * 1.5, 
                    startX: offS.x,
                    startZ: offS.z,
                    skipLog: idx > 0 
                });
            }
        );
      }, totalDelay);
    });
  };

  const createBackgroundStars = (scene: THREE.Scene) => {
    const starGeo = new THREE.BufferGeometry();
    const count = 4000;
    const pos = new Float32Array(count * 3);
    const col = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const r = 3000 + Math.random() * 2000;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      pos[i * 3 + 2] = r * Math.cos(phi);
      col[i * 3] = 0.8; col[i * 3 + 1] = 0.8; col[i * 3 + 2] = 1.0;
    }

    starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));

    const starMat = new THREE.PointsMaterial({
      size: 3, vertexColors: true, transparent: true, opacity: 0.5, sizeAttenuation: false
    });
    scene.add(new THREE.Points(starGeo, starMat));
  };

  const createReferenceGround = (scene: THREE.Scene) => {
    const grid = new THREE.GridHelper(8000, 80, 0x223344, 0x05101a);
    const gridMat = grid.material as THREE.Material;
    gridMat.transparent = true;
    gridMat.opacity = 0.1;
    grid.position.y = -10;
    scene.add(grid);
  };

  const updateStarsTwinkle = (time: number) => {
    const stars = sceneRef.current?.children.find(c => c instanceof THREE.Points && !(c.material as any).map);
    if (stars && stars instanceof THREE.Points) {
      const colors = stars.geometry.attributes.color.array as Float32Array;
      for (let i = 0; i < colors.length; i += 3) {
        const f = 0.7 + 0.3 * Math.sin(time + i);
        colors[i] = 0.8 * f;
        colors[i + 1] = 0.8 * f;
        colors[i + 2] = 1.0 * f;
      }
      stars.geometry.attributes.color.needsUpdate = true;
    }
  };

  // === ç”Ÿå‘½å‘¨æœŸï¼šåˆå§‹åŒ–åœºæ™¯ ===
  useEffect(() => {
    if (!containerRef.current) return;

    // 1. åˆå§‹åŒ–åœºæ™¯å®¹å™¨
    containerRef.current.innerHTML = '';

    // 2. åˆ›å»ºåœºæ™¯ (Scene)
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e17);
    scene.fog = new THREE.FogExp2(0x0a0e17, 0.0006);
    sceneRef.current = scene;

    // 3. åˆ›å»ºç›¸æœº (Camera)
    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        10000
    );
    camera.position.set(0, 150, 600);
    cameraRef.current = camera;

    // 4. åˆ›å»ºæ¸²æŸ“å™¨ (Renderer) - HDR é…ç½®
    const renderer = new THREE.WebGLRenderer({
      antialias: false,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    // ä½¿ç”¨ ACES Filmic è‰²è°ƒæ˜ å°„ - ç”µå½±çº§ HDR æ¸²æŸ“
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // 5. é…ç½®å¢å¼ºç‰ˆåæœŸå¤„ç† (EffectComposer)
    // ä½¿ç”¨æ›´å¼ºçš„ Bloom æ•ˆæœå®ç° HDR å…‰æº¢å‡º
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.8,   // å¼ºåº¦ - å¢å¼ºåˆ° 1.8 å®ç°æ›´æ˜æ˜¾çš„å…‰æº¢å‡º
        0.5,   // åŠå¾„ - å¢åŠ åˆ° 0.5 è®©å…‰æ™•æ›´æŸ”å’Œ
        0.15   // é˜ˆå€¼ - é™ä½åˆ° 0.15 è®©æ›´å¤šåŒºåŸŸäº§ç”Ÿè¾‰å…‰
    );
    composer.addPass(renderPass);
    composer.addPass(bloomPass);
    composerRef.current = composer;

    // 6. é…ç½®è½¨é“æ§åˆ¶å™¨ (OrbitControls)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 100;
    controls.maxDistance = 2000;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controlsRef.current = controls;

    // 7. åˆå§‹åŒ–ç²’å­ç³»ç»Ÿå‡ ä½•ä½“
    const maxParticles = 30000;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3).fill(-10000);
    const colors = new Float32Array(maxParticles * 3);
    const sizes = new Float32Array(maxParticles);

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particleMaterial = new THREE.PointsMaterial({
      size: 8,
      map: createDetailedParticleTexture(),
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    const particlePoints = new THREE.Points(particleGeometry, particleMaterial);
    particlePoints.frustumCulled = false;
    scene.add(particlePoints);

    // 8. åˆ›å»ºèƒŒæ™¯å…ƒç´ 
    createBackgroundStars(scene);

    // å…·è±¡åŒ– XOZ å¹³é¢ (åœ°é¢) - æåº§æ ‡ç½‘æ ¼ + æ ‡å‡†ç½‘æ ¼
    const polarGrid = new THREE.PolarGridHelper(300, 16, 8, 0x059669, 0x064e3b);
    polarGrid.position.y = -50; // ä¸‹æ²‰è‡³åœ°é¢
    (polarGrid.material as THREE.Material).transparent = true;
    (polarGrid.material as THREE.Material).opacity = 0.2;
    scene.add(polarGrid);

    const gridHelper = new THREE.GridHelper(800, 40, 0x334155, 0x0f172a);
    gridHelper.position.y = -50;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.15;
    scene.add(gridHelper);
    
    // createReferenceGround(scene); // Deprecated
    createReferenceGround(scene);

    // 9. å¤„ç†çª—å£ç¼©æ”¾
    const onResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    };
    window.addEventListener('resize', onResize);

    // 10. æ ¸å¿ƒåŠ¨ç”»ä¸»å¾ªç¯
    const renderLoop = () => {
      requestRef.current = requestAnimationFrame(renderLoop);

      const tc = timeControllerRef.current;
      const currentSettings = settingsRef.current;
      const currentConfig = configRef.current;

      // æ›´æ–°æ§åˆ¶å™¨
      if (controlsRef.current) {
        controlsRef.current.autoRotate = autoRotateRef.current;
        controlsRef.current.update();
      }

      // å¦‚æœæœªæš‚åœï¼Œæ‰§è¡Œç‰©ç†æ¨¡æ‹Ÿ
      if (!tc.isPaused) {
        tc.update();
        const dt = tc.deltaTime;
        const virtualNow = tc.virtualTime * 1000;

        // A. è‡ªåŠ¨å˜‰å¹´åæ³¢æ¬¡åˆ¤å®š
        if (currentSettings.enableAutoCarnival) {
          if (virtualNow - lastCarnivalRef.current > currentSettings.carnivalInterval * 1000) {
            launchCarnivalWave(currentSettings, currentConfig);
            lastCarnivalRef.current = virtualNow;
          }
        }

        // === Sub-stepping å¸§å†…å¤šæ¬¡ç‰©ç†è®¡ç®— ===
        // ç¡®ä¿å³ä½¿åœ¨ä½å¸§ç‡ä¸‹è½¨è¿¹ä¹Ÿä¸æ»‘å¹³ç¨³
        const SUB_STEPS = 4;  // æ¯å¸§è¿›è¡Œ 4 æ¬¡ç‰©ç†æ›´æ–°
        const subDt = dt / SUB_STEPS;
        
        for (let step = 0; step < SUB_STEPS; step++) {
          // B. çƒŸèŠ±ç‰©ç†æ›´æ–° (ä½¿ç”¨ Verlet ç§¯åˆ†å™¨è‡ªåŠ¨å¤„ç†)
          for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
            const fw = fireworksRef.current[i];
            fw.update(currentSettings, subDt);

            // å‡ç©ºè¿‡ç¨‹ï¼šç”Ÿæˆå°¾ç„°ç²’å­ (ä»…åœ¨æœ€åä¸€ä¸ªå­æ­¥éª¤ç”Ÿæˆï¼Œé¿å…è¿‡å¤šç²’å­)
            // å‡ç©ºè¿‡ç¨‹ï¼šç”Ÿæˆå°¾ç„°ç²’å­
            // å¢å¼ºé€»è¾‘ï¼šå¯¹äºå¤æ‚è½¨è¿¹ï¼Œåœ¨æ¯ä¸ª sub-step éƒ½ç”Ÿæˆç²’å­ä»¥è·å¾—å¹³æ»‘æ›²çº¿
            // å¯¹äºç›´çº¿/ç®€å•è½¨è¿¹ï¼Œä»…åœ¨æ¯å¸§ç”Ÿæˆä¸€æ¬¡ä»¥èŠ‚çœæ€§èƒ½
            const isComplexTrail = Boolean(fw.ascension && fw.ascension.match(/(SPIRAL|HELIX|ZIGZAG|SINE|WOBBLE)/i));
            const shouldEmit = !fw.exploded && (isComplexTrail || step === SUB_STEPS - 1);

            if (shouldEmit) {
              const speed = fw.velocity.length();
              const t = fw.lifeTime;  // æ—¶é—´ç”¨äºåŠ¨ç”»æ•ˆæœ
              
              // æ ¹æ®è½¨è¿¹ç±»å‹ç¡®å®šå°¾ç„°å‚æ•°
              const trajectoryType = fw.ascension;
              const trajectoryName = (fw.ascension || 'LINEAR').toUpperCase();
              
              // åŸºç¡€å‚æ•°
              let trailCount = 1;        // æ¯å¸§ç”Ÿæˆæ•°é‡
              let trailSize = 6;         // å°¾ç„°å¤§å°
              let trailDecay = 0.05;     // è¡°å‡é€Ÿåº¦ (è¶Šå°æ‹–å°¾è¶Šé•¿)
              let trailSpread = 1.0;     // æ¨ªå‘æ‰©æ•£
              let trailGravity = 0.01;   // å—é‡åŠ›å½±å“
              let offsetX = 0, offsetZ = 0;
              let extraBrightness = 1.0; 
              let baseHue = fw.hue;
              
              // === è½¨è¿¹è§†è§‰å¼ºåŒ– ===

              if (trajectoryName.includes('SPIRAL') || trajectoryName.includes('HELIX')) {
                // èºæ—‹/DNAï¼šåŒè‚¡èºæ—‹ï¼Œé«˜å¯†åº¦ï¼Œè‰²å½©åˆ†ç¦»
                trailCount = 2; // æ¯æ­¥2ä¸ªç‚¹ (åŒèºæ—‹)
                trailSize = 5;
                trailDecay = 0.04;
                const spiralSpeed = 10;
                const spiralRadius = 12.0; // [VISIBILITY] å¢åŠ åŠå¾„åˆ° 12 (åŸ 3.5)
                
                // è®¡ç®—èºæ—‹åç§»
                const angle = t * spiralSpeed;
                offsetX = Math.cos(angle) * spiralRadius;
                offsetZ = Math.sin(angle) * spiralRadius;
                
                // é¢œè‰²åç§»ï¼šè®©ä¸¤æ¡èºæ—‹çº¿é¢œè‰²ç¨å¾®ä¸åŒ (äº®åº¦åŒºåˆ†)
                extraBrightness = 1.5;

              } else if (trajectoryName.includes('ZIGZAG') || trajectoryName.includes('SINE') || trajectoryName.includes('WOBBLE')) {
                // Så‹/æ‘‡æ‘†ï¼šå¤§å¹…åº¦æ‘†åŠ¨ï¼Œæ›´å®½çš„æ‹–å°¾
                trailCount = 2;
                trailSize = 6;
                trailDecay = 0.03; 
                const waveAmp = 25.0; // [VISIBILITY] å¢åŠ å¹…åº¦åˆ° 25
                const waveFreq = 6.0;
                
                // å‚ç›´äºè¿åŠ¨æ–¹å‘çš„æ‘†åŠ¨
                offsetX = Math.sin(t * waveFreq) * waveAmp;
                // Zè½´ç¨å¾®é”™å¼€å¢åŠ ç«‹ä½“æ„Ÿ
                offsetZ = Math.cos(t * waveFreq * 0.7) * (waveAmp * 0.4);
                
                trailSpread = 2.0;

              } else if (trajectoryName.includes('ACCELERATE') || trajectoryName === 'æé€Ÿæ¨è¿›') {
                // åŠ é€Ÿ/ç«ç®­ï¼šç»†é•¿ï¼Œæä¸ºæ˜äº®çš„æ ¸å¿ƒï¼Œä¼´éšçƒŸé›¾
                trailCount = 6;     // æ›´å¤šç²’å­
                trailSize = 8;        // æ ¸å¿ƒå¾ˆå¤§
                trailDecay = 0.015;   // æé•¿æ‹–å°¾
                trailSpread = 0.8;    // æ”¶æŸ
                extraBrightness = 4.0; // çˆ†äº®
                trailGravity = 0;     // æ— é‡åŠ›
                baseHue = 30;         // å¼ºåˆ¶åå‘ç«ç„°è‰² (æ©™/é»„) å¦‚æœä¸æ˜¯ override
                if (Math.random() < 0.3) baseHue = fw.hue; // å¶å°”æ··åˆåŸæœ¬é¢œè‰²

              } else if (trajectoryName.includes('BEZIER') || trajectoryName.includes('CURVE')) {
                // æ›²çº¿ï¼šå¹³æ»‘ï¼Œä¼˜é›…
                trailCount = 1;
                trailSize = 5;
                trailDecay = 0.04;
                extraBrightness = 1.2;
              }

              // ç”Ÿæˆç²’å­
              const spawnProbability = Math.min(1.0, speed / 10); 
              const alphaValue = Math.min(1, speed / 15) * extraBrightness;
              const emissiveBoost = (2.0 + speed * 0.2) * extraBrightness;

              for (let tc = 0; tc < trailCount; tc++) {
                if (Math.random() < spawnProbability) {
                  let finalOffX = offsetX;
                  let finalOffZ = offsetZ;
                  let pSize = trailSize;
                  let pHue = baseHue;

                  // èºæ—‹ç‰¹æ®Šå¤„ç†ï¼šåŒè‚¡åç›¸
                  if (trajectoryName.includes('SPIRAL') || trajectoryName.includes('HELIX')) {
                      // tc=0: æ­£ç›¸, tc=1: åç›¸ (PI)
                      const phase = (tc % 2) * Math.PI;
                      // é‡ç®—åç§»ä»¥ç¡®ä¿åŒè‚¡æ­£ç¡®
                      finalOffX = Math.cos(t * 10 + phase) * 12.0;
                      finalOffZ = Math.sin(t * 10 + phase) * 12.0;
                      
                      // åŒè‰²
                      pHue = fw.hue + (tc % 2 === 0 ? 0 : 180); 
                      pSize = trailSize * 0.8;
                  }

                  const p = particlePoolRef.current.get({
                    x: fw.position.x + finalOffX + (Math.random() - 0.5) * trailSpread,
                    y: fw.position.y - 1.0, 
                    z: fw.position.z + finalOffZ + (Math.random() - 0.5) * trailSpread,
                    hue: pHue,  
                    speed: 0, 
                    size: pSize * (Math.random() * 0.4 + 0.8),
                    decay: trailDecay * (Math.random() * 0.4 + 0.8),
                    behavior: 'default',
                    gravity: trailGravity
                  });
                  
                  if (p) {
                    p.alpha = alphaValue; 
                    p.emissiveIntensity = emissiveBoost;
                    // åŠ é€Ÿå°¾ç„°åæ¨æ•ˆæœ
                    if (trajectoryName.includes('ACCELERATE')) {
                       p.velocity.y = -speed * 0.15;
                       p.velocity.x *= 0.1;
                       p.velocity.z *= 0.1;
                    }
                  }
                }
              }
            }

            // çˆ†ç‚¸é€»è¾‘
            if (fw.exploded) {
              fw.createExplosion(currentSettings, (opts) => particlePoolRef.current.get(opts));
              fireworksRef.current.splice(i, 1);
            }
          }

          // C. å…¨å±€ç²’å­ç‰©ç†æ›´æ–° (Verlet ç§¯åˆ†)
          particlePoolRef.current.update(subDt);
        }
      }

      // D. åŒæ­¥ç²’å­ Buffer åˆ° GPU
      const activeParticles = particlePoolRef.current.getActiveParticles();
      const posArray = particleGeometry.attributes.position.array as Float32Array;
      const colArray = particleGeometry.attributes.color.array as Float32Array;

      for (let i = 0; i < activeParticles.length; i++) {
        const p = activeParticles[i];
        const idx = i * 3;
        posArray[idx] = p.position.x;
        posArray[idx + 1] = p.position.y;
        posArray[idx + 2] = p.position.z;

        // HDR é¢œè‰²è®¡ç®—ï¼šåŸºç¡€è‰² Ã— alpha Ã— å‘å…‰å¼ºåº¦
        // emissiveIntensity > 1.0 ä¼šäº§ç”Ÿ HDR æ•ˆæœï¼Œä¸ Bloom é…åˆäº§ç”Ÿå…‰æº¢å‡º
        const color = p.getColor();
        const hdrMultiplier = p.alpha * Math.min(p.emissiveIntensity, 5.0);  // é™åˆ¶æœ€å¤§å¼ºåº¦é¿å…è¿‡æ›
        colArray[idx] = color.r * hdrMultiplier;
        colArray[idx + 1] = color.g * hdrMultiplier;
        colArray[idx + 2] = color.b * hdrMultiplier;
      }

      // éšè—éæ´»åŠ¨ç²’å­
      for (let i = activeParticles.length; i < maxParticles; i++) {
        const idx = i * 3;
        if (posArray[idx + 1] > -5000) {
          posArray[idx] = 0;
          posArray[idx + 1] = -10000;
          posArray[idx + 2] = 0;
        } else if (i > activeParticles.length + 200) {
          break; // ä¼˜åŒ–ï¼šå¦‚æœå·²ç»æ˜¯ä¸€å—è¿ç»­çš„éšè—åŒºåˆ™åœæ­¢
        }
      }

      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;

      // E. æ›´æ–°æ˜Ÿæ˜Ÿé—ªçƒ
      updateStarsTwinkle(performance.now() * 0.0005);

      // F. FPS ç»Ÿè®¡
      fpsRef.current.frames++;
      if (performance.now() - fpsRef.current.lastTime > 1000) {
        fpsRef.current.value = fpsRef.current.frames;
        fpsRef.current.frames = 0;
        fpsRef.current.lastTime = performance.now();
      }

      // G. æ¸²æŸ“
      composer.render();

      // H. å›è°ƒ
      if (onTimeUpdate) onTimeUpdate(tc);
      if (onStatsUpdate) {
        onStatsUpdate({
          particles: activeParticles.length,
          fireworks: fireworksRef.current.length,
          fps: fpsRef.current.value
        });
      }
    };

    renderLoop();

    return () => {
      window.removeEventListener('resize', onResize);
      cancelAnimationFrame(requestRef.current);
      renderer.dispose();
      controls.dispose();
    };
  }, []);

  // äº¤äº’å‰§æœ¬ç´¢å¼•æŒ‡é’ˆ
  const manualStepIndexRef = useRef<number>(0);

  // === æš´éœ²æ¥å£ç»™çˆ¶ç»„ä»¶ ===
  useImperativeHandle(ref, () => ({
    launchCarnival: () => launchCarnivalWave(settingsRef.current, configRef.current),
    launchAt: (x, y, z) => {
      const mc = manualConfigRef.current;
      const c = configRef.current;
      const settings = settingsRef.current;
      const manualSeq = c.manualSequence || [];

      // å¦‚æœé…ç½®äº†æ‰‹åŠ¨äº¤äº’å‰§æœ¬ï¼Œåˆ™æŒ‰å‰§æœ¬é¡ºåºå‘å°„
      if (manualSeq.length > 0) {
        const stage = manualSeq[manualStepIndexRef.current];
        onLaunch?.(`[å‰§æœ¬] ${stage.name}`);
        
        launchGroup(
            stage.formation || LaunchFormation.SINGLE,
            stage.count,
            stage.interval || 100,
            stage.duration || 0,
            (idx, offS, offT) => {
               launchSingle(settings, c, {
                 trajectory: stage.trajectory,
                 shape: stage.shape,
                 combo: stage.combo,
                 duration: stage.duration,
                 targetX: x + offT.x,
                 targetY: y > 50 ? y : 220,
                 targetZ: z + offT.z,
                 startX: x + (Math.random() - 0.5) * 40 + offS.x,
                 startZ: z + (Math.random() - 0.5) * 40 + offS.z,
                 skipLog: idx > 0
               });
            }
        );

        manualStepIndexRef.current = (manualStepIndexRef.current + 1) % manualSeq.length;
      } else {
        // å›é€€é€»è¾‘ï¼šæ‰‹åŠ¨é…ç½®
        // ä½¿ç”¨æ–°å‚æ•° lockedFormation, lockedCount, lockedDuration
        const formation = mc.lockedFormation || LaunchFormation.SINGLE;
        const count = mc.lockedCount || 1;
        
        launchGroup(
            formation,
            count,
            mc.lockedInterval || 100,
            mc.lockedDuration || 0,
            (idx, offS, offT) => {
                launchSingle(settings, c, {
                  trajectory: mc.lockedTrajectory,
                  shape: mc.lockedShape,
                  combo: mc.lockedCombo,
                  duration: mc.lockedDuration,
                  targetX: x + offT.x,
                  targetY: y > 50 ? y + (Math.random()-0.5)*20 : 200 + (Math.random()-0.5)*20,
                  targetZ: z + offT.z,
                  startX: x + (Math.random() - 0.5) * 50 + offS.x,
                  startZ: z + (Math.random() - 0.5) * 50 + offS.z,
                  skipLog: idx > 0
                });
            }
        );
        
        if (count <= 1) onLaunch?.(`ğŸ¯ æ‰‹åŠ¨å•å‘`);
        else onLaunch?.(`ğŸ¯ æ‰‹åŠ¨é½å°„: ${count}å‘ (${formation})`);
      }
    },
    getTimeController: () => timeControllerRef.current
  }));

  // === é¼ æ ‡äº¤äº’äº‹ä»¶ ===
  const handleInteraction = (e: React.MouseEvent) => {
    if (e.button === 0 && cameraRef.current && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
      );

      const ray = new THREE.Raycaster();
      ray.setFromCamera(mouse, cameraRef.current);
      const targetPoint = new THREE.Vector3();
      ray.ray.intersectPlane(planeRef.current, targetPoint);

      if (targetPoint) {
        // é€šè¿‡ Ref è·å–è‡ªèº«æš´éœ²çš„æ¥å£è¿›è¡Œå‘å°„
        // @ts-ignore
        ref.current?.launchAt(targetPoint.x, targetPoint.y, targetPoint.z);
      }
    }
  };

  return (
      <div
          ref={containerRef}
          className="w-full h-full block cursor-crosshair outline-none"
          onMouseDown={(e) => {
            mouseDownPos.current = { x: e.clientX, y: e.clientY };
            mouseDownTime.current = performance.now();
          }}
          onMouseUp={(e) => {
            const dist = Math.sqrt(Math.pow(e.clientX - mouseDownPos.current.x, 2) + Math.pow(e.clientY - mouseDownPos.current.y, 2));
            if (dist < 5 && (performance.now() - mouseDownTime.current) < 300) {
              handleInteraction(e);
            }
          }}
      />
  );
};

// å°è£…å¯¼å‡º
export const FireworkScene3D = memo(forwardRef(FireworkScene3DInner));

// =============================================================================
// FILE: src\components\StreamFireworkDemo.tsx
// =============================================================================

/**
 * StreamFireworkDemo.tsx
 * 
 * æ¼”ç¤ºç»„ä»¶ï¼šå±•ç¤º"ä¸€åˆ‡çš†æµ"æ¶æ„çš„çƒŸèŠ±æ•ˆæœ
 * 
 * ç‰¹æ€§ï¼š
 * - ç‚¹å‡»ç©ºä¸­å‘å°„çƒŸèŠ±
 * - æ”¯æŒå¤šç§é¢„è®¾æ¸…å•
 * - å®æ—¶ç»Ÿè®¡æ˜¾ç¤º
 */

import React, { useEffect, useRef, useCallback, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Director, StreamRenderer, globalDirector } from '../core/stream';
import { Vector3 } from '../core/Vector3';

interface StreamFireworkDemoProps {
  width?: number;
  height?: number;
}

interface Stats {
  activeFireworks: number;
  totalParticles: number;
  trailParticles: number;
  fps: number;
}

const StreamFireworkDemo: React.FC<StreamFireworkDemoProps> = ({
  width = window.innerWidth,
  height = window.innerHeight
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const streamRendererRef = useRef<StreamRenderer | null>(null);
  const directorRef = useRef<Director | null>(null);
  const animationIdRef = useRef<number>(0);
  const lastTimeRef = useRef<number>(0);
  const frameCountRef = useRef<number>(0);
  const fpsTimeRef = useRef<number>(0);

  const [stats, setStats] = useState<Stats>({
    activeFireworks: 0,
    totalParticles: 0,
    trailParticles: 0,
    fps: 60
  });
  const [selectedManifest, setSelectedManifest] = useState<string>('phoenix_rebirth');
  const [isPaused, setIsPaused] = useState(false);

  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;

    // === åˆ›å»ºåœºæ™¯ ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    sceneRef.current = scene;

    // === åˆ›å»ºç›¸æœº ===
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);
    camera.position.set(0, 50, 150);
    camera.lookAt(0, 50, 0);
    cameraRef.current = camera;

    // === åˆ›å»ºæ¸²æŸ“å™¨ ===
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // === è½¨é“æ§åˆ¶å™¨ ===
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 50, 0);
    controls.minDistance = 50;
    controls.maxDistance = 500;
    controlsRef.current = controls;

    // === ç¯å¢ƒå…‰ ===
    const ambientLight = new THREE.AmbientLight(0x111122, 0.3);
    scene.add(ambientLight);

    // === æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯ ===
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount; i++) {
      const radius = 500 + Math.random() * 500;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      
      starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      starPositions[i * 3 + 1] = radius * Math.cos(phi);
      starPositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
      
      const brightness = 0.3 + Math.random() * 0.7;
      starColors[i * 3] = brightness;
      starColors[i * 3 + 1] = brightness;
      starColors[i * 3 + 2] = brightness + Math.random() * 0.1;
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    
    const starMaterial = new THREE.PointsMaterial({
      size: 1.5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8
    });
    
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // === æ·»åŠ åœ°å¹³çº¿ç½‘æ ¼ ===
    const gridHelper = new THREE.GridHelper(400, 40, 0x222244, 0x111133);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    // === åˆ›å»ºå¯¼æ¼”å’Œæ¸²æŸ“å™¨ ===
    const director = new Director({ debug: true, maxActiveFireworks: 30 });
    directorRef.current = director;

    const streamRenderer = new StreamRenderer(scene, director, {
      maxParticles: 50000,
      maxTrailParticles: 10000,
      particleTexture: 'soft',
      glowMultiplier: 2
    });
    streamRendererRef.current = streamRenderer;

    // === åŠ¨ç”»å¾ªç¯ ===
    let lastTime = performance.now();
    
    const animate = (currentTime: number) => {
      animationIdRef.current = requestAnimationFrame(animate);
      
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      
      // FPS è®¡ç®—
      frameCountRef.current++;
      if (currentTime - fpsTimeRef.current >= 1000) {
        setStats(prev => ({ ...prev, fps: frameCountRef.current }));
        frameCountRef.current = 0;
        fpsTimeRef.current = currentTime;
      }
      
      // æ›´æ–°æ§åˆ¶å™¨
      controls.update();
      
      // æ›´æ–°å¯¼æ¼”å’Œæ¸²æŸ“å™¨
      director.update(deltaTime);
      streamRenderer.update(deltaTime);
      
      // æ›´æ–°ç»Ÿè®¡
      const directorStats = director.getStats();
      setStats(prev => ({
        ...prev,
        activeFireworks: directorStats.activeFireworks,
        totalParticles: directorStats.totalParticles,
        trailParticles: directorStats.trailParticles
      }));
      
      // æ¸²æŸ“åœºæ™¯
      renderer.render(scene, camera);
    };
    
    animationIdRef.current = requestAnimationFrame(animate);

    // === æ¸…ç† ===
    return () => {
      cancelAnimationFrame(animationIdRef.current);
      streamRenderer.dispose();
      renderer.dispose();
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
    };
  }, [width, height]);

  // å¤„ç†ç‚¹å‡»å‘å°„
  const handleClick = useCallback((event: React.MouseEvent<HTMLDivElement>) => {
    if (!cameraRef.current || !directorRef.current || !sceneRef.current) return;
    
    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const mouse = new THREE.Vector2(
      ((event.clientX - rect.left) / rect.width) * 2 - 1,
      -((event.clientY - rect.top) / rect.height) * 2 + 1
    );

    // åˆ›å»ºå°„çº¿
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cameraRef.current);

    // è®¡ç®—åœ¨ Y=80 å¹³é¢ä¸Šçš„äº¤ç‚¹ä½œä¸ºç›®æ ‡ä½ç½®
    const targetY = 60 + Math.random() * 40;
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -targetY);
    const target = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, target);

    if (!target) return;

    // å‘å°„ä½ç½®åœ¨åœ°é¢
    const launchX = target.x + (Math.random() - 0.5) * 20;
    const launchZ = target.z + (Math.random() - 0.5) * 20;

    const launchPos = new Vector3(launchX, 0, launchZ);
    const targetPos = new Vector3(target.x, target.y, target.z);

    // å‘å°„çƒŸèŠ±
    directorRef.current.launch(
      selectedManifest,
      launchPos,
      targetPos,
      Math.random() * 360
    );
  }, [selectedManifest]);

  // è‡ªåŠ¨å‘å°„
  const handleAutoLaunch = useCallback(() => {
    if (!directorRef.current) return;

    const x = (Math.random() - 0.5) * 100;
    const z = (Math.random() - 0.5) * 100;
    const y = 60 + Math.random() * 40;

    const launchPos = new Vector3(x, 0, z);
    const targetPos = new Vector3(x + (Math.random() - 0.5) * 20, y, z + (Math.random() - 0.5) * 20);

    const manifests = directorRef.current.getAllManifests();
    const randomManifest = manifests[Math.floor(Math.random() * manifests.length)];
    
    directorRef.current.launch(
      randomManifest.id,
      launchPos,
      targetPos,
      Math.random() * 360
    );
  }, []);

  // æš‚åœ/ç»§ç»­
  const togglePause = useCallback(() => {
    if (!directorRef.current) return;
    
    if (isPaused) {
      directorRef.current.resume();
    } else {
      directorRef.current.pause();
    }
    setIsPaused(!isPaused);
  }, [isPaused]);

  // é‡ç½®
  const handleReset = useCallback(() => {
    directorRef.current?.reset();
  }, []);

  return (
    <div style={{ position: 'relative', width, height, overflow: 'hidden' }}>
      <div
        ref={containerRef}
        onClick={handleClick}
        style={{ width: '100%', height: '100%', cursor: 'crosshair' }}
      />
      
      {/* æ§åˆ¶é¢æ¿ */}
      <div style={{
        position: 'absolute',
        top: 20,
        left: 20,
        background: 'rgba(0, 0, 0, 0.7)',
        borderRadius: 12,
        padding: 20,
        color: '#fff',
        fontFamily: 'system-ui, sans-serif',
        backdropFilter: 'blur(10px)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        minWidth: 200
      }}>
        <h3 style={{ margin: '0 0 15px 0', fontSize: 18, fontWeight: 600 }}>
          ğŸ† Stream Architecture Demo
        </h3>
        
        {/* ç»Ÿè®¡ä¿¡æ¯ */}
        <div style={{ marginBottom: 15, fontSize: 13, opacity: 0.9 }}>
          <div>FPS: <span style={{ color: stats.fps > 30 ? '#4ade80' : '#f87171' }}>{stats.fps}</span></div>
          <div>Active Fireworks: {stats.activeFireworks}</div>
          <div>Particles: {stats.totalParticles.toLocaleString()}</div>
          <div>Trail Particles: {stats.trailParticles.toLocaleString()}</div>
        </div>
        
        {/* æ¸…å•é€‰æ‹© */}
        <div style={{ marginBottom: 15 }}>
          <label style={{ display: 'block', marginBottom: 5, fontSize: 12, opacity: 0.7 }}>
            Select Manifest:
          </label>
          <select
            value={selectedManifest}
            onChange={(e) => setSelectedManifest(e.target.value)}
            style={{
              width: '100%',
              padding: '8px 12px',
              borderRadius: 6,
              border: '1px solid rgba(255,255,255,0.2)',
              background: 'rgba(255,255,255,0.1)',
              color: '#fff',
              fontSize: 14,
              cursor: 'pointer'
            }}
          >
            <option value="phoenix_rebirth">ğŸ”¥ å‡¤å‡°æ¶…æ§ƒ</option>
            <option value="simple_sphere">ğŸ’¥ ç»å…¸çƒå½¢</option>
            <option value="heart_morph">â¤ï¸ å¿ƒå¿ƒç›¸å°</option>
            <option value="galaxy_spiral">ğŸŒŒ é“¶æ²³è¯ç”Ÿ</option>
          </select>
        </div>
        
        {/* æ§åˆ¶æŒ‰é’® */}
        <div style={{ display: 'flex', gap: 10 }}>
          <button
            onClick={handleAutoLaunch}
            style={{
              flex: 1,
              padding: '10px',
              borderRadius: 6,
              border: 'none',
              background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)',
              color: '#fff',
              fontSize: 14,
              fontWeight: 500,
              cursor: 'pointer',
              transition: 'transform 0.1s'
            }}
            onMouseDown={(e) => (e.currentTarget.style.transform = 'scale(0.95)')}
            onMouseUp={(e) => (e.currentTarget.style.transform = 'scale(1)')}
          >
            ğŸš€ Launch
          </button>
          
          <button
            onClick={togglePause}
            style={{
              padding: '10px 15px',
              borderRadius: 6,
              border: 'none',
              background: isPaused ? '#22c55e' : '#eab308',
              color: '#000',
              fontSize: 14,
              fontWeight: 500,
              cursor: 'pointer'
            }}
          >
            {isPaused ? 'â–¶ï¸' : 'â¸ï¸'}
          </button>
          
          <button
            onClick={handleReset}
            style={{
              padding: '10px 15px',
              borderRadius: 6,
              border: 'none',
              background: '#ef4444',
              color: '#fff',
              fontSize: 14,
              fontWeight: 500,
              cursor: 'pointer'
            }}
          >
            ğŸ”„
          </button>
        </div>
        
        {/* æç¤º */}
        <p style={{ marginTop: 15, fontSize: 11, opacity: 0.6, marginBottom: 0 }}>
          Click anywhere in the sky to launch!
        </p>
      </div>
      
      {/* æ¶æ„è¯´æ˜ */}
      <div style={{
        position: 'absolute',
        bottom: 20,
        left: 20,
        right: 20,
        background: 'rgba(0, 0, 0, 0.5)',
        borderRadius: 8,
        padding: 15,
        color: '#fff',
        fontFamily: 'system-ui, sans-serif',
        fontSize: 12,
        backdropFilter: 'blur(5px)'
      }}>
        <strong>Architecture: </strong>
        Director â†’ CarrierSystem (launch) â†’ ParticleStream (explosion/morph) â†’ StreamRenderer (GPU)
        <span style={{ opacity: 0.6, marginLeft: 10 }}>
          | ForceFieldSystem (physics) | MorphingEngine (shape transitions)
        </span>
      </div>
    </div>
  );
};

export default StreamFireworkDemo;


// =============================================================================
// FILE: src\components\StreamFireworkScene.tsx
// =============================================================================

/**
 * StreamFireworkScene.tsx - åŸºäºæ–°æ¶æ„çš„çƒŸèŠ±åœºæ™¯
 * 
 * ä½¿ç”¨ "ä¸€åˆ‡çš†æµ" (Everything is a Stream) æ¶æ„
 * å®Œæ•´æ•´åˆ Director, ParticleStream, MorphingEngine ç­‰æ ¸å¿ƒç»„ä»¶
 * åŒ…å«æš‚åœå’Œæ—‹è½¬æ§åˆ¶
 */

import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

import { Director } from '../core/stream/Director';
import { StreamRenderer } from '../core/stream/StreamRenderer';
import { Vector3 } from '../core/Vector3';
import {
  FireworkLifecycleConfig,
} from '../types/lifecycle';
import {
  FireworkManifest,
  PRESET_CURVES,
  PRESET_GRADIENTS,
  PRESET_FORCE_FIELDS,
} from '../core/stream/types';
import { Shape3DType } from '../core/shapes/Shape3DFactory';

// ============================================================================
// å½¢çŠ¶æ˜ å°„ - æ‰©å±•ç‰ˆæœ¬
// ============================================================================

const SHAPE_MAP: Record<string, Shape3DType> = {
  // å‡ ä½•ç±»
  sphere: Shape3DType.SPHERE,
  cube: Shape3DType.CUBE,
  pyramid: Shape3DType.PYRAMID,
  octahedron: Shape3DType.OCTAHEDRON,
  torus: Shape3DType.TORUS,
  cylinder: Shape3DType.CYLINDER,
  cone: Shape3DType.CONE,
  star_3d: Shape3DType.STAR_3D,
  diamond: Shape3DType.DIAMOND,
  mobius: Shape3DType.MOBIUS,
  
  // è‡ªç„¶ç±»
  butterfly_3d: Shape3DType.BUTTERFLY_3D,
  flower_3d: Shape3DType.FLOWER_3D,
  tree: Shape3DType.TREE,
  bird: Shape3DType.BIRD,
  jellyfish: Shape3DType.JELLYFISH,
  shell: Shape3DType.SHELL,
  snowflake_3d: Shape3DType.SNOWFLAKE_3D,
  leaf: Shape3DType.LEAF,
  mushroom: Shape3DType.MUSHROOM,
  fish_3d: Shape3DType.FISH_3D,
  
  // æ–‡åŒ–ç±»
  heart_3d: Shape3DType.HEART_3D,
  phoenix: Shape3DType.PHOENIX,
  dragon_3d: Shape3DType.DRAGON_3D,
  crown_3d: Shape3DType.CROWN_3D,
  lotus: Shape3DType.LOTUS,
  lantern: Shape3DType.LANTERN,
  yin_yang: Shape3DType.YIN_YANG,
  ribbon: Shape3DType.RIBBON,
  firework_classic: Shape3DType.FIREWORK_CLASSIC,
  firework_willow: Shape3DType.FIREWORK_WILLOW,
  
  // å®‡å®™ç±»
  galaxy_spiral: Shape3DType.GALAXY_SPIRAL,
  planet_rings: Shape3DType.PLANET_RINGS,
  nebula: Shape3DType.NEBULA,
  black_hole: Shape3DType.BLACK_HOLE,
  supernova: Shape3DType.SUPERNOVA,
  comet: Shape3DType.COMET,
  constellation: Shape3DType.CONSTELLATION,
  pulsar: Shape3DType.PULSAR,
  wormhole: Shape3DType.WORMHOLE,
  asteroid_belt: Shape3DType.ASTEROID_BELT,
  
  // ç‰¹æ•ˆç±»
  explosion_burst: Shape3DType.EXPLOSION_BURST,
  ring_wave: Shape3DType.RING_WAVE,
  double_ring: Shape3DType.DOUBLE_RING,
  cascade: Shape3DType.CASCADE,
  fountain: Shape3DType.FOUNTAIN,
  vortex: Shape3DType.VORTEX,
  shockwave: Shape3DType.SHOCKWAVE,
  sparkle_cloud: Shape3DType.SPARKLE_CLOUD,
  chaos_scatter: Shape3DType.CHAOS_SCATTER,
  nested_spheres: Shape3DType.NESTED_SPHERES,
};

// ============================================================================
// æ¥å£å®šä¹‰
// ============================================================================

export interface StreamFireworkSceneProps {
  lifecycleConfig: FireworkLifecycleConfig;
  onStatsUpdate?: (stats: { particles: number; fireworks: number; fps: number }) => void;
  isPaused?: boolean;
  isAutoRotate?: boolean;
}

export interface StreamFireworkSceneHandle {
  launch: () => void;
  launchAt: (position: { x: number; y: number; z: number }) => void;
  launchCarnival: () => void;
  togglePause: () => void;
  toggleAutoRotate: () => void;
}

// ============================================================================
// è¾…åŠ©å‡½æ•°ï¼šå°†ç”Ÿå‘½å‘¨æœŸé…ç½®è½¬æ¢ä¸º FireworkManifest
// ============================================================================

function lifecycleToManifest(config: FireworkLifecycleConfig): FireworkManifest {
  const shape = SHAPE_MAP[config.explosion.shape] || Shape3DType.SPHERE;
  
  // åˆ¤æ–­æ˜¯å¦éœ€è¦ä¿æŒå½¢çŠ¶ç»“æ„
  // è¿™äº›å½¢çŠ¶åº”è¯¥ç›´æ¥å‘ˆç°ï¼Œè€Œä¸æ˜¯çˆ†ç‚¸æˆçƒï¼
  const STRUCTURE_SHAPES = [
    'heart_3d', 'phoenix', 'dragon_3d', 'butterfly_3d', 'flower_3d', 
    'star_3d', 'crown_3d', 'lotus', 'lantern', 'yin_yang', 'ribbon',
    'tree', 'bird', 'jellyfish', 'shell', 'snowflake_3d', 'leaf', 'fish_3d',
    'torus', 'cube', 'pyramid', 'octahedron', 'mobius', 'diamond',
    'galaxy_spiral', 'constellation', 'double_ring',
    'firework_classic', 'firework_willow'
  ];
  const isStructureShape = STRUCTURE_SHAPES.includes(config.explosion.shape);
  
  // çˆ†ç‚¸å½¢çŠ¶ï¼ˆåº”è¯¥ç”¨radialæ¨¡å¼ï¼‰
  const EXPLODE_SHAPES = [
    'sphere', 'explosion_burst', 'ring_wave', 'shockwave', 
    'supernova', 'chaos_scatter', 'sparkle_cloud', 'fountain', 'cascade'
  ];
  const isExplodeShape = EXPLODE_SHAPES.includes(config.explosion.shape);
  
  // é€Ÿåº¦æ›²çº¿æ˜ å°„
  const curveMap: Record<string, typeof PRESET_CURVES.LINEAR> = {
    linear: PRESET_CURVES.LINEAR,
    easeIn: PRESET_CURVES.EASE_IN,
    easeOut: PRESET_CURVES.EASE_OUT,
    easeInOut: PRESET_CURVES.EASE_IN_OUT,
    bounce: PRESET_CURVES.BOUNCE,
  };

  // è®¡ç®—æ€»æ—¶é•¿
  const totalDuration = 
    config.ascent.duration + 
    config.hover.duration + 
    config.fade.duration + 2;

  // æ‚¬åœé˜¶æ®µçš„é‡åŠ›è®¾ç½®
  const hoverGravityStrength = (1 - config.hover.gravityResistance) * 10;
  const isStableHover = ['lock', 'freeze', 'anchor', 'suspend', 'levitate'].includes(config.hover.hoverMode);
  const effectiveGravity = isStableHover ? 0 : hoverGravityStrength;

  // æ„å»ºé˜¶æ®µæ•°ç»„
  const stages = [];

  // é˜¶æ®µ1: çˆ†ç‚¸ + æ‚¬åœ
  // å…³é”®ä¿®å¤ï¼šæ ¹æ®å½¢çŠ¶ç±»å‹é€‰æ‹©ä¸åŒçš„é€Ÿåº¦æ¨¡å¼ï¼
  const velocityMode = isStructureShape ? 'structure_preserve' : 'radial';
  const velocitySpeed: [number, number] = isStructureShape 
    ? [0, 0]  // ç»“æ„ä¿æŒæ¨¡å¼ä¸‹ç²’å­ç›´æ¥å‡ºç°åœ¨ä½ç½®ä¸Š
    : [config.explosion.power * 60, config.explosion.power * 100];

  stages.push({
    id: 'explosion-hover',
    name: 'çˆ†ç‚¸æ‚¬åœ',
    timeOffset: 0,
    duration: config.hover.duration,
    topology: {
      type: 'mathematical_shape' as const,
      source: shape,
      resolution: config.explosion.particleCount,
      scale: config.explosion.scale * 50,
    },
    dynamics: {
      transitionMode: 'explode' as const,
      initialVelocity: {
        mode: velocityMode as any,  // å…³é”®ä¿®å¤ï¼
        speed: velocitySpeed,
      },
      forceFields: [
        // ç»“æ„å½¢çŠ¶ç”¨æ›´ä½é˜»åŠ›ä¿æŒå½¢çŠ¶ï¼Œçˆ†ç‚¸å½¢çŠ¶ç”¨é«˜é˜»åŠ›å‡é€Ÿ
        { ...PRESET_FORCE_FIELDS.HEAVY_DRAG, strength: isStructureShape ? 0.3 : 0.15 + (1 - config.hover.stability) * 0.1 },
        // æ‚¬åœæ—¶å…³é—­é‡åŠ›æˆ–ä½¿ç”¨æä½é‡åŠ›
        { ...PRESET_FORCE_FIELDS.LIGHT_GRAVITY, strength: effectiveGravity, enabled: effectiveGravity > 0.1 },
        // å¾®æ‰°åŠ¨
        { ...PRESET_FORCE_FIELDS.TURBULENCE, strength: config.hover.turbulence * 5, enabled: config.hover.turbulence > 0.05 },
      ],
      velocityProfile: curveMap[config.ascent.velocityCurve] || PRESET_CURVES.EASE_OUT,
    },
    rendering: {
      // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ç”¨æˆ·é…ç½®çš„é¢œè‰²ï¼
      colorMap: {
        stops: config.explosion.colorMode === 'rainbow' 
          ? [
              { position: 0, hue: 0, saturation: 1, lightness: 0.6 },
              { position: 0.2, hue: 60, saturation: 1, lightness: 0.6 },
              { position: 0.4, hue: 120, saturation: 1, lightness: 0.5 },
              { position: 0.6, hue: 200, saturation: 1, lightness: 0.5 },
              { position: 0.8, hue: 280, saturation: 1, lightness: 0.5 },
              { position: 1, hue: 340, saturation: 1, lightness: 0.6 },
            ]
          : [
              { position: 0, hue: config.explosion.primaryHue, saturation: 1, lightness: 0.8 },
              { position: 0.3, hue: config.explosion.primaryHue + 15, saturation: 1, lightness: 0.65 },
              { position: 0.7, hue: config.explosion.primaryHue + 30, saturation: 0.9, lightness: 0.5 },
              { position: 1, hue: config.explosion.primaryHue + 45, saturation: 0.8, lightness: 0.35 },
            ]
      },
      sizeCurve: PRESET_CURVES.EASE_OUT,
      baseSize: config.rendering?.particleSize ?? 1.5,
      blending: 'additive' as const,
      useBlackbodyRadiation: config.fade.useBlackbody,
      initialTemperature: 7000,
      coolingRate: config.fade.coolingRate * 300,
      glowIntensity: config.rendering?.glowIntensity ?? 2,
    },
  });

  // é˜¶æ®µ2: åŠ¨ä½œ (å¦‚æœæ˜¯å˜å½¢ç±»å‹)
  if (config.action.actionType === 'morph' && config.action.morphTarget) {
    const morphShape = SHAPE_MAP[config.action.morphTarget] || Shape3DType.PHOENIX;
    stages.push({
      id: 'morph',
      name: 'å˜å½¢',
      timeOffset: config.hover.duration * 0.4,
      duration: config.hover.duration * 0.8,
      reuseParticles: true,
      topology: {
        type: 'mathematical_shape' as const,
        source: morphShape,
        resolution: config.explosion.particleCount,
        scale: config.explosion.scale * 45,
      },
      dynamics: {
        transitionMode: 'morph' as const,
        initialVelocity: {
          mode: 'target_seeking' as const,
          speed: 30 * config.action.intensity,
        },
        forceFields: [
          { ...PRESET_FORCE_FIELDS.AIR_DRAG, strength: 0.02 },
        ],
        velocityProfile: PRESET_CURVES.EASE_IN_OUT,
        morphAttractionStrength: 80 * config.action.intensity,
        morphDamping: 0.92,
      },
      rendering: {
        colorMap: PRESET_GRADIENTS.PHOENIX,
        sizeCurve: PRESET_CURVES.LINEAR,
        baseSize: 1.2,
        blending: 'additive' as const,
        glowIntensity: 1.5,
      },
    });
  }

  // é˜¶æ®µ3: æ¶ˆæ•£
  stages.push({
    id: 'fade',
    name: 'æ¶ˆæ•£',
    timeOffset: config.hover.duration,
    duration: config.fade.duration,
    reuseParticles: true,
    topology: {
      type: 'mathematical_shape' as const,
      source: Shape3DType.CHAOS_SCATTER,
      resolution: config.explosion.particleCount,
      scale: config.explosion.scale * 80,
    },
    dynamics: {
      transitionMode: 'scatter' as const,
      initialVelocity: {
        mode: 'random' as const,
        speed: [3, 10] as [number, number],
      },
      forceFields: [
        // æ¶ˆæ•£é˜¶æ®µä½¿ç”¨é…ç½®çš„é‡åŠ›
        { ...PRESET_FORCE_FIELDS.EARTH_GRAVITY, strength: config.fade.useGravity ? config.fade.gravityStrength * 15 : 0.5 },
        { ...PRESET_FORCE_FIELDS.GENTLE_WIND, strength: config.fade.windStrength * 8 },
        { ...PRESET_FORCE_FIELDS.TURBULENCE, strength: 3 },
      ],
      velocityProfile: PRESET_CURVES.LINEAR,
    },
    rendering: {
      colorMap: {
        stops: [
          { position: 0, hue: 30, saturation: 0.8, lightness: 0.5, alpha: 1 },
          { position: 0.5, hue: 20, saturation: 0.5, lightness: 0.3, alpha: 0.6 },
          { position: 1, hue: 0, saturation: 0.2, lightness: 0.1, alpha: 0 },
        ],
      },
      sizeCurve: PRESET_CURVES.EASE_OUT,
      baseSize: 0.8,
      blending: 'normal' as const,
      useBlackbodyRadiation: config.fade.useBlackbody,
      initialTemperature: 2500,
      coolingRate: config.fade.coolingRate * 500,
    },
  });

  return {
    id: config.id,
    name: config.name,
    duration: totalDuration,
    carrier: {
      type: 'comet',
      path: {
        type: config.ascent.pathCategory === 'spiral' ? 'spiral' : 'bezier_3d',
        points: [],
        speedCurve: curveMap[config.ascent.velocityCurve] || PRESET_CURVES.EASE_OUT,
        spiralRadius: config.ascent.spiralRadius || 5,
        spiralFrequency: 2,
      },
      duration: config.ascent.duration,
      trail: {
        emissionRate: config.ascent.trailDensity * 150,
        lifeTime: 0.5,
        colorGradient: PRESET_GRADIENTS.GOLD,
        texture: 'spark',
        size: config.ascent.trailSize * 0.4,
      },
    },
    payload: {
      stages,
    },
  };
}

// ============================================================================
// ä¸»ç»„ä»¶
// ============================================================================

const StreamFireworkSceneInner: React.ForwardRefRenderFunction<
  StreamFireworkSceneHandle,
  StreamFireworkSceneProps
> = ({ lifecycleConfig, onStatsUpdate, isPaused = false, isAutoRotate = true }, ref) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const composerRef = useRef<EffectComposer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const bloomPassRef = useRef<any>(null); // UnrealBloomPass ref

  const directorRef = useRef<Director | null>(null);
  const streamRendererRef = useRef<StreamRenderer | null>(null);
  const requestRef = useRef<number>(0);

  const lifecycleConfigRef = useRef(lifecycleConfig);
  const isPausedRef = useRef(isPaused);
  const fpsRef = useRef({ frames: 0, lastTime: 0, value: 60 });

  // åŒæ­¥é…ç½®å¼•ç”¨åŠæ¸²æŸ“å‚æ•°
  useEffect(() => {
    lifecycleConfigRef.current = lifecycleConfig;
    
    // æ›´æ–° Director çš„ manifest
    if (directorRef.current) {
      const manifest = lifecycleToManifest(lifecycleConfig);
      directorRef.current.registerManifest(manifest);
    }
    
    // å®æ—¶æ›´æ–°æ¸²æŸ“å‚æ•°
    if (lifecycleConfig.rendering) {
      // æ›´æ–°æ›å…‰åº¦
      if (rendererRef.current) {
        rendererRef.current.toneMappingExposure = lifecycleConfig.rendering.exposure ?? 0.4;
      }
      // æ›´æ–°è¾‰å…‰å¼ºåº¦
      if (bloomPassRef.current) {
        bloomPassRef.current.strength = lifecycleConfig.rendering.bloomStrength ?? 0.3;
      }
    }
  }, [lifecycleConfig]);

  // åŒæ­¥æš‚åœçŠ¶æ€
  useEffect(() => {
    isPausedRef.current = isPaused;
    if (directorRef.current) {
      if (isPaused) {
        directorRef.current.pause();
      } else {
        directorRef.current.resume();
      }
    }
  }, [isPaused]);

  // åŒæ­¥æ—‹è½¬çŠ¶æ€
  useEffect(() => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = isAutoRotate;
    }
  }, [isAutoRotate]);

  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;

    containerRef.current.innerHTML = '';

    // åˆ›å»ºåœºæ™¯
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050810);
    scene.fog = new THREE.FogExp2(0x050810, 0.0003);
    sceneRef.current = scene;

    // åˆ›å»ºç›¸æœº
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      1,
      10000
    );
    camera.position.set(0, 100, 500);
    cameraRef.current = camera;

    // åˆ›å»ºæ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({
      antialias: false,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.35; // æå¤§é™ä½æ›å…‰ (åŸ0.8)
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // åˆ›å»ºåæœŸå¤„ç†
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.2,    // æä½å¼ºåº¦ (åŸ0.6)
      1.0,    // æ›´å¤§åŠå¾„ï¼Œæ›´æŸ”å’Œ
      0.4     // æ›´é«˜é˜ˆå€¼ï¼Œåªè®©æœ€äº®ç‚¹å‘å…‰
    );
    composer.addPass(renderPass);
    composer.addPass(bloomPass);
    composerRef.current = composer;
    bloomPassRef.current = bloomPass; // ä¿å­˜å¼•ç”¨ä¾›åç»­åŠ¨æ€æ›´æ–°

    // åˆ›å»ºè½¨é“æ§åˆ¶å™¨
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 100;
    controls.maxDistance = 2000;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.autoRotate = isAutoRotate;
    controls.autoRotateSpeed = 0.3;
    controlsRef.current = controls;

    // åˆ›å»º Director
    const director = new Director({
      maxActiveFireworks: 50,
      maxParticlesPerFirework: 5000,
      debug: false,
    });
    directorRef.current = director;

    // æ³¨å†Œåˆå§‹ manifest
    const manifest = lifecycleToManifest(lifecycleConfigRef.current);
    director.registerManifest(manifest);

    // åˆ›å»º StreamRenderer
    const streamRenderer = new StreamRenderer(scene, director, {
      maxParticles: 100000,
      maxTrailParticles: 20000,
    });
    streamRendererRef.current = streamRenderer;

    // åˆ›å»ºèƒŒæ™¯
    createStarfield(scene);
    createGround(scene);

    // çª—å£ç¼©æ”¾å¤„ç†
    const onResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    };
    window.addEventListener('resize', onResize);

    // åŠ¨ç”»å¾ªç¯
    let lastTime = performance.now();

    const animate = () => {
      requestRef.current = requestAnimationFrame(animate);

      const now = performance.now();
      const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;

      // æ›´æ–°æ§åˆ¶å™¨ï¼ˆå³ä½¿æš‚åœä¹Ÿæ›´æ–°ä»¥ä¿æŒäº¤äº’ï¼‰
      controls.update();

      // åªåœ¨éæš‚åœçŠ¶æ€æ›´æ–°ç‰©ç†
      if (!isPausedRef.current) {
        director.update(deltaTime);
        streamRenderer.update(deltaTime);
      }

      // å§‹ç»ˆæ¸²æŸ“
      composer.render();

      // FPS ç»Ÿè®¡
      fpsRef.current.frames++;
      if (now - fpsRef.current.lastTime > 1000) {
        fpsRef.current.value = fpsRef.current.frames;
        fpsRef.current.frames = 0;
        fpsRef.current.lastTime = now;
      }

      // å›è°ƒç»Ÿè®¡
      if (onStatsUpdate) {
        const stats = director.getStats();
        onStatsUpdate({
          particles: stats.totalParticles + stats.trailParticles,
          fireworks: stats.activeFireworks,
          fps: fpsRef.current.value,
        });
      }
    };

    animate();

    return () => {
      window.removeEventListener('resize', onResize);
      cancelAnimationFrame(requestRef.current);
      renderer.dispose();
      controls.dispose();
      director.reset();
    };
  }, []);

  // æš´éœ²æ¥å£
  useImperativeHandle(ref, () => ({
    launch: () => {
      if (directorRef.current && !isPausedRef.current) {
        const config = lifecycleConfigRef.current;
        const launchPos = new Vector3(
          (Math.random() - 0.5) * 400,
          0,
          (Math.random() - 0.5) * 400
        );
        const targetPos = new Vector3(
          (Math.random() - 0.5) * 200,
          150 + Math.random() * 100,
          (Math.random() - 0.5) * 200
        );
        directorRef.current.launch(
          config.id,
          launchPos,
          targetPos,
          config.hueOverride ?? Math.random() * 360
        );
      }
    },

    launchAt: (position) => {
      if (directorRef.current && !isPausedRef.current) {
        const config = lifecycleConfigRef.current;
        const launchPos = new Vector3(position.x, 0, position.z);
        const targetPos = new Vector3(position.x, position.y || 180, position.z);
        directorRef.current.launch(
          config.id,
          launchPos,
          targetPos,
          config.hueOverride ?? Math.random() * 360
        );
      }
    },

    launchCarnival: () => {
      if (directorRef.current && !isPausedRef.current) {
        const config = lifecycleConfigRef.current;
        const count = 5 + Math.floor(Math.random() * 8);
        
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            if (!isPausedRef.current) {
              const launchPos = new Vector3(
                (Math.random() - 0.5) * 600,
                0,
                (Math.random() - 0.5) * 600
              );
              const targetPos = new Vector3(
                (Math.random() - 0.5) * 300,
                120 + Math.random() * 150,
                (Math.random() - 0.5) * 300
              );
              directorRef.current?.launch(
                config.id,
                launchPos,
                targetPos,
                Math.random() * 360
              );
            }
          }, i * 150);
        }
      }
    },

    togglePause: () => {
      isPausedRef.current = !isPausedRef.current;
      if (directorRef.current) {
        if (isPausedRef.current) {
          directorRef.current.pause();
        } else {
          directorRef.current.resume();
        }
      }
    },

    toggleAutoRotate: () => {
      if (controlsRef.current) {
        controlsRef.current.autoRotate = !controlsRef.current.autoRotate;
      }
    },
  }));

  // é¼ æ ‡ç‚¹å‡»å‘å°„
  const handleClick = (e: React.MouseEvent) => {
    if (e.button !== 0) return;
    if (isPausedRef.current) return;
    if (!cameraRef.current || !containerRef.current) return;

    const rect = containerRef.current.getBoundingClientRect();
    const mouse = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cameraRef.current);

    // æŠ•å½±åˆ° XOZ å¹³é¢ (Y=0 çš„åœ°é¢)
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    const intersect = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, intersect);

    if (intersect && directorRef.current) {
      const config = lifecycleConfigRef.current;
      const launchPos = new Vector3(intersect.x, 0, intersect.z);
      // ç›®æ ‡é«˜åº¦éšæœºåŒ–
      const targetY = 120 + Math.random() * 80;
      const targetPos = new Vector3(intersect.x * 0.8, targetY, intersect.z * 0.8);
      directorRef.current.launch(
        config.id,
        launchPos,
        targetPos,
        config.hueOverride ?? Math.random() * 360
      );
    }
  };

  return (
    <div
      ref={containerRef}
      className="absolute inset-0 w-full h-full"
      onClick={handleClick}
    />
  );
};

// ============================================================================
// è¾…åŠ©å‡½æ•°
// ============================================================================

function createStarfield(scene: THREE.Scene) {
  const starGeo = new THREE.BufferGeometry();
  const count = 5000;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const r = 3000 + Math.random() * 3000;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    
    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    positions[i * 3 + 2] = r * Math.cos(phi);
    
    const brightness = 0.3 + Math.random() * 0.4; // é™ä½æ˜Ÿæ˜Ÿäº®åº¦
    colors[i * 3] = brightness * 0.8;
    colors[i * 3 + 1] = brightness * 0.85;
    colors[i * 3 + 2] = brightness;
  }

  starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const starMat = new THREE.PointsMaterial({
    size: 1.5,
    vertexColors: true,
    transparent: true,
    opacity: 0.5,
    sizeAttenuation: false,
  });

  scene.add(new THREE.Points(starGeo, starMat));
}

function createGround(scene: THREE.Scene) {
  // åˆ›å»ºå…«å¦å›¾æ¡ˆçº¹ç†
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext('2d')!;
  
  const cx = 512;
  const cy = 512;
  
  // èƒŒæ™¯
  ctx.fillStyle = '#0a0e14';
  ctx.fillRect(0, 0, 1024, 1024);
  
  // å¤–åœˆè£…é¥°ç¯
  ctx.strokeStyle = '#1e3a5f';
  ctx.lineWidth = 2;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.arc(cx, cy, 200 + i * 50, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // å…«å¦ï¼šé˜´é˜³é±¼
  const radius = 180;
  
  // ç™½è‰²åŠåœ†
  ctx.fillStyle = '#f0f4f8';
  ctx.beginPath();
  ctx.arc(cx, cy, radius, -Math.PI / 2, Math.PI / 2);
  ctx.fill();
  
  // é»‘è‰²åŠåœ†
  ctx.fillStyle = '#1a2634';
  ctx.beginPath();
  ctx.arc(cx, cy, radius, Math.PI / 2, -Math.PI / 2);
  ctx.fill();
  
  // ä¸Šæ–¹å°ç™½åœ† (åœ¨é»‘è‰²åŠåœ†å†…)
  ctx.fillStyle = '#f0f4f8';
  ctx.beginPath();
  ctx.arc(cx, cy - radius / 2, radius / 2, 0, Math.PI * 2);
  ctx.fill();
  
  // ä¸‹æ–¹å°é»‘åœ† (åœ¨ç™½è‰²åŠåœ†å†…)
  ctx.fillStyle = '#1a2634';
  ctx.beginPath();
  ctx.arc(cx, cy + radius / 2, radius / 2, 0, Math.PI * 2);
  ctx.fill();
  
  // é˜´é˜³é±¼çœ¼
  ctx.fillStyle = '#1a2634';
  ctx.beginPath();
  ctx.arc(cx, cy - radius / 2, radius / 8, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#f0f4f8';
  ctx.beginPath();
  ctx.arc(cx, cy + radius / 2, radius / 8, 0, Math.PI * 2);
  ctx.fill();
  
  // å…«å¦ï¼šå…«ä¸ªå¦è±¡ (ç®€åŒ–ç‰ˆ)
  const trigramRadius = 280;
  const trigrams = [
    [1, 1, 1], // ä¹¾
    [0, 0, 0], // å¤
    [1, 0, 0], // éœ‡
    [0, 0, 1], // è‰®
    [0, 1, 0], // å
    [1, 0, 1], // ç¦»
    [0, 1, 1], // å…‘
    [1, 1, 0], // å·½
  ];
  
  trigrams.forEach((trigram, i) => {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    const tx = cx + Math.cos(angle) * trigramRadius;
    const ty = cy + Math.sin(angle) * trigramRadius;
    
    // ç»˜åˆ¶ä¸‰æ¡æ¨ªçº¿
    trigram.forEach((solid, j) => {
      const lineY = ty - 15 + j * 15;
      const lineWidth = 30;
      
      ctx.strokeStyle = solid ? '#3b82f6' : '#3b82f6';
      ctx.lineWidth = 4;
      
      if (solid) {
        // å®çº¿ (é˜³çˆ»)
        ctx.beginPath();
        ctx.moveTo(tx - lineWidth / 2, lineY);
        ctx.lineTo(tx + lineWidth / 2, lineY);
        ctx.stroke();
      } else {
        // è™šçº¿ (é˜´çˆ») - ä¸­é—´æ–­å¼€
        ctx.beginPath();
        ctx.moveTo(tx - lineWidth / 2, lineY);
        ctx.lineTo(tx - 5, lineY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(tx + 5, lineY);
        ctx.lineTo(tx + lineWidth / 2, lineY);
        ctx.stroke();
      }
    });
  });
  
  // å¤–åœˆå‘å…‰è¾¹æ¡†
  ctx.strokeStyle = '#38bdf8';
  ctx.lineWidth = 3;
  ctx.shadowColor = '#38bdf8';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.arc(cx, cy, 450, 0, Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;
  
  // åˆ›å»ºçº¹ç†
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  
  // åˆ›å»ºåœ°é¢å¹³é¢
  const groundGeo = new THREE.PlaneGeometry(800, 800);
  const groundMat = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    opacity: 0.6,
    side: THREE.DoubleSide,
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -5;
  scene.add(ground);
  
  // å¤–å›´æ·¡åŒ–ç½‘æ ¼
  const gridHelper = new THREE.GridHelper(2000, 30, 0x1e3a5f, 0x0a1628);
  gridHelper.position.y = -6;
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = 0.08;
  scene.add(gridHelper);
}

// ============================================================================
// å¯¼å‡º
// ============================================================================

export const StreamFireworkScene = forwardRef(StreamFireworkSceneInner);
export default StreamFireworkScene;


// =============================================================================
// FILE: src\components\ui\CustomSelect.tsx
// =============================================================================

// FILE: src/components/ui/CustomSelect.tsx
// è‡ªå®šä¹‰ä¸‹æ‹‰é€‰æ‹©æ¡† - å½»åº•æ›¿ä»£åŸç”Ÿä¸‘é™‹çš„ select
// è§†è§‰é£æ ¼ï¼šæ¶²æ€ç»ç’ƒï¼Œæ‚¬æµ®èœå•ï¼Œç²¾è‡´åŠ¨ç”»

import React, { useState, useRef, useEffect } from "react";

interface Option {
  label: string;
  value: string;
}

interface CustomSelectProps {
  value: string;
  options: Option[];
  onChange: (value: string) => void;
  icon?: string;
  className?: string;
}

export const CustomSelect: React.FC<CustomSelectProps> = ({
  value,
  options,
  onChange,
  icon,
  className = "",
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // æŸ¥æ‰¾å½“å‰é€‰ä¸­çš„ label
  const selectedLabel = options.find((o) => o.value === value)?.label || value;

  // ç‚¹å‡»å¤–éƒ¨å…³é—­
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  return (
    <div className={`relative group ${className}`} ref={containerRef}>
      {/* è§¦å‘æŒ‰é’® */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          w-full flex items-center justify-between
          px-3 py-2.5 rounded-xl
          bg-white/40 backdrop-blur-md
          border border-white/60
          text-[10px] font-black text-slate-700
          shadow-sm transition-all duration-300
          hover:bg-white/60 hover:border-emerald-300 hover:shadow-emerald-100/30
          focus:outline-none focus:ring-2 focus:ring-emerald-500/20
          ${
            isOpen
              ? "border-emerald-400 bg-white/80 ring-2 ring-emerald-500/20"
              : ""
          }
        `}
      >
        <div className="flex items-center gap-2 truncate">
          {icon && <span className="text-lg opacity-80">{icon}</span>}
          <span className="truncate">{selectedLabel}</span>
        </div>
        <div
          className={`
           text-[8px] text-slate-400 transition-transform duration-300 ml-2
           ${
             isOpen
               ? "rotate-180 text-emerald-500"
               : "group-hover:text-emerald-400"
           }
        `}
        >
          â–¼
        </div>
      </button>

      {/* ä¸‹æ‹‰èœå• (Portal like behavior but simplified for this context, assume z-index is high enough) */}
      <div
        className={`
          absolute left-0 right-0 top-full mt-2
          bg-white/90 backdrop-blur-xl
          border border-white/60 rounded-xl
          shadow-xl shadow-slate-200/50
          max-h-60 overflow-y-auto custom-scrollbar
          z-50 transform origin-top transition-all duration-200 cubic-bezier(0.2, 0.8, 0.2, 1)
          ${
            isOpen
              ? "opacity-100 scale-100 translate-y-0 visible"
              : "opacity-0 scale-95 -translate-y-2 invisible pointer-events-none"
          }
        `}
      >
        <div className="p-1.5 space-y-0.5">
          {options.map((option) => {
            const isSelected = option.value === value;
            return (
              <button
                key={option.value}
                onClick={() => {
                  onChange(option.value);
                  setIsOpen(false);
                }}
                className={`
                  w-full text-left px-3 py-2 rounded-lg text-[10px] font-bold transition-all
                  flex items-center justify-between
                  ${
                    isSelected
                      ? "bg-emerald-50 text-emerald-700"
                      : "text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                  }
                `}
              >
                <span>{option.label}</span>
                {isSelected && <span className="text-emerald-500">âœ“</span>}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\components\ui\CustomSelectWithPreview.tsx
// =============================================================================

// FILE: src/components/ui/CustomSelectWithPreview.tsx
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { ShapePreview3D } from './ShapePreviewCard';
import { TrajectoryPreviewCanvas } from './TrajectoryPreview3D';
import { Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';

interface Option {
  label: string;
  value: string;
  icon?: string;
}

type PreviewType = 'shape' | 'trajectory' | 'none';

interface CustomSelectWithPreviewProps {
  value: string;
  options: Option[];
  onChange: (value: string) => void;
  previewType: PreviewType;
  icon?: string;
  className?: string;
  placeholder?: string;
}

/**
 * ä¸‹æ‹‰é€‰æ‹©ç»„ä»¶ (å¸¦ Portal æ‚¬æµ®é¢„è§ˆ)
 * - é¢„è§ˆæ¡†ä½¿ç”¨ Portal æ¸²æŸ“åˆ° bodyï¼Œå½»åº•è§£å†³ overflow è£å‰ªé—®é¢˜
 * - æ™ºèƒ½è®¡ç®—ä½ç½®ï¼Œå§‹ç»ˆè·Ÿéšé¼ æ ‡/é€‰é¡¹ä½ç½®
 */
export const CustomSelectWithPreview: React.FC<CustomSelectWithPreviewProps> = ({
  value,
  options,
  onChange,
  previewType,
  icon,
  className = '',
  placeholder = 'é€‰æ‹©...'
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [hoveredValue, setHoveredValue] = useState<string | null>(null);
  const [previewPos, setPreviewPos] = useState<{ top: number; left: number; side: 'left' | 'right' } | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // é€‰ä¸­é¡¹å›æ˜¾
  const selectedOption = options.find(o => o.value === value);
  const selectedLabel = selectedOption?.label || placeholder;

  // ç‚¹å‡»å¤–éƒ¨å…³é—­
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      // å¦‚æœç‚¹å‡»çš„æ˜¯ Portal å†…éƒ¨å…ƒç´ ï¼Œä¹Ÿä¸å¤„ç† (è™½ç„¶ Portal åœ¨ bodyï¼Œä½†äº‹ä»¶å†’æ³¡...)
      // è¿™é‡Œç®€åŒ–ï¼šåªè¦ä¸æ˜¯ç‚¹å‡» containerRef å†…éƒ¨ï¼Œå°±å…³é—­
      // æ³¨æ„ï¼šPortal é‡Œçš„äº‹ä»¶ä¼šå†’æ³¡åˆ° React æ ‘çš„çˆ¶çº§ï¼Œæ‰€ä»¥è¦åˆ¤æ–­
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setHoveredValue(null);
        setPreviewPos(null);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelect = useCallback((optionValue: string) => {
    onChange(optionValue);
    setIsOpen(false);
    setHoveredValue(null);
    setPreviewPos(null);
  }, [onChange]);

  // å¤„ç†é€‰é¡¹æ‚¬åœï¼šè®¡ç®—å¹¶è®¾ç½®é¢„è§ˆæ¡†ä½ç½®
  const handleOptionHover = (e: React.MouseEvent<HTMLButtonElement>, val: string) => {
    setHoveredValue(val);
    
    // è·å–å½“å‰é€‰é¡¹çš„ä½ç½®
    const rect = e.currentTarget.getBoundingClientRect();
    const PREVIEW_SIZE = 200; // é¢„è§ˆæ¡†å¤§æ¦‚å°ºå¯¸
    const GAP = 10;
    
    let left = rect.right + GAP;
    let side: 'left' | 'right' = 'right';

    // æ™ºèƒ½åˆ¤æ–­å·¦å³ï¼šå¦‚æœå³è¾¹æ”¾ä¸ä¸‹ï¼Œå°±æ”¾å·¦è¾¹
    if (left + PREVIEW_SIZE > window.innerWidth) {
        left = rect.left - PREVIEW_SIZE - GAP;
        side = 'left';
    }

    // å‚ç›´å¯¹é½ï¼šå°½é‡å±…ä¸­äºé€‰é¡¹ï¼Œä½†ä¸èƒ½è¶…å‡ºå±å¹•
    let top = rect.top + rect.height/2 - PREVIEW_SIZE/2;
    if (top < 10) top = 10;
    if (top + PREVIEW_SIZE > window.innerHeight) top = window.innerHeight - PREVIEW_SIZE - 10;

    setPreviewPos({ top, left, side });
  };

  const clearHover = () => {
    setHoveredValue(null);
    setPreviewPos(null);
  };

  const previewValue = hoveredValue || value;
  const showPreview = isOpen && previewType !== 'none' && previewValue && previewValue !== 'RANDOM' && previewPos;

  return (
    <div className={`relative ${className}`} ref={containerRef}>
      {/* è§¦å‘å™¨ */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          w-full flex items-center justify-between
          px-3 py-2.5 rounded-xl
          bg-white/40 backdrop-blur-md
          border border-white/60
          text-[10px] font-black text-slate-700
          shadow-sm transition-all duration-300
          hover:bg-white/60 hover:border-emerald-300 hover:shadow-emerald-100/30
          focus:outline-none focus:ring-2 focus:ring-emerald-500/20
          ${isOpen 
            ? 'border-emerald-400 bg-white/80 ring-2 ring-emerald-500/20' 
            : ''
          }
        `}
      >
        <div className="flex items-center gap-2 truncate">
          {icon && <span className="text-lg opacity-80">{icon}</span>}
          <span className="truncate">{selectedLabel}</span>
        </div>
        <div className={`
          text-[8px] text-slate-400 transition-transform duration-300 ml-2
          ${isOpen ? 'rotate-180 text-emerald-500' : 'group-hover:text-emerald-400'}
        `}>â–¼</div>
      </button>

      {/* ä¸‹æ‹‰èœå• (ç»å¯¹å®šä½) */}
      <div className={`
        absolute left-0 top-full mt-2 w-full z-50
        transform origin-top transition-all duration-200
        ${isOpen 
          ? 'opacity-100 scale-100 translate-y-0 visible' 
          : 'opacity-0 scale-95 -translate-y-2 invisible pointer-events-none'
        }
      `}>
        <div className="
          bg-white/95 backdrop-blur-xl
          border border-white/70 rounded-2xl
          shadow-2xl shadow-slate-300/30
          max-h-72 overflow-y-auto custom-scrollbar
        ">
          <div className="p-1.5 space-y-0.5">
            {options.map(option => {
              const isSelected = option.value === value;
              const isHovered = option.value === hoveredValue;
              
              return (
                <button
                  key={option.value}
                  onClick={() => handleSelect(option.value)}
                  onMouseEnter={(e) => handleOptionHover(e, option.value)}
                  // onMouseLeave={clearHover} // ä¸éœ€è¦ï¼Œä¿æŒæœ€åä¸€æ¬¡æ‚¬åœ
                  className={`
                    w-full text-left px-3 py-2.5 rounded-xl text-[10px] font-bold transition-all
                    flex items-center justify-between gap-2
                    ${isHovered 
                      ? 'bg-gradient-to-r from-emerald-50 to-cyan-50 text-emerald-700 scale-[1.02] shadow-sm' 
                      : isSelected 
                        ? 'bg-emerald-50 text-emerald-700' 
                        : 'text-slate-600 hover:bg-slate-50 hover:text-slate-900'
                    }
                  `}
                >
                  <span className="flex items-center gap-2">
                    {option.icon && <span className="text-base">{option.icon}</span>}
                    <span>{option.label}</span>
                  </span>
                  {isSelected && <span className="text-emerald-500 text-sm">âœ“</span>}
                </button>
              );
            })}
          </div>
        </div>
      </div>

      {/* æ‚¬æµ®é¢„è§ˆæ¡† (Portal) */}
      {showPreview && createPortal(
        <div 
          className="fixed z-[9999] pointer-events-none w-48 h-48 animate-slideInFade"
          style={{
             top: previewPos.top,
             left: previewPos.left,
          }}
        >
          <div className="
            w-full h-full bg-slate-900/95 backdrop-blur-2xl
            border border-emerald-500/30 rounded-2xl
            shadow-[0_10px_40px_-10px_rgba(0,0,0,0.5)]
            overflow-hidden relative
          ">
            {previewType === 'shape' && (
              <ShapePreview3D 
                shapeType={previewValue as Shape3DType} 
                className="w-full h-full"
              />
            )}
            {previewType === 'trajectory' && (
              <TrajectoryPreviewCanvas
                trajectoryType={previewValue as TrajectoryType}
                className="w-full h-full"
              />
            )}
            
            {/* æ ‡ç­¾ */}
            <div className="absolute bottom-3 left-0 right-0 flex justify-center">
               <div className="bg-black/50 backdrop-blur px-3 py-1 rounded-full border border-white/10">
                 <span className="text-[9px] font-black text-emerald-400 uppercase tracking-widest">
                   {previewType === 'shape' && SHAPE_3D_INFO[previewValue as Shape3DType]?.name}
                   {previewType === 'trajectory' && TRAJECTORY_INFO[previewValue as TrajectoryType]?.name}
                 </span>
               </div>
            </div>
          </div>
        </div>,
        document.body
      )}
      
      <style>{`
        @keyframes slideInFade {
          from { opacity: 0; transform: scale(0.95); }
          to { opacity: 1; transform: scale(1); }
        }
        .animate-slideInFade { animation: slideInFade 0.15s ease-out forwards; }
      `}</style>
    </div>
  );
};


// =============================================================================
// FILE: src\components\ui\DirectionIndicator.tsx
// =============================================================================

// FILE: src/components/ui/DirectionIndicator.tsx
// ä¸»ç”»é¢æ–¹å‘æŒ‡ç¤ºå™¨ - æ˜¾ç¤º XYZ åæ ‡è½´æ–¹å‘
// åŒ…å«ä¸€ä¸ªå‘ä¸Šçš„ç®­å¤´æŒ‡ç¤º +Z æ–¹å‘

import React from 'react';

interface DirectionIndicatorProps {
  className?: string;
}

/**
 * 3D æ–¹å‘æŒ‡ç¤ºå™¨
 * æ˜¾ç¤ºåœ¨ä¸»ç”»é¢åº•éƒ¨ï¼ŒæŒ‡ç¤ºå½“å‰çš„åæ ‡ç³»æ–¹å‘
 */
export const DirectionIndicator: React.FC<DirectionIndicatorProps> = ({
  className = ''
}) => {
  return (
    <div className={`fixed left-8 bottom-72 z-20 pointer-events-none ${className}`}>
      {/* 3D æ‚¬æµ®æŒ‡ç¤ºå™¨å®¹å™¨ */}
      <div className="relative group">
        
        {/* ========= æ ¸å¿ƒï¼šå‘ä¸Šçš„æŒ‡å¼•ç®­å¤´ ========= */}
        <div className="absolute -top-24 left-1/2 -translate-x-1/2 flex flex-col items-center animate-bounce-slow">
            <div className="relative">
                {/* ç®­å¤´ä¸»ä½“ - éœ“è™¹å‘å…‰ */}
                <svg width="40" height="60" viewBox="0 0 40 60" className="drop-shadow-[0_0_15px_rgba(16,185,129,0.8)]">
                    <defs>
                        <linearGradient id="neonGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                           <stop offset="0%" stopColor="#059669" stopOpacity="0" />
                           <stop offset="50%" stopColor="#10b981" stopOpacity="0.8" />
                           <stop offset="100%" stopColor="#34d399" stopOpacity="1" />
                        </linearGradient>
                    </defs>
                    <path d="M20 0 L35 25 L24 25 L24 60 L16 60 L16 25 L5 25 Z" fill="url(#neonGradient)" />
                </svg>
                {/* é¡¶ç«¯å…‰ç‚¹ */}
                <div className="absolute top-0 left-1/2 -translate-x-1/2 w-8 h-8 bg-emerald-400 rounded-full blur-xl opacity-60"></div>
            </div>
            <div className="mt-1 text-[10px] font-black tracking-[0.2em] text-emerald-400 uppercase drop-shadow-md">UP</div>
        </div>

        {/* ========= åæ ‡è½´ Gizmo ========= */}
        <div className="w-24 h-24 relative perspective-500">
            {/* ç»ç’ƒæ€èƒŒæ™¯åœ†ç›˜ */}
            <div className="absolute inset-0 bg-gradient-to-tr from-slate-900/80 to-slate-800/80 rounded-full border border-white/10 backdrop-blur-md shadow-2xl"></div>
            <div className="absolute inset-2 border border-dashed border-white/5 rounded-full animate-spin-slow-reverse"></div>
            
            {/* åæ ‡è½´ SVG */}
            <svg viewBox="0 0 100 100" className="w-full h-full p-4 overflow-visible">
                {/* Y Axis (Up) */}
                <line x1="50" y1="50" x2="50" y2="10" stroke="#10b981" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(16,185,129,0.8)]" />
                <text x="54" y="15" fill="#10b981" fontSize="10" fontWeight="900">Y+</text>

                {/* X Axis (Right) */}
                <line x1="50" y1="50" x2="90" y2="50" stroke="#f43f5e" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(244,63,94,0.8)]" />
                <text x="92" y="54" fill="#f43f5e" fontSize="10" fontWeight="900">X+</text>

                {/* Z Axis (Forward - Projected) */}
                <line x1="50" y1="50" x2="20" y2="85" stroke="#3b82f6" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(59,130,246,0.8)]" />
                <text x="10" y="90" fill="#3b82f6" fontSize="10" fontWeight="900">Z+</text>

                {/* Center Point */}
                <circle cx="50" cy="50" r="4" fill="white" className="drop-shadow-[0_0_5px_rgba(255,255,255,1)]" />
            </svg>
        </div>
      </div>
      
      {/* åº•éƒ¨æ–‡å­—ä¿¡æ¯ */}
      <div className="mt-2 text-center">
        <div className="text-[9px] font-bold text-slate-400/80 tracking-widest uppercase">System Ready</div>
      </div>

      <style>{`
        .perspective-500 { perspective: 500px; }
        .animate-spin-slow-reverse { animation: spin 10s linear infinite reverse; }
        .animate-bounce-slow { animation: bounceSlow 3s infinite ease-in-out; }
        @keyframes bounceSlow {
            0%, 100% { transform: translate(-50%, 0); }
            50% { transform: translate(-50%, -10px); }
        }
      `}</style>
    </div>
  );
};

/**
 * ç®€åŒ–ç‰ˆï¼šä»…æ˜¾ç¤ºåæ ‡è½´æ ‡è¯† (å¤‡ç”¨)
 */
export const AxisIndicator: React.FC<{ className?: string }> = ({ className = '' }) => (
  <div className={`fixed left-6 bottom-6 z-20 pointer-events-none ${className}`}>
     {/* ç®€å•çš„æŒ‡ç¤ºå™¨å†…å®¹ï¼Œä¿æŒåŸæ ·æˆ–ç•¥å¾®ä¼˜åŒ– */}
     <div className="w-12 h-12 bg-white/10 rounded-full border border-white/20"></div>
  </div>
);


// =============================================================================
// FILE: src\components\ui\FireworkInfoPanel.tsx
// =============================================================================

// FILE: src/components/ui/FireworkInfoPanel.tsx
// ä¿¡æ¯é¢æ¿ï¼šæ˜¾ç¤ºå½“å‰çƒŸèŠ±çš„å½¢çŠ¶å’Œè½¨è¿¹ç±»å‹
// å½“ç”¨æˆ·æ”¾æ…¢é€Ÿåº¦æ—¶å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°æ¯ä¸ªçƒŸèŠ±çš„è¯¦ç»†ä¿¡æ¯

import React from 'react';
import { Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';

export interface FireworkInfo {
  id: string;
  shape: Shape3DType;
  trajectory: TrajectoryType;
  position: { x: number; y: number; z: number };
  velocity: number;
  particleCount: number;
  progress: number;  // 0-1, ç”Ÿå‘½è¿›åº¦
}

interface FireworkInfoPanelProps {
  fireworks: FireworkInfo[];
  timeScale: number;  // å½“å‰æ—¶é—´ç¼©æ”¾
  show: boolean;
}

/**
 * çƒŸèŠ±ä¿¡æ¯é¢æ¿
 * å½“æ—¶é—´æ”¾æ…¢æ—¶æ˜¾ç¤ºæ¯ä¸ªçƒŸèŠ±çš„è¯¦ç»†ä¿¡æ¯
 */
export const FireworkInfoPanel: React.FC<FireworkInfoPanelProps> = ({
  fireworks,
  timeScale,
  show
}) => {
  // åªåœ¨æ…¢é€Ÿæ—¶æ˜¾ç¤ºï¼ˆtimeScale < 0.5ï¼‰
  const shouldShow = show && timeScale < 0.5 && fireworks.length > 0;
  
  if (!shouldShow) return null;
  
  return (
    <div className="absolute left-8 top-1/2 -translate-y-1/2 z-20 pointer-events-none">
      <div className="bg-black/70 backdrop-blur-xl rounded-2xl border border-white/10 p-4 max-h-[60vh] overflow-y-auto custom-scrollbar">
        {/* æ ‡é¢˜ */}
        <div className="flex items-center gap-2 mb-3 pb-2 border-b border-white/10">
          <div className="w-2 h-2 rounded-full bg-cyan-400 animate-pulse"></div>
          <span className="text-[9px] font-black text-cyan-400 uppercase tracking-wider">
            Slow Motion Analysis
          </span>
        </div>
        
        {/* æ—¶é—´ç¼©æ”¾æŒ‡ç¤ºå™¨ */}
        <div className="mb-3 p-2 bg-white/5 rounded-lg">
          <div className="text-[8px] text-white/50 uppercase tracking-wider">Time Scale</div>
          <div className="text-lg font-black text-white">{(timeScale * 100).toFixed(0)}%</div>
        </div>
        
        {/* çƒŸèŠ±åˆ—è¡¨ */}
        <div className="space-y-2">
          {fireworks.slice(0, 5).map((fw, i) => (
            <div 
              key={fw.id}
              className="p-3 bg-white/5 rounded-xl border border-white/5 hover:border-white/20 transition-colors"
            >
              {/* å½¢çŠ¶ä¿¡æ¯ */}
              <div className="flex items-center gap-2 mb-1">
                <span className="text-lg">{SHAPE_3D_INFO[fw.shape]?.icon || 'âœ¨'}</span>
                <div>
                  <div className="text-xs font-bold text-white">
                    {SHAPE_3D_INFO[fw.shape]?.name || fw.shape}
                  </div>
                  <div className="text-[8px] text-white/40">SHAPE</div>
                </div>
              </div>
              
              {/* è½¨è¿¹ä¿¡æ¯ */}
              <div className="flex items-center gap-2 mb-2">
                <span className="text-lg">{TRAJECTORY_INFO[fw.trajectory]?.icon || 'ğŸš€'}</span>
                <div>
                  <div className="text-xs font-bold text-emerald-400">
                    {TRAJECTORY_INFO[fw.trajectory]?.name || fw.trajectory}
                  </div>
                  <div className="text-[8px] text-white/40">TRAJECTORY</div>
                </div>
              </div>
              
              {/* å®æ—¶æ•°æ® */}
              <div className="grid grid-cols-2 gap-2 text-[8px] font-mono text-white/50">
                <div>
                  <span className="text-white/30">POS: </span>
                  <span className="text-cyan-300">
                    {fw.position.x.toFixed(0)}, {fw.position.y.toFixed(0)}
                  </span>
                </div>
                <div>
                  <span className="text-white/30">VEL: </span>
                  <span className="text-orange-300">{fw.velocity.toFixed(1)} m/s</span>
                </div>
                <div className="col-span-2">
                  <span className="text-white/30">PARTICLES: </span>
                  <span className="text-purple-300">{fw.particleCount}</span>
                </div>
              </div>
              
              {/* è¿›åº¦æ¡ */}
              <div className="mt-2 h-1 bg-white/10 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-cyan-500 to-emerald-500 transition-all"
                  style={{ width: `${fw.progress * 100}%` }}
                />
              </div>
            </div>
          ))}
          
          {fireworks.length > 5 && (
            <div className="text-center text-[9px] text-white/30 py-2">
              +{fireworks.length - 5} more fireworks...
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

/**
 * ç®€åŒ–ç‰ˆï¼šå•ä¸ªçƒŸèŠ±æ ‡ç­¾ï¼ˆç”¨äºè·Ÿè¸ªæ˜¾ç¤ºï¼‰
 */
export const FireworkLabel: React.FC<{
  shape: Shape3DType;
  trajectory: TrajectoryType;
  position: { x: number; y: number };
}> = ({ shape, trajectory, position }) => {
  return (
    <div 
      className="absolute pointer-events-none z-30"
      style={{ 
        left: position.x, 
        top: position.y,
        transform: 'translate(-50%, -100%) translateY(-10px)'
      }}
    >
      <div className="bg-black/80 backdrop-blur-sm rounded-lg px-2 py-1 border border-white/20 whitespace-nowrap">
        <div className="text-[10px] font-bold text-white flex items-center gap-1">
          <span>{SHAPE_3D_INFO[shape]?.icon}</span>
          <span>{SHAPE_3D_INFO[shape]?.name}</span>
        </div>
        <div className="text-[8px] text-emerald-400 flex items-center gap-1">
          <span>{TRAJECTORY_INFO[trajectory]?.icon}</span>
          <span>{TRAJECTORY_INFO[trajectory]?.name}</span>
        </div>
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\components\ui\HUD.tsx
// =============================================================================


import React from 'react';

export const HUD: React.FC = () => {
  return (
    <>
      {/* å¤´éƒ¨ä¿¡æ¯ */}
      <div className="absolute top-10 left-10 z-10 pointer-events-none">
        <div className="flex items-center gap-4 mb-2">
          <div className="w-1.5 h-12 bg-cyan-500 rounded-full shadow-[0_0_20px_rgba(6,182,212,1)] animate-pulse"></div>
          <div>
            <h1 className="text-5xl font-black tracking-tighter italic leading-none">
              ç’€ç’¨<span className="text-cyan-400">æ˜Ÿè¾°</span> V4
            </h1>
            <p className="text-[10px] text-cyan-500/50 tracking-[0.5em] font-bold uppercase mt-1">
              Deep Space Particle System â€¢ Pro Edition
            </p>
          </div>
        </div>
      </div>

      {/* åº•éƒ¨æµ®æ ‡ */}
      <footer className="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-12 pointer-events-none opacity-20">
        <div className="h-[1px] w-40 bg-gradient-to-r from-transparent via-white/40 to-transparent"></div>
        <div className="text-[10px] text-white uppercase tracking-[1em] font-light flex gap-8">
          <span>è¡Œæ˜Ÿ</span><span>è’²å…¬è‹±</span><span>è¤ç«è™«</span><span>åœŸæ˜Ÿç¯</span><span>æ˜ŸèŠ’</span><span>æ³¢æµª</span>
        </div>
        <div className="h-[1px] w-40 bg-gradient-to-l from-transparent via-white/40 to-transparent"></div>
      </footer>

      {/* äº’åŠ¨æç¤º */}
      <div className="absolute bottom-10 left-10 text-[9px] text-white/30 tracking-[0.2em] font-medium pointer-events-none space-y-1">
        <p>â€¢ ç‚¹å‡»/è§¦æ‘¸å‘å°„</p>
        <p>â€¢ é•¿æŒ‰è“„åŠ›å¤§æ‹›</p>
        <p>â€¢ ç§»åŠ¨é¼ æ ‡äº§ç”Ÿæ˜Ÿå°˜</p>
      </div>

      <div className="absolute inset-0 bg-gradient-to-t from-cyan-950/20 via-transparent to-transparent pointer-events-none"></div>
    </>
  );
};


// =============================================================================
// FILE: src\components\ui\HUD3D.tsx
// =============================================================================

// FILE: src/components/ui/HUD3D.tsx

import React from 'react';

export const HUD3D: React.FC = () => {
    return (
        <>
            {/* å¤´éƒ¨ä¿¡æ¯ - æµ…è‰²æç®€é£æ ¼ */}
            <div className="absolute top-8 left-8 z-10 pointer-events-none select-none">
                <div className="flex items-center gap-4">
                    <div className="w-1.5 h-12 bg-gradient-to-b from-gray-800 to-gray-400 rounded-full"></div>
                    <div>
                        <h1 className="text-4xl font-black tracking-tight text-gray-800">
                            Celestial <span className="text-gray-400 font-light">Fireworks</span>
                        </h1>
                        <p className="text-[10px] text-gray-500 tracking-[0.4em] font-medium uppercase mt-1">
                            Interactive 3D Simulation
                        </p>
                    </div>
                </div>
            </div>

            {/* å³ä¸‹äº’åŠ¨æç¤º - å¡ç‰‡å¼è®¾è®¡ */}
            <div className="absolute bottom-8 right-8 pointer-events-none">
                <div className="bg-white/80 backdrop-blur-md p-5 rounded-2xl shadow-lg border border-white/50 text-gray-600">
                    <p className="text-gray-900 font-bold text-xs mb-3 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-green-400"></span>
                        CONTROL GUIDE
                    </p>
                    <div className="space-y-1.5 text-[10px] font-medium tracking-wide">
                        <div className="flex justify-between w-40">
                            <span>Rotate View</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">LMB / Drag</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Launch</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Click Ground</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Zoom</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Scroll</span>
                        </div>
                        <div className="flex justify-between w-40 mt-2 pt-2 border-t border-gray-200">
                            <span>Pause / Play</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">P</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* åº•éƒ¨è£…é¥°çº¿ */}
            <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-gray-300 to-transparent opacity-50 pointer-events-none"></div>
        </>
    );
};

// END OF FILE: src/components/ui/HUD3D.tsx

// =============================================================================
// FILE: src\components\ui\LifecycleConfigPanel.tsx
// =============================================================================

/**
 * LifecycleConfigPanel - äº”é˜¶æ®µç”Ÿå‘½å‘¨æœŸé…ç½®å™¨ V4 (Hoverä¿®å¤ç‰ˆ)
 * 
 * æ ¸å¿ƒä¿®å¤ï¼š
 * 1. çœŸæ­£å®ç° Hover 3D é¢„è§ˆ
 * 2. ç´§å‡‘å¸ƒå±€
 * 3. Light Mode é©¬å¡é¾™è‰²ç³»
 */

import React, { useState, useCallback, useRef, useEffect } from 'react';
import ReactDOM from 'react-dom';
import {
  FireworkLifecycleConfig,
  LifecyclePhase,
  LIFECYCLE_PRESETS,
  PHASE_THEMES,
  TRAIL_CATEGORIES,
  PATH_CATEGORIES,
  SHAPE_CATEGORIES,
  ACTION_CATEGORIES,
  HOVER_CATEGORIES,
  FADE_CATEGORIES,
  EFFECT_LABELS,
  TrailCategory, PathCategory, ShapeCategory, ActionCategory, HoverCategory, FadeCategory
} from '../../types/lifecycle';
import { ShapePreview } from './ShapePreview';

// ============================================================================
// æ ·å¼ä¸»é¢˜å®šä¹‰ (é©¬å¡é¾™è‰²ç³»)
// ============================================================================

const PHASE_COLORS: Record<LifecyclePhase, { 
  active: string; bg: string; text: string; hex: string 
}> = {
  ascent: { active: 'bg-sky-400', bg: 'bg-sky-50', text: 'text-sky-600', hex: '#38bdf8' },
  explosion: { active: 'bg-rose-400', bg: 'bg-rose-50', text: 'text-rose-600', hex: '#fb7185' },
  action: { active: 'bg-violet-400', bg: 'bg-violet-50', text: 'text-violet-600', hex: '#a78bfa' },
  hover: { active: 'bg-emerald-400', bg: 'bg-emerald-50', text: 'text-emerald-600', hex: '#34d399' },
  fade: { active: 'bg-amber-400', bg: 'bg-amber-50', text: 'text-amber-600', hex: '#fbbf24' },
};

// ============================================================================
// Hover é¢„è§ˆ Portal ç»„ä»¶ (ä½¿ç”¨ createPortal ç¡®ä¿æ¸²æŸ“åœ¨æœ€é¡¶å±‚)
// ============================================================================

interface HoverPreviewPortalProps {
  shapeType: string;
  label: string;
  color: string;
  position: { x: number; y: number };
}

const HoverPreviewPortal: React.FC<HoverPreviewPortalProps> = ({ 
  shapeType, label, color, position 
}) => {
  // è°ƒæ•´ä½ç½®ç¡®ä¿ä¸è¶…å‡ºå±å¹•
  const adjustedX = Math.min(position.x + 20, window.innerWidth - 180);
  const adjustedY = Math.max(position.y - 70, 10);

  return ReactDOM.createPortal(
    <div
      className="fixed pointer-events-none z-[9999]"
      style={{ 
        left: adjustedX, 
        top: adjustedY,
      }}
    >
      <div className="flex items-center gap-3 bg-white rounded-2xl shadow-2xl p-3 border border-slate-100">
        {/* 3D é¢„è§ˆç”»å¸ƒ */}
        <div className="w-20 h-20 bg-gradient-to-br from-slate-50 to-slate-100 rounded-xl overflow-hidden flex items-center justify-center border border-slate-200">
          <ShapePreview shapeType={shapeType} color={color} size={80} />
        </div>
        {/* ä¿¡æ¯ */}
        <div className="flex flex-col pr-2">
          <span className="text-sm font-bold text-slate-800">{label}</span>
          <span className="text-[10px] text-slate-400 mt-0.5">3D å®æ—¶é¢„è§ˆ</span>
          <span className="text-[9px] text-slate-300 mt-1">ç‚¹å‡»é€‰æ‹©</span>
        </div>
      </div>
    </div>,
    document.body
  );
};

// ============================================================================
// ç®€æ´æ»‘å—
// ============================================================================

interface SliderProps {
  label: string;
  value: number;
  min: number;
  max: number;
  step?: number;
  colorTheme: LifecyclePhase;
  onChange: (v: number) => void;
  unit?: string;
}

const Slider: React.FC<SliderProps> = ({ 
  label, value, min, max, step = 0.1, colorTheme, onChange, unit = '' 
}) => {
  const pct = ((value - min) / (max - min)) * 100;
  const theme = PHASE_COLORS[colorTheme];

  return (
    <div className="flex flex-col gap-1 w-full">
      <div className="flex justify-between items-center">
        <span className="text-[10px] font-medium text-slate-500">{label}</span>
        <span className={`text-[10px] font-bold ${theme.text}`}>
          {value.toFixed(step < 1 ? 1 : 0)}{unit}
        </span>
      </div>
      <div className="relative h-1.5 w-full">
        <div className="absolute inset-0 rounded-full bg-slate-100" />
        <div 
          className={`absolute left-0 top-0 h-full rounded-full ${theme.active}`}
          style={{ width: `${pct}%` }}
        />
        <div
          className="absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-white rounded-full shadow border border-slate-200"
          style={{ left: `calc(${pct}% - 6px)` }}
        />
        <input
          type="range" min={min} max={max} step={step} value={value}
          onChange={e => onChange(parseFloat(e.target.value))}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
        />
      </div>
    </div>
  );
};

// ============================================================================
// å¸¦ Hover é¢„è§ˆçš„ç½‘æ ¼é€‰æ‹©å™¨
// ============================================================================

interface GridSelectorProps<T extends string> {
  categories: Record<string, { label: string; icon: string; items: readonly string[] }>;
  selectedCategory: T;
  selectedItem: string;
  colorTheme: LifecyclePhase;
  onCategoryChange: (c: T) => void;
  onItemChange: (i: string) => void;
}

function GridSelector<T extends string>({
  categories, selectedCategory, selectedItem, colorTheme, onCategoryChange, onItemChange
}: GridSelectorProps<T>) {
  const [hoverData, setHoverData] = useState<{ id: string; x: number; y: number } | null>(null);
  const theme = PHASE_COLORS[colorTheme];
  const items = categories[selectedCategory]?.items || [];

  return (
    <div className="flex flex-col gap-2 h-full">
      {/* åˆ†ç±»æ ‡ç­¾ */}
      <div className="flex gap-1 flex-wrap">
        {Object.entries(categories).map(([key, cat]) => (
          <button
            key={key}
            onClick={() => onCategoryChange(key as T)}
            className={`
              flex items-center gap-1 px-2 py-1 rounded-lg text-[10px] font-bold transition-all border
              ${selectedCategory === key 
                ? `bg-white ${theme.text} border-current shadow-sm` 
                : 'bg-transparent border-transparent text-slate-400 hover:bg-white/50'}
            `}
          >
            <span>{cat.icon}</span>
            <span>{cat.label}</span>
          </button>
        ))}
      </div>

      {/* é€‰é¡¹ç½‘æ ¼ */}
      <div className="grid grid-cols-5 gap-1.5 overflow-y-auto max-h-28 pr-1">
        {items.map((item) => (
          <button
            key={item}
            onClick={() => onItemChange(item)}
            onMouseEnter={(e) => setHoverData({ id: item, x: e.clientX, y: e.clientY })}
            onMouseMove={(e) => setHoverData({ id: item, x: e.clientX, y: e.clientY })}
            onMouseLeave={() => setHoverData(null)}
            className={`
              relative p-2 rounded-xl border text-[9px] font-medium transition-all text-center
              ${selectedItem === item
                ? `${theme.active} text-white border-transparent shadow-md`
                : 'bg-white border-slate-100 text-slate-500 hover:border-slate-200 hover:shadow-sm'}
            `}
          >
            {(EFFECT_LABELS[item] || item).slice(0, 4)}
          </button>
        ))}
      </div>

      {/* Hover é¢„è§ˆ Portal */}
      {hoverData && (
        <HoverPreviewPortal
          shapeType={hoverData.id}
          label={EFFECT_LABELS[hoverData.id] || hoverData.id}
          color={theme.hex}
          position={{ x: hoverData.x, y: hoverData.y }}
        />
      )}
    </div>
  );
}

// ============================================================================
// é˜¶æ®µå†…å®¹ç»„ä»¶
// ============================================================================

interface PhaseProps {
  config: FireworkLifecycleConfig;
  onUpdate: (u: Partial<FireworkLifecycleConfig>) => void;
}

const AscentPhase: React.FC<PhaseProps> = ({ config, onUpdate }) => (
  <div className="grid grid-cols-2 gap-4 h-full">
    <div className="space-y-2">
      <span className="text-[10px] font-bold text-slate-400 uppercase">å°¾ç„°æ•ˆæœ</span>
      <GridSelector
        categories={TRAIL_CATEGORIES}
        selectedCategory={config.ascent.trailCategory}
        selectedItem={config.ascent.trailEffect}
        colorTheme="ascent"
        onCategoryChange={c => onUpdate({ ascent: { ...config.ascent, trailCategory: c as TrailCategory } })}
        onItemChange={i => onUpdate({ ascent: { ...config.ascent, trailEffect: i as any } })}
      />
    </div>
    <div className="space-y-3 p-3 bg-sky-50/50 rounded-xl">
      <Slider label="å°¾ç„°å¯†åº¦" value={config.ascent.trailDensity} min={0} max={1} colorTheme="ascent" onChange={v => onUpdate({ ascent: { ...config.ascent, trailDensity: v } })} />
      <Slider label="é£è¡Œæ—¶é•¿" value={config.ascent.duration} min={0.5} max={4} colorTheme="ascent" onChange={v => onUpdate({ ascent: { ...config.ascent, duration: v } })} unit="s" />
    </div>
  </div>
);

const ExplosionPhase: React.FC<PhaseProps> = ({ config, onUpdate }) => (
  <div className="grid grid-cols-[1.3fr_0.7fr] gap-4 h-full">
    <div className="space-y-2">
      <span className="text-[10px] font-bold text-slate-400 uppercase">çˆ†ç‚¸å½¢çŠ¶</span>
      <GridSelector
        categories={SHAPE_CATEGORIES}
        selectedCategory={config.explosion.shapeCategory}
        selectedItem={config.explosion.shape}
        colorTheme="explosion"
        onCategoryChange={c => onUpdate({ explosion: { ...config.explosion, shapeCategory: c as ShapeCategory } })}
        onItemChange={i => onUpdate({ explosion: { ...config.explosion, shape: i as any } })}
      />
    </div>
    <div className="space-y-2 p-3 bg-rose-50/50 rounded-xl">
      <Slider label="ç²’å­æ•°é‡" value={config.explosion.particleCount} min={500} max={5000} step={100} colorTheme="explosion" onChange={v => onUpdate({ explosion: { ...config.explosion, particleCount: v } })} />
      <Slider label="å½¢çŠ¶ç¼©æ”¾" value={config.explosion.scale} min={0.3} max={2} colorTheme="explosion" onChange={v => onUpdate({ explosion: { ...config.explosion, scale: v } })} unit="x" />
      {/* è‰²ç›¸é€‰æ‹©å™¨ - å…³é”®ï¼è®©ç”¨æˆ·èƒ½é€‰æ‹©é¢œè‰² */}
      <div>
        <div className="flex justify-between text-[10px] text-slate-500 mb-1">
          <span className="font-medium">è‰²ç›¸</span>
          <span className="font-bold" style={{ color: `hsl(${config.explosion.primaryHue}, 80%, 50%)` }}>
            {config.explosion.primaryHue}Â°
          </span>
        </div>
        <input 
          type="range" min="0" max="360" step="10" 
          value={config.explosion.primaryHue}
          onChange={e => onUpdate({ explosion: { ...config.explosion, primaryHue: parseInt(e.target.value) } })}
          className="w-full h-2 rounded-full appearance-none cursor-pointer"
          style={{
            background: 'linear-gradient(to right, hsl(0,100%,50%), hsl(60,100%,50%), hsl(120,100%,50%), hsl(180,100%,50%), hsl(240,100%,50%), hsl(300,100%,50%), hsl(360,100%,50%))'
          }}
        />
      </div>
    </div>
  </div>
);

const ActionPhase: React.FC<PhaseProps> = ({ config, onUpdate }) => (
  <div className="grid grid-cols-2 gap-4 h-full">
    <div className="space-y-2">
      <span className="text-[10px] font-bold text-slate-400 uppercase">åŠ¨ä½œç±»å‹</span>
      <GridSelector
        categories={ACTION_CATEGORIES}
        selectedCategory={config.action.actionCategory}
        selectedItem={config.action.actionType}
        colorTheme="action"
        onCategoryChange={c => onUpdate({ action: { ...config.action, actionCategory: c as ActionCategory } })}
        onItemChange={i => onUpdate({ action: { ...config.action, actionType: i as any } })}
      />
    </div>
    <div className="space-y-3 p-3 bg-violet-50/50 rounded-xl">
      <Slider label="åŠ¨ä½œå¼ºåº¦" value={config.action.intensity} min={0} max={1} colorTheme="action" onChange={v => onUpdate({ action: { ...config.action, intensity: v } })} />
      <Slider label="é¢‘ç‡" value={config.action.frequency} min={0.1} max={5} colorTheme="action" onChange={v => onUpdate({ action: { ...config.action, frequency: v } })} unit="Hz" />
    </div>
  </div>
);

const HoverPhase: React.FC<PhaseProps> = ({ config, onUpdate }) => (
  <div className="grid grid-cols-2 gap-4 h-full">
    <div className="space-y-2">
      <span className="text-[10px] font-bold text-slate-400 uppercase">æ‚¬åœæ¨¡å¼</span>
      <GridSelector
        categories={HOVER_CATEGORIES}
        selectedCategory={config.hover.hoverCategory}
        selectedItem={config.hover.hoverMode}
        colorTheme="hover"
        onCategoryChange={c => onUpdate({ hover: { ...config.hover, hoverCategory: c as HoverCategory } })}
        onItemChange={i => onUpdate({ hover: { ...config.hover, hoverMode: i as any } })}
      />
    </div>
    <div className="space-y-3 p-3 bg-emerald-50/50 rounded-xl">
      <Slider label="æ‚¬åœæ—¶é•¿" value={config.hover.duration} min={0} max={10} colorTheme="hover" onChange={v => onUpdate({ hover: { ...config.hover, duration: v } })} unit="s" />
      <Slider label="æŠ—é‡åŠ›" value={config.hover.gravityResistance} min={0} max={1} colorTheme="hover" onChange={v => onUpdate({ hover: { ...config.hover, gravityResistance: v } })} />
      <Slider label="å¾®æ‰°åŠ¨" value={config.hover.turbulence} min={0} max={1} colorTheme="hover" onChange={v => onUpdate({ hover: { ...config.hover, turbulence: v } })} />
    </div>
  </div>
);

const FadePhase: React.FC<PhaseProps> = ({ config, onUpdate }) => (
  <div className="grid grid-cols-2 gap-4 h-full">
    <div className="space-y-2">
      <span className="text-[10px] font-bold text-slate-400 uppercase">æ¶ˆå¤±æ•ˆæœ</span>
      <GridSelector
        categories={FADE_CATEGORIES}
        selectedCategory={config.fade.fadeCategory}
        selectedItem={config.fade.fadeEffect}
        colorTheme="fade"
        onCategoryChange={c => onUpdate({ fade: { ...config.fade, fadeCategory: c as FadeCategory } })}
        onItemChange={i => onUpdate({ fade: { ...config.fade, fadeEffect: i as any } })}
      />
    </div>
    <div className="space-y-3 p-3 bg-amber-50/50 rounded-xl">
      <Slider label="æ¶ˆå¤±æ—¶é•¿" value={config.fade.duration} min={0.5} max={5} colorTheme="fade" onChange={v => onUpdate({ fade: { ...config.fade, duration: v } })} unit="s" />
      <Slider label="é‡åŠ›å¼ºåº¦" value={config.fade.gravityStrength} min={0} max={1} colorTheme="fade" onChange={v => onUpdate({ fade: { ...config.fade, gravityStrength: v } })} />
      <label className="flex items-center gap-2 mt-2">
        <input type="checkbox" checked={config.fade.useBlackbody} onChange={e => onUpdate({ fade: { ...config.fade, useBlackbody: e.target.checked } })} className="w-3.5 h-3.5 accent-amber-500" />
        <span className="text-[10px] font-medium text-amber-700">é»‘ä½“è¾å°„ç€è‰²</span>
      </label>
    </div>
  </div>
);

// ============================================================================
// ä¸»é¢æ¿
// ============================================================================

interface LifecycleConfigPanelProps {
  config: FireworkLifecycleConfig;
  onConfigChange: (c: FireworkLifecycleConfig) => void;
  onLaunch: () => void;
  onPauseToggle?: () => void;
  onRotateToggle?: () => void;
  isPaused?: boolean;
  isAutoRotate?: boolean;
  stats?: { particles: number; fps: number; fireworks: number };
}

export const LifecycleConfigPanel: React.FC<LifecycleConfigPanelProps> = ({
  config, onConfigChange, onLaunch, onPauseToggle, onRotateToggle, isPaused, isAutoRotate, stats
}) => {
  const [activePhase, setActivePhase] = useState<LifecyclePhase>('explosion');
  const [isCollapsed, setIsCollapsed] = useState(false);

  const update = useCallback((part: Partial<FireworkLifecycleConfig>) => {
    onConfigChange({ ...config, ...part });
  }, [config, onConfigChange]);

  const phases: Array<{ key: LifecyclePhase; icon: string; label: string }> = [
    { key: 'ascent', icon: 'ğŸš€', label: 'ä¸Šå‡' },
    { key: 'explosion', icon: 'âœ¨', label: 'çˆ†ç‚¸' },
    { key: 'action', icon: 'ğŸ­', label: 'åŠ¨ä½œ' },
    { key: 'hover', icon: 'â˜ï¸', label: 'æ‚¬åœ' },
    { key: 'fade', icon: 'ğŸŒ«ï¸', label: 'æ¶ˆå¤±' },
  ];

  const renderPhase = () => {
    const props = { config, onUpdate: update };
    switch (activePhase) {
      case 'ascent': return <AscentPhase {...props} />;
      case 'explosion': return <ExplosionPhase {...props} />;
      case 'action': return <ActionPhase {...props} />;
      case 'hover': return <HoverPhase {...props} />;
      case 'fade': return <FadePhase {...props} />;
    }
  };

  if (isCollapsed) {
    return (
      <div 
        onClick={() => setIsCollapsed(false)}
        className="fixed bottom-4 left-1/2 -translate-x-1/2 bg-white/90 backdrop-blur-xl shadow-xl rounded-full px-6 py-3 flex items-center gap-3 z-50 cursor-pointer hover:shadow-2xl transition-shadow border border-slate-100"
      >
        <span className="text-xs font-bold text-slate-700">FIREWORK DNA</span>
        <span className={`text-[10px] px-2 py-0.5 rounded-full ${PHASE_COLORS[activePhase].bg} ${PHASE_COLORS[activePhase].text} font-bold`}>
          {phases.find(p => p.key === activePhase)?.label}
        </span>
        <svg className="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
        </svg>
      </div>
    );
  }

  return (
    <div className="fixed bottom-6 left-1/2 -translate-x-1/2 w-[880px] bg-white/90 backdrop-blur-2xl shadow-2xl border border-slate-100 rounded-3xl z-50 overflow-hidden">
      {/* Header */}
      <div className="flex items-center justify-between px-5 py-2.5 border-b border-slate-100 bg-white/60">
        <div className="flex items-center gap-3">
          <h1 className="text-sm font-black text-slate-800">FIREWORK DNA</h1>
          <span className="px-1.5 py-0.5 bg-slate-100 text-[9px] font-bold text-slate-400 rounded">V4</span>
        </div>

        {stats && (
          <div className="flex items-center gap-4 text-[10px]">
            <span className="text-emerald-500 font-bold">{stats.fps} FPS</span>
            <span className="text-slate-400">
              <span className="text-rose-400">âœ¦</span> {stats.particles.toLocaleString()}
            </span>
          </div>
        )}

        <div className="flex items-center gap-1">
          {onPauseToggle && (
            <button onClick={onPauseToggle} className={`p-2 rounded-xl ${isPaused ? 'bg-rose-100 text-rose-500' : 'hover:bg-slate-100 text-slate-400'}`}>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                {isPaused ? <path d="M5 3l14 9-14 9V3z" fill="currentColor" /> : <path d="M10 9v6m4-6v6" strokeWidth={2} strokeLinecap="round" />}
              </svg>
            </button>
          )}
          {onRotateToggle && (
            <button onClick={onRotateToggle} className={`p-2 rounded-xl ${!isAutoRotate ? 'bg-amber-100 text-amber-500' : 'hover:bg-slate-100 text-slate-400'}`}>
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m0 0a8.001 8.001 0 0115.356 2M4.582 9H9m11 11v-5h-.581m0 0a8.001 8.001 0 01-15.357-2m15.357 2H15" />
              </svg>
            </button>
          )}
          <button onClick={() => setIsCollapsed(true)} className="p-2 hover:bg-slate-100 text-slate-400 rounded-xl">
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
          </button>
        </div>
      </div>

      {/* Body */}
      <div className="flex">
        {/* Left: Phase Tabs */}
        <div className="w-28 bg-slate-50/70 border-r border-slate-100 py-3 px-2 flex flex-col gap-1">
          {phases.map(p => {
            const isActive = activePhase === p.key;
            const theme = PHASE_COLORS[p.key];
            return (
              <button
                key={p.key}
                onClick={() => setActivePhase(p.key)}
                className={`
                  flex items-center gap-2 px-3 py-2 rounded-xl text-[11px] font-bold transition-all
                  ${isActive ? `${theme.active} text-white shadow-lg` : 'text-slate-500 hover:bg-white'}
                `}
              >
                <span>{p.icon}</span>
                <span>{p.label}</span>
              </button>
            );
          })}
          
          {/* æ¸²æŸ“æ§åˆ¶åˆ†éš”çº¿ */}
          <div className="border-t border-slate-200 mt-2 pt-2">
            <span className="text-[8px] font-bold text-slate-300 uppercase px-1">æ¸²æŸ“</span>
          </div>
          
          {/* è¿·ä½ äº®åº¦æ»‘å— */}
          <div className="px-1 space-y-2 mt-1">
            <div>
              <div className="flex justify-between text-[8px] text-slate-400 mb-0.5">
                <span>æ›å…‰</span>
                <span className="text-slate-600">{config.rendering?.exposure?.toFixed(1) ?? 0.4}</span>
              </div>
              <input 
                type="range" min="0.1" max="2" step="0.1" 
                value={config.rendering?.exposure ?? 0.4}
                onChange={e => onConfigChange({ 
                  ...config, 
                  rendering: { ...config.rendering, exposure: parseFloat(e.target.value) } 
                })}
                className="w-full h-1 bg-slate-200 rounded-full appearance-none cursor-pointer accent-blue-500"
              />
            </div>
            <div>
              <div className="flex justify-between text-[8px] text-slate-400 mb-0.5">
                <span>è¾‰å…‰</span>
                <span className="text-slate-600">{config.rendering?.bloomStrength?.toFixed(1) ?? 0.3}</span>
              </div>
              <input 
                type="range" min="0" max="3" step="0.1" 
                value={config.rendering?.bloomStrength ?? 0.3}
                onChange={e => onConfigChange({ 
                  ...config, 
                  rendering: { ...config.rendering, bloomStrength: parseFloat(e.target.value) } 
                })}
                className="w-full h-1 bg-slate-200 rounded-full appearance-none cursor-pointer accent-violet-500"
              />
            </div>
            <div>
              <div className="flex justify-between text-[8px] text-slate-400 mb-0.5">
                <span>ç²’å­</span>
                <span className="text-slate-600">{config.rendering?.particleSize?.toFixed(1) ?? 2}</span>
              </div>
              <input 
                type="range" min="0.5" max="8" step="0.5" 
                value={config.rendering?.particleSize ?? 2}
                onChange={e => onConfigChange({ 
                  ...config, 
                  rendering: { ...config.rendering, particleSize: parseFloat(e.target.value) } 
                })}
                className="w-full h-1 bg-slate-200 rounded-full appearance-none cursor-pointer accent-rose-500"
              />
            </div>
          </div>
        </div>

        {/* Right: Content */}
        <div className="flex-1 p-4 h-48 overflow-hidden">
          {renderPhase()}
        </div>
      </div>

      {/* Footer */}
      <div className="flex items-center justify-between px-5 py-3 border-t border-slate-100 bg-slate-50/50">
        <div className="flex items-center gap-2">
          <span className="text-[9px] font-bold text-slate-400 uppercase">Presets</span>
          {LIFECYCLE_PRESETS.map(preset => (
            <button
              key={preset.id}
              onClick={() => onConfigChange(preset)}
              className={`px-2.5 py-1 rounded-lg text-[10px] font-bold border transition-all ${
                config.id === preset.id 
                  ? 'bg-slate-800 text-white border-slate-800' 
                  : 'bg-white border-slate-200 text-slate-500 hover:border-slate-300'
              }`}
            >
              {preset.name}
            </button>
          ))}
        </div>

        <button
          onClick={onLaunch}
          className="flex items-center gap-2 px-6 py-2 bg-gradient-to-r from-slate-900 to-slate-700 text-white rounded-full shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 transition-all"
        >
          <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
          <span className="text-xs font-bold">LAUNCH</span>
        </button>
      </div>
    </div>
  );
};

export default LifecycleConfigPanel;


// =============================================================================
// FILE: src\components\ui\ModernSettingsPanel.tsx
// =============================================================================

// FILE: src/components/ui/ModernSettingsPanel.tsx
// ç°ä»£åŒ–è®¾ç½®é¢æ¿ - æµ…è‰²ä¸»é¢˜ï¼Œæ•´åˆæ–°ç³»ç»Ÿ - æ¶²æ€ç»ç’ƒé£æ ¼

import React, { useState, useMemo } from 'react';
import { ShapePreviewCard, ShapePreview3D } from './ShapePreviewCard';
import { TrajectoryPreview3D } from './TrajectoryPreview3D';
import { CustomSelect } from './CustomSelect';
import { CustomSelectWithPreview } from './CustomSelectWithPreview';
import { Shape3DType, SHAPE_3D_INFO, SHAPE_CATEGORIES } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { ComboType } from '../../core/combos/ComboManager';

// å¯¼å…¥ç°æœ‰ç±»å‹ä»¥ä¿æŒå…¼å®¹
import { 
  AppSettings, 
  FireworkConfig, 
  ManualConfig, 
  CarnivalStage,
  LaunchFormation
} from '../../types';

interface ModernSettingsPanelProps {
  show: boolean;
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  onClose: () => void;
  onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
  onUpdateConfig: (config: FireworkConfig) => void;
  onUpdateManual: (config: ManualConfig) => void;
  onRandomize: () => void;
  onReset: () => void;
  onLaunchCarnival: () => void;
}

type TabId = 'shapes' | 'trajectories' | 'manual' | 'carnival' | 'physics';

export const ModernSettingsPanel: React.FC<ModernSettingsPanelProps> = ({
  show,
  settings,
  config,
  manualConfig,
  onClose,
  onUpdate,
  onUpdateConfig,
  onUpdateManual,
  onRandomize,
  onReset,
  onLaunchCarnival
}) => {
  const [activeTab, setActiveTab] = useState<TabId>('shapes');
  
  // æ ¸å¿ƒçŠ¶æ€ï¼šå½“å‰æ­£åœ¨é¢„è§ˆçš„é¡¹ (æ¥è‡ª Grid Hover æˆ– Dropdown Hover)
  // å¦‚æœæ²¡æœ‰ Hoverï¼Œåˆ™æ˜¾ç¤ºå½“å‰é€‰ä¸­çš„ï¼ˆå¦‚ç¬¬ä¸€ä¸ªå¯ç”¨çš„å½¢çŠ¶æˆ–è½¨è¿¹ï¼‰
  const [previewShape, setPreviewShape] = useState<Shape3DType | null>(null);
  const [previewTrajectory, setPreviewTrajectory] = useState<TrajectoryType | null>(null);

  const [selectedCategory, setSelectedCategory] = useState<string>(SHAPE_CATEGORIES.BASIC_GEOMETRY);
  
  // çŠ¶æ€åŒæ­¥ä¼˜åŒ–
  const [localSeq, setLocalSeq] = useState<CarnivalStage[]>(config.carnivalSequence || []);
  const [hasChanges, setHasChanges] = useState(false);

  // å½“å¤–éƒ¨ config å˜åŒ–ä¸”éæœ¬åœ°ç¼–è¾‘å¯¼è‡´æ—¶ï¼ŒåŒæ­¥æ•°æ®
  React.useEffect(() => {
    if (!hasChanges) {
      setLocalSeq(config.carnivalSequence || []);
    }
  }, [config.carnivalSequence, hasChanges]);

  const handleUpdateLocal = (newSeq: CarnivalStage[]) => {
    setLocalSeq(newSeq);
    setHasChanges(true);
  };

  const handleApplySequence = () => {
    onUpdateConfig({ ...config, carnivalSequence: localSeq });
    setHasChanges(false);
  };
  
  // æŒ‰ç±»åˆ«åˆ†ç»„å½¢çŠ¶
  const shapesByCategory = useMemo(() => {
    const groups: Record<string, Shape3DType[]> = {};
    Object.values(Shape3DType).forEach(type => {
      const info = SHAPE_3D_INFO[type];
      if (!groups[info.category]) groups[info.category] = [];
      groups[info.category].push(type);
    });
    return groups;
  }, []);
  
  const [selectedNewShapes, setSelectedNewShapes] = useState<Shape3DType[]>(config.enabledShape3Ds || []);
  const [selectedTrajectories, setSelectedTrajectories] = useState<TrajectoryType[]>(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  
  React.useEffect(() => {
    setSelectedNewShapes(config.enabledShape3Ds || []);
    setSelectedTrajectories(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  }, [config.enabledShape3Ds, config.enabledTrajectories]);

  const toggleNewShape = (type: Shape3DType) => {
    const next = selectedNewShapes.includes(type) 
      ? selectedNewShapes.filter(t => t !== type)
      : [...selectedNewShapes, type];
    setSelectedNewShapes(next);
    onUpdateConfig({ ...config, enabledShape3Ds: next });
  };
  
  const toggleTrajectory = (type: TrajectoryType) => {
    const next = selectedTrajectories.includes(type) 
      ? selectedTrajectories.filter(t => t !== type)
      : [...selectedTrajectories, type];
    setSelectedTrajectories(next);
    onUpdateConfig({ ...config, enabledTrajectories: next });
  };
  
  const tabs = [
    { id: 'shapes' as TabId, label: 'Shape Lab', icon: 'ğŸ¨', title: 'å½¢çŠ¶å®éªŒå®¤' },
    { id: 'trajectories' as TabId, label: 'Path', icon: 'ğŸš€', title: 'è½¨è¿¹è§„åˆ’' },
    { id: 'manual' as TabId, label: 'Interaction', icon: 'ğŸ‘†', title: 'æ‰‹åŠ¨äº¤äº’é…ç½®' },
    { id: 'carnival' as TabId, label: 'Show', icon: 'ğŸ¬', title: 'å¤§ç§€ç¼–æ’' },
    { id: 'physics' as TabId, label: 'Engine', icon: 'âš™ï¸', title: 'ç‰©ç†å¼•æ“' },
  ];

  // è®¡ç®—å½“å‰åº”è¯¥åœ¨é¡¶éƒ¨å›ºå®šé¢„è§ˆæ˜¾ç¤ºçš„é¡¹
  const activeShapeToShow = previewShape || (selectedNewShapes.length > 0 ? selectedNewShapes[0] : Shape3DType.SPHERE);
  const activeTrajectoryToShow = previewTrajectory || (selectedTrajectories.length > 0 ? selectedTrajectories[0] : TrajectoryType.LINEAR);
  
  // å†³å®šæ˜¾ç¤ºå“ªç§é¢„è§ˆ (Shape è¿˜æ˜¯ Trajectory)
  // è§„åˆ™ï¼šåœ¨ Trajectories Tab æ˜¾ç¤ºè½¨è¿¹ï¼Œå…¶ä»–æƒ…å†µé»˜è®¤æ˜¾ç¤ºå½¢çŠ¶ï¼ˆæˆ–æ ¹æ®ä¸Šä¸‹æ–‡ï¼‰
  const showTrajectoryPreview = activeTab === 'trajectories';

  return (
    <div 
      className={`
        fixed top-0 right-0 h-full w-[480px] 
        bg-slate-50/90 backdrop-blur-3xl 
        shadow-[0_0_50px_rgba(0,0,0,0.2)] z-40 
        transform transition-all duration-500 cubic-bezier(0.2, 0.8, 0.2, 1)
        border-l border-white/60
        flex flex-col
        ${show ? 'translate-x-0' : 'translate-x-full'}
      `}
    >
      {/* ========== Header ========== */}
      <div className="px-6 pt-6 pb-2 border-b border-white/50 bg-gradient-to-b from-white/60 to-transparent">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h2 className="text-2xl font-black text-slate-800 tracking-tight drop-shadow-sm flex items-center gap-2">
              <span className="text-3xl">âœ¨</span>
              Aetheris
            </h2>
            <p className="text-[10px] text-slate-400 font-bold tracking-[0.2em] uppercase ml-1">
              Universal Particle System
            </p>
          </div>
          <button 
            onClick={onClose}
            className="w-10 h-10 rounded-full flex items-center justify-center text-slate-400 hover:text-white hover:bg-slate-800 transition-all shadow-sm border border-white/50"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Tabs */}
        <div className="flex gap-2 bg-slate-200/50 p-1.5 rounded-2xl border border-white/50 shadow-inner overflow-x-auto custom-scrollbar">
          {tabs.map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`
                flex-1 min-w-[70px] py-3 px-2 rounded-xl text-[10px] font-black uppercase tracking-wider
                transition-all relative overflow-hidden group
                ${activeTab === tab.id 
                  ? 'bg-white text-emerald-600 shadow-[0_4px_12px_rgba(16,185,129,0.15)] ring-1 ring-emerald-100' 
                  : 'text-slate-400 hover:text-slate-600 hover:bg-white/40'
                }
              `}
            >
              <div className="flex flex-col items-center gap-1">
                <span className="text-xl filter drop-shadow-sm transition-transform group-hover:scale-110">{tab.icon}</span>
                <span className="scale-90">{tab.label}</span>
              </div>
            </button>
          ))}
        </div>
      </div>
      
      {/* ========== Unified Fixed Preview Area (Sticky Top) ========== */}
      <div className="relative z-10 bg-gradient-to-b from-slate-100/50 to-white/30 border-b border-white/60">
        {showTrajectoryPreview ? (
           <div className="h-48 w-full bg-slate-900 border-y border-white/10 relative overflow-hidden group">
              <TrajectoryPreview3D 
                trajectoryType={activeTrajectoryToShow}
                speed={15}
                height={250}
                angle={0}
              />
              <div className="absolute top-2 left-3 bg-black/50 backdrop-blur px-2 py-1 rounded-lg text-[9px] font-bold text-cyan-400 border border-cyan-500/30">
                PATH PREVIEW
              </div>
           </div>
        ) : (
           <ShapePreview3D 
              shapeType={activeShapeToShow} 
              className="h-48 border-b border-white/40 bg-gradient-to-b from-slate-50/50 to-white/50 shadow-inner"
           />
        )}
      </div>
      
      {/* ========== Content ========== */}
      <div className="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar bg-white/30">
        
        {/* ===== Tab: Shapes ===== */}
        {activeTab === 'shapes' && (
          <div className="space-y-6 animate-slideUp">
            <div className="flex flex-wrap gap-2 sticky top-0 bg-white/80 backdrop-blur p-2 -mx-2 rounded-xl z-10 border border-white/50 shadow-sm">
              {Object.values(SHAPE_CATEGORIES).map(cat => (
                <button
                  key={cat}
                  onClick={() => setSelectedCategory(cat)}
                  className={`
                    px-4 py-2 rounded-xl text-[10px] font-bold transition-all border
                    ${selectedCategory === cat 
                      ? 'bg-emerald-500 border-emerald-500 text-white shadow-lg shadow-emerald-500/30' 
                      : 'bg-white border-white text-slate-500 hover:bg-emerald-50 hover:text-emerald-600'
                    }
                  `}
                >
                  {cat}
                </button>
              ))}
            </div>
            
            <div className="grid grid-cols-2 gap-3">
              {shapesByCategory[selectedCategory]?.map(type => (
                <ShapePreviewCard
                  key={type}
                  type={type}
                  active={selectedNewShapes.includes(type)}
                  onClick={() => toggleNewShape(type)}
                  onPreview={(shape) => setPreviewShape(shape)}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Trajectories ===== */}
        {activeTab === 'trajectories' && (
          <div className="space-y-4 animate-slideUp">
             <div className="bg-blue-50/50 p-4 rounded-2xl border border-blue-100 text-[10px] text-blue-600 font-medium">
                é€‰æ‹©å·²å¯ç”¨çš„ä¸Šå‡è½¨è¿¹ã€‚ç³»ç»Ÿå°†åœ¨å‘å°„æ—¶ä»ä¸­éšæœºé€‰æ‹©ã€‚
             </div>
             <div className="grid grid-cols-1 gap-2">
              {Object.values(TrajectoryType).map(type => {
                const info = TRAJECTORY_INFO[type];
                const isSelected = selectedTrajectories.includes(type);
                const isHovered = previewTrajectory === type;
                
                return (
                  <button
                    key={type}
                    onClick={() => toggleTrajectory(type)}
                    onMouseEnter={() => setPreviewTrajectory(type)}
                    onMouseLeave={() => setPreviewTrajectory(null)}
                    className={`
                      w-full p-4 rounded-2xl border text-left transition-all duration-300 flex items-center justify-between group
                      ${isHovered 
                        ? 'border-cyan-300 bg-gradient-to-r from-cyan-50 to-emerald-50 shadow-lg scale-[1.02]'
                        : isSelected 
                          ? 'border-emerald-200 bg-white shadow-lg shadow-emerald-100/50 scale-[1.01]' 
                          : 'border-white/60 bg-white/60 hover:bg-white hover:border-emerald-100'
                      }
                    `}
                  >
                    <div className="flex items-center gap-4">
                      <div className={`
                        w-11 h-11 rounded-2xl flex items-center justify-center text-xl
                        ${isHovered || isSelected ? 'bg-emerald-50 text-emerald-600' : 'bg-slate-50 text-slate-400'}
                      `}>
                        {info.icon}
                      </div>
                      <div>
                        <div className="text-sm font-black text-slate-700">{info.name}</div>
                        <p className="text-[10px] text-slate-400 font-medium">{info.description}</p>
                      </div>
                    </div>
                    {isSelected && <span className="text-emerald-500 text-lg">âœ“</span>}
                  </button>
                );
              })}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Manual Interaction ===== */}
        {activeTab === 'manual' && (
          <div className="space-y-8 animate-slideUp">
             {/* Locked Configuration for Manual Click */}
             <div className="bg-white/60 backdrop-blur-xl p-6 rounded-3xl border border-white shadow-sm space-y-5">
                <div className="flex items-center gap-3 mb-2">
                   <div className="p-2 bg-orange-100 text-orange-500 rounded-lg text-lg">ğŸ‘‡</div>
                   <div>
                      <h3 className="text-sm font-black text-slate-800">ç‚¹å‡»äº¤äº’é…ç½®</h3>
                      <p className="text-[10px] text-slate-400 font-bold">é…ç½®é¼ æ ‡ç‚¹å‡»ç©ºç™½å¤„æ—¶çš„å‘å°„è¡Œä¸º</p>
                   </div>
                </div>

                {/* 1. å‘å°„é˜Ÿå½¢ä¸æ•°é‡ */}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="å‘å°„é˜Ÿå½¢" />
                      <CustomSelect 
                         value={manualConfig.lockedFormation || LaunchFormation.SINGLE}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedFormation: v as LaunchFormation })}
                         options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="å•æ¬¡æ•°é‡" />
                      <div className="h-10 flex items-center bg-white/50 rounded-xl px-2 border border-white/50">
                         <input 
                           type="range" min="1" max="20" step="1" 
                           value={manualConfig.lockedCount || 1}
                           onChange={e => onUpdateManual({ ...manualConfig, lockedCount: parseInt(e.target.value) })}
                           className="w-full h-1.5 bg-gray-200 rounded-full appearance-none accent-orange-500 cursor-pointer"
                         />
                         <span className="ml-2 text-xs font-black min-w-[20px] text-right">{manualConfig.lockedCount || 1}</span>
                      </div>
                   </div>
                </div>

                {/* 2. å½¢çŠ¶ä¸è½¨è¿¹é”å®š - ä½¿ç”¨å¸¦é¢„è§ˆçš„ Select */}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="é”å®šå½¢çŠ¶ (Hover Preview)" />
                      <CustomSelectWithPreview 
                         value={manualConfig.lockedShape as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedShape: v as any })}
                         options={[{ label: 'ğŸ² éšæœº', value: 'RANDOM' }, ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))]}
                         previewType="shape"
                         placeholder="éšæœº"
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="é”å®šè½¨è¿¹ (Hover Preview)" />
                      <CustomSelectWithPreview 
                         value={manualConfig.lockedTrajectory as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedTrajectory: v as any })}
                         options={[{ label: 'ğŸ² éšæœº', value: 'RANDOM' }, ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))]}
                         previewType="trajectory"
                         placeholder="éšæœº"
                      />
                   </div>
                </div>

                {/* 3. é«˜çº§å‚æ•° */}
                 <div className="space-y-4 pt-4 border-t border-gray-100">
                    <Label text="é«˜çº§å‚æ•° (Advanced)" />
                    <div className="grid grid-cols-2 gap-4">
                       <Slider label="å‘å°„é—´éš” (ms)" value={manualConfig.lockedInterval || 0} min={0} max={500} step={10} onChange={v => onUpdateManual({ ...manualConfig, lockedInterval: v })} color="orange" />
                       <Slider label="å­˜ç»­æ—¶é—´ (s)" value={manualConfig.lockedDuration || 0} min={0} max={10} step={0.5} unit="s" onChange={v => onUpdateManual({ ...manualConfig, lockedDuration: v })} color="orange" />
                    </div>
                </div>
             </div>
          </div>
        )}
        
        {/* ===== Tab: Carnival ===== */}
        {activeTab === 'carnival' && (
          <div className="space-y-6">
            <div className="bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-500 p-6 rounded-[32px] shadow-2xl text-white relative overflow-hidden group">
               {/* Background Glow */}
               <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2 group-hover:bg-white/20 transition-all duration-1000" />
               
               <div className="relative z-10">
                  <div className="flex justify-between items-start mb-6">
                    <div>
                      <h3 className="text-xl font-black tracking-tight">å¤§ç§€ç¼–æ’</h3>
                      <p className="text-[10px] font-bold opacity-60 uppercase tracking-widest mt-1">Direct Your Masterpiece</p>
                    </div>
                   <div className="flex flex-col items-end gap-2">
                      <div className="flex items-center gap-2 bg-black/20 backdrop-blur rounded-full px-1 py-1">
                         <label className="text-[9px] font-black px-3 uppercase opacity-80">Auto Loop</label>
                         <ToggleSwitch checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} color="emerald" customClass="scale-75 origin-right" />
                      </div>
                      {/* è‡ªåŠ¨æ’­æ”¾é—´éš”æ§åˆ¶ */}
                      {settings.enableAutoCarnival && (
                        <div className="flex items-center gap-2 bg-white/10 backdrop-blur rounded-lg px-2 py-1 animate-slideUp">
                           <span className="text-[9px] font-bold opacity-70">Interval</span>
                           <input 
                             type="range" min="1" max="10" step="1" 
                             value={settings.carnivalInterval} 
                             onChange={e => onUpdate('carnivalInterval', parseFloat(e.target.value))}
                             className="w-16 h-1 bg-white/30 rounded-full appearance-none accent-white cursor-pointer"
                           />
                           <span className="text-[9px] font-bold w-4">{settings.carnivalInterval}s</span>
                        </div>
                      )}
                   </div>
                  </div>
                  
                  <div className="flex gap-3">
                     <button 
                       onClick={handleApplySequence}
                       disabled={!hasChanges}
                       className={`
                          flex-1 py-3 rounded-2xl text-xs font-black transition-all border
                          ${hasChanges ? 'bg-white text-indigo-600 border-white shadow-lg' : 'bg-black/20 text-white/40 border-transparent cursor-not-allowed'}
                       `}
                     >
                       {hasChanges ? 'âœ“ åŒæ­¥å‰§æœ¬' : 'å·²åŒæ­¥'}
                     </button>
                     <button 
                       onClick={onLaunchCarnival}
                       className="flex-[2] py-3 bg-white text-slate-900 rounded-2xl text-xs font-black shadow-lg hover:scale-105 active:scale-95 transition-all flex items-center justify-center gap-2"
                     >
                        <span>ğŸ¬</span> ç«‹å³å¯åŠ¨å¤§ç§€
                     </button>
                  </div>
               </div>
            </div>

            <div className="space-y-3 pb-20">
              <div className="flex justify-between items-end px-2">
                 <Label text="WAVE SEQUENCE" />
                 <button
                    onClick={() => {
                      const id = Math.random().toString(36).substr(2, 9);
                      handleUpdateLocal([...localSeq, { id, name: `Wave ${localSeq.length + 1}`, count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.SPHERE, combo: ComboType.SINGLE, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 0 }]);
                    }}
                    className="text-[10px] font-black bg-indigo-50 text-indigo-600 px-3 py-1.5 rounded-lg hover:bg-indigo-100 transition-colors"
                  >
                    + æ·»åŠ æ³¢æ¬¡
                  </button>
              </div>

              {localSeq.map((stage, idx) => (
                <div key={stage.id} className="bg-white p-5 rounded-[24px] border border-gray-100 shadow-sm hover:shadow-md transition-all flex flex-col gap-4 group">
                  <div className="flex justify-between items-center text-[12px] font-black text-slate-700">
                    <div className="flex items-center gap-3 flex-1">
                       <div className="w-6 h-6 rounded-full bg-slate-100 flex items-center justify-center text-[10px] text-slate-400 font-mono">{idx+1}</div>
                       <input 
                          value={stage.name} 
                          onChange={e => {
                            const next = [...localSeq];
                            next[idx] = { ...stage, name: e.target.value };
                            handleUpdateLocal(next);
                          }} 
                          className="bg-transparent outline-none w-full hover:bg-slate-50 focus:bg-slate-50 px-2 rounded transition-colors" 
                       />
                    </div>
                    <button onClick={() => {
                      const next = [...localSeq];
                      next.splice(idx, 1);
                      handleUpdateLocal(next);
                    }} className="text-gray-200 hover:text-red-400 text-lg px-2">Ã—</button>
                  </div>
                  
                  {/* ä¸»è¦å‚æ•° - ä½¿ç”¨å¸¦é¢„è§ˆçš„ Select */}
                  <div className="grid grid-cols-2 gap-3">
                     <CustomSelectWithPreview
                        value={stage.trajectory}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, trajectory: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: 'ğŸ² éšæœºè½¨è¿¹', value: 'RANDOM' },
                          ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))
                        ]}
                        previewType="trajectory"
                        placeholder="é€‰æ‹©è½¨è¿¹"
                     />
                     <CustomSelectWithPreview
                        value={stage.shape}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, shape: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: 'ğŸ² éšæœºå½¢çŠ¶', value: 'RANDOM' },
                          ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))
                        ]}
                        previewType="shape"
                        placeholder="é€‰æ‹©å½¢çŠ¶"
                     />
                  </div>
                  
                  {/* è¯¦ç»†å‚æ•°åŒº - é»˜è®¤æ˜¾ç¤ºç®€å•çš„ Grid */}
                  <div className="grid grid-cols-2 gap-x-4 gap-y-3 p-3 bg-slate-50/50 rounded-2xl border border-slate-100">
                      <div className="col-span-2">
                        <Label text="LAUNCH FORMATION" />
                        <CustomSelect
                          value={stage.formation || LaunchFormation.RANDOM}
                          onChange={v => {
                             const next = [...localSeq];
                             next[idx] = { ...stage, formation: v as any };
                             handleUpdateLocal(next);
                          }}
                          options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                        />
                      </div>
                      <Slider label="æ•°é‡" value={stage.count} min={1} max={50} step={1} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, count: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="æ³¢æ¬¡å»¶è¿Ÿ (ms)" value={stage.delay} min={0} max={5000} step={100} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, delay: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="é—´éš” (ms)" value={stage.interval || 0} min={0} max={500} step={10} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, interval: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="å­˜ç»­ (s)" value={stage.duration || 0} min={0} max={10} step={0.5} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, duration: v }; handleUpdateLocal(next);
                      }} />
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Physics ===== */}
        {activeTab === 'physics' && (
          <div className="space-y-6">
            <div className="bg-white/60 p-6 rounded-[32px] border border-white space-y-6">
               <h3 className="text-sm font-black text-slate-800">Global Physics</h3>
               <Slider label="Gravity (é‡åŠ›)" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
               <Slider label="Air Resistance (é˜»åŠ›)" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
               <Slider label="Particle Density (å¯†åº¦)" value={settings.particleCountMultiplier} min={0.1} max={3.0} step={0.1} unit="x" onChange={v => onUpdate('particleCountMultiplier', v)} />
               <Slider label="Explosion Scale (è§„æ¨¡)" value={settings.explosionSizeMultiplier} min={0.1} max={100} step={0.1} unit="x" onChange={v => onUpdate('explosionSizeMultiplier', v)} />
            </div>
          </div>
        )}
      </div>

      {/* ========== Footer ========== */}
      <div className="p-4 border-t border-white/60 bg-white/60 backdrop-blur flex gap-3 z-50 shadow-inner">
        <button onClick={onRandomize} className="flex-1 py-3 rounded-xl bg-slate-900 text-white text-xs font-bold hover:bg-emerald-600 transition-all shadow-lg hover:shadow-emerald-500/30">ğŸ² Randomize Physics</button>
        <button onClick={onReset} className="px-6 py-3 rounded-xl bg-white border border-slate-200 text-slate-500 text-xs font-bold hover:bg-red-50 hover:text-red-500 hover:border-red-100 transition-all">Reset All</button>
      </div>
    </div>
  );
};

// ========== Subcomponents ========== //

const Label: React.FC<{ text: string }> = ({ text }) => (
   <div className="text-[9px] font-black text-slate-400 uppercase tracking-wider mb-1.5">{text}</div>
);

const Slider: React.FC<{ label: string, value: number, min: number, max: number, step: number, unit?: string, onChange: (v: number) => void, color?: string }> = ({ label, value, min, max, step, unit = '', onChange, color = 'indigo' }) => (
  <div className="space-y-1.5">
    <div className="flex justify-between items-center text-[10px]">
      <span className="font-bold text-slate-500">{label}</span>
      <span className="font-black text-slate-700 bg-white/50 px-1.5 py-0.5 rounded border border-white">{value.toFixed(step < 1 ? 2 : 0)}{unit}</span>
    </div>
    <input type="range" min={min} max={max} step={step} value={value} onChange={e => onChange(parseFloat(e.target.value))} className={`w-full h-1.5 bg-slate-200 rounded-full appearance-none cursor-pointer accent-${color}-500 hover:accent-${color}-400 transition-all`} />
  </div>
);

const ToggleSwitch: React.FC<{ checked: boolean, onChange: (v: boolean) => void, color?: string, customClass?: string }> = ({ checked, onChange, color = 'emerald', customClass = '' }) => (
  <button onClick={() => onChange(!checked)} className={`w-10 h-6 rounded-full transition-all duration-300 relative border border-transparent ${checked ? `bg-${color}-500 shadow-inner` : 'bg-slate-300'} ${customClass}`}>
    <div className={`absolute top-0.5 w-4 h-4 bg-white rounded-full shadow-md transition-all duration-300 ${checked ? 'left-5' : 'left-1'}`} />
  </button>
);


// =============================================================================
// FILE: src\components\ui\PreviewScene.tsx
// =============================================================================

// FILE: src/components/ui/PreviewScene.tsx

import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { ExplosionType, ColorStyle } from '../../types';
import { Firework3D } from '../../core/Firework3D';
import { ParticlePool3D } from '../../core/ParticlePool3D';

interface PreviewSceneProps {
    shape: ExplosionType;
    colorStyle: ColorStyle;
}

/**
 * ä¸€ä¸ªè¶…è½»é‡çº§çš„ 3D é¢„è§ˆç»„ä»¶ï¼Œç”¨äºåœ¨é…ç½®é¢æ¿ä¸­å±•ç¤ºçƒŸèŠ±æ•ˆæœ
 */
export const PreviewScene: React.FC<PreviewSceneProps> = ({ shape, colorStyle }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
    const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(2000));
    const fireworksRef = useRef<Firework3D[]>([]);

    useEffect(() => {
        if (!containerRef.current) return;

        const width = containerRef.current.clientWidth;
        const height = containerRef.current.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8fafc); // æµ…è‰²èƒŒæ™¯ç¬¦åˆç°ä»£ UI

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
        camera.position.set(0, 0, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // ç®€åŒ–çš„ç²’å­ç³»ç»Ÿ
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            transparent: true,
            blending: THREE.NormalBlending, // é¢„è§ˆä½¿ç”¨æ­£å¸¸æ··åˆä»¥åŒ¹é…æµ…è‰²èƒŒæ™¯
            depthWrite: false
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        let lastSpawn = 0;
        let requestID: number;

        const animate = (time: number) => {
            requestID = requestAnimationFrame(animate);

            // æ¯éš” 1.5 ç§’è‡ªåŠ¨è§¦å‘ä¸€æ¬¡é¢„è§ˆçˆ†ç‚¸
            if (time - lastSpawn > 1500) {
                const fw = new Firework3D(
                    { startX: 0, startZ: 0, targetX: 0, targetY: 0, targetZ: 0, hue: Math.random() * 360, charge: 1.0 },
                    { gravity: 0.1, friction: 0.95, autoLaunchDelay: 1000, particleCountMultiplier: 1, explosionSizeMultiplier: 1, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                    { enabledShapes: [shape], enabledAscensions: [], enabledColors: [colorStyle] }
                );
                fw.exploded = true; // ç›´æ¥è®¾ç½®ä¸ºçˆ†ç‚¸çŠ¶æ€
                fireworksRef.current = [fw];
                lastSpawn = time;
            }

            fireworksRef.current.forEach((fw, i) => {
                if (fw.exploded) {
                    fw.createExplosion(
                        { gravity: 0.05, friction: 0.95, autoLaunchDelay: 0, particleCountMultiplier: 1, explosionSizeMultiplier: 0.8, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                        (opts) => particlePoolRef.current.get(opts)
                    );
                    fireworksRef.current.splice(i, 1);
                }
            });

            particlePoolRef.current.update(0.016);

            // æ›´æ–° Buffer æ•°æ®
            const particles = particlePoolRef.current.getActiveParticles();
            const pos = new Float32Array(particles.length * 3);
            const col = new Float32Array(particles.length * 3);

            particles.forEach((p, i) => {
                pos[i * 3] = p.position.x; pos[i * 3 + 1] = p.position.y; pos[i * 3 + 2] = p.position.z;
                const c = p.getColor();
                col[i * 3] = c.r; col[i * 3 + 1] = c.g; col[i * 3 + 2] = c.b;
            });

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            renderer.render(scene, camera);
        };

        requestID = requestAnimationFrame(animate);

        return () => {
            cancelAnimationFrame(requestID);
            renderer.dispose();
            if (containerRef.current) containerRef.current.innerHTML = '';
        };
    }, [shape, colorStyle]);

    return (
        <div className="w-full h-full relative group">
            <div ref={containerRef} className="w-full h-full" />
            <div className="absolute inset-0 pointer-events-none border-2 border-dashed border-gray-200 rounded-xl m-2 group-hover:border-blue-400 transition-colors" />
            <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-[10px] font-black text-gray-300 uppercase tracking-widest">
                Live 3D Preview
            </div>
        </div>
    );
};

// END OF FILE: src/components/ui/PreviewScene.tsx

// =============================================================================
// FILE: src\components\ui\SettingsPanel.tsx
// =============================================================================

// FILE: src/components/ui/SettingsPanel.tsx

import React, { useState } from 'react';
import { AppSettings, FireworkConfig, ManualConfig, ExplosionType, AscensionType, ColorStyle, SHAPE_ICONS, COLOR_ICONS, ASCENSION_ICONS } from '../../types';
import { PreviewScene } from './PreviewScene';

interface SettingsPanelProps {
    show: boolean;
    settings: AppSettings;
    config: FireworkConfig;
    manualConfig: ManualConfig;
    onClose: () => void;
    onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
    onUpdateConfig: (config: FireworkConfig) => void;
    onUpdateManual: (config: ManualConfig) => void;
    onRandomize: () => void;
    onReset: () => void;
}

export const SettingsPanel: React.FC<SettingsPanelProps> = ({
                                                                show, settings, config, manualConfig, onClose, onUpdate, onUpdateConfig, onUpdateManual, onRandomize, onReset
                                                            }) => {
    const [activeTab, setActiveTab] = useState<'carnival' | 'manual' | 'physics'>('carnival');

    // è·å–å½“å‰é¢„è§ˆçš„å¯¹è±¡
    const previewShape = activeTab === 'manual' && manualConfig.lockedShape !== 'RANDOM'
        ? (manualConfig.lockedShape as ExplosionType)
        : ExplosionType.SPHERE;

    const previewColor = activeTab === 'manual' && manualConfig.lockedColor !== 'RANDOM'
        ? (manualConfig.lockedColor as ColorStyle)
        : ColorStyle.RAINBOW;

    return (
        <div className={`absolute top-0 right-0 h-full w-[450px] bg-white/95 backdrop-blur-3xl shadow-2xl z-40 transform transition-transform duration-500 ease-[cubic-bezier(0.23,1,0.32,1)] border-l border-gray-200 flex flex-col ${show ? 'translate-x-0' : 'translate-x-full'}`}>

            {/* 1. Panel Header */}
            <div className="p-6 pb-2 border-b border-gray-100">
                <div className="flex justify-between items-center mb-6">
                    <div>
                        <h2 className="text-2xl font-black tracking-tighter text-gray-800 italic">DESIGNER <span className="text-blue-600">HUB</span></h2>
                        <p className="text-[10px] text-gray-400 font-bold uppercase tracking-[0.2em] mt-1">Configure & Preview Your Show</p>
                    </div>
                    <button onClick={onClose} className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-50 text-gray-400 hover:bg-red-50 hover:text-red-500 transition-all border border-gray-100">âœ•</button>
                </div>

                {/* 2. Navigation Tabs */}
                <div className="flex p-1 bg-gray-100 rounded-2xl mb-4">
                    {[
                        { id: 'carnival', label: 'å˜‰å¹´åé…ç½®', icon: 'ğŸ¡' },
                        { id: 'manual', label: 'å•å‘è®¾è®¡', icon: 'ğŸ¯' },
                        { id: 'physics', label: 'å¼•æ“æ ¸å¿ƒ', icon: 'âš¡' }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id as any)}
                            className={`flex-1 py-3 text-xs font-black rounded-xl transition-all flex items-center justify-center gap-2 ${activeTab === tab.id ? 'bg-white shadow-lg text-blue-600 scale-[1.02]' : 'text-gray-400 hover:text-gray-600'}`}
                        >
                            <span>{tab.icon}</span>{tab.label}
                        </button>
                    ))}
                </div>
            </div>

            {/* 3. Main Content Scroll Area */}
            <div className="flex-1 overflow-y-auto custom-scrollbar p-6 space-y-8">

                {/* === å®æ—¶ 3D é¢„è§ˆçª—å£ === */}
                <div className="h-48 bg-gray-50 rounded-3xl overflow-hidden border border-gray-100 shadow-inner relative">
                    <PreviewScene shape={previewShape} colorStyle={previewColor} />
                </div>

                {/* --- Tab 1: Carnival --- */}
                {activeTab === 'carnival' && (
                    <div className="space-y-8 animate-fadeIn">
                        <section className="bg-gradient-to-br from-blue-50 to-indigo-50 p-5 rounded-3xl border border-blue-100/50">
                            <div className="flex justify-between items-center mb-4">
                                <span className="text-xs font-black text-blue-900 uppercase">è‡ªåŠ¨è½®æ’­å˜‰å¹´å</span>
                                <Toggle checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} />
                            </div>
                            <SettingSlider label="å‘å°„æ³¢æ¬¡é¢‘ç‡" value={settings.carnivalInterval} min={1} max={15} step={1} unit="s" onChange={v => onUpdate('carnivalInterval', v)} />
                        </section>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-300 uppercase tracking-[0.3em] mb-4">å¯ç”¨å½¢çŠ¶é›†</h3>
                            <div className="grid grid-cols-2 gap-3">
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={config.enabledShapes.includes(t)}
                                        onClick={() => onUpdateConfig({...config, enabledShapes: config.enabledShapes.includes(t) ? config.enabledShapes.filter(s => s !== t) : [...config.enabledShapes, t]})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 2: Manual --- */}
                {activeTab === 'manual' && (
                    <div className="space-y-8 animate-fadeIn">
                        <div className="bg-gray-50 p-4 rounded-2xl text-[11px] text-gray-500 font-medium italic border-l-4 border-blue-400">
                            æç¤ºï¼šå•å‘æ¨¡å¼é…ç½®é¼ æ ‡ç‚¹å‡»æ—¶çš„å›ºå®šæ ·å¼ã€‚è‹¥è®¾ä¸ºâ€œéšæœºâ€ï¼Œåˆ™éµå¾ªå˜‰å¹´åç™½åå•ã€‚
                        </div>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-400 uppercase tracking-[0.3em] mb-4">é”å®šå•å‘å½¢çŠ¶</h3>
                            <div className="grid grid-cols-2 gap-3">
                                <div onClick={() => onUpdateManual({...manualConfig, lockedShape: 'RANDOM'})} className={`p-4 rounded-2xl border-2 transition-all cursor-pointer flex items-center gap-4 ${manualConfig.lockedShape === 'RANDOM' ? 'border-blue-500 bg-blue-50/50' : 'border-gray-100 hover:border-gray-200'}`}>
                                    <div className="text-2xl">ğŸ²</div>
                                    <div className="font-black text-xs text-gray-700">éšæœºå½¢çŠ¶</div>
                                </div>
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={manualConfig.lockedShape === t}
                                        onClick={() => onUpdateManual({...manualConfig, lockedShape: t})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 3: Physics --- */}
                {activeTab === 'physics' && (
                    <div className="space-y-6 animate-fadeIn">
                        <SettingSlider label="å…¨å±€é‡åŠ›" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
                        <SettingSlider label="å¤§æ°”ç²˜åº¦" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
                        <SettingSlider label="ç²’å­å¯†åº¦å€ç‡" value={settings.particleCountMultiplier} min={0.2} max={2.0} step={0.1} onChange={v => onUpdate('particleCountMultiplier', v)} />
                    </div>
                )}
            </div>

            {/* 4. Footer Actions */}
            <div className="p-6 border-t border-gray-100 bg-gray-50/30 flex gap-4">
                <button onClick={onRandomize} className="flex-1 py-4 bg-gray-900 text-white rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-blue-600 transition-all shadow-xl active:scale-95">ğŸ² éšæœºåŒ–å‚æ•°</button>
                <button onClick={onReset} className="px-6 py-4 bg-white border border-gray-200 text-gray-400 rounded-2xl text-[10px] font-black uppercase hover:text-red-500 transition-all">é‡ç½®</button>
            </div>
        </div>
    );
};

// --- å­ç»„ä»¶: æ ·å¼åŒ–å¡ç‰‡ ---

const ShapeCard = ({ type, active, onClick }: { type: ExplosionType, active: boolean, onClick: () => void }) => (
    <div
        onClick={onClick}
        className={`group relative p-4 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden ${active ? 'border-blue-500 bg-blue-50/50 shadow-lg scale-[1.02]' : 'border-gray-50 bg-white hover:border-gray-200'}`}
    >
        <div className="flex items-center gap-3">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-lg ${active ? 'bg-white' : 'bg-gray-50'}`}>
                {SHAPE_ICONS[type]}
            </div>
            <div className="flex flex-col">
                <span className={`text-[10px] font-black uppercase tracking-tighter ${active ? 'text-blue-600' : 'text-gray-700'}`}>{type}</span>
                <span className="text-[8px] text-gray-400 font-bold uppercase tracking-widest">FIREWORK</span>
            </div>
        </div>
        {/* CSS è£…é¥°èƒŒæ™¯ */}
        <div className={`absolute -right-2 -bottom-2 w-12 h-12 opacity-[0.03] group-hover:opacity-[0.08] transition-opacity ${active ? 'text-blue-600' : 'text-black'}`}>
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>
        </div>
    </div>
);

const SettingSlider = ({ label, value, min, max, step, unit = '', onChange }: any) => (
    <div className="space-y-3">
        <div className="flex justify-between items-center">
            <span className="text-[10px] font-black text-gray-400 uppercase tracking-widest">{label}</span>
            <span className="bg-gray-100 text-gray-600 px-2 py-0.5 rounded-lg text-[10px] font-mono font-bold">{value.toFixed(2)}{unit}</span>
        </div>
        <input
            type="range" min={min} max={max} step={step} value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="w-full h-1.5 bg-gray-100 rounded-full appearance-none cursor-pointer accent-blue-600"
        />
    </div>
);

const Toggle = ({ checked, onChange }: { checked: boolean, onChange: (v: boolean) => void }) => (
    <button
        onClick={() => onChange(!checked)}
        className={`w-10 h-5 rounded-full transition-colors relative ${checked ? 'bg-blue-600' : 'bg-gray-200'}`}
    >
        <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-transform ${checked ? 'left-6' : 'left-1'}`} />
    </button>
);

// END OF FILE: src/components/ui/SettingsPanel.tsx

// =============================================================================
// FILE: src\components\ui\ShapePreview.tsx
// =============================================================================

/**
 * ShapePreview.tsx - å¾®å‹ 3D å½¢çŠ¶é¢„è§ˆå™¨
 * 
 * ç”¨äºåœ¨é¼ æ ‡æ‚¬åœæ—¶ï¼Œå®æ—¶æ¸²æŸ“è¯¥å½¢çŠ¶çš„åŠ¨æ€ 3D ç²’å­é¢„è§ˆ
 */

import React, { useEffect, useRef, memo } from 'react';

// ç®€åŒ–çš„å½¢çŠ¶ç”Ÿæˆå™¨ï¼ˆç‹¬ç«‹äºä¸»å¼•æ“ï¼Œé¿å…å¯¼å…¥é—®é¢˜ï¼‰
function generateShapePoints(shapeType: string, count: number = 150): Array<{x: number, y: number, z: number}> {
  const points: Array<{x: number, y: number, z: number}> = [];
  const scale = 30;

  switch (shapeType) {
    case 'heart_3d':
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 2;
        const p = Math.acos(2 * Math.random() - 1);
        const x = 16 * Math.pow(Math.sin(t), 3) * 0.8;
        const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.8;
        const z = (Math.random() - 0.5) * 10;
        points.push({ x, y: y + 5, z });
      }
      break;
      
    case 'phoenix':
    case 'bird':
      // é¸Ÿ/å‡¤å‡°å½¢çŠ¶ - å±•å¼€çš„ç¿…è†€
      for (let i = 0; i < count; i++) {
        const t = (i / count) * 2 - 1; // -1 to 1
        const wingSpan = 25;
        const x = t * wingSpan;
        const y = Math.abs(t) * 8 + Math.sin(Math.abs(t) * Math.PI) * 10;
        const z = Math.cos(t * Math.PI) * 5;
        points.push({ x, y, z });
      }
      break;
      
    case 'butterfly_3d':
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 2;
        const m = (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t/12), 5)) * 5;
        const x = Math.sin(t) * m;
        const y = Math.cos(t) * m;
        const z = Math.abs(x) * 0.3;
        points.push({ x, y, z });
      }
      break;
      
    case 'star_3d':
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const isOuter = Math.floor((i / count) * 10) % 2 === 0;
        const r = isOuter ? 20 : 8;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        const z = (Math.random() - 0.5) * 6;
        points.push({ x, y, z });
      }
      break;
      
    case 'galaxy_spiral':
      for (let i = 0; i < count; i++) {
        const arm = Math.floor(Math.random() * 3);
        const t = Math.random() * 3;
        const angle = t * Math.PI + (arm / 3) * Math.PI * 2;
        const r = t * 8 + Math.random() * 3;
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = (Math.random() - 0.5) * 3;
        points.push({ x, y, z });
      }
      break;
      
    case 'dragon_3d':
      // é¾™å½¢ - Sæ›²çº¿èº«ä½“
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 2;
        const x = Math.sin(t * 2) * 15;
        const y = t * 5 - 15;
        const z = Math.cos(t * 2) * 8;
        points.push({ x, y, z });
      }
      break;
      
    case 'torus':
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 2;
        const R = 15, r = 5;
        const x = (R + r * Math.cos(phi)) * Math.cos(theta);
        const y = r * Math.sin(phi);
        const z = (R + r * Math.cos(phi)) * Math.sin(theta);
        points.push({ x, y, z });
      }
      break;
      
    case 'flower_3d':
    case 'lotus':
      for (let i = 0; i < count; i++) {
        const layer = Math.floor(Math.random() * 3);
        const angle = (i / count) * Math.PI * 2;
        const r = (10 + layer * 5) * Math.pow(Math.abs(Math.cos(angle * 3)), 0.5);
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = layer * 3;
        points.push({ x, y, z });
      }
      break;

    case 'cube':
      for (let i = 0; i < count; i++) {
        const face = Math.floor(Math.random() * 6);
        const u = (Math.random() - 0.5) * 20;
        const v = (Math.random() - 0.5) * 20;
        let x, y, z;
        switch(face) {
          case 0: x = 10; y = u; z = v; break;
          case 1: x = -10; y = u; z = v; break;
          case 2: x = u; y = 10; z = v; break;
          case 3: x = u; y = -10; z = v; break;
          case 4: x = u; y = v; z = 10; break;
          default: x = u; y = v; z = -10;
        }
        points.push({ x, y, z });
      }
      break;

    default: // sphere
      for (let i = 0; i < count; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 15;
        const x = Math.sin(phi) * Math.cos(theta) * r;
        const y = Math.sin(phi) * Math.sin(theta) * r;
        const z = Math.cos(phi) * r;
        points.push({ x, y, z });
      }
  }

  return points;
}

interface ShapePreviewProps {
  shapeType: string;
  color: string;
  size?: number;
}

export const ShapePreview: React.FC<ShapePreviewProps> = memo(({ 
  shapeType, 
  color, 
  size = 100 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const requestRef = useRef<number>();
  const angleRef = useRef<number>(0);
  const pointsRef = useRef<Array<{x: number, y: number, z: number}>>([]);

  useEffect(() => {
    // ç”Ÿæˆå½¢çŠ¶ç‚¹
    pointsRef.current = generateShapePoints(shapeType, 200);
  }, [shapeType]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const animate = () => {
      ctx.clearRect(0, 0, size, size);
      
      const cx = size / 2;
      const cy = size / 2;
      
      angleRef.current += 0.03;
      const cos = Math.cos(angleRef.current);
      const sin = Math.sin(angleRef.current);

      // æ’åºä»¥å®ç°æ·±åº¦æ•ˆæœ
      const sortedPoints = [...pointsRef.current].sort((a, b) => {
        const za = a.x * sin + a.z * cos;
        const zb = b.x * sin + b.z * cos;
        return za - zb;
      });

      sortedPoints.forEach(p => {
        const x = p.x * cos - p.z * sin;
        const z = p.x * sin + p.z * cos;
        const y = p.y;

        const scale = 150 / (150 + z);
        const screenX = cx + x * scale * 1.5;
        const screenY = cy - y * scale * 1.5; // æ³¨æ„Yè½´ç¿»è½¬
        const pointSize = Math.max(1, 2.5 * scale);

        const alpha = 0.4 + (z + 30) / 60 * 0.6;
        ctx.globalAlpha = Math.max(0.2, Math.min(1, alpha));
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, pointSize, 0, Math.PI * 2);
        ctx.fill();
      });

      requestRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [shapeType, color, size]);

  return (
    <canvas 
      ref={canvasRef} 
      width={size} 
      height={size}
      style={{ width: size, height: size }}
    />
  );
});

ShapePreview.displayName = 'ShapePreview';
export default ShapePreview;


// =============================================================================
// FILE: src\components\ui\ShapePreviewCard.tsx
// =============================================================================

// FILE: src/components/ui/ShapePreviewCard.tsx
// å½¢çŠ¶é¢„è§ˆå¡ç‰‡ç»„ä»¶ - ç‚¹å‡»æ—¶åœ¨é¡¶éƒ¨æ˜¾ç¤º3Dé¢„è§ˆ

import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { Shape3DFactory, Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';

interface ShapePreviewCardProps {
  type: Shape3DType;
  active: boolean;
  onClick: () => void;
  onPreview?: (type: Shape3DType) => void;
}

/**
 * å½¢çŠ¶é¢„è§ˆå¡ç‰‡
 * æ”¯æŒæ‚¬åœé¢„è§ˆå’Œç‚¹å‡»é€‰ä¸­
 */
export const ShapePreviewCard: React.FC<ShapePreviewCardProps> = ({
  type,
  active,
  onClick,
  onPreview
}) => {
  const info = SHAPE_3D_INFO[type];
  
  return (
    <div
      onClick={onClick}
      onMouseEnter={() => onPreview?.(type)}
      className={`
        group relative p-3 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden
        ${active 
          ? 'border-emerald-400 bg-gradient-to-br from-emerald-50 to-teal-50 shadow-lg scale-[1.02]' 
          : 'border-gray-100 bg-white/80 hover:border-emerald-200 hover:shadow-md'
        }
      `}
    >
      <div className="flex items-center gap-3">
        {/* å›¾æ ‡ */}
        <div className={`
          w-10 h-10 rounded-xl flex items-center justify-center text-xl
          transition-all
          ${active ? 'bg-white shadow-sm' : 'bg-gray-50 group-hover:bg-emerald-50'}
        `}>
          {info.icon}
        </div>
        
        {/* æ–‡å­— */}
        <div className="flex flex-col flex-1 min-w-0">
          <span className={`
            text-[11px] font-bold truncate
            ${active ? 'text-emerald-700' : 'text-gray-700'}
          `}>
            {info.name}
          </span>
          <span className={`
            text-[9px] truncate
            ${active ? 'text-emerald-500' : 'text-gray-400'}
          `}>
            {info.category}
          </span>
        </div>
        
        {/* é€‰ä¸­æ ‡è®° */}
        {active && (
          <div className="w-5 h-5 rounded-full bg-emerald-400 flex items-center justify-center">
            <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
            </svg>
          </div>
        )}
      </div>
      
      {/* æ‚¬åœæç¤º */}
      <div className="
        absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-1.5
        bg-gray-900 text-white text-[10px] rounded-lg
        opacity-0 group-hover:opacity-100 transition-opacity
        pointer-events-none whitespace-nowrap z-50
      ">
        {info.description}
        <div className="absolute top-full left-1/2 -translate-x-1/2 border-4 border-transparent border-t-gray-900" />
      </div>
    </div>
  );
};

/**
 * 3D å®æ—¶é¢„è§ˆçª—å£
 */
interface ShapePreview3DProps {
  shapeType: Shape3DType | null;
  className?: string;
}

export const ShapePreview3D: React.FC<ShapePreview3DProps> = ({
  shapeType,
  className = ''
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const pointsRef = useRef<THREE.Points | null>(null);
  const frameRef = useRef<number>(0);
  
  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    // åœºæ™¯
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);
    sceneRef.current = scene;
    
    // ç›¸æœº
    const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
    camera.position.set(0, 0, 100);
    cameraRef.current = camera;
    
    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // ç²’å­ç³»ç»Ÿ
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(3000 * 3);
    const colors = new Float32Array(3000 * 3);
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
      size: 3,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true
    });
    
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    pointsRef.current = points;
    
    // åŠ¨ç”»
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (pointsRef.current) {
        pointsRef.current.rotation.y += 0.01;
        pointsRef.current.rotation.x += 0.003;
      }
      
      renderer.render(scene, camera);
    };
    animate();
    
    // æ¸…ç†
    return () => {
      cancelAnimationFrame(frameRef.current);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
      container.removeChild(renderer.domElement);
    };
  }, []);
  
  // æ›´æ–°å½¢çŠ¶
  useEffect(() => {
    if (!pointsRef.current || !shapeType) return;
    
    const shape3DPoints = Shape3DFactory.generate(shapeType, 500, 1, 180);
    const geometry = pointsRef.current.geometry;
    const positions = geometry.attributes.position.array as Float32Array;
    const colors = geometry.attributes.color.array as Float32Array;
    
    // æ¸…ç©º
    positions.fill(0);
    colors.fill(0);
    
    // å¡«å……æ–°ç‚¹
    for (let i = 0; i < Math.min(shape3DPoints.length, 1000); i++) {
      const point = shape3DPoints[i];
      const idx = i * 3;
      
      positions[idx] = point.position.x;
      positions[idx + 1] = point.position.y;
      positions[idx + 2] = point.position.z;
      
      // HSL to RGB
      const h = point.hue / 360;
      const s = 0.7;
      const l = 0.6;
      const { r, g, b } = hslToRgb(h, s, l);
      
      colors[idx] = r;
      colors[idx + 1] = g;
      colors[idx + 2] = b;
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
  }, [shapeType]);
  
  const info = shapeType ? SHAPE_3D_INFO[shapeType] : null;
  
  return (
    <div className={`relative overflow-hidden ${className}`}>
      <div ref={containerRef} className="w-full h-full" />
      
      {/* ä¿¡æ¯è¦†ç›– */}
      {info && (
        <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-white/90 to-transparent">
          <div className="flex items-center gap-2">
            <span className="text-xl">{info.icon}</span>
            <div>
              <div className="text-sm font-bold text-gray-800">{info.name}</div>
              <div className="text-[10px] text-gray-500">{info.description}</div>
            </div>
          </div>
        </div>
      )}
      
      {/* ç©ºçŠ¶æ€ */}
      {!shapeType && (
        <div className="absolute inset-0 flex items-center justify-center text-gray-300">
          <div className="text-center">
            <div className="text-3xl mb-2">âœ¨</div>
            <div className="text-xs font-medium">æ‚¬åœå½¢çŠ¶å¡ç‰‡ä»¥é¢„è§ˆ</div>
          </div>
        </div>
      )}
    </div>
  );
};

// HSL to RGB è½¬æ¢
function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  let r: number, g: number, b: number;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return { r, g, b };
}

// END OF FILE: src/components/ui/ShapePreviewCard.tsx


// =============================================================================
// FILE: src\components\ui\TimeControlPanel.tsx
// =============================================================================

// FILE: src/components/ui/TimeControlPanel.tsx

import React from 'react';
import { TimeController } from '../../core/TimeController';

interface TimeControlPanelProps {
  timeController: TimeController | null;
  stats: {
    particles: number;
    fireworks: number;
    fps: number;
  };
  onTimeScaleChange: (scale: number) => void;
  onTogglePause: () => void;
  autoRotate: boolean;
  onToggleAutoRotate: () => void;
}

export const TimeControlPanel: React.FC<TimeControlPanelProps> = ({
                                                                    timeController,
                                                                    stats,
                                                                    onTimeScaleChange,
                                                                    onTogglePause,
                                                                    autoRotate,
                                                                    onToggleAutoRotate
                                                                  }) => {
  const timeScale = timeController?.timeScale ?? 1;
  const isPaused = timeController?.isPaused ?? false;

  return (
      <div className="absolute bottom-8 left-8 z-30 flex flex-col gap-3">
        {/* ç°ä»£åŒ–æµ…è‰²å¡ç‰‡ */}
        <div className="bg-white/80 backdrop-blur-xl rounded-2xl p-4 shadow-xl border border-white/50 w-64 transition-all hover:shadow-2xl hover:scale-[1.02]">

          {/* æ ‡é¢˜æ  */}
          <div className="flex justify-between items-center mb-4">
          <span className="text-gray-800 text-xs font-bold tracking-wider flex items-center gap-2">
             <span className="text-lg">âš™ï¸</span> ENGINE
          </span>
            <div className="flex gap-2 items-center bg-gray-100 px-2 py-1 rounded-lg">
              <div className={`w-1.5 h-1.5 rounded-full ${isPaused ? 'bg-amber-400 animate-pulse' : 'bg-green-500'}`}></div>
              <span className="text-[10px] font-mono text-gray-500 font-bold">{stats.fps} FPS</span>
            </div>
          </div>

          {/* æ§åˆ¶æŒ‰é’®ç½‘æ ¼ */}
          <div className="grid grid-cols-2 gap-2 mb-4">
            <button
                onClick={onTogglePause}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    isPaused
                        ? 'bg-amber-50 text-amber-600 border-amber-200 hover:bg-amber-100'
                        : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50 hover:text-gray-900'
                }`}
            >
              {isPaused ? 'â–¶ RESUME' : 'â¸ PAUSE'}
            </button>

            <button
                onClick={onToggleAutoRotate}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    autoRotate
                        ? 'bg-blue-50 text-blue-600 border-blue-200 hover:bg-blue-100'
                        : 'bg-white text-gray-400 border-gray-200 hover:bg-gray-50 hover:text-gray-600'
                }`}
            >
              {autoRotate ? 'â†º ROTATING' : 'âŠ˜ STATIC'}
            </button>
          </div>

          {/* é€Ÿåº¦æ»‘å— */}
          <div className="bg-gray-50 rounded-xl p-3 border border-gray-100">
            <div className="flex justify-between text-[10px] text-gray-400 mb-2 font-bold uppercase">
              <span>Time Scale</span>
              <span className="text-gray-800">{timeScale.toFixed(1)}x</span>
            </div>
            <input
                type="range"
                min="0.1"
                max="3"
                step="0.1"
                value={timeScale}
                onChange={(e) => onTimeScaleChange(parseFloat(e.target.value))}
                className="w-full h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer accent-gray-700 hover:accent-blue-600 transition-all"
            />
            <div className="flex justify-between mt-1 text-[8px] text-gray-300 font-mono">
              <span>SLOW</span>
              <span>FAST</span>
            </div>
          </div>

          {/* åº•éƒ¨ç»Ÿè®¡ä¿¡æ¯ */}
          <div className="mt-4 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[9px] text-gray-400 font-mono">
            <div>
              <span className="block text-gray-300 uppercase text-[8px]">Particles</span>
              <span className="font-bold text-gray-600">{(stats.particles/1000).toFixed(1)}k</span>
            </div>
            <div className="text-right">
              <span className="block text-gray-300 uppercase text-[8px]">Fireworks</span>
              <span className="font-bold text-gray-600">{stats.fireworks}</span>
            </div>
          </div>
        </div>
      </div>
  );
};

// END OF FILE: src/components/ui/TimeControlPanel.tsx

// =============================================================================
// FILE: src\components\ui\TimelinePanel.tsx
// =============================================================================

// FILE: src/components/ui/TimelinePanel.tsx
// æ—¶é—´çº¿é¢æ¿ç»„ä»¶ - å¯è§†åŒ–æ—¶é—´è½´ã€å…³é”®å¸§ã€æ‹–åŠ¨è·³è½¬

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { TimelineManager, TimelineKeyframe, timelineManager } from '../../core/timeline/TimelineManager';

interface TimelinePanelProps {
  className?: string;
  logs?: Array<{ time: number; message: string; type: 'launch' | 'explosion' | 'carnival' }>;
  onSeek?: (time: number) => void;
}

/**
 * æ—¶é—´çº¿é¢æ¿
 * åŠŸèƒ½ï¼š
 * 1. å¯è§†åŒ–æ—¶é—´è½´ (0-100%)
 * 2. å…³é”®å¸§æ ‡è®°ç‚¹
 * 3. æ‹–åŠ¨æ»‘å—è·³è½¬
 * 4. æ’­æ”¾/æš‚åœ/æ—¶é—´ç¼©æ”¾æ§åˆ¶
 * 5. æ—¥å¿—äº‹ä»¶æ˜¾ç¤º
 */
export const TimelinePanel: React.FC<TimelinePanelProps> = ({
  className = '',
  logs = [],
  onSeek
}) => {
  const [state, setState] = useState(timelineManager.getState());
  const [isDragging, setIsDragging] = useState(false);
  const [showLogs, setShowLogs] = useState(false);
  const trackRef = useRef<HTMLDivElement>(null);

  // è®¢é˜…æ—¶é—´å˜åŒ–
  useEffect(() => {
    const unsubscribe = timelineManager.onTimeChange((time) => {
      setState(timelineManager.getState());
    });
    
    // åˆå§‹çŠ¶æ€
    setState(timelineManager.getState());
    
    return unsubscribe;
  }, []);

  // é”®ç›˜å¿«æ·é”®
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // é¿å…åœ¨è¾“å…¥æ¡†ä¸­è§¦å‘
      if ((e.target as HTMLElement).tagName === 'INPUT') return;
      
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          timelineManager.nudge(-0.5);
          break;
        case 'ArrowRight':
          e.preventDefault();
          timelineManager.nudge(0.5);
          break;
        case 'Home':
          e.preventDefault();
          timelineManager.seekTo(0);
          break;
        case 'End':
          e.preventDefault();
          timelineManager.seekTo(timelineManager.getDuration());
          break;
        case ' ':
          e.preventDefault();
          timelineManager.togglePlay();
          setState(timelineManager.getState());
          break;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // æ‹–åŠ¨å¤„ç†
  const handleTrackClick = useCallback((e: React.MouseEvent) => {
    if (!trackRef.current) return;
    const rect = trackRef.current.getBoundingClientRect();
    const progress = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    timelineManager.seekToProgress(progress);
    onSeek?.(progress * state.duration);
  }, [state.duration, onSeek]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    setIsDragging(true);
    handleTrackClick(e);
  }, [handleTrackClick]);

  useEffect(() => {
    if (!isDragging) return;
    
    const handleMouseMove = (e: MouseEvent) => {
      if (!trackRef.current) return;
      const rect = trackRef.current.getBoundingClientRect();
      const progress = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      timelineManager.seekToProgress(progress);
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging]);

  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const progress = state.duration > 0 ? (state.currentTime / state.duration) * 100 : 0;

  // æ—¶é—´å€ç‡é€‰é¡¹
  const timeScales = [0.25, 0.5, 1, 2, 5, 10];

  return (
    <div className={`
      bg-white/90 backdrop-blur-xl 
      border border-white/60 rounded-2xl 
      shadow-xl shadow-slate-200/30
      p-4 select-none
      ${className}
    `}>
      {/* é¡¶éƒ¨æ§åˆ¶æ  */}
      <div className="flex items-center justify-between mb-3">
        {/* æ’­æ”¾æ§åˆ¶ */}
        <div className="flex items-center gap-2">
          {/* æ’­æ”¾/æš‚åœ */}
          <button
            onClick={() => {
              timelineManager.togglePlay();
              setState(timelineManager.getState());
            }}
            className={`
              w-10 h-10 rounded-xl flex items-center justify-center
              transition-all duration-200
              ${state.isPlaying 
                ? 'bg-emerald-500 text-white shadow-lg shadow-emerald-200' 
                : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
              }
            `}
            title={state.isPlaying ? 'æš‚åœ (Space)' : 'æ’­æ”¾ (Space)'}
          >
            {state.isPlaying ? (
              <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="4" width="4" height="16" rx="1" />
                <rect x="14" y="4" width="4" height="16" rx="1" />
              </svg>
            ) : (
              <svg className="w-5 h-5 ml-0.5" viewBox="0 0 24 24" fill="currentColor">
                <path d="M8 5v14l11-7z" />
              </svg>
            )}
          </button>

          {/* è·³è½¬æŒ‰é’® */}
          <button
            onClick={() => timelineManager.seekTo(0)}
            className="w-8 h-8 rounded-lg bg-slate-100 text-slate-500 hover:bg-slate-200 flex items-center justify-center transition-all"
            title="å›åˆ°å¼€å§‹ (Home)"
          >
            <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
            </svg>
          </button>

          <button
            onClick={() => timelineManager.jumpToPrevKeyframe()}
            className="w-8 h-8 rounded-lg bg-slate-100 text-slate-500 hover:bg-slate-200 flex items-center justify-center transition-all"
            title="ä¸Šä¸€å…³é”®å¸§"
          >
            <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
              <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" />
            </svg>
          </button>

          <button
            onClick={() => timelineManager.jumpToNextKeyframe()}
            className="w-8 h-8 rounded-lg bg-slate-100 text-slate-500 hover:bg-slate-200 flex items-center justify-center transition-all"
            title="ä¸‹ä¸€å…³é”®å¸§"
          >
            <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z" />
            </svg>
          </button>
        </div>

        {/* æ—¶é—´æ˜¾ç¤º */}
        <div className="text-center">
          <div className="text-lg font-mono font-bold text-slate-800">
            {formatTime(state.currentTime)}
          </div>
          <div className="text-[9px] text-slate-400 font-medium">
            / {formatTime(state.duration)}
          </div>
        </div>

        {/* æ—¶é—´å€ç‡ */}
        <div className="flex items-center gap-1">
          <span className="text-[9px] text-slate-400 mr-1">é€Ÿåº¦</span>
          {timeScales.map(scale => (
            <button
              key={scale}
              onClick={() => {
                timelineManager.setTimeScale(scale);
                setState(timelineManager.getState());
              }}
              className={`
                px-2 py-1 rounded-lg text-[10px] font-bold transition-all
                ${state.timeScale === scale 
                  ? 'bg-emerald-500 text-white shadow-md' 
                  : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                }
              `}
            >
              {scale}x
            </button>
          ))}
        </div>
      </div>

      {/* æ—¶é—´è½´è½¨é“ */}
      <div 
        ref={trackRef}
        className={`
          relative h-8 bg-slate-100 rounded-xl cursor-pointer
          border border-slate-200
          ${isDragging ? 'ring-2 ring-emerald-500/50' : ''}
        `}
        onMouseDown={handleMouseDown}
      >
        {/* è¿›åº¦æ¡ */}
        <div 
          className="absolute left-0 top-0 h-full bg-gradient-to-r from-emerald-400 to-cyan-400 rounded-xl transition-all duration-75"
          style={{ width: `${progress}%` }}
        />

        {/* å…³é”®å¸§æ ‡è®° */}
        {state.keyframes.map(kf => {
          const pos = (kf.time / state.duration) * 100;
          return (
            <div
              key={kf.id}
              className="absolute top-1/2 -translate-y-1/2 -translate-x-1/2 z-10 group"
              style={{ left: `${pos}%` }}
              title={`${kf.label} (${formatTime(kf.time)})`}
            >
              <div
                className={`
                  w-3 h-3 rounded-full border-2 border-white shadow-sm cursor-pointer
                  transition-transform hover:scale-150
                `}
                style={{ backgroundColor: kf.color }}
                onClick={(e) => {
                  e.stopPropagation();
                  timelineManager.seekTo(kf.time);
                }}
              />
              {/* Tooltip */}
              <div className="absolute bottom-full mb-2 left-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                <div className="bg-slate-900 text-white text-[9px] px-2 py-1 rounded-lg whitespace-nowrap">
                  {kf.label}
                </div>
              </div>
            </div>
          );
        })}

        {/* å½“å‰æ—¶é—´æŒ‡é’ˆ */}
        <div 
          className="absolute top-0 bottom-0 w-1 bg-white rounded-full shadow-lg border-2 border-emerald-500 -translate-x-1/2 z-20"
          style={{ left: `${progress}%` }}
        />

        {/* æ—¶é—´åˆ»åº¦ */}
        <div className="absolute inset-0 flex items-end pb-1 px-2 pointer-events-none">
          {[0, 25, 50, 75, 100].map(pct => (
            <div 
              key={pct}
              className="absolute text-[8px] text-slate-400 font-mono"
              style={{ left: `${pct}%`, transform: 'translateX(-50%)' }}
            >
              {formatTime((pct / 100) * state.duration)}
            </div>
          ))}
        </div>
      </div>

      {/* æ—¥å¿—åŒºåŸŸ (å¯æŠ˜å ) */}
      {logs.length > 0 && (
        <div className="mt-3">
          <button
            onClick={() => setShowLogs(!showLogs)}
            className="flex items-center gap-2 text-[10px] font-bold text-slate-500 hover:text-slate-700 transition-colors"
          >
            <span className={`transition-transform ${showLogs ? 'rotate-90' : ''}`}>â–¶</span>
            äº‹ä»¶æ—¥å¿— ({logs.length})
          </button>
          
          {showLogs && (
            <div className="mt-2 max-h-32 overflow-y-auto space-y-1 custom-scrollbar">
              {logs.slice(-10).reverse().map((log, i) => (
                <button
                  key={i}
                  onClick={() => timelineManager.seekTo(log.time)}
                  className="w-full text-left p-2 bg-slate-50 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-2"
                >
                  <span className={`w-2 h-2 rounded-full ${
                    log.type === 'launch' ? 'bg-emerald-500' :
                    log.type === 'explosion' ? 'bg-orange-500' :
                    'bg-purple-500'
                  }`} />
                  <span className="text-[9px] font-mono text-slate-400 w-12">
                    {formatTime(log.time)}
                  </span>
                  <span className="text-[10px] text-slate-600 truncate">
                    {log.message}
                  </span>
                </button>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// END OF FILE: src/components/ui/TimelinePanel.tsx


// =============================================================================
// FILE: src\components\ui\TrajectoryPreview3D.tsx
// =============================================================================

// FILE: src/components/ui/TrajectoryPreview3D.tsx
// é‡å†™ï¼šè½¨è¿¹é¢„è§ˆç»„ä»¶ - å¸¦ç®­å¤´çš„è·¯å¾„å¯è§†åŒ– + é€Ÿåº¦å‘é‡æ˜¾ç¤º
// æ¯ç§è½¨è¿¹ç±»å‹æœ‰æ˜æ˜¾ä¸åŒçš„è§†è§‰è¡¨ç°

import React, { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import { TrajectoryType, TrajectoryFactory, TrajectoryCalculator, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { Vector3 } from '../../core/Vector3';

// ============ ä¸»ç»„ä»¶ï¼š3D è½¨è¿¹é¢„è§ˆ ============
interface TrajectoryPreview3DProps {
  trajectoryType: TrajectoryType | null;
  className?: string;
  // è‡ªå®šä¹‰å‚æ•°
  speed?: number;       // åˆå§‹é€Ÿåº¦ (1-30)
  height?: number;      // ç›®æ ‡é«˜åº¦ (100-500)
  angle?: number;       // å‘å°„è§’åº¦ (-45 to 45 åº¦)
}

export const TrajectoryPreview3D: React.FC<TrajectoryPreview3DProps> = ({
  trajectoryType,
  className = '',
  speed = 15,
  height = 300,
  angle = 0
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const frameRef = useRef<number>(0);
  
  // è½¨è¿¹çº¿å’Œç®­å¤´çš„å¼•ç”¨
  const pathLineRef = useRef<THREE.Line | null>(null);
  const arrowsRef = useRef<THREE.Group | null>(null);
  const projectileRef = useRef<THREE.Mesh | null>(null);
  const animationTimeRef = useRef<number>(0);
  const pathPointsRef = useRef<THREE.Vector3[]>([]);
  
  // åˆå§‹åŒ–åœºæ™¯
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    
    // åœºæ™¯
    const scene = new THREE.Scene();
    scene.background = null;  // é€æ˜èƒŒæ™¯
    sceneRef.current = scene;
    
    // ç›¸æœº
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 12, 35);
    camera.lookAt(0, 10, 0);
    cameraRef.current = camera;
    
    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // åœ°é¢ç½‘æ ¼
    const gridHelper = new THREE.GridHelper(40, 20, 0x333333, 0x1a1a1a);
    gridHelper.position.y = -2;
    scene.add(gridHelper);
    
    // åæ ‡è½´ (å°å‹)
    const axesHelper = new THREE.AxesHelper(3);
    axesHelper.position.set(-15, -2, -15);
    scene.add(axesHelper);
    
    // ç²’å­å‘å°„ä½“
    const projGeo = new THREE.SphereGeometry(0.5, 16, 16);
    const projMat = new THREE.MeshBasicMaterial({ 
      color: 0x4ade80,
      transparent: true,
      opacity: 0.9
    });
    const projectile = new THREE.Mesh(projGeo, projMat);
    scene.add(projectile);
    projectileRef.current = projectile;
    
    // è·¯å¾„çº¿
    const lineMat = new THREE.LineBasicMaterial({ 
      color: 0x4ade80, 
      transparent: true, 
      opacity: 0.6,
      linewidth: 2
    });
    const lineGeo = new THREE.BufferGeometry();
    const pathLine = new THREE.Line(lineGeo, lineMat);
    scene.add(pathLine);
    pathLineRef.current = pathLine;
    
    // ç®­å¤´ç»„
    const arrowsGroup = new THREE.Group();
    scene.add(arrowsGroup);
    arrowsRef.current = arrowsGroup;
    
    // åŠ¨ç”»å¾ªç¯
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        animationTimeRef.current += 0.016;
        
        // æ²¿è·¯å¾„ç§»åŠ¨ç²’å­
        if (pathPointsRef.current.length > 0 && projectileRef.current) {
          const totalPoints = pathPointsRef.current.length;
          const loopTime = 2.5;  // 2.5ç§’å®Œæˆä¸€ä¸ªå¾ªç¯
          const t = (animationTimeRef.current % loopTime) / loopTime;
          const idx = Math.min(Math.floor(t * totalPoints), totalPoints - 1);
          
          const point = pathPointsRef.current[idx];
          projectileRef.current.position.copy(point);
          
          // ç²’å­åœ¨è·¯å¾„æœ«å°¾æ¸éš
          const fadeStart = 0.8;
          if (t > fadeStart) {
            (projectileRef.current.material as THREE.MeshBasicMaterial).opacity = 
              1 - ((t - fadeStart) / (1 - fadeStart));
          } else {
            (projectileRef.current.material as THREE.MeshBasicMaterial).opacity = 0.9;
          }
        }
        
        // ç¼“æ…¢æ—‹è½¬ç›¸æœº
        const camAngle = animationTimeRef.current * 0.15;
        cameraRef.current.position.x = Math.sin(camAngle) * 35;
        cameraRef.current.position.z = Math.cos(camAngle) * 35;
        cameraRef.current.lookAt(0, 8, 0);
        
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };
    animate();
    
    // Resize
    const handleResize = () => {
      if (containerRef.current && cameraRef.current && rendererRef.current) {
        const w = containerRef.current.clientWidth;
        const h = containerRef.current.clientHeight;
        cameraRef.current.aspect = w / h;
        cameraRef.current.updateProjectionMatrix();
        rendererRef.current.setSize(w, h);
      }
    };
    window.addEventListener('resize', handleResize);
    
    return () => {
      cancelAnimationFrame(frameRef.current);
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      if (container.contains(renderer.domElement)) {
        container.removeChild(renderer.domElement);
      }
    };
  }, []);
  
  // å½“è½¨è¿¹ç±»å‹æˆ–å‚æ•°å˜åŒ–æ—¶ï¼Œé‡æ–°ç”Ÿæˆè·¯å¾„
  useEffect(() => {
    if (!sceneRef.current || !pathLineRef.current || !arrowsRef.current) return;
    
    // æ¸…ç†æ—§ç®­å¤´
    while (arrowsRef.current.children.length > 0) {
      arrowsRef.current.remove(arrowsRef.current.children[0]);
    }
    
    if (!trajectoryType) {
      pathPointsRef.current = [];
      pathLineRef.current.geometry.setFromPoints([]);
      if (projectileRef.current) projectileRef.current.visible = false;
      return;
    }
    
    if (projectileRef.current) projectileRef.current.visible = true;
    
    // ç”Ÿæˆå®Œæ•´è½¨è¿¹è·¯å¾„
    const points = generateTrajectoryPath(trajectoryType, speed, height, angle);
    pathPointsRef.current = points;
    
    // æ›´æ–°è·¯å¾„çº¿
    pathLineRef.current.geometry.setFromPoints(points);
    
    // æ·»åŠ é€Ÿåº¦ç®­å¤´ (æ¯éš”ä¸€å®šè·ç¦»)
    const arrowInterval = Math.ceil(points.length / 8);
    for (let i = arrowInterval; i < points.length - 5; i += arrowInterval) {
      const point = points[i];
      const nextPoint = points[Math.min(i + 5, points.length - 1)];
      
      // è®¡ç®—æ–¹å‘
      const direction = new THREE.Vector3()
        .subVectors(nextPoint, point)
        .normalize();
      
      // è®¡ç®—é€Ÿåº¦å¤§å° (ç”¨äºç®­å¤´é•¿åº¦)
      const velocity = new THREE.Vector3().subVectors(nextPoint, point).length();
      const arrowLength = Math.min(velocity * 0.8, 3);
      
      // åˆ›å»ºç®­å¤´
      const arrow = createArrow(direction, arrowLength, i / points.length);
      arrow.position.copy(point);
      arrowsRef.current.add(arrow);
    }
    
    // é‡ç½®åŠ¨ç”»æ—¶é—´
    animationTimeRef.current = 0;
    
  }, [trajectoryType, speed, height, angle]);
  
  // è·å–è½¨è¿¹ä¿¡æ¯
  const info = trajectoryType ? TRAJECTORY_INFO[trajectoryType] : null;
  
  return (
    <div className={`relative w-full h-full overflow-hidden ${className}`}>
      {/* 3D Canvas */}
      <div ref={containerRef} className="absolute inset-0 z-0" />
      
      {/* å‚æ•°æ˜¾ç¤º */}
      {trajectoryType && (
        <div className="absolute top-3 right-3 bg-black/50 backdrop-blur-sm rounded-lg p-2 text-right">
          <div className="text-[8px] text-white/50 font-mono">
            <div>Speed: {speed.toFixed(1)}</div>
            <div>Height: {(height/10).toFixed(0)}m</div>
            <div>Angle: {angle}Â°</div>
          </div>
        </div>
      )}
      
      {/* åº•éƒ¨ä¿¡æ¯ */}
      <div className="absolute inset-x-0 bottom-0 flex flex-col items-center justify-end pb-3 pointer-events-none z-10">
        {!trajectoryType ? (
          <div className="text-white/40 text-xs font-bold uppercase tracking-widest bg-black/30 px-4 py-2 rounded-full backdrop-blur-sm">
            Select a Path
          </div>
        ) : (
          <div className="flex flex-col items-center gap-1">
            <div className="flex items-center gap-2 animate-pulse">
              <span className="text-lg">{info?.icon}</span>
            </div>
            <div className="text-[10px] font-black text-emerald-400 uppercase tracking-[0.15em] drop-shadow-md bg-black/60 backdrop-blur-md px-3 py-1 rounded-full border border-emerald-500/30">
              {info?.name}
            </div>
            <div className="text-[8px] text-white/50 font-medium max-w-[180px] text-center">
              {info?.description}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// ============ 2D Canvas é¢„è§ˆ (ç”¨äºä¸‹æ‹‰æ¡†ä¾§è¾¹é¢„è§ˆ) ============
interface TrajectoryPreviewCanvasProps {
  trajectoryType: TrajectoryType | null;
  className?: string;
}

export const TrajectoryPreviewCanvas: React.FC<TrajectoryPreviewCanvasProps> = ({
  trajectoryType,
  className = ''
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const timeRef = useRef<number>(0);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d')!;
    const width = canvas.width = 192;
    const height = canvas.height = 192;
    
    // ç”Ÿæˆ2Dè·¯å¾„ç‚¹
    const path2D = trajectoryType ? generate2DPath(trajectoryType) : [];
    
    const animate = () => {
      animationRef.current = requestAnimationFrame(animate);
      timeRef.current += 0.02;
      
      // æ¸…ç©º
      ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
      ctx.fillRect(0, 0, width, height);
      
      if (path2D.length === 0) {
        // æ— è½¨è¿¹æ—¶æ˜¾ç¤ºæç¤º
        ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Hover to Preview', width / 2, height / 2);
        return;
      }
      
      // ç»˜åˆ¶è·¯å¾„
      ctx.strokeStyle = 'rgba(74, 222, 128, 0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      path2D.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();
      
      // ç»˜åˆ¶ç®­å¤´
      const arrowInterval = Math.ceil(path2D.length / 6);
      ctx.fillStyle = 'rgba(74, 222, 128, 0.8)';
      for (let i = arrowInterval; i < path2D.length - 3; i += arrowInterval) {
        const p = path2D[i];
        const next = path2D[Math.min(i + 3, path2D.length - 1)];
        const angle = Math.atan2(next.y - p.y, next.x - p.x);
        drawArrow(ctx, p.x, p.y, angle, 6);
      }
      
      // åŠ¨ç”»ç²’å­
      const loopTime = 2.0;
      const t = (timeRef.current % loopTime) / loopTime;
      const idx = Math.floor(t * path2D.length);
      if (idx < path2D.length) {
        const pos = path2D[idx];
        
        // å‘å…‰æ•ˆæœ
        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 15);
        gradient.addColorStop(0, 'rgba(74, 222, 128, 1)');
        gradient.addColorStop(0.5, 'rgba(74, 222, 128, 0.3)');
        gradient.addColorStop(1, 'rgba(74, 222, 128, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // æ ¸å¿ƒç‚¹
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // èµ·ç‚¹æ ‡è®°
      if (path2D.length > 0) {
        ctx.strokeStyle = 'rgba(251, 146, 60, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const start = path2D[0];
        ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
        ctx.stroke();
      }
    };
    
    animate();
    
    return () => {
      cancelAnimationFrame(animationRef.current);
    };
  }, [trajectoryType]);
  
  return (
    <canvas 
      ref={canvasRef} 
      className={`${className}`}
      style={{ width: '100%', height: '100%' }}
    />
  );
};

// ============ è¾…åŠ©å‡½æ•° ============

/**
 * ç”Ÿæˆ3Dè½¨è¿¹è·¯å¾„ç‚¹ - å¢å¼ºç‰ˆï¼Œè®©ä¸åŒè½¨è¿¹ç±»å‹çš„è§†è§‰å·®å¼‚æ›´æ˜æ˜¾
 */
function generateTrajectoryPath(
  type: TrajectoryType,
  speed: number,
  height: number,
  angle: number
): THREE.Vector3[] {
  const points: THREE.Vector3[] = [];
  const calculator = TrajectoryFactory.create(type);
  
  // åˆå§‹æ¡ä»¶
  const startPos = { x: 0, y: -2, z: 0 };
  const angleRad = (angle * Math.PI) / 180;
  let pos = new Vector3(startPos.x, startPos.y, startPos.z);
  let vel = new Vector3(
    Math.sin(angleRad) * speed * 0.3,  // å¢åŠ æ¨ªå‘é€Ÿåº¦çš„å½±å“
    speed * 1.2,  // å¢åŠ åˆå§‹ä¸Šå‡é€Ÿåº¦
    0
  );
  
  const maxTime = 4.0;  // å¢åŠ æ¨¡æ‹Ÿæ—¶é—´
  const dt = 0.015;     // æ›´ç»†è‡´çš„æ­¥é•¿
  const gravity = 0.04; // å¤§å¹…é™ä½é‡åŠ›ï¼Œè®©è½¨è¿¹æ›´å®Œæ•´
  
  // æ”¾å¤§å› å­ï¼šè®©è½¨è¿¹åœ¨é¢„è§ˆä¸­æ›´å¤§
  const scaleFactor = 5;
  
  for (let t = 0; t < maxTime; t += dt) {
    // è®°å½•ç‚¹ï¼ˆæ”¾å¤§åæ ‡ï¼‰
    points.push(new THREE.Vector3(
      pos.x * scaleFactor, 
      pos.y * scaleFactor, 
      pos.z * scaleFactor
    ));
    
    // ä½¿ç”¨è½¨è¿¹è®¡ç®—å™¨æ›´æ–°é€Ÿåº¦
    vel = calculator.calculate(vel, gravity, dt);
    
    // æ›´æ–°ä½ç½®
    pos.x += vel.x * dt * 2;  // å¢åŠ ä½ç½®å˜åŒ–çš„çµæ•åº¦
    pos.y += vel.y * dt * 2;
    pos.z += vel.z * dt * 2;
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡é«˜åº¦æˆ–å¼€å§‹ä¸‹è½å¤ªå¿«
    if (pos.y > height / 8 || vel.y < -5) break;
  }
  
  return points;
}

/**
 * ç”Ÿæˆ2Dè·¯å¾„ç‚¹ (ç”¨äºCanvasé¢„è§ˆ) - å¢å¼ºç‰ˆ
 */
function generate2DPath(type: TrajectoryType): { x: number; y: number }[] {
  const points: { x: number; y: number }[] = [];
  const calculator = TrajectoryFactory.create(type);
  
  // 2Dåæ ‡æ˜ å°„
  const width = 192;
  const height = 192;
  const startX = width / 2;
  const startY = height - 15;
  
  let posX = 0;
  let posY = 0;
  let vel = new Vector3(0, 25, 0);  // å¢åŠ åˆå§‹é€Ÿåº¦
  
  const maxTime = 3.5;   // å¢åŠ æ¨¡æ‹Ÿæ—¶é—´
  const dt = 0.02;
  const gravity = 0.05;  // é™ä½é‡åŠ›è®©è½¨è¿¹æ›´å®Œæ•´
  
  // å¢å¤§åæ ‡ç¼©æ”¾å› å­ï¼Œè®©ä¸åŒè½¨è¿¹çš„å·®å¼‚æ›´æ˜æ˜¾
  const scaleFactor = 8;
  
  for (let t = 0; t < maxTime; t += dt) {
    const screenX = startX + posX * scaleFactor;
    const screenY = startY - posY * scaleFactor;
    
    if (screenY > 5 && screenY < height - 5 && screenX > 5 && screenX < width - 5) {
      points.push({ x: screenX, y: screenY });
    }
    
    // æ›´æ–°ç‰©ç†
    vel = calculator.calculate(vel, gravity, dt);
    posX += vel.x * dt * 1.5;
    posY += vel.y * dt * 1.5;
    
    if (screenY < 8 || vel.y < -6) break;
  }
  
  return points;
}

/**
 * åˆ›å»º3Dç®­å¤´
 */
function createArrow(direction: THREE.Vector3, length: number, progress: number): THREE.Group {
  const group = new THREE.Group();
  
  // ç®­å¤´é¢œè‰²éšè¿›åº¦å˜åŒ–
  const hue = 160 - progress * 60;  // ä»é’è‰²åˆ°ç»¿è‰²
  const color = new THREE.Color(`hsl(${hue}, 80%, 60%)`);
  
  // ç®­å¤´å¤´éƒ¨ (é”¥å½¢)
  const coneGeo = new THREE.ConeGeometry(0.3, 0.8, 8);
  const coneMat = new THREE.MeshBasicMaterial({ 
    color,
    transparent: true,
    opacity: 0.8
  });
  const cone = new THREE.Mesh(coneGeo, coneMat);
  
  // å¯¹é½æ–¹å‘
  cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
  
  group.add(cone);
  
  return group;
}

/**
 * åœ¨Canvasä¸Šç»˜åˆ¶ç®­å¤´
 */
function drawArrow(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, size: number) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size * 0.5, -size * 0.5);
  ctx.lineTo(-size * 0.5, size * 0.5);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}


// =============================================================================
// FILE: src\components\ui\TutorialOverlay.tsx
// =============================================================================

// FILE: src/components/ui/TutorialOverlay.tsx
// å¼•å¯¼æ•™ç¨‹è¦†ç›–å±‚ - å¸®åŠ©ç”¨æˆ·äº†è§£å¦‚ä½•ä½¿ç”¨æ¨¡æ‹Ÿå™¨ (å¢å¼ºç‰ˆ)

import React, { useState, useEffect } from 'react';

interface TutorialStep {
  id: string;
  title: string;
  description: string;
  icon: string;
  position: 'center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'top-left';
  highlight?: string; // CSS selector to highlight
}

const TUTORIAL_STEPS: TutorialStep[] = [
  {
    id: 'welcome',
    title: 'æ¬¢è¿æ¥åˆ° Aetheris âœ¨',
    description: 'è¿™æ˜¯ä¸€ä¸ªæ¢ç´¢å…‰ä¸ç‰©ç†çš„ 3D ç²’å­å·¥åŠã€‚åœ¨è¿™é‡Œï¼Œæ‚¨å¯ä»¥æŒ‡æŒ¥æ˜Ÿç³»è¯ç”Ÿï¼Œç¼–æ’çƒŸèŠ±å¤§ç§€ï¼Œä½“éªŒçº¯ç²¹çš„è§†è§‰è‰ºæœ¯ã€‚',
    icon: 'ğŸ†',
    position: 'center'
  },
  {
    id: 'basic-nav',
    title: 'åŸºæœ¬äº¤äº’',
    description: 'ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨ï¼šæ—‹è½¬è§†è§’\nğŸ–±ï¸ å³é”®æ‹–åŠ¨ï¼šå¹³ç§»è§†è§’\nğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾è·ç¦»\nğŸ‘† ç‚¹å‡»ä»»æ„ç©ºç™½å¤„ï¼šåœ¨è¯¥ä½ç½®å‘å°„ä¸€æœµçƒŸèŠ±ï¼',
    icon: 'ğŸ®',
    position: 'center'
  },
  {
    id: 'workshop',
    title: 'åˆ›æ„å·¥åŠ (Workshop)',
    description: 'å³ä¸Šè§’çš„ã€åˆ›æ„å·¥åŠã€‘æ˜¯æ‚¨çš„åˆ›é€ ä¸­å¿ƒã€‚åœ¨è¿™é‡Œæ‚¨å¯ä»¥ï¼š\n- æŒ‘é€‰å‡ åç§é«˜çº§ 3D å½¢çŠ¶ (å…‹è±å› ç“¶ã€çˆ±å¿ƒã€èºæ—‹...)\n- é¢„è§ˆå¹¶é€‰æ‹©ç‹¬ç‰¹çš„ä¸Šå‡è½¨è¿¹\n- ç¼–æ’è‡ªåŠ¨åŒ–çš„çƒŸèŠ±å¤§ç§€å‰§æœ¬',
    icon: 'ğŸ¨',
    position: 'top-right'
  },
  {
    id: 'trajectory-preview',
    title: 'å…¨æ–°ï¼è½¨è¿¹é¢„è§ˆ',
    description: 'è¿›å…¥åˆ›æ„å·¥åŠçš„â€œä¸Šå‡è½¨è¿¹â€é¢æ¿ï¼Œå°†é¼ æ ‡æ‚¬æµ®åœ¨è½¨è¿¹å¡ç‰‡ä¸Šï¼Œå³å¯çœ‹åˆ°é€¼çœŸçš„ 3D è·¯å¾„åŠ¨æ€é¢„è§ˆï¼æ‰€è§å³æ‰€å¾—ã€‚',
    icon: 'ğŸš€',
    position: 'top-right'
  },
  {
    id: 'time-control',
    title: 'æ—¶ç©ºæ§åˆ¶å°',
    description: 'åº•éƒ¨çš„æ§åˆ¶é¢æ¿è®©æ‚¨æˆä¸ºæ—¶é—´çš„é­”æ³•å¸ˆã€‚\nâ¸ï¸ æš‚åœæ—¶é—´ï¼šå®šæ ¼çˆ†ç‚¸ç¬é—´\nâª æ…¢åŠ¨ä½œï¼šä»¥ 0.1x é€Ÿåº¦æ¬£èµæ¯ä¸€ä¸ªç²’å­çš„ç»½æ”¾\nğŸ”„ è‡ªåŠ¨æ—‹è½¬ï¼šå¼€å¯æ²‰æµ¸å¼ç¯ç»•è§†è§’',
    icon: 'â³',
    position: 'bottom-center'
  },
  {
    id: 'carnival',
    title: 'å¤§ç§€ä¸äº¤äº’',
    description: 'æƒ³è¦æ›´éœ‡æ’¼çš„ä½“éªŒï¼Ÿåœ¨å·¥åŠä¸­æŸ¥æ‰¾â€œå¤§ç§€ç¼–æ’â€ï¼Œä¸€é”®å¯åŠ¨ç»è¿‡ç²¾å¿ƒè®¾è®¡çš„çƒŸèŠ±äº¤å“ä¹ã€‚æ‚¨ä¹Ÿå¯ä»¥è‡ªå®šä¹‰äº¤äº’å‰§æœ¬ï¼Œè®©æ¯ä¸€æ¬¡ç‚¹å‡»éƒ½å……æ»¡æƒŠå–œã€‚',
    icon: 'ğŸ­',
    position: 'top-right'
  },
  {
    id: 'ready',
    title: 'å¼€å§‹åˆ›é€ ï¼',
    description: 'èˆå°å·²ä¸ºæ‚¨å°±ç»ªã€‚å»ç‚¹äº®è¿™ç‰‡å¤œç©ºå§ï¼\n(æç¤ºï¼šç‚¹å‡»è®¾ç½®é¢æ¿å¤–éƒ¨çš„ç©ºç™½åŒºåŸŸå¯å¿«é€Ÿå…³é—­é¢æ¿)',
    icon: 'âœ¨',
    position: 'center'
  }
];

interface TutorialOverlayProps {
  onComplete: () => void;
}

export const useTutorial = () => {
  const [showTutorial, setShowTutorial] = useState(false);

  useEffect(() => {
    const hasSeenTutorial = localStorage.getItem('aetheris_tutorial_seen_v2');
    if (!hasSeenTutorial) {
      setShowTutorial(true);
    }
  }, []);

  const completeTutorial = () => {
    localStorage.setItem('aetheris_tutorial_seen_v2', 'true');
    setShowTutorial(false);
  };

  const resetTutorial = () => {
    localStorage.removeItem('aetheris_tutorial_seen_v2');
    setShowTutorial(true);
  };

  return { showTutorial, completeTutorial, resetTutorial };
};

export const TutorialOverlay: React.FC<TutorialOverlayProps> = ({ onComplete }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [isVisible, setIsVisible] = useState(true);
  
  const step = TUTORIAL_STEPS[currentStep];
  const isLastStep = currentStep === TUTORIAL_STEPS.length - 1;
  const progress = ((currentStep + 1) / TUTORIAL_STEPS.length) * 100;
  
  const handleNext = () => {
    if (isLastStep) {
      setIsVisible(false);
      setTimeout(onComplete, 300);
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };
  
  const handleSkip = () => {
    setIsVisible(false);
    setTimeout(onComplete, 300);
  };
  
  const handlePrev = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };
  
  // è·å–ä½ç½®æ ·å¼
  const getPositionStyles = () => {
    switch (step.position) {
      case 'top-right':
        return 'top-24 right-8';
      case 'top-left':
        return 'top-24 left-8';
      case 'bottom-left':
        return 'bottom-24 left-8';
      case 'bottom-center':
        return 'bottom-32 left-1/2 -translate-x-1/2';
      default:
        return 'top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
    }
  };
  
  return (
    <div 
      className={`
        fixed inset-0 z-[100] transition-opacity duration-300
        ${isVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}
      `}
    >
      {/* èƒŒæ™¯é®ç½© */}
      <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm" />
      
      {/* æ•™ç¨‹å¡ç‰‡ */}
      <div className={`absolute ${getPositionStyles()} w-[420px] max-w-[90vw] transition-all duration-500 ease-out`}>
        <div className="bg-white/90 backdrop-blur-xl rounded-[32px] shadow-2xl overflow-hidden border border-white/40 ring-1 ring-white/50 animate-slideUp">
          {/* è¿›åº¦æ¡ */}
          <div className="h-1.5 bg-gray-100/50">
            <div 
              className="h-full bg-gradient-to-r from-emerald-400 to-teal-500 transition-all duration-500 shadow-[0_0_10px_rgba(16,185,129,0.5)]"
              style={{ width: `${progress}%` }}
            />
          </div>
          
          {/* å†…å®¹ */}
          <div className="p-8">
            {/* å›¾æ ‡å’Œæ ‡é¢˜ */}
            <div className="flex items-start gap-5 mb-6">
              <div className="w-16 h-16 shrink-0 rounded-2xl bg-gradient-to-br from-white to-emerald-50 border border-emerald-100/50 flex items-center justify-center text-4xl shadow-lg shadow-emerald-100">
                {step.icon}
              </div>
              <div>
                <h3 className="text-xl font-black text-gray-800 tracking-tight mb-1">{step.title}</h3>
                <p className="text-xs font-bold text-gray-400 uppercase tracking-widest">Step {currentStep + 1} of {TUTORIAL_STEPS.length}</p>
              </div>
            </div>
            
            {/* æè¿° */}
            <div className="text-gray-600 text-sm leading-relaxed mb-8 whitespace-pre-line font-medium p-4 bg-white/50 rounded-2xl border border-white/50">
              {step.description}
            </div>
            
            {/* æ­¥éª¤æŒ‡ç¤ºå™¨ */}
            <div className="flex justify-center gap-2 mb-8">
              {TUTORIAL_STEPS.map((_, idx) => (
                <div
                  key={idx}
                  className={`
                    h-2 rounded-full transition-all duration-300
                    ${idx === currentStep 
                      ? 'bg-emerald-500 w-8 shadow-sm' 
                      : idx < currentStep 
                        ? 'bg-emerald-200 w-2' 
                        : 'bg-gray-200 w-2'
                    }
                  `}
                />
              ))}
            </div>
            
            {/* æŒ‰é’® */}
            <div className="flex gap-3">
              {currentStep > 0 && (
                <button
                  onClick={handlePrev}
                  className="px-5 py-3 rounded-xl bg-gray-100 text-gray-500 text-xs font-bold hover:bg-gray-200 transition-all"
                >
                  â† è¿”å›
                </button>
              )}
              
              <button
                onClick={handleSkip}
                className="px-5 py-3 rounded-xl text-gray-400 text-xs font-bold hover:text-gray-600 hover:bg-gray-50 transition-all ml-auto"
              >
                è·³è¿‡
              </button>
              
              <button
                onClick={handleNext}
                className="
                  px-8 py-3 rounded-xl text-xs font-black
                  bg-gradient-to-r from-emerald-500 to-teal-500 text-white
                  hover:from-emerald-600 hover:to-teal-600
                  shadow-lg shadow-emerald-200/50
                  transition-all hover:scale-105 active:scale-95
                  flex items-center gap-2
                "
              >
                {isLastStep ? 'å¼€å§‹ä½“éªŒ ğŸ‰' : 'ä¸‹ä¸€æ­¥ â†’'}
              </button>
            </div>
          </div>
        </div>
        
        {/* æŒ‡ç¤ºå…‰æ™• - ä»…ä½œä¸ºè£…é¥° */}
        <div className="absolute -inset-4 bg-emerald-500/20 blur-3xl -z-10 rounded-full opacity-0 animate-pulse" />
      </div>
      
      {/* å¿«æ·é”®æç¤ºæ¡ */}
      <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-6 text-white/50 text-[10px] font-mono tracking-wider backdrop-blur px-6 py-2 rounded-full bg-black/20 border border-white/10">
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Left Click</kbd>
          <span>Rotate</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Right Click</kbd>
          <span>Pan</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Scroll</kbd>
          <span>Zoom</span>
        </span>
      </div>
    </div>
  );
};


// =============================================================================
// FILE: src\core\AdvancedEffects.ts
// =============================================================================

/**
 * AdvancedEffects.ts - ç”µå½±çº§é«˜çº§æ¸²æŸ“æ•ˆæœ
 * 
 * å®ç°"ä¸ç°å®æ— æ³•åˆ†è¾¨"çš„æè‡´è§†è§‰æ•ˆæœï¼š
 * 
 * 1. ä½“ç§¯æ„ŸçƒŸé›¾ä¸è‡ªå‘å…‰é®è”½
 * 2. ç‰©ç†å¿«é—¨è¿åŠ¨æ¨¡ç³Š (é•¿æ›å…‰)
 * 3. å¤§æ°”æ•£å°„ä¸ä¸è¾¾å°”æ•ˆåº”
 * 4. é•œå¤´å…‰å­¦: å…‰æ™•ã€è‰²å·®ã€æ™¯æ·±
 * 5. é»‘ä½“è¾å°„é¢œè‰²æ¨¡æ‹Ÿ
 */

import * as THREE from 'three';

// ============================================================
// 1. ä½“ç§¯çƒŸé›¾ç³»ç»Ÿ
// ============================================================

/**
 * çƒŸé›¾ç²’å­é…ç½®
 */
export interface SmokeParticle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  size: number;
  opacity: number;
  color: THREE.Color;
  illumination: number;  // è¢«çƒŸèŠ±ç…§äº®çš„ç¨‹åº¦
}

/**
 * ä½“ç§¯çƒŸé›¾ç®¡ç†å™¨
 * æ¨¡æ‹ŸçƒŸèŠ±äº§ç”Ÿçš„çƒŸé›¾è¢«ç«å…‰ç…§äº®çš„æ•ˆæœ
 */
export class VolumetricSmokeSystem {
  private particles: SmokeParticle[] = [];
  private geometry: THREE.BufferGeometry;
  private material: THREE.PointsMaterial;
  private mesh: THREE.Points;
  private maxParticles: number;
  
  constructor(scene: THREE.Scene, maxParticles: number = 2000) {
    this.maxParticles = maxParticles;
    
    // åˆ›å»ºå‡ ä½•ä½“
    this.geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3);
    const colors = new Float32Array(maxParticles * 3);
    const sizes = new Float32Array(maxParticles);
    
    this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    // çƒŸé›¾æè´¨ï¼šä½¿ç”¨ additive æ··åˆæ¨¡æ‹Ÿå†…å‘å…‰
    this.material = new THREE.PointsMaterial({
      size: 20,
      map: this.createSmokeTexture(),
      vertexColors: true,
      transparent: true,
      opacity: 0.15,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });
    
    this.mesh = new THREE.Points(this.geometry, this.material);
    this.mesh.frustumCulled = false;
    scene.add(this.mesh);
  }
  
  /**
   * åˆ›å»ºæŸ”å’Œçš„çƒŸé›¾çº¹ç†
   */
  private createSmokeTexture(): THREE.Texture {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d')!;
    
    // å¤šå±‚é«˜æ–¯æ¸å˜æ¨¡æ‹ŸçƒŸé›¾
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
    gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
    gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.05)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
  }
  
  /**
   * åœ¨æŒ‡å®šä½ç½®ç”ŸæˆçƒŸé›¾
   */
  emit(position: THREE.Vector3, color: THREE.Color, intensity: number = 1): void {
    if (this.particles.length >= this.maxParticles) {
      // å›æ”¶æœ€è€çš„ç²’å­
      this.particles.shift();
    }
    
    // æ·»åŠ éšæœºåç§»
    const spread = 5;
    const smokePos = new THREE.Vector3(
      position.x + (Math.random() - 0.5) * spread,
      position.y + (Math.random() - 0.5) * spread,
      position.z + (Math.random() - 0.5) * spread
    );
    
    // çƒŸé›¾ç¼“æ…¢ä¸Šå‡å’Œæ‰©æ•£
    const velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.5,
      Math.random() * 0.8 + 0.2,  // ä¸»è¦å‘ä¸Š
      (Math.random() - 0.5) * 0.5
    );
    
    this.particles.push({
      position: smokePos,
      velocity,
      life: 1,
      maxLife: 3 + Math.random() * 2,  // 3-5ç§’ç”Ÿå‘½
      size: 15 + Math.random() * 20,
      opacity: 0.1 + Math.random() * 0.1,
      color: color.clone(),
      illumination: intensity
    });
  }
  
  /**
   * æ›´æ–°çƒŸé›¾ç‰©ç†å’Œæ¸²æŸ“
   */
  update(deltaTime: number, lightSources: { position: THREE.Vector3; color: THREE.Color; intensity: number }[] = []): void {
    const positions = this.geometry.attributes.position.array as Float32Array;
    const colors = this.geometry.attributes.color.array as Float32Array;
    const sizes = this.geometry.attributes.size.array as Float32Array;
    
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      
      // æ›´æ–°ç”Ÿå‘½
      p.life -= deltaTime / p.maxLife;
      
      if (p.life <= 0) {
        this.particles.splice(i, 1);
        continue;
      }
      
      // ç‰©ç†æ›´æ–°ï¼šç¼“æ…¢æ‰©æ•£
      p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
      p.velocity.y *= 0.99;  // é˜»åŠ›
      p.size += deltaTime * 5;  // é€æ¸å˜å¤§
      
      // è®¡ç®—å…‰ç…§ï¼šè¢«å‘¨å›´å…‰æºç…§äº®
      let totalIllumination = p.illumination * 0.95;  // è¡°å‡
      const illuminatedColor = p.color.clone();
      
      for (const light of lightSources) {
        const dist = p.position.distanceTo(light.position);
        if (dist < 100) {
          const falloff = 1 - (dist / 100);
          const contrib = falloff * falloff * light.intensity * 0.3;
          totalIllumination += contrib;
          
          // Mie æ•£å°„ï¼šå…‰æŸ“çƒŸé›¾
          illuminatedColor.lerp(light.color, contrib * 0.5);
        }
      }
      
      p.illumination = Math.min(totalIllumination, 1);
      
      // æ›´æ–° buffer
      const idx3 = i * 3;
      positions[idx3] = p.position.x;
      positions[idx3 + 1] = p.position.y;
      positions[idx3 + 2] = p.position.z;
      
      // é¢œè‰²å—å…‰ç…§å½±å“
      const fadeAlpha = p.life * p.illumination;
      colors[idx3] = illuminatedColor.r * fadeAlpha;
      colors[idx3 + 1] = illuminatedColor.g * fadeAlpha;
      colors[idx3 + 2] = illuminatedColor.b * fadeAlpha;
      
      sizes[i] = p.size * p.life;
    }
    
    // éšè—æœªä½¿ç”¨çš„ç²’å­
    for (let i = this.particles.length; i < this.maxParticles; i++) {
      const idx3 = i * 3;
      positions[idx3 + 1] = -10000;
    }
    
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  }
  
  dispose(): void {
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============================================================
// 2. è¿åŠ¨æ¨¡ç³Š (é•¿æ›å…‰æ•ˆæœ)
// ============================================================

/**
 * è¿åŠ¨æ¨¡ç³Šç€è‰²å™¨
 * åŸºäºé€Ÿåº¦å‘é‡çš„åŠ¨æ€æ¨¡ç³Š
 */
export const MotionBlurShader = {
  name: 'MotionBlurShader',
  uniforms: {
    tDiffuse: { value: null },
    tVelocity: { value: null },  // é€Ÿåº¦ç¼“å†²
    velocityFactor: { value: 0.5 },
    samples: { value: 16 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform sampler2D tVelocity;
    uniform float velocityFactor;
    uniform int samples;
    varying vec2 vUv;
    
    void main() {
      vec2 velocity = texture2D(tVelocity, vUv).rg * velocityFactor;
      
      vec4 color = vec4(0.0);
      vec2 offset = velocity / float(samples);
      
      for(int i = 0; i < 32; i++) {
        if(i >= samples) break;
        vec2 sampleUv = vUv + offset * float(i - samples / 2);
        color += texture2D(tDiffuse, sampleUv);
      }
      
      gl_FragColor = color / float(samples);
    }
  `
};

/**
 * ç´¯ç§¯ç¼“å†²è¿åŠ¨æ¨¡ç³Š (é•¿æ›å…‰)
 */
export class AccumulationBuffer {
  private accumTexture: THREE.WebGLRenderTarget;
  private blendAmount: number;
  
  constructor(width: number, height: number, blendAmount: number = 0.9) {
    this.blendAmount = blendAmount;
    this.accumTexture = new THREE.WebGLRenderTarget(width, height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      type: THREE.FloatType
    });
  }
  
  /**
   * è·å–ç´¯ç§¯çº¹ç†
   */
  getTexture(): THREE.Texture {
    return this.accumTexture.texture;
  }
  
  /**
   * è®¾ç½®æ··åˆé‡ (0=æ— æ¨¡ç³Š, 0.99=å¼ºçƒˆæ‹–å°¾)
   */
  setBlendAmount(amount: number): void {
    this.blendAmount = Math.max(0, Math.min(0.99, amount));
  }
  
  resize(width: number, height: number): void {
    this.accumTexture.setSize(width, height);
  }
  
  dispose(): void {
    this.accumTexture.dispose();
  }
}

// ============================================================
// 3. å¤§æ°”æ•£å°„ä¸ä¸è¾¾å°”æ•ˆåº” (God Rays)
// ============================================================

/**
 * ä¸è¾¾å°”æ•ˆåº”/å…‰æŸ±ç€è‰²å™¨
 */
export const GodRaysShader = {
  name: 'GodRaysShader',
  uniforms: {
    tDiffuse: { value: null },
    tDepth: { value: null },
    lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
    exposure: { value: 0.3 },
    decay: { value: 0.95 },
    density: { value: 0.8 },
    weight: { value: 0.5 },
    samples: { value: 60 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec2 lightPosition;
    uniform float exposure;
    uniform float decay;
    uniform float density;
    uniform float weight;
    uniform int samples;
    varying vec2 vUv;
    
    void main() {
      vec2 deltaTextCoord = vUv - lightPosition;
      deltaTextCoord *= 1.0 / float(samples) * density;
      
      vec2 coord = vUv;
      vec4 color = texture2D(tDiffuse, coord);
      float illuminationDecay = 1.0;
      
      for(int i = 0; i < 100; i++) {
        if(i >= samples) break;
        coord -= deltaTextCoord;
        vec4 sampleColor = texture2D(tDiffuse, coord);
        sampleColor *= illuminationDecay * weight;
        color += sampleColor;
        illuminationDecay *= decay;
      }
      
      gl_FragColor = color * exposure;
    }
  `
};

// ============================================================
// 4. é•œå¤´å…‰å­¦æ•ˆæœ
// ============================================================

/**
 * é•œå¤´å…‰æ™• (Lens Flare) é…ç½®
 */
export interface LensFlareConfig {
  enabled: boolean;
  intensity: number;
  size: number;
  haloSize: number;
  ghostCount: number;
  threshold: number;
}

/**
 * é•œå¤´å…‰æ™•ç€è‰²å™¨
 */
export const LensFlareShader = {
  name: 'LensFlareShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.3 },
    threshold: { value: 0.8 },
    ghostCount: { value: 5 },
    ghostSpacing: { value: 0.3 },
    haloWidth: { value: 0.6 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float threshold;
    uniform int ghostCount;
    uniform float ghostSpacing;
    uniform float haloWidth;
    varying vec2 vUv;
    
    vec3 sampleGhost(vec2 uv, float offset) {
      vec2 ghostUv = vec2(1.0) - uv;
      ghostUv = mix(vec2(0.5), ghostUv, offset);
      
      if(ghostUv.x < 0.0 || ghostUv.x > 1.0 || ghostUv.y < 0.0 || ghostUv.y > 1.0) {
        return vec3(0.0);
      }
      
      vec3 color = texture2D(tDiffuse, ghostUv).rgb;
      float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));
      
      if(brightness < threshold) return vec3(0.0);
      
      return color * (brightness - threshold);
    }
    
    void main() {
      vec4 base = texture2D(tDiffuse, vUv);
      vec3 flare = vec3(0.0);
      
      // å¹½çµå›¾åƒ
      for(int i = 0; i < 10; i++) {
        if(i >= ghostCount) break;
        float offset = ghostSpacing * float(i + 1);
        flare += sampleGhost(vUv, offset) * (1.0 / float(i + 1));
      }
      
      // å…‰ç¯
      vec2 haloVec = vec2(0.5) - vUv;
      float haloDist = length(haloVec);
      float halo = pow(1.0 - abs(haloDist - haloWidth), 5.0);
      halo *= texture2D(tDiffuse, vUv + normalize(haloVec) * haloWidth).r;
      flare += vec3(halo) * 0.5;
      
      gl_FragColor = vec4(base.rgb + flare * intensity, base.a);
    }
  `
};

/**
 * æ™¯æ·±ç€è‰²å™¨ (Depth of Field)
 */
export const DepthOfFieldShader = {
  name: 'DepthOfFieldShader',
  uniforms: {
    tDiffuse: { value: null },
    tDepth: { value: null },
    focusDistance: { value: 300.0 },
    focusRange: { value: 150.0 },
    maxBlur: { value: 3.0 },
    resolution: { value: new THREE.Vector2(1, 1) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform sampler2D tDepth;
    uniform float focusDistance;
    uniform float focusRange;
    uniform float maxBlur;
    uniform vec2 resolution;
    varying vec2 vUv;
    
    float getDepth(vec2 uv) {
      return texture2D(tDepth, uv).r * 1000.0;
    }
    
    void main() {
      float depth = getDepth(vUv);
      float blur = clamp(abs(depth - focusDistance) / focusRange, 0.0, 1.0) * maxBlur;
      
      if(blur < 0.5) {
        gl_FragColor = texture2D(tDiffuse, vUv);
        return;
      }
      
      vec2 texelSize = 1.0 / resolution;
      vec4 color = vec4(0.0);
      float total = 0.0;
      
      // ç®€å•çš„æ¡†æ¨¡ç³Š
      for(float x = -3.0; x <= 3.0; x += 1.0) {
        for(float y = -3.0; y <= 3.0; y += 1.0) {
          vec2 offset = vec2(x, y) * texelSize * blur;
          color += texture2D(tDiffuse, vUv + offset);
          total += 1.0;
        }
      }
      
      gl_FragColor = color / total;
    }
  `
};

// ============================================================
// 5. é»‘ä½“è¾å°„é¢œè‰²
// ============================================================

/**
 * åŸºäºæ¸©åº¦çš„é»‘ä½“è¾å°„é¢œè‰²
 * çœŸå®æ¨¡æ‹Ÿé‡‘å±/ç«ç„°éšæ¸©åº¦å˜åŒ–çš„é¢œè‰²
 * 
 * @param temperature æ¸©åº¦ (Kelvin), 1000-15000
 * @returns RGB é¢œè‰²
 */
export function blackbodyColor(temperature: number): { r: number; g: number; b: number } {
  // Clamp temperature
  const temp = Math.max(1000, Math.min(15000, temperature));
  const t = temp / 100;
  
  let r: number, g: number, b: number;
  
  // çº¢è‰²é€šé“
  if (t <= 66) {
    r = 255;
  } else {
    r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  
  // ç»¿è‰²é€šé“
  if (t <= 66) {
    g = 99.4708025861 * Math.log(t) - 161.1195681661;
  } else {
    g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  
  // è“è‰²é€šé“
  if (t >= 66) {
    b = 255;
  } else if (t <= 19) {
    b = 0;
  } else {
    b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  
  return {
    r: r / 255,
    g: g / 255,
    b: b / 255
  };
}

/**
 * æ ¹æ®ç”Ÿå‘½å€¼è®¡ç®—å†·å´é¢œè‰²
 * æ¨¡æ‹Ÿç«èŠ±ä»äº®é»„è‰²å†·å´åˆ°æš—çº¢è‰²çš„è¿‡ç¨‹
 * 
 * @param life ç”Ÿå‘½å€¼ (0-1)
 * @param baseHue åŸºç¡€è‰²ç›¸
 * @returns THREE.Color
 */
export function coolingColor(life: number, baseHue: number = 0): THREE.Color {
  // ç”Ÿå‘½å€¼é«˜æ—¶: é«˜æ¸© (6000K - ç™½/é»„)
  // ç”Ÿå‘½å€¼ä½æ—¶: ä½æ¸© (2000K - çº¢/æš—çº¢)
  const temperature = 2000 + life * 4000;
  const blackbody = blackbodyColor(temperature);
  
  // æ··åˆåŸºç¡€è‰²ç›¸
  const baseColor = new THREE.Color();
  baseColor.setHSL(baseHue / 360, 0.8, 0.5);
  
  const finalColor = new THREE.Color(blackbody.r, blackbody.g, blackbody.b);
  finalColor.lerp(baseColor, 0.3 * life);  // é«˜ç”Ÿå‘½æ—¶æ›´å¤šåŸè‰²
  
  // ä½ç”Ÿå‘½æ—¶é™ä½äº®åº¦
  if (life < 0.3) {
    finalColor.multiplyScalar(life / 0.3);
  }
  
  return finalColor;
}

// ============================================================
// 6. ç»¼åˆæ•ˆæœç®¡ç†å™¨
// ============================================================

/**
 * é«˜çº§æ•ˆæœé…ç½®
 */
export interface AdvancedEffectsConfig {
  // çƒŸé›¾
  smokeEnabled: boolean;
  smokeIntensity: number;
  
  // è¿åŠ¨æ¨¡ç³Š
  motionBlurEnabled: boolean;
  motionBlurStrength: number;
  
  // God Rays
  godRaysEnabled: boolean;
  godRaysIntensity: number;
  
  // é•œå¤´æ•ˆæœ
  lensFlareEnabled: boolean;
  lensFlareIntensity: number;
  depthOfFieldEnabled: boolean;
  focusDistance: number;
  
  // é¢œè‰²
  useBlackbodyColors: boolean;
}

/**
 * é»˜è®¤é«˜çº§æ•ˆæœé…ç½®
 */
export const DEFAULT_ADVANCED_EFFECTS: AdvancedEffectsConfig = {
  smokeEnabled: true,
  smokeIntensity: 0.3,
  
  motionBlurEnabled: false,  // é»˜è®¤å…³é—­ï¼Œæ€§èƒ½è€ƒé‡
  motionBlurStrength: 0.5,
  
  godRaysEnabled: false,     // é»˜è®¤å…³é—­
  godRaysIntensity: 0.3,
  
  lensFlareEnabled: true,
  lensFlareIntensity: 0.2,
  depthOfFieldEnabled: false,
  focusDistance: 300,
  
  useBlackbodyColors: true
};

/**
 * é«˜æ€§èƒ½é…ç½® (å…³é—­å¤§éƒ¨åˆ†æ•ˆæœ)
 */
export const PERFORMANCE_ADVANCED_EFFECTS: AdvancedEffectsConfig = {
  smokeEnabled: false,
  smokeIntensity: 0,
  motionBlurEnabled: false,
  motionBlurStrength: 0,
  godRaysEnabled: false,
  godRaysIntensity: 0,
  lensFlareEnabled: false,
  lensFlareIntensity: 0,
  depthOfFieldEnabled: false,
  focusDistance: 300,
  useBlackbodyColors: false
};


// =============================================================================
// FILE: src\core\carnival\RandomGenerator.ts
// =============================================================================

// FILE: src/core/carnival/RandomGenerator.ts
// å˜‰å¹´åçœŸéšæœºç³»ç»Ÿ - åŠ å¯†çº§éšæœºæ•°ç”Ÿæˆ + æ™ºèƒ½ç­›é€‰

import { Shape3DType } from '../shapes/Shape3DFactory';
import { TrajectoryType } from '../trajectories/TrajectoryFactory';
import { ComboType } from '../combos/ComboManager';
import { CarnivalStage, LaunchFormation } from '../../types';

/**
 * éšæœºæ¨¡å¼é…ç½®
 */
export interface RandomModeConfig {
  enabled: boolean;
  
  // é˜¶æ®µæ•°èŒƒå›´
  minStages: number;   // 2-8
  maxStages: number;
  
  // æ—¶é—´é—´éš”èŒƒå›´
  minDelay: number;    // 0.5-10s
  maxDelay: number;
  
  // æ¯é˜¶æ®µå‘å°„æ•°é‡èŒƒå›´
  minCount: number;    // 1-20
  maxCount: number;
  
  // æƒé‡é…ç½® (å¯é€‰)
  weights?: {
    shapes?: Record<Shape3DType, number>;
    trajectories?: Record<TrajectoryType, number>;
    combos?: Record<ComboType, number>;
    formations?: Record<LaunchFormation, number>;
  };
  
  // æ’é™¤åˆ—è¡¨
  excludedShapes?: Shape3DType[];
  excludedTrajectories?: TrajectoryType[];
  excludedCombos?: ComboType[];
}

/**
 * é»˜è®¤éšæœºé…ç½®
 */
export const DEFAULT_RANDOM_CONFIG: RandomModeConfig = {
  enabled: false,
  minStages: 3,
  maxStages: 6,
  minDelay: 500,  // ms
  maxDelay: 2000,
  minCount: 3,
  maxCount: 10,
};

/**
 * çœŸéšæœºæ•°ç”Ÿæˆå™¨
 * ä½¿ç”¨ Crypto API æä¾›åŠ å¯†çº§éšæœºæ€§
 */
export class CryptoRandomGenerator {
  
  /**
   * ç”ŸæˆåŠ å¯†çº§éšæœºæ•° (0-1)
   */
  static random(): number {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const array = new Uint32Array(1);
      crypto.getRandomValues(array);
      return array[0] / 0xFFFFFFFF;
    }
    // å›é€€åˆ° Math.random
    return Math.random();
  }
  
  /**
   * ç”ŸæˆæŒ‡å®šèŒƒå›´çš„éšæœºæ•´æ•° [min, max]
   */
  static randomInt(min: number, max: number): number {
    return Math.floor(this.random() * (max - min + 1)) + min;
  }
  
  /**
   * ç”ŸæˆæŒ‡å®šèŒƒå›´çš„éšæœºæµ®ç‚¹æ•° [min, max)
   */
  static randomFloat(min: number, max: number): number {
    return this.random() * (max - min) + min;
  }
  
  /**
   * ä»æ•°ç»„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ 
   */
  static randomPick<T>(array: T[]): T {
    if (array.length === 0) throw new Error('Cannot pick from empty array');
    return array[Math.floor(this.random() * array.length)];
  }
  
  /**
   * å¸¦æƒé‡çš„éšæœºé€‰æ‹©
   * @param items é¡¹ç›®æ•°ç»„
   * @param weights å¯¹åº”æƒé‡æ•°ç»„ (æ­£æ•°)
   */
  static weightedPick<T>(items: T[], weights: number[]): T {
    if (items.length !== weights.length) throw new Error('Items and weights must have same length');
    
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = this.random() * totalWeight;
    
    for (let i = 0; i < items.length; i++) {
      random -= weights[i];
      if (random <= 0) return items[i];
    }
    
    return items[items.length - 1];
  }
  
  /**
   * æ´—ç‰Œç®—æ³• (Fisher-Yates)
   */
  static shuffle<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = Math.floor(this.random() * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
  
  /**
   * ç”Ÿæˆä¸é‡å¤çš„éšæœºé¢œè‰² (HSL)
   */
  static randomHue(): number {
    return Math.floor(this.random() * 360);
  }
  
  /**
   * ç”Ÿæˆæ¸å˜è‰²ç›¸ (ç¡®ä¿ç›¸é‚»ä¸ä¼šå¤ªç›¸ä¼¼)
   */
  static generateDistinctHues(count: number): number[] {
    const baseHue = this.randomHue();
    const step = 360 / count;
    const hues: number[] = [];
    
    for (let i = 0; i < count; i++) {
      hues.push((baseHue + i * step + this.randomFloat(-10, 10)) % 360);
    }
    
    return this.shuffle(hues);
  }
}

/**
 * å˜‰å¹´åéšæœºåºåˆ—ç”Ÿæˆå™¨
 */
export class CarnivalRandomSequenceGenerator {
  private config: RandomModeConfig;
  private enabledShapes: Shape3DType[] = [];
  private enabledTrajectories: TrajectoryType[] = [];
  private enabledCombos: ComboType[] = [];
  
  // å†å²è®°å½• (ç”¨äºé¿å…è¿ç»­ç›¸ä¼¼)
  private lastShape: Shape3DType | null = null;
  private lastTrajectory: TrajectoryType | null = null;
  
  constructor(config: RandomModeConfig) {
    this.config = config;
  }
  
  /**
   * è®¾ç½®å¯ç”¨çš„æ± 
   */
  setEnabledPools(
    shapes: Shape3DType[],
    trajectories: TrajectoryType[],
    combos: ComboType[]
  ): void {
    // åº”ç”¨æ’é™¤è§„åˆ™
    this.enabledShapes = shapes.filter(s => 
      !this.config.excludedShapes?.includes(s)
    );
    this.enabledTrajectories = trajectories.filter(t => 
      !this.config.excludedTrajectories?.includes(t)
    );
    this.enabledCombos = combos.filter(c => 
      !this.config.excludedCombos?.includes(c)
    );
  }
  
  /**
   * ç”Ÿæˆå®Œæ•´çš„éšæœºå˜‰å¹´ååºåˆ—
   */
  generateSequence(): CarnivalStage[] {
    if (!this.config.enabled) return [];
    
    const stageCount = CryptoRandomGenerator.randomInt(
      this.config.minStages,
      this.config.maxStages
    );
    
    const stages: CarnivalStage[] = [];
    
    for (let i = 0; i < stageCount; i++) {
      stages.push(this.generateStage(i, stageCount));
    }
    
    return stages;
  }
  
  /**
   * ç”Ÿæˆå•ä¸ªé˜¶æ®µ
   */
  private generateStage(index: number, total: number): CarnivalStage {
    const isOpeningOrFinale = index === 0 || index === total - 1;
    
    // é€‰æ‹©å½¢çŠ¶ (é¿å…ä¸ä¸Šä¸€ä¸ªç›¸åŒ)
    let shape = this.pickShape();
    let attempts = 0;
    while (shape === this.lastShape && attempts < 3) {
      shape = this.pickShape();
      attempts++;
    }
    this.lastShape = shape;
    
    // é€‰æ‹©è½¨è¿¹ (é¿å…ä¸ä¸Šä¸€ä¸ªç›¸åŒ)
    let trajectory = this.pickTrajectory();
    attempts = 0;
    while (trajectory === this.lastTrajectory && attempts < 3) {
      trajectory = this.pickTrajectory();
      attempts++;
    }
    this.lastTrajectory = trajectory;
    
    // é€‰æ‹©ç»„åˆæŠ€
    const combo = this.pickCombo();
    
    // é€‰æ‹©é˜Ÿå½¢
    const formation = this.pickFormation();
    
    // å‘å°„æ•°é‡ (å¼€åœºå’Œç»“å°¾æ›´å¤š)
    let count = CryptoRandomGenerator.randomInt(
      this.config.minCount,
      this.config.maxCount
    );
    if (isOpeningOrFinale) {
      count = Math.min(count * 2, 20);
    }
    
    // å»¶è¿Ÿ
    const delay = index === 0 
      ? 0 
      : CryptoRandomGenerator.randomInt(this.config.minDelay, this.config.maxDelay);
    
    // é˜¶æ®µåç§°
    const stageNames = [
      'åºç« ', 'å¯èˆª', 'ç»½æ”¾', 'é«˜æ½®', 'æ¶Ÿæ¼ª', 
      'å‡å', 'è½¬æŠ˜', 'å‹è½´', 'ç»ˆç« '
    ];
    const name = index === 0 
      ? 'åºå¹•' 
      : index === total - 1 
        ? 'ç»ˆç« ' 
        : stageNames[CryptoRandomGenerator.randomInt(1, stageNames.length - 2)];
    
    return {
      id: `random_stage_${index}`,
      name: `${name} #${index + 1}`,
      shape,
      trajectory,
      combo,
      formation,
      count,
      delay,
      interval: CryptoRandomGenerator.randomInt(50, 200),
      duration: CryptoRandomGenerator.randomFloat(2, 5),
    };
  }
  
  private pickShape(): Shape3DType {
    if (this.enabledShapes.length === 0) return Shape3DType.SPHERE;
    
    if (this.config.weights?.shapes) {
      const shapes = this.enabledShapes;
      const weights = shapes.map(s => this.config.weights!.shapes![s] || 1);
      return CryptoRandomGenerator.weightedPick(shapes, weights);
    }
    
    return CryptoRandomGenerator.randomPick(this.enabledShapes);
  }
  
  private pickTrajectory(): TrajectoryType {
    if (this.enabledTrajectories.length === 0) return TrajectoryType.LINEAR;
    
    if (this.config.weights?.trajectories) {
      const trajs = this.enabledTrajectories;
      const weights = trajs.map(t => this.config.weights!.trajectories![t] || 1);
      return CryptoRandomGenerator.weightedPick(trajs, weights);
    }
    
    return CryptoRandomGenerator.randomPick(this.enabledTrajectories);
  }
  
  private pickCombo(): ComboType {
    if (this.enabledCombos.length === 0) return ComboType.SINGLE;
    return CryptoRandomGenerator.randomPick(this.enabledCombos);
  }
  
  private pickFormation(): LaunchFormation {
    const formations = Object.values(LaunchFormation);
    
    if (this.config.weights?.formations) {
      const weights = formations.map(f => this.config.weights!.formations![f] || 1);
      return CryptoRandomGenerator.weightedPick(formations, weights);
    }
    
    return CryptoRandomGenerator.randomPick(formations);
  }
  
  /**
   * é¢„è§ˆæ¨¡å¼ï¼šç”Ÿæˆä½†ä¸æ˜¾ç¤ºå…·ä½“å†…å®¹
   */
  previewSequence(): { stageCount: number; estimatedDuration: number } {
    const seq = this.generateSequence();
    const totalDelay = seq.reduce((sum, s) => sum + s.delay, 0);
    const avgDuration = seq.reduce((sum, s) => sum + (s.duration || 3), 0) / seq.length;
    
    return {
      stageCount: seq.length,
      estimatedDuration: totalDelay + avgDuration * seq.length
    };
  }
}

// END OF FILE: src/core/carnival/RandomGenerator.ts


// =============================================================================
// FILE: src\core\combos\ComboManager.ts
// =============================================================================

// FILE: src/core/combos/ComboManager.ts
// ç»„åˆæŠ€ç³»ç»Ÿï¼šå®šä¹‰å¤šé˜¶æ®µçˆ†ç‚¸å’Œå¤æ‚ç‰¹æ•ˆç»„åˆ

import { Shape3DType } from '../shapes/Shape3DFactory';
import { TrajectoryType } from '../trajectories/TrajectoryFactory';

/**
 * ç»„åˆæŠ€ç±»å‹
 */
export enum ComboType {
  // === ç»å…¸ç»„åˆ ===
  SINGLE = 'single',                    // å•æ¬¡çˆ†ç‚¸ï¼ˆé»˜è®¤ï¼‰
  STAGED = 'staged',                    // å­æ¯è¿çˆ†ï¼ˆ2-3é˜¶æ®µï¼‰
  DELAYED_BURST = 'delayed_burst',      // å»¶è¿Ÿçˆ†å‘
  MULTI_WAVE = 'multi_wave',            // å¤šæ³¢æ¬¡æ‰©æ•£
  
  // === å½¢å˜ç»„åˆ ===
  MORPH = 'morph',                      // å½¢æ€å˜åŒ–ï¼ˆçƒ->å¿ƒç­‰ï¼‰
  SPLIT = 'split',                      // åˆ†è£‚æ•ˆæœ
  CONVERGE = 'converge',                // æ±‡èšæ•ˆæœ
  EXPAND_CONTRACT = 'expand_contract',  // æ‰©å¼ æ”¶ç¼©
  
  // === ç‰¹æ•ˆç»„åˆ ===
  TRAIL_EXPLOSION = 'trail_explosion',  // å°¾è¿¹çˆ†ç‚¸
  RAIN_DOWN = 'rain_down',              // é›¨è½æ•ˆæœ
  SPIRAL_SCATTER = 'spiral_scatter',    // èºæ—‹æ•£å°„
  PHOENIX_RISE = 'phoenix_rise',        // å‡¤å‡°é‡ç”Ÿ
  
  // === é«˜çº§ç»„åˆ ===
  CASCADE_CHAIN = 'cascade_chain',      // è¿é”ç€‘å¸ƒ
  GALAXY_BIRTH = 'galaxy_birth',        // é“¶æ²³è¯ç”Ÿ
  SUPERNOVA_COLLAPSE = 'supernova_collapse', // è¶…æ–°æ˜Ÿå¡Œç¼©
  FIREWORK_SYMPHONY = 'firework_symphony', // çƒŸèŠ±äº¤å“æ›²
}

/**
 * ç»„åˆæŠ€ä¿¡æ¯
 */
export interface ComboInfo {
  name: string;
  icon: string;
  description: string;
  stages: number;
  duration: number; // æ€»æŒç»­æ—¶é—´(ç§’)
}

/**
 * ç»„åˆæŠ€ä¿¡æ¯æ˜ å°„
 */
export const COMBO_INFO: Record<ComboType, ComboInfo> = {
  [ComboType.SINGLE]: { name: 'å•æ¬¡çˆ†ç‚¸', icon: 'ğŸ’¥', description: 'ç»å…¸å•æ¬¡ç‚¸å¼€', stages: 1, duration: 0 },
  [ComboType.STAGED]: { name: 'å­æ¯è¿çˆ†', icon: 'ğŸ†', description: 'å…ˆç‚¸å¼€å†äºŒæ¬¡çˆ†ç‚¸', stages: 2, duration: 0.8 },
  [ComboType.DELAYED_BURST]: { name: 'å»¶è¿Ÿçˆ†å‘', icon: 'â±ï¸', description: 'æ‚¬åœåçªç„¶ç‚¸å¼€', stages: 2, duration: 1.2 },
  [ComboType.MULTI_WAVE]: { name: 'å¤šæ³¢æ‰©æ•£', icon: 'ã€°ï¸', description: 'ä¸‰æ³¢ä¾æ¬¡æ‰©æ•£', stages: 3, duration: 1.5 },
  
  [ComboType.MORPH]: { name: 'å½¢æ€å˜åŒ–', icon: 'ğŸ”„', description: 'çƒå½¢å˜å¿ƒå½¢', stages: 2, duration: 1.0 },
  [ComboType.SPLIT]: { name: 'åˆ†è£‚æ•ˆæœ', icon: 'âœ‚ï¸', description: 'ä¸€åˆ†ä¸ºå¤š', stages: 2, duration: 0.6 },
  [ComboType.CONVERGE]: { name: 'æ±‡èšæ•ˆæœ', icon: 'ğŸ¯', description: 'å››æ•£åæ±‡èš', stages: 2, duration: 1.5 },
  [ComboType.EXPAND_CONTRACT]: { name: 'å‘¼å¸è„‰åŠ¨', icon: 'ğŸ’“', description: 'æ‰©å¼ å†æ”¶ç¼©', stages: 3, duration: 2.0 },
  
  [ComboType.TRAIL_EXPLOSION]: { name: 'å°¾è¿¹çˆ†ç‚¸', icon: 'â˜„ï¸', description: 'è½¨è¿¹ä¸Šè¿ç»­å°çˆ†ç‚¸', stages: 5, duration: 1.0 },
  [ComboType.RAIN_DOWN]: { name: 'é›¨è½æ•ˆæœ', icon: 'ğŸŒ§ï¸', description: 'ç‚¸å¼€åå¦‚é›¨ä¸‹è½', stages: 2, duration: 2.0 },
  [ComboType.SPIRAL_SCATTER]: { name: 'èºæ—‹æ•£å°„', icon: 'ğŸŒ€', description: 'èºæ—‹é£å‡º', stages: 1, duration: 0.5 },
  [ComboType.PHOENIX_RISE]: { name: 'å‡¤å‡°æ¶…æ§ƒ', icon: 'ğŸ”¥', description: 'ä¸‹è½åé‡æ–°å‡èµ·', stages: 3, duration: 3.0 },
  
  [ComboType.CASCADE_CHAIN]: { name: 'è¿é”ç€‘å¸ƒ', icon: 'ğŸŒŠ', description: 'å±‚å±‚ä¸‹è½', stages: 5, duration: 2.5 },
  [ComboType.GALAXY_BIRTH]: { name: 'é“¶æ²³è¯ç”Ÿ', icon: 'ğŸŒŒ', description: 'ä»ç‚¹åˆ°é“¶æ²³', stages: 4, duration: 3.0 },
  [ComboType.SUPERNOVA_COLLAPSE]: { name: 'è¶…æ–°æ˜Ÿå¡Œç¼©', icon: 'ğŸ’«', description: 'çˆ†ç‚¸åå¡Œç¼©', stages: 3, duration: 2.0 },
  [ComboType.FIREWORK_SYMPHONY]: { name: 'çƒŸèŠ±äº¤å“', icon: 'ğŸµ', description: 'å¤šç§æ•ˆæœåå¥', stages: 6, duration: 4.0 },
};

/**
 * é˜¶æ®µé…ç½®
 */
export interface StageConfig {
  delay: number;          // å»¶è¿Ÿæ—¶é—´(ç§’)
  shape: Shape3DType;     // å½¢çŠ¶
  scale: number;          // ç¼©æ”¾
  particleCount: number;  // ç²’å­æ•°é‡å€ç‡
  hueShift: number;       // è‰²ç›¸åç§»
  behavior?: string;      // ç²’å­è¡Œä¸º
  velocityScale?: number; // é€Ÿåº¦ç¼©æ”¾
  gravity?: number;       // é‡åŠ›è¦†ç›–
  decay?: number;         // è¡°å‡è¦†ç›–
  spawnOffset?: { x: number; y: number; z: number }; // ç”Ÿæˆä½ç½®åç§»
}

/**
 * ç»„åˆæŠ€é…ç½®
 */
export interface ComboConfig {
  type: ComboType;
  trajectory: TrajectoryType;
  stages: StageConfig[];
}

/**
 * ç»„åˆæŠ€ç”Ÿæˆå™¨
 */
export class ComboGenerator {
  /**
   * ç”Ÿæˆç»„åˆæŠ€é…ç½®
   */
  static generate(type: ComboType, baseShape: Shape3DType = Shape3DType.SPHERE): ComboConfig {
    const stages: StageConfig[] = [];
    let trajectory = TrajectoryType.LINEAR;
    
    switch (type) {
      case ComboType.SINGLE:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        break;
        
      case ComboType.STAGED:
        // ç¬¬ä¸€é˜¶æ®µï¼šå°çˆ†ç‚¸
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 0,
          decay: 0.05
        });
        // ç¬¬äºŒé˜¶æ®µï¼šä¸»çˆ†ç‚¸
        stages.push({
          delay: 0.8,
          shape: baseShape,
          scale: 1.2,
          particleCount: 1,
          hueShift: 60
        });
        break;
        
      case ComboType.DELAYED_BURST:
        // ç¬¬ä¸€é˜¶æ®µï¼šæ‚¬åœé—ªçƒ
        stages.push({
          delay: 0,
          shape: Shape3DType.SPARKLE_CLOUD,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter',
          velocityScale: 0.1
        });
        // ç¬¬äºŒé˜¶æ®µï¼šçªç„¶çˆ†å‘
        stages.push({
          delay: 1.2,
          shape: baseShape,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0
        });
        break;
        
      case ComboType.MULTI_WAVE:
        // ä¸‰æ³¢æ‰©æ•£
        for (let i = 0; i < 3; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 0.8 + i * 0.3,
            particleCount: 0.5,
            hueShift: i * 40
          });
        }
        break;
        
      case ComboType.MORPH:
        // çƒå½¢
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 0,
          decay: 0.03
        });
        // å˜å¿ƒå½¢
        stages.push({
          delay: 1.0,
          shape: Shape3DType.HEART_3D,
          scale: 1.2,
          particleCount: 1,
          hueShift: 330 // ç²‰çº¢
        });
        break;
        
      case ComboType.SPLIT:
        // ä¸»ä½“
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.6,
          particleCount: 0.3,
          hueShift: 0
        });
        // å››ä¸ªåˆ†è£‚ç‚¹
        const splitOffsets = [
          { x: 40, y: 0, z: 0 },
          { x: -40, y: 0, z: 0 },
          { x: 0, y: 0, z: 40 },
          { x: 0, y: 0, z: -40 }
        ];
        for (const offset of splitOffsets) {
          stages.push({
            delay: 0.6,
            shape: baseShape,
            scale: 0.5,
            particleCount: 0.3,
            hueShift: Math.random() * 60,
            spawnOffset: offset
          });
        }
        break;
        
      case ComboType.TRAIL_EXPLOSION:
        // æ²¿è½¨è¿¹çš„å°çˆ†ç‚¸
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.2,
            shape: Shape3DType.EXPLOSION_BURST,
            scale: 0.4,
            particleCount: 0.2,
            hueShift: i * 30,
            spawnOffset: { x: 0, y: -i * 30, z: 0 }
          });
        }
        trajectory = TrajectoryType.LINEAR;
        break;
        
      case ComboType.RAIN_DOWN:
        // çˆ†ç‚¸
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        // é›¨è½
        stages.push({
          delay: 0.8,
          shape: Shape3DType.CASCADE,
          scale: 1.5,
          particleCount: 0.8,
          hueShift: 30,
          behavior: 'falling',
          gravity: 0.15
        });
        break;
        
      case ComboType.SPIRAL_SCATTER:
        stages.push({
          delay: 0,
          shape: Shape3DType.VORTEX,
          scale: 1.2,
          particleCount: 1,
          hueShift: 0
        });
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      case ComboType.PHOENIX_RISE:
        // ä¸‹è½ç«ç„°
        stages.push({
          delay: 0,
          shape: Shape3DType.FIREWORK_WILLOW,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 30,
          gravity: 0.2
        });
        // åº•éƒ¨æ±‡èš
        stages.push({
          delay: 1.5,
          shape: Shape3DType.VORTEX,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 15,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        // å‡¤å‡°å‡èµ·
        stages.push({
          delay: 3.0,
          shape: Shape3DType.PHOENIX,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0,
          velocityScale: 1.5,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        trajectory = TrajectoryType.FALL_RISE;
        break;
        
      case ComboType.CASCADE_CHAIN:
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 1 - i * 0.15,
            particleCount: 0.4,
            hueShift: i * 20,
            spawnOffset: { x: 0, y: -i * 25, z: 0 }
          });
        }
        break;
        
      case ComboType.GALAXY_BIRTH:
        // ä¸­å¿ƒé—ªå…‰
        stages.push({
          delay: 0,
          shape: Shape3DType.EXPLOSION_BURST,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter'
        });
        // æ‰©æ•£
        stages.push({
          delay: 0.8,
          shape: Shape3DType.NEBULA,
          scale: 0.6,
          particleCount: 0.4,
          hueShift: 200
        });
        // æ—‹è‡‚å½¢æˆ
        stages.push({
          delay: 1.8,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1,
          particleCount: 0.8,
          hueShift: 240
        });
        // å®Œæ•´é“¶æ²³
        stages.push({
          delay: 3.0,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1.5,
          particleCount: 1,
          hueShift: 260
        });
        break;
        
      case ComboType.SUPERNOVA_COLLAPSE:
        // çˆ†å‘
        stages.push({
          delay: 0,
          shape: Shape3DType.SUPERNOVA,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 30
        });
        // æ‰©æ•£
        stages.push({
          delay: 0.8,
          shape: Shape3DType.SHOCKWAVE,
          scale: 2,
          particleCount: 0.5,
          hueShift: 200
        });
        // å¡Œç¼©æˆç‚¹
        stages.push({
          delay: 2.0,
          shape: Shape3DType.BLACK_HOLE,
          scale: 0.3,
          particleCount: 0.3,
          hueShift: 270,
          velocityScale: -0.5 // å‘å†…
        });
        break;
        
      case ComboType.FIREWORK_SYMPHONY:
        const symphonyShapes = [
          Shape3DType.SPHERE,
          Shape3DType.RING_WAVE,
          Shape3DType.HEART_3D,
          Shape3DType.STAR_3D,
          Shape3DType.FLOWER_3D,
          Shape3DType.EXPLOSION_BURST
        ];
        for (let i = 0; i < symphonyShapes.length; i++) {
          stages.push({
            delay: i * 0.6,
            shape: symphonyShapes[i],
            scale: 0.7 + Math.random() * 0.4,
            particleCount: 0.5,
            hueShift: (i / symphonyShapes.length) * 360
          });
        }
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      default:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
    }
    
    return { type, trajectory, stages };
  }
}

/**
 * ç»„åˆæŠ€ç®¡ç†å™¨
 */
export class ComboManager {
  private static allTypes: ComboType[] = Object.values(ComboType);
  
  /**
   * è·å–æ‰€æœ‰ç»„åˆæŠ€ç±»å‹
   */
  static getAllTypes(): ComboType[] {
    return [...this.allTypes];
  }
  
  /**
   * éšæœºè·å–ä¸€ä¸ªç»„åˆæŠ€ç±»å‹
   */
  static getRandomType(): ComboType {
    return this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
  }
  
  /**
   * è·å–ç»„åˆæŠ€ä¿¡æ¯
   */
  static getInfo(type: ComboType): ComboInfo {
    return COMBO_INFO[type];
  }
  
  /**
   * ç”Ÿæˆç»„åˆæŠ€é…ç½®
   */
  static generateConfig(type: ComboType, baseShape?: Shape3DType): ComboConfig {
    return ComboGenerator.generate(type, baseShape);
  }
  
  /**
   * è·å–ç®€å•ç»„åˆæŠ€ï¼ˆé€‚åˆè‡ªåŠ¨å‘å°„ï¼‰
   */
  static getSimpleTypes(): ComboType[] {
    return [
      ComboType.SINGLE,
      ComboType.STAGED,
      ComboType.MULTI_WAVE,
      ComboType.SPLIT
    ];
  }
  
  /**
   * è·å–é«˜çº§ç»„åˆæŠ€ï¼ˆé€‚åˆæ‰‹åŠ¨è§¦å‘ï¼‰
   */
  static getAdvancedTypes(): ComboType[] {
    return [
      ComboType.PHOENIX_RISE,
      ComboType.GALAXY_BIRTH,
      ComboType.SUPERNOVA_COLLAPSE,
      ComboType.FIREWORK_SYMPHONY
    ];
  }
}

// END OF FILE: src/core/combos/ComboManager.ts


// =============================================================================
// FILE: src\core\effects\DragonPath.ts
// =============================================================================

// FILE: src/core/effects/DragonPath.ts
// é¾™å½¢ç‰¹æ•ˆè·¯å¾„ - å›¾æ¡ˆåŒ–ä¸Šå‡è½¨è¿¹

import { Vector3 } from '../Vector3';

/**
 * ç‰¹æ•ˆå›¾æ¡ˆç±»å‹
 */
export enum EffectPatternType {
  // åŠ¨ç‰©ç±»
  DRAGON = 'dragon',           // é¾™
  PHOENIX = 'phoenix',         // å‡¤å‡°
  QILIN = 'qilin',             // éº’éºŸ
  CRANE = 'crane',             // ä»™é¹¤
  KOI = 'koi',                 // é”¦é²¤
  BUTTERFLY = 'butterfly',     // è´è¶
  EAGLE = 'eagle',             // é¹°
  
  // ç¥å…½ç±»
  ZHUQUE = 'zhuque',           // æœ±é›€ (å—æ–¹)
  QINGLONG = 'qinglong',       // é’é¾™ (ä¸œæ–¹)
  BAIHU = 'baihu',             // ç™½è™ (è¥¿æ–¹)
  XUANWU = 'xuanwu',           // ç„æ­¦ (åŒ—æ–¹)
  
  // è‡ªç„¶ç±»
  PLUM = 'plum',               // æ¢…èŠ±
  BAMBOO = 'bamboo',           // ç«¹å­
  CHRYSANTHEMUM = 'chrysanthemum', // èŠèŠ±
  ORCHID = 'orchid',           // å…°èŠ±
  LOTUS = 'lotus',             // è²èŠ±
  MAPLE = 'maple',             // æ«å¶
  
  // æ–‡åŒ–ç±»
  CLOUD = 'cloud',             // ç¥¥äº‘
  RUYI = 'ruyi',               // å¦‚æ„
  CHINESE_KNOT = 'chinese_knot', // ä¸­å›½ç»“
}

/**
 * ç‰¹æ•ˆä¿¡æ¯
 */
export const EFFECT_PATTERN_INFO: Record<EffectPatternType, { 
  name: string; 
  icon: string; 
  description: string;
  controlPoints: number;
}> = {
  [EffectPatternType.DRAGON]: { name: 'ç¥é¾™', icon: 'ğŸ‰', description: 'èœ¿èœ’å‡è…¾çš„ç¥é¾™', controlPoints: 150 },
  [EffectPatternType.PHOENIX]: { name: 'å‡¤å‡°', icon: 'ğŸ¦…', description: 'æ¶…æ§ƒé‡ç”Ÿçš„å‡¤å‡°', controlPoints: 120 },
  [EffectPatternType.QILIN]: { name: 'éº’éºŸ', icon: 'ğŸ¦Œ', description: 'ç¥¥ç‘ä¹‹å…½', controlPoints: 100 },
  [EffectPatternType.CRANE]: { name: 'ä»™é¹¤', icon: 'ğŸ¦¢', description: 'é•¿å¯¿ä»™ç¦½', controlPoints: 80 },
  [EffectPatternType.KOI]: { name: 'é”¦é²¤', icon: 'ğŸŸ', description: 'è·ƒé¾™é—¨çš„é”¦é²¤', controlPoints: 60 },
  [EffectPatternType.BUTTERFLY]: { name: 'è´è¶', icon: 'ğŸ¦‹', description: 'ç¿©ç¿©èµ·èˆ', controlPoints: 50 },
  [EffectPatternType.EAGLE]: { name: 'é›„é¹°', icon: 'ğŸ¦…', description: 'å±•ç¿…é«˜é£', controlPoints: 90 },
  
  [EffectPatternType.ZHUQUE]: { name: 'æœ±é›€', icon: 'ğŸ”¥', description: 'å—æ–¹ç¥å…½', controlPoints: 110 },
  [EffectPatternType.QINGLONG]: { name: 'é’é¾™', icon: 'ğŸŒ¿', description: 'ä¸œæ–¹ç¥å…½', controlPoints: 140 },
  [EffectPatternType.BAIHU]: { name: 'ç™½è™', icon: 'ğŸ…', description: 'è¥¿æ–¹ç¥å…½', controlPoints: 100 },
  [EffectPatternType.XUANWU]: { name: 'ç„æ­¦', icon: 'ğŸ¢', description: 'åŒ—æ–¹ç¥å…½', controlPoints: 90 },
  
  [EffectPatternType.PLUM]: { name: 'æ¢…èŠ±', icon: 'ğŸŒ¸', description: 'å‚²é›ªå¯’æ¢…', controlPoints: 40 },
  [EffectPatternType.BAMBOO]: { name: 'ç«¹å­', icon: 'ğŸ‹', description: 'èŠ‚èŠ‚é«˜å‡', controlPoints: 30 },
  [EffectPatternType.CHRYSANTHEMUM]: { name: 'èŠèŠ±', icon: 'ğŸŒ¼', description: 'ç§‹èŠå‚²éœœ', controlPoints: 50 },
  [EffectPatternType.ORCHID]: { name: 'å…°èŠ±', icon: 'ğŸ’®', description: 'ç©ºè°·å¹½å…°', controlPoints: 35 },
  [EffectPatternType.LOTUS]: { name: 'è²èŠ±', icon: 'ğŸª·', description: 'å‡ºæ·¤æ³¥è€Œä¸æŸ“', controlPoints: 60 },
  [EffectPatternType.MAPLE]: { name: 'æ«å¶', icon: 'ğŸ', description: 'ç§‹æ—¥çº¢å¶', controlPoints: 25 },
  
  [EffectPatternType.CLOUD]: { name: 'ç¥¥äº‘', icon: 'â˜', description: 'å‰ç¥¥å¦‚æ„', controlPoints: 40 },
  [EffectPatternType.RUYI]: { name: 'å¦‚æ„', icon: 'ğŸ', description: 'ä¸‡äº‹å¦‚æ„', controlPoints: 30 },
  [EffectPatternType.CHINESE_KNOT]: { name: 'ä¸­å›½ç»“', icon: 'ğŸ€', description: 'å¹³å®‰å–œä¹', controlPoints: 80 },
};

/**
 * é¾™å½¢è·¯å¾„ç‚¹
 */
export interface DragonSegment {
  position: Vector3;
  size: number;       // è¯¥æ®µç²—ç»†
  hue: number;        // è‰²ç›¸
  alpha: number;      // é€æ˜åº¦
  type: 'head' | 'horn' | 'eye' | 'whisker' | 'body' | 'claw' | 'tail';
}

/**
 * é¾™å½¢æ•ˆæœçŠ¶æ€
 */
export interface DragonEffectState {
  phase: 'generating' | 'rising' | 'dissipating' | 'complete';
  progress: number;   // å½“å‰é˜¶æ®µè¿›åº¦ (0-1)
  segments: DragonSegment[];
  position: Vector3;  // æ•´ä½“ä½ç½®
  velocity: Vector3;  // æ•´ä½“é€Ÿåº¦
  lifeTime: number;
}

/**
 * é¾™å½¢è·¯å¾„ç”Ÿæˆå™¨
 */
export class DragonPathGenerator {
  private segments: DragonSegment[] = [];
  private basePosition: Vector3;
  private baseHue: number;
  
  // é¾™èº«å‚æ•°
  private bodyLength: number = 30;   // é¾™èº«èŠ‚æ•°
  private bodyWaveAmp: number = 20;  // æ³¢åŠ¨å¹…åº¦
  private bodyWaveFreq: number = 3;  // æ³¢åŠ¨é¢‘ç‡
  private headSize: number = 15;
  private tailTaper: number = 0.6;   // å°¾éƒ¨æ¸ç»†æ¯”ä¾‹
  
  constructor(startPosition: Vector3, hue: number = 45) {
    this.basePosition = startPosition.clone();
    this.baseHue = hue; // é‡‘è‰²
  }
  
  /**
   * ç”Ÿæˆå®Œæ•´é¾™å½¢è·¯å¾„
   * æŒ‰é¡ºåºï¼šé¾™è§’ â†’ é¾™çœ¼ â†’ é¾™é¼» â†’ é¾™é¡» â†’ é¾™èº« â†’ é¾™çˆª â†’ é¾™å°¾
   */
  generateDragonPath(): DragonSegment[] {
    this.segments = [];
    
    // é¾™å¤´ (åŸºäºèµ·å§‹ä½ç½®)
    this.generateHead();
    
    // é¾™èº« (èœ¿èœ’å‘ä¸Š)
    this.generateBody();
    
    // é¾™å°¾ (æ¸ç»†)
    this.generateTail();
    
    // é¾™çˆª (ä¸¤å¯¹)
    this.generateClaws();
    
    return this.segments;
  }
  
  private generateHead(): void {
    const headCenter = this.basePosition.clone();
    
    // é¾™å¤´ä¸»ä½“
    for (let i = 0; i < 10; i++) {
      const t = i / 10;
      const angle = t * Math.PI * 0.3;
      this.segments.push({
        position: new Vector3(
          headCenter.x + Math.cos(angle) * this.headSize * (1 - t * 0.3),
          headCenter.y + t * 5,
          headCenter.z + Math.sin(angle) * this.headSize * 0.5
        ),
        size: this.headSize * (1 - t * 0.2),
        hue: this.baseHue,
        alpha: 1,
        type: 'head'
      });
    }
    
    // é¾™è§’ (ä¸¤åª)
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 5; i++) {
        const t = i / 5;
        this.segments.push({
          position: new Vector3(
            headCenter.x + side * 8 + side * t * 5,
            headCenter.y + 10 + t * 20,
            headCenter.z - 5 + t * 3
          ),
          size: 4 * (1 - t * 0.7),
          hue: this.baseHue + 20,
          alpha: 1,
          type: 'horn'
        });
      }
    }
    
    // é¾™çœ¼ (ä¸¤åª)
    for (let side = -1; side <= 1; side += 2) {
      this.segments.push({
        position: new Vector3(
          headCenter.x + side * 6,
          headCenter.y + 5,
          headCenter.z + 8
        ),
        size: 5,
        hue: 0, // çº¢è‰²
        alpha: 1,
        type: 'eye'
      });
    }
    
    // é¾™é¡» (å››æ ¹)
    for (let side = -1; side <= 1; side += 2) {
      for (let row = 0; row < 2; row++) {
        for (let i = 0; i < 8; i++) {
          const t = i / 8;
          const wave = Math.sin(t * Math.PI * 3) * 3;
          this.segments.push({
            position: new Vector3(
              headCenter.x + side * (10 + t * 25),
              headCenter.y + 2 - row * 3 + wave,
              headCenter.z + 10 + t * 5
            ),
            size: 2 * (1 - t * 0.8),
            hue: this.baseHue + 10,
            alpha: 0.8 - t * 0.3,
            type: 'whisker'
          });
        }
      }
    }
  }
  
  private generateBody(): void {
    // é¾™èº«ï¼šæ­£å¼¦æ³¢èœ¿èœ’å‘ä¸Š
    for (let i = 0; i < this.bodyLength; i++) {
      const t = i / this.bodyLength;
      const y = this.basePosition.y + 20 + t * 150; // å‘ä¸Šå»¶ä¼¸
      const wave = Math.sin(t * Math.PI * this.bodyWaveFreq) * this.bodyWaveAmp;
      const waveZ = Math.cos(t * Math.PI * this.bodyWaveFreq * 0.7) * this.bodyWaveAmp * 0.5;
      
      // é¾™èº«å˜ç»†
      const bodySize = this.headSize * 0.8 * (1 - t * this.tailTaper * 0.5);
      
      this.segments.push({
        position: new Vector3(
          this.basePosition.x + wave,
          y,
          this.basePosition.z + waveZ
        ),
        size: bodySize,
        hue: this.baseHue + t * 30, // æ¸å˜è‰²
        alpha: 1 - t * 0.1,
        type: 'body'
      });
    }
  }
  
  private generateTail(): void {
    const lastBody = this.segments[this.segments.length - 1];
    const tailStart = lastBody.position.clone();
    
    // é¾™å°¾ï¼šç»§ç»­å‘ä¸Šï¼Œæ¸ç»†ï¼Œæœ«ç«¯åˆ†å‰
    for (let i = 0; i < 15; i++) {
      const t = i / 15;
      const y = tailStart.y + t * 40;
      const wave = Math.sin(t * Math.PI * 4) * 15 * (1 - t);
      
      this.segments.push({
        position: new Vector3(
          tailStart.x + wave,
          y,
          tailStart.z + Math.cos(t * Math.PI * 3) * 8
        ),
        size: 8 * (1 - t * 0.9),
        hue: this.baseHue + 40,
        alpha: 1 - t * 0.5,
        type: 'tail'
      });
    }
  }
  
  private generateClaws(): void {
    // åœ¨é¾™èº«ä¸Šæ‰¾ä¸¤å¯¹çˆªå­ä½ç½®
    const bodySegments = this.segments.filter(s => s.type === 'body');
    const clawPositions = [
      bodySegments[Math.floor(bodySegments.length * 0.2)],
      bodySegments[Math.floor(bodySegments.length * 0.6)]
    ];
    
    for (const base of clawPositions) {
      if (!base) continue;
      
      // æ¯å¯¹çˆªå­ä¸¤åª
      for (let side = -1; side <= 1; side += 2) {
        for (let i = 0; i < 6; i++) {
          const t = i / 6;
          this.segments.push({
            position: new Vector3(
              base.position.x + side * (10 + t * 20),
              base.position.y - t * 15,
              base.position.z + (Math.random() - 0.5) * 5
            ),
            size: 4 * (1 - t * 0.6),
            hue: this.baseHue + 15,
            alpha: 1 - t * 0.3,
            type: 'claw'
          });
        }
      }
    }
  }
  
  /**
   * è·å–æŒ‡å®šè¿›åº¦çš„éƒ¨åˆ†è·¯å¾„ (ç”¨äºé€æ­¥ç”ŸæˆåŠ¨ç”»)
   * @param progress 0-1, ç”Ÿæˆè¿›åº¦
   */
  getPartialPath(progress: number): DragonSegment[] {
    const fullPath = this.generateDragonPath();
    const count = Math.floor(fullPath.length * Math.min(1, progress));
    return fullPath.slice(0, count);
  }
  
  /**
   * æ›´æ–°é¾™èº«æ³¢åŠ¨åŠ¨ç”»
   * @param segments å½“å‰è·¯å¾„
   * @param time æ—¶é—´
   * @param risingSpeed ä¸Šå‡é€Ÿåº¦
   */
  static animateRising(
    segments: DragonSegment[], 
    time: number, 
    risingSpeed: number = 0.5
  ): DragonSegment[] {
    return segments.map((seg, i) => {
      const t = i / segments.length;
      
      // æ•´ä½“ä¸Šå‡
      const newY = seg.position.y + risingSpeed;
      
      // èº«ä½“æ³¢åŠ¨
      let waveX = 0, waveZ = 0;
      if (seg.type === 'body' || seg.type === 'tail') {
        waveX = Math.sin(time * 3 + t * Math.PI * 4) * 5;
        waveZ = Math.cos(time * 2 + t * Math.PI * 3) * 3;
      }
      
      // é¾™é¡»é£˜åŠ¨
      if (seg.type === 'whisker') {
        waveX = Math.sin(time * 5 + i * 0.5) * 8;
      }
      
      return {
        ...seg,
        position: new Vector3(
          seg.position.x + waveX,
          newY,
          seg.position.z + waveZ
        )
      };
    });
  }
  
  /**
   * æ¶ˆæ•£åŠ¨ç”»ï¼šä»å°¾éƒ¨å¼€å§‹æ¶ˆå¤±
   * @param segments å½“å‰è·¯å¾„
   * @param progress æ¶ˆæ•£è¿›åº¦ 0-1
   */
  static animateDissipate(
    segments: DragonSegment[],
    progress: number
  ): DragonSegment[] {
    return segments.map((seg, i) => {
      const t = i / segments.length;
      
      // ä»å°¾éƒ¨å‘å¤´éƒ¨æ¶ˆæ•£
      const dissipateThreshold = progress;
      const fadeStart = 1 - t; // å°¾éƒ¨å…ˆæ¶ˆæ•£
      
      if (fadeStart < dissipateThreshold) {
        const localFade = (dissipateThreshold - fadeStart) / 0.3;
        return {
          ...seg,
          alpha: Math.max(0, seg.alpha * (1 - localFade)),
          size: seg.size * (1 - localFade * 0.5),
          // å‘ä¸Šé£˜æ•£
          position: new Vector3(
            seg.position.x + (Math.random() - 0.5) * 10 * localFade,
            seg.position.y + localFade * 20,
            seg.position.z + (Math.random() - 0.5) * 10 * localFade
          )
        };
      }
      
      return seg;
    });
  }
}

// END OF FILE: src/core/effects/DragonPath.ts


// =============================================================================
// FILE: src\core\Firework.ts
// =============================================================================


import { Vector2 } from './Vector2';
import { FireworkOptions, ExplosionType, AppSettings, ParticleOptions } from '../types';
import { Particle } from './Particle';

export class Firework {
  pos: Vector2;
  target: Vector2;
  vel: Vector2;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector2[] = [];
  trailLength: number;

  constructor(options: FireworkOptions, settings: AppSettings) {
    this.pos = new Vector2(options.startX, window.innerHeight);
    this.target = new Vector2(options.targetX, options.targetY);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;

    const distanceY = this.pos.y - this.target.y;
    const gravity = settings.gravity;
    const initialVelY = -Math.sqrt(2 * gravity * Math.max(10, distanceY)) * (0.85 + Math.random() * 0.3);
    const timeToApex = -initialVelY / gravity;
    const initialVelX = (this.target.x - this.pos.x) / timeToApex;

    this.vel = new Vector2(initialVelX, initialVelY);
  }

  update(settings: AppSettings): void {
    this.trail.push(this.pos.clone());
    if (this.trail.length > this.trailLength) {
      this.trail.shift();
    }
    this.vel.y += settings.gravity;
    this.pos.add(this.vel);
    
    if (this.vel.y >= -0.2) {
      this.exploded = true;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.strokeStyle = `hsl(${this.hue}, 100%, 75%)`;
    ctx.lineWidth = 1.2;
    for (let i = 0; i < this.trail.length; i++) {
      const p = this.trail[i];
      const alpha = i / this.trail.length;
      ctx.globalAlpha = alpha * 0.8;
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  createExplosion(settings: AppSettings, spawnParticle: (opts: ParticleOptions) => Particle): void {
    const types = Object.values(ExplosionType);
    const type = types[Math.floor(Math.random() * types.length)] as ExplosionType;
    
    let baseCount = Math.floor((180 + this.charge * 450) * settings.particleCountMultiplier);
    const sizeScale = settings.explosionSizeMultiplier;

    const spawn = (angle: number, speed: number, extraHue = 0, behavior: any = 'default', decay?: number) => {
      spawnParticle({
        x: this.pos.x, y: this.pos.y,
        originX: this.pos.x,
        originY: this.pos.y,
        hue: (this.hue + extraHue) % 360,
        angle,
        speed: speed * sizeScale,
        gravity: settings.gravity,
        friction: settings.friction,
        behavior,
        decay
      });
    };

    switch (type) {
      case ExplosionType.HEART:
        const heartCount = baseCount * 1.5;
        for (let i = 0; i < heartCount; i++) {
          const t = (i / heartCount) * Math.PI * 2;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          const speed = (Math.sqrt(x*x + y*y) / 8) * (6 + this.charge * 8);
          spawn(Math.atan2(y, x), speed, 0, 'default', 0.012);
        }
        break;

      case ExplosionType.STAR:
        const pts = 5;
        const starCount = baseCount * 1.3;
        for (let i = 0; i < starCount; i++) {
          const ang = (i / starCount) * Math.PI * 2;
          const mod = (Math.abs(Math.cos(ang * pts / 2)) * 0.7 + 0.3);
          spawn(ang, mod * (14 + this.charge * 18));
        }
        break;

      case ExplosionType.GALAXY:
        const arms = 4 + Math.floor(this.charge * 4);
        for (let a = 0; a < arms; a++) {
          const armBaseAngle = (a / arms) * Math.PI * 2;
          for (let i = 0; i < baseCount / arms; i++) {
            const prog = i / (baseCount / arms);
            const angle = armBaseAngle + prog * Math.PI * 2.5;
            const speed = prog * (15 + this.charge * 15);
            spawn(angle, speed, prog * 80, 'galaxy');
          }
        }
        break;

      case ExplosionType.SPIRAL:
        const sArms = 4 + Math.floor(this.charge * 4);
        const pPerArm = Math.floor(baseCount / sArms);
        for (let a = 0; a < sArms; a++) {
          const armBaseAngle = (a / sArms) * Math.PI * 2;
          for (let i = 0; i < pPerArm; i++) {
            const prog = i / pPerArm;
            const swirlAngle = armBaseAngle + (prog * Math.PI * 8);
            const speed = (0.2 + prog * 0.8) * (20 + this.charge * 15);
            spawn(swirlAngle, speed, prog * 60);
          }
        }
        break;

      case ExplosionType.BUTTERFLY:
        const bfCount = baseCount * 1.5;
        for (let i = 0; i < bfCount; i++) {
          const t = (i / bfCount) * Math.PI * 2;
          const r = Math.exp(Math.sin(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin((2 * t - Math.PI) / 24), 5);
          const x = Math.sin(t) * r;
          const y = -Math.cos(t) * r;
          spawn(Math.atan2(y, x), Math.sqrt(x*x + y*y) * (8 + this.charge * 10), Math.sin(t) * 40);
        }
        break;

      case ExplosionType.DOUBLE_RING:
        const ringCount = Math.floor(baseCount * 0.6);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2, 22 + this.charge * 12);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2 + 0.2, 14 + this.charge * 8, 40);
        break;

      case ExplosionType.GLITTER:
        for (let i = 0; i < baseCount; i++) spawn(Math.random() * Math.PI * 2, Math.random() * (22 + this.charge * 18), 0, 'glitter');
        break;

      default:
        for (let i = 0; i < baseCount; i++) {
          const angle = (i / baseCount) * Math.PI * 2;
          spawn(angle, Math.random() * (20 + this.charge * 24));
        }
        break;
    }
  }
}


// =============================================================================
// FILE: src\core\Firework3D.ts
// =============================================================================

import { Vector3 } from './Vector3';
import { ExplosionType, AscensionType, ColorStyle, AppSettings, ParticleOptions3D, FireworkConfig } from '../types';
import { Particle3D } from './Particle3D';
import { TrajectoryFactory, TrajectoryCalculator, TrajectoryType } from './trajectories/TrajectoryFactory';
import { Shape3DFactory, Shape3DType } from './shapes/Shape3DFactory';
import { ComboManager, ComboConfig, ComboType } from './combos/ComboManager';

export interface Firework3DOptions {
  startX: number;
  startZ: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  hue: number;
  charge: number;
  // æ–°å‘åå…¼å®¹å­—æ®µ
  trajectoryType?: TrajectoryType;
  comboType?: ComboType;
  customShape?: Shape3DType;
  lifeTimeOverride?: number; // è¦†ç›–æŒç»­æ—¶é—´ (ç§’)
}

/**
 * 3D Firework class
 */
export class Firework3D {
  position: Vector3;
  target: Vector3;
  velocity: Vector3;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector3[] = [];
  trailLength: number;
  
  public lifeTimeOverride: number = 0;

  public type: ExplosionType;
  public ascension: AscensionType;
  public colorStyle: ColorStyle;
  public lifeTime: number = 0;

  private trajectoryCalculator: TrajectoryCalculator;
  private comboConfig: ComboConfig;
  private currentStageIndex: number = 0;
  private lastStageTime: number = 0;

  constructor(options: Firework3DOptions, settings: AppSettings, config: FireworkConfig) {
    this.position = new Vector3(options.startX, 0, options.startZ);
    this.target = new Vector3(options.targetX, options.targetY, options.targetZ);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;
    this.lifeTimeOverride = options.lifeTimeOverride || 0;

    // ... (rest of constructor logic) ... 
    // I need to be careful with replace_file_content to not delete the logic I'm not showing.
    // The replace tool requires REPLACEMENT of the block.
    
    // 1. ç¡®å®šç»„åˆæŠ€å’Œè½¨è¿¹
    const cType = options.comboType || ComboType.SINGLE;
    
    // ä¿®å¤æ ·å¼åº”ç”¨é—®é¢˜ï¼šå¤„ç† legacy ExplosionType çš„è½¬æ¢
    const rawShape = options.customShape as any;
    const baseShape = this.mapToShape3D(rawShape);
    
    this.comboConfig = ComboManager.generateConfig(cType, baseShape);

    const tType = options.trajectoryType || this.comboConfig.trajectory;
    this.trajectoryCalculator = TrajectoryFactory.create(tType);

    // 2. ä¿æŒå¯¹æ—§æœ‰ç±»å‹çš„å…¼å®¹æ€§ï¼ˆç”¨äº UI æ˜¾ç¤ºç­‰ï¼‰
    const ascList = config.enabledAscensions.length > 0 ? config.enabledAscensions : [AscensionType.LINEAR];
    this.ascension = ascList[Math.floor(Math.random() * ascList.length)];
    this.colorStyle = config.enabledColors[Math.floor(Math.random() * config.enabledColors.length)] || ColorStyle.SINGLE;
    this.type = rawShape in ExplosionType ? (rawShape as ExplosionType) : ExplosionType.SPHERE;
    // 3. è®¡ç®—åˆå§‹é€Ÿåº¦
    const distanceY = this.target.y - this.position.y;
    const gravity = settings.gravity * 1.5;
    const timeToApex = Math.sqrt(2 * Math.max(10, distanceY) / gravity);
    const initialVelY = gravity * timeToApex;
    const initialVelX = (this.target.x - this.position.x) / timeToApex;
    const initialVelZ = (this.target.z - this.position.z) / timeToApex;

    this.velocity = new Vector3(initialVelX, initialVelY, initialVelZ);
  }

  private mapToShape3D(shape: any): Shape3DType {
    if (!shape) return Shape3DType.SPHERE;
    if (Object.values(Shape3DType).includes(shape as Shape3DType)) return shape as Shape3DType;
    
    // æ˜ å°„æ—§ç‰ˆåˆ°æ–°ç‰ˆ
    const mapping: Record<string, Shape3DType> = {
      [ExplosionType.SPHERE]: Shape3DType.SPHERE,
      [ExplosionType.BURST]: Shape3DType.EXPLOSION_BURST,
      [ExplosionType.RING]: Shape3DType.RING_WAVE,
      [ExplosionType.DOUBLE_RING]: Shape3DType.DOUBLE_RING,
      [ExplosionType.WILLOW]: Shape3DType.FIREWORK_WILLOW,
      [ExplosionType.CUBE]: Shape3DType.CUBE,
      [ExplosionType.PYRAMID]: Shape3DType.PYRAMID,
      [ExplosionType.STAR]: Shape3DType.STAR_3D,
      [ExplosionType.GALAXY]: Shape3DType.GALAXY_SPIRAL,
      [ExplosionType.HEART]: Shape3DType.HEART_3D,
      [ExplosionType.HEART_BEAT]: Shape3DType.HEART_3D,
      [ExplosionType.SNOWFLAKE]: Shape3DType.SNOWFLAKE_3D,
      [ExplosionType.BUTTERFLY]: Shape3DType.BUTTERFLY_3D,
      [ExplosionType.FLOWER]: Shape3DType.FLOWER_3D,
      [ExplosionType.FISH]: Shape3DType.FISH_3D,
      [ExplosionType.SATURN]: Shape3DType.PLANET_RINGS,
      [ExplosionType.HELIX]: Shape3DType.HELIX_TUBE,
      [ExplosionType.WATERFALL]: Shape3DType.WATERFALL_3D,
    };
    
    return mapping[shape] || Shape3DType.SPHERE;
  }


  update(settings: AppSettings, deltaTime: number): void {
    if (deltaTime <= 0) return;

    const dt = deltaTime * 60;
    
    // ä½¿ç”¨æ–°çš„è½¨è¿¹è®¡ç®—å™¨æ›´æ–°ç‰©ç†
    if (!this.exploded) {
      this.velocity = this.trajectoryCalculator.calculate(this.velocity, settings.gravity, deltaTime);
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.position.z += this.velocity.z * dt;
      this.lifeTime = this.trajectoryCalculator.getLifeTime();

      if (this.velocity.y <= -2.5) {
        this.exploded = true;
        this.lastStageTime = this.lifeTime;
      }
    } else {
      // çˆ†ç‚¸åçš„é€»è¾‘ï¼šå¤„ç†å¤šé˜¶æ®µç»„åˆæŠ€
      this.handleComboStages(settings, (opts) => this.spawnParticleCallback?.(opts) as any);
    }
  }

  // ä¸´æ—¶å­˜å‚¨å›è°ƒï¼Œä»¥ä¾¿åœ¨ update ä¸­è°ƒç”¨
  private spawnParticleCallback: ((opts: ParticleOptions3D) => Particle3D) | null = null;

  createExplosion(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    this.spawnParticleCallback = spawnParticle;
    // ç«‹å³è§¦å‘ç¬¬ä¸€é˜¶æ®µï¼ˆå¦‚æœæœ‰å»¶è¿Ÿä¸º0çš„é˜¶æ®µï¼‰
    this.handleComboStages(settings, spawnParticle);
  }

  private handleComboStages(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    if (!this.comboConfig || this.currentStageIndex >= this.comboConfig.stages.length) return;

    const timeSinceExplosion = this.lifeTime - this.lastStageTime;
    const currentStage = this.comboConfig.stages[this.currentStageIndex];

    if (timeSinceExplosion >= currentStage.delay) {
      this.executeStage(currentStage, settings, spawnParticle);
      this.currentStageIndex++;
    }
  }

  private executeStage(
    stage: any,
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    const baseCount = Math.floor((200 + this.charge * 400) * settings.particleCountMultiplier * stage.particleCount);
    const scale = settings.explosionSizeMultiplier * stage.scale;
    const hue = (this.hue + stage.hueShift) % 360;

    // è·å–çœŸ3Då½¢çŠ¶ç‚¹åˆ†å¸ƒ
    const points = Shape3DFactory.generate(stage.shape, baseCount, scale, hue);
    
    // è®¡ç®— decay: å¦‚æœæœ‰ overrideï¼Œåæ¨ decay
    let finalDecay = stage.decay ?? (0.01 + Math.random() * 0.015);
    if (this.lifeTimeOverride > 0) {
      finalDecay = 1 / (this.lifeTimeOverride * 60);
    }

    points.forEach(p => {
      const pos = p.position.clone();
      if (stage.spawnOffset) {
        pos.x += stage.spawnOffset.x;
        pos.y += stage.spawnOffset.y;
        pos.z += stage.spawnOffset.z;
      }

      const particle = spawnParticle({
        x: this.position.x + pos.x,
        y: this.position.y + pos.y,
        z: this.position.z + pos.z,
        originX: this.position.x,
        originY: this.position.y,
        originZ: this.position.z,
        hue: p.hue,
        // åˆå§‹åŠ¨é‡ä¸å†æ˜¯éšæœºä¹±è·³ï¼Œè€Œæ˜¯ç»§æ‰¿ä¸€éƒ¨åˆ†å½¢çŠ¶åŠ¨é‡
        speed: (stage.velocityScale || 1.0) * (1 + Math.random() * 2), 
        gravity: stage.gravity ?? settings.gravity,
        friction: settings.friction,
        behavior: (p.behavior || stage.behavior || 'default') as any,
        size: p.size || 5,
        decay: finalDecay
      });

      // æ ¸å¿ƒä¿®å¤ï¼šåŸºäºè·ç¦»çš„æ‰©å¼ é€Ÿåº¦ (Spherical Expansion)
      // åªæœ‰è¿™æ ·ï¼Œå¤æ‚çš„ 3D å½¢çŠ¶æ‰èƒ½åœ¨è†¨èƒ€æ—¶ä¿æŒâ€œå½¢çŠ¶â€ï¼Œè€Œä¸æ˜¯è¿…é€Ÿå˜æˆä¸€ä¸ªçƒå£³
      if (particle) {
        const dist = p.position.length();
        if (dist > 0) {
          const dir = p.position.clone().normalize();
          // è®©æ‰©æ•£é€Ÿåº¦ä¸å…¶åœ¨å½¢çŠ¶ä¸­çš„è·ç¦»æˆæ­£æ¯”ï¼Œå®ç°æŒ‰æ¯”ä¾‹ç¼©æ”¾è†¨èƒ€
          const expandSpeed = (stage.velocityScale || 1.0) * (dist * 0.5); 
          particle.velocity.x = dir.x * expandSpeed;
          particle.velocity.y = dir.y * expandSpeed;
          particle.velocity.z = dir.z * expandSpeed;
        }
      }
    });
  }

  getColor(): { r: number; g: number; b: number } {
    const h = this.hue / 360; const s = 1; const l = 0.6;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q;
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    };
    return { r: hue2rgb(p, q, h + 1/3), g: hue2rgb(p, q, h), b: hue2rgb(p, q, h - 1/3) };
  }
}

// END OF FILE: src/core/Firework3D.ts

// =============================================================================
// FILE: src\core\Particle.ts
// =============================================================================


import { ParticleOptions, ParticleBehavior } from '../types';

/**
 * Performance-optimized Particle class.
 */
export class Particle {
  public x: number = 0;
  public y: number = 0;
  public vx: number = 0;
  public vy: number = 0;
  public originX: number = 0;
  public originY: number = 0;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public color: string = '';
  public rotationSpeed: number = 0;

  constructor() {}

  init(options: ParticleOptions): void {
    this.x = options.x;
    this.y = options.y;
    this.originX = options.originX ?? options.x;
    this.originY = options.originY ?? options.y;
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();

    const angle = options.angle ?? Math.random() * Math.PI * 2;
    const speed = options.speed ?? Math.random() * 10 + 2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;

    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
    this.color = `hsl(${this.hue % 360}, 100%, 75%)`;
  }

  update(): void {
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.vx += Math.sin(now) * 0.05;
      this.vy += Math.cos(now) * 0.05;
    } else if (this.behavior === 'galaxy') {
      const dx = this.x - this.originX;
      const dy = this.y - this.originY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) + this.rotationSpeed;
      
      const targetX = this.originX + Math.cos(angle) * (dist + this.vx);
      const targetY = this.originY + Math.sin(angle) * (dist + this.vy);
      
      this.vx = targetX - this.x;
      this.vy = targetY - this.y;
    }

    const speedSq = this.vx * this.vx + this.vy * this.vy;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance;
      this.vx -= (this.vx / speed) * drag;
      this.vy -= (this.vy / speed) * drag;
    }

    this.vx *= this.friction;
    this.vy = this.vy * this.friction + this.gravity;
    
    this.x += this.vx;
    this.y += this.vy;

    this.life -= this.decay;
    
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }
    
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15) % 1;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    if (this.alpha <= 0) return;

    let currentAlpha = this.alpha;
    if (this.behavior === 'glitter' && this.twinkleFactor > 0.5) {
      currentAlpha *= 0.2;
    }

    ctx.globalAlpha = currentAlpha;
    ctx.fillStyle = this.color;
    
    if (this.behavior === 'willow' || this.behavior === 'comet') {
      ctx.beginPath();
      const trailLen = this.behavior === 'comet' ? 8 : 3;
      ctx.lineWidth = this.behavior === 'comet' ? this.size * this.life : this.size;
      ctx.strokeStyle = this.color;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * trailLen, this.y - this.vy * trailLen);
      ctx.stroke();
      
      if (this.behavior === 'comet') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, 6.28);
        ctx.fill();
      }
    } else if (this.behavior === 'galaxy') {
      ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
    } else {
      if (this.size < 2) {
        ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
      } else {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 6.28);
        ctx.fill();
      }
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }
}


// =============================================================================
// FILE: src\core\Particle3D.ts
// =============================================================================

import { Vector3 } from './Vector3';
import { ParticleBehavior, ParticleOptions3D } from '../types';
import { getPhysicsEngine } from './PhysicsEngine';
import { ParticlePBRProperties, ParticleMaterialType, PBR_PRESETS } from './PBRMaterial';

/**
 * 3D Particle class for the firework system
 * Uses Three.js coordinate system (Y-up)
 * 
 * å‡çº§ç‰¹æ€§ï¼š
 * - Verlet/RK4 ç§¯åˆ†å™¨æ”¯æŒ (é€šè¿‡ PhysicsEngine)
 * - PBR æè´¨å±æ€§ (ç²—ç³™åº¦ã€é‡‘å±åº¦ã€å‘å…‰å¼ºåº¦)
 * - é«˜ç²¾åº¦è½¨è¿¹è®¡ç®—
 */
export class Particle3D {
  public position: Vector3;
  public velocity: Vector3;
  public previousPosition: Vector3;  // Verlet ç§¯åˆ†å™¨æ‰€éœ€
  public origin: Vector3;
  
  // åŸºç¡€å±æ€§
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.005;  // Default gravity reduced for hover effect
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public rotationSpeed: number = 0;
  
  // PBR æè´¨å±æ€§
  public roughness: number = 0.3;
  public metalness: number = 0.5;
  public emissiveIntensity: number = 2.0;
  public temperature: number = 5000;  // è‰²æ¸© (Kelvin)
  
  // ç‰©ç†å¼•æ“æ ‡è®°
  public useAdvancedPhysics: boolean = true;
  private isFirstUpdate: boolean = true;

  // Trail for comet/willow effects
  public trail: Vector3[] = [];
  public maxTrailLength: number = 10;

  constructor() {
    this.position = new Vector3();
    this.velocity = new Vector3();
    this.previousPosition = new Vector3();
    this.origin = new Vector3();
  }

  init(options: ParticleOptions3D): void {
    this.position = new Vector3(options.x, options.y, options.z);
    this.previousPosition = this.position.clone();  // Verlet ç§¯åˆ†å™¨åˆå§‹åŒ–
    this.origin = new Vector3(
      options.originX ?? options.x,
      options.originY ?? options.y,
      options.originZ ?? options.z
    );
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();
    this.trail = [];
    this.isFirstUpdate = true;

    // Calculate velocity from spherical coordinates
    const theta = options.theta ?? Math.random() * Math.PI * 2;
    const phi = options.phi ?? Math.random() * Math.PI;
    const speed = options.speed ?? Math.random() * 10 + 2;

    this.velocity = new Vector3(
      speed * Math.sin(phi) * Math.cos(theta),
      speed * Math.cos(phi),
      speed * Math.sin(phi) * Math.sin(theta)
    );

    // Apply behavior-specific settings with PBR properties
    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.99;
      this.gravity = options.gravity ?? 0.02;   // é™ä½é‡åŠ›
      this.decay = options.decay ?? 0.003;      // é™ä½è¡°å‡
      this.size = options.size ?? 1.5;
      this.maxTrailLength = 15;
      // PBR: æŸ³å¶çƒŸèŠ± - æŸ”å’Œã€ä½é‡‘å±åº¦
      this.roughness = 0.7;
      this.metalness = 0.2;
      this.emissiveIntensity = 1.5;
      this.temperature = 3500;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.96;
      this.gravity = options.gravity ?? 0.05;   // é™ä½é‡åŠ›
      this.decay = options.decay ?? 0.01;       // é™ä½è¡°å‡
      this.size = options.size ?? Math.random() * 2 + 1;
      // PBR: é—ªç²‰ - é«˜é‡‘å±åº¦ã€ä½ç²—ç³™åº¦ï¼Œå¼ºåå°„
      this.roughness = 0.1;
      this.metalness = 1.0;
      this.emissiveIntensity = 4.0 + Math.random() * 2;
      this.temperature = 6500;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
      // PBR: è¤ç«è™« - å¼ºå‘å…‰ã€æœ‰æœºè´¨æ„Ÿ
      this.roughness = 0.4;
      this.metalness = 0.1;
      this.emissiveIntensity = 3.0;
      this.temperature = 4500;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
      this.maxTrailLength = 20;
      // PBR: å½—æ˜Ÿ - è¶…å¼ºå‘å…‰ã€ç­‰ç¦»å­è´¨æ„Ÿ
      this.roughness = 0.05;
      this.metalness = 0.7;
      this.emissiveIntensity = 6.0;
      this.temperature = 8000;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
      // PBR: æ˜Ÿç³» - ä¸­ç­‰å‘å…‰ã€æ˜Ÿå°˜è´¨æ„Ÿ
      this.roughness = 0.5;
      this.metalness = 0.6;
      this.emissiveIntensity = 2.5;
      this.temperature = 5500 + Math.random() * 3000;
    } else {
      this.friction = options.friction ?? 0.92;  // High friction (drag)
      this.gravity = options.gravity ?? 0.005;   // HOVER EFFECT: Near zero gravity
      this.decay = options.decay ?? Math.random() * 0.008 + 0.004;
      this.size = options.size ?? Math.random() * 2 + 1;
      // PBR: é»˜è®¤ç«èŠ± - æ ‡å‡†çƒŸèŠ±æ•ˆæœ
      this.roughness = 0.3;
      this.metalness = 0.5;
      this.emissiveIntensity = 2.0 + this.life;
      this.temperature = 3000 + Math.random() * 4000;
    }

    this.resistance = options.resistance ?? 0.002;  // é™ä½ç©ºæ°”é˜»åŠ›
  }

  update(deltaTime: number): void {
    // Skip update if effectively paused
    if (deltaTime <= 0) return;
    
    // Use a minimum dt to prevent division by zero and ensure smooth updates
    const dt = Math.max(deltaTime * 60, 0.001); // Normalize to 60fps with minimum

    // Store trail position (before position update)
    if (this.behavior === 'comet' || this.behavior === 'willow') {
      this.trail.push(this.position.clone());
      if (this.trail.length > this.maxTrailLength) {
        this.trail.shift();
      }
    }

    // Behavior-specific velocity modifiers
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.velocity.x += Math.sin(now) * 0.05 * dt;
      this.velocity.y += Math.cos(now * 0.7) * 0.05 * dt;
      this.velocity.z += Math.sin(now * 1.3) * 0.05 * dt;
    } else if (this.behavior === 'galaxy') {
      const dx = this.position.x - this.origin.x;
      const dz = this.position.z - this.origin.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const angle = Math.atan2(dz, dx) + this.rotationSpeed * dt;

      const targetX = this.origin.x + Math.cos(angle) * (dist + this.velocity.x * dt);
      const targetZ = this.origin.z + Math.sin(angle) * (dist + this.velocity.z * dt);

      if (dt > 0.001) {
        this.velocity.x = (targetX - this.position.x) / dt;
        this.velocity.z = (targetZ - this.position.z) / dt;
      }
    }

    // === é«˜çº§ç‰©ç†è®¡ç®— (Verlet ç§¯åˆ†å™¨) ===
    if (this.useAdvancedPhysics && !this.isFirstUpdate) {
      // Verlet ç§¯åˆ†: x(t+dt) = 2*x(t) - x(t-dt) + a*dt^2
      // åŠ é€Ÿåº¦ = é‡åŠ› + ç©ºæ°”é˜»åŠ›
      
      // è®¡ç®—ç©ºæ°”é˜»åŠ›åŠ é€Ÿåº¦
      const speedSq = this.velocity.x * this.velocity.x +
                      this.velocity.y * this.velocity.y +
                      this.velocity.z * this.velocity.z;
      
      let dragAx = 0, dragAy = 0, dragAz = 0;
      if (speedSq > 0.001) {
        const speed = Math.sqrt(speedSq);
        const dragMag = speedSq * this.resistance;
        dragAx = -(this.velocity.x / speed) * dragMag;
        dragAy = -(this.velocity.y / speed) * dragMag;
        dragAz = -(this.velocity.z / speed) * dragMag;
      }
      
      // æ€»åŠ é€Ÿåº¦
      const ax = dragAx;
      const ay = -this.gravity + dragAy;
      const az = dragAz;
      
      // Verlet ç§¯åˆ†å…¬å¼
      const newX = 2 * this.position.x - this.previousPosition.x + ax * deltaTime * deltaTime * 3600;
      const newY = 2 * this.position.y - this.previousPosition.y + ay * deltaTime * deltaTime * 3600;
      const newZ = 2 * this.position.z - this.previousPosition.z + az * deltaTime * deltaTime * 3600;
      
      // ä»ä½ç½®å·®æ¨å¯¼æ–°é€Ÿåº¦
      this.velocity.x = (newX - this.position.x) / dt;
      this.velocity.y = (newY - this.position.y) / dt;
      this.velocity.z = (newZ - this.position.z) / dt;
      
      // åº”ç”¨æ‘©æ“¦åŠ›
      const frictionPower = Math.pow(this.friction, dt);
      this.velocity.x *= frictionPower;
      this.velocity.y *= frictionPower;
      this.velocity.z *= frictionPower;
      
      // æ›´æ–°ä½ç½®
      this.previousPosition.x = this.position.x;
      this.previousPosition.y = this.position.y;
      this.previousPosition.z = this.position.z;
      
      this.position.x = newX;
      this.position.y = newY;
      this.position.z = newZ;
    } else {
      // === æ ‡å‡†æ¬§æ‹‰ç§¯åˆ† (å…¼å®¹æ¨¡å¼æˆ–é¦–å¸§) ===
      
      // Apply air resistance
      const speedSq = this.velocity.x * this.velocity.x +
                      this.velocity.y * this.velocity.y +
                      this.velocity.z * this.velocity.z;
      if (speedSq > 0.001) {
        const speed = Math.sqrt(speedSq);
        const drag = speedSq * this.resistance * dt;
        this.velocity.x -= (this.velocity.x / speed) * drag;
        this.velocity.y -= (this.velocity.y / speed) * drag;
        this.velocity.z -= (this.velocity.z / speed) * drag;
      }

      // Apply friction
      const frictionPower = Math.pow(this.friction, dt);
      this.velocity.x *= frictionPower;
      this.velocity.y *= frictionPower;
      this.velocity.z *= frictionPower;

      // Apply gravity (Y-up in Three.js)
      this.velocity.y -= this.gravity * dt;

      // Store previous position for Verlet
      this.previousPosition.x = this.position.x;
      this.previousPosition.y = this.position.y;
      this.previousPosition.z = this.position.z;

      // Update position
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.position.z += this.velocity.z * dt;
      
      this.isFirstUpdate = false;
    }

    // Update life
    this.life -= this.decay * dt;

    // Update alpha based on behavior
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }

    // Glitter twinkle
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15 * dt) % 1;
      // é—ªç²‰åŠ¨æ€å‘å…‰å¼ºåº¦
      this.emissiveIntensity = 3.0 + Math.sin(this.twinkleFactor * Math.PI * 2) * 2.0;
    }
    
    // åŠ¨æ€æ›´æ–° PBR å‘å…‰å¼ºåº¦ (éšç”Ÿå‘½å€¼è¡°å‡)
    if (this.behavior !== 'glitter') {
      this.emissiveIntensity = this.emissiveIntensity * (0.5 + this.life * 0.5);
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }

  getColor(): { r: number; g: number; b: number } {
    // HSL to RGB conversion
    const h = this.hue / 360;
    const s = 1;
    const l = 0.75;

    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    return {
      r: hue2rgb(p, q, h + 1/3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1/3)
    };
  }
}


// =============================================================================
// FILE: src\core\ParticlePool.ts
// =============================================================================


import { Particle } from './Particle';
import { ParticleOptions } from '../types';

/**
 * Performance-optimized Particle Pool
 */
export class ParticlePool {
  private pool: Particle[] = [];
  private active: Particle[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle());
    }
  }

  /**
   * Get a particle: recycle the oldest active one if limit reached.
   */
  get(options: ParticleOptions): Particle {
    let p: Particle;
    
    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle();
    }
    
    p.init(options);
    this.active.push(p);
    return p;
  }

  updateAndDraw(ctx: CanvasRenderingContext2D): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update();
      p.draw(ctx);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  get activeCount() { return this.active.length; }
}


// =============================================================================
// FILE: src\core\ParticlePool3D.ts
// =============================================================================

import { Particle3D } from './Particle3D';
import { ParticleOptions3D } from '../types';

/**
 * Performance-optimized 3D Particle Pool
 * Manages particle lifecycle with object pooling to minimize GC
 */
export class ParticlePool3D {
  private pool: Particle3D[] = [];
  private active: Particle3D[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle3D());
    }
  }

  /**
   * Get a particle from the pool
   * Recycles the oldest active particle if limit is reached
   */
  get(options: ParticleOptions3D): Particle3D {
    let p: Particle3D;

    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle3D();
    }

    p.init(options);
    this.active.push(p);
    return p;
  }

  /**
   * Update all active particles
   */
  update(deltaTime: number): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update(deltaTime);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  /**
   * Get all active particles for rendering
   */
  getActiveParticles(): Particle3D[] {
    return this.active;
  }

  /**
   * Get the count of active particles
   */
  get activeCount(): number {
    return this.active.length;
  }

  /**
   * Clear all active particles
   */
  clear(): void {
    while (this.active.length > 0) {
      const p = this.active.pop()!;
      this.pool.push(p);
    }
  }
}


// =============================================================================
// FILE: src\core\patterns\PatternFactory.ts
// =============================================================================

// FILE: src/core/patterns/PatternFactory.ts
// åœ°é¢å›¾æ¡ˆå·¥å‚ï¼šå…«å¦é˜µã€å¤ªæå›¾ã€äº”è¡Œé˜µã€å‡ ä½•å›¾å½¢ç­‰

import * as THREE from 'three';

/**
 * å›¾æ¡ˆç±»å‹æšä¸¾
 */
export enum PatternType {
  // ä¸­å›½ä¼ ç»Ÿæ³•é˜µç³»åˆ—
  BAGUA = 'bagua',                    // å…«å¦é˜µ
  TAIJI = 'taiji',                    // å¤ªæå›¾
  WUXING = 'wuxing',                  // äº”è¡Œé˜µ
  JIUGONG = 'jiugong',                // ä¹å®«æ ¼
  
  // å‡ ä½•å›¾å½¢ç³»åˆ—
  POLYGON_3 = 'polygon_3',            // ä¸‰è§’å½¢
  POLYGON_4 = 'polygon_4',            // æ­£æ–¹å½¢
  POLYGON_5 = 'polygon_5',            // äº”è¾¹å½¢
  POLYGON_6 = 'polygon_6',            // å…­è¾¹å½¢
  POLYGON_8 = 'polygon_8',            // å…«è¾¹å½¢
  POLYGON_12 = 'polygon_12',          // åäºŒè¾¹å½¢
  
  STAR_5 = 'star_5',                  // äº”è§’æ˜Ÿ
  STAR_6 = 'star_6',                  // å…­èŠ’æ˜Ÿ
  STAR_8 = 'star_8',                  // å…«è§’æ˜Ÿ
  
  SPIRAL_ARCHIMEDEAN = 'spiral_arch', // é˜¿åŸºç±³å¾·èºæ—‹
  SPIRAL_LOG = 'spiral_log',          // å¯¹æ•°èºæ—‹
  
  // ç®€å•å½¢çŠ¶
  CIRCLE = 'circle',
  GRID = 'grid',
  CROSS = 'cross',
  
  // è‡ªå®šä¹‰
  CUSTOM = 'custom'
}

/**
 * å›¾æ¡ˆä¿¡æ¯
 */
export const PATTERN_INFO: Record<PatternType, { name: string; icon: string; description: string }> = {
  [PatternType.BAGUA]: { name: 'å…«å¦é˜µ', icon: 'â˜¯', description: 'ä¹¾å¤éœ‡å·½åç¦»è‰®å…‘' },
  [PatternType.TAIJI]: { name: 'å¤ªæå›¾', icon: 'â˜¯', description: 'é˜´é˜³äº¤è' },
  [PatternType.WUXING]: { name: 'äº”è¡Œé˜µ', icon: 'ğŸ”¥', description: 'é‡‘æœ¨æ°´ç«åœŸ' },
  [PatternType.JIUGONG]: { name: 'ä¹å®«æ ¼', icon: 'â¬œ', description: 'æ´›ä¹¦ä¹å®«' },
  
  [PatternType.POLYGON_3]: { name: 'ä¸‰è§’å½¢', icon: 'â–³', description: 'ä¸‰è¾¹å½¢' },
  [PatternType.POLYGON_4]: { name: 'æ­£æ–¹å½¢', icon: 'â–¡', description: 'å››è¾¹å½¢' },
  [PatternType.POLYGON_5]: { name: 'äº”è¾¹å½¢', icon: 'â¬ ', description: 'äº”è¾¹å½¢' },
  [PatternType.POLYGON_6]: { name: 'å…­è¾¹å½¢', icon: 'â¬¡', description: 'å…­è¾¹å½¢' },
  [PatternType.POLYGON_8]: { name: 'å…«è¾¹å½¢', icon: 'â¯ƒ', description: 'å…«è¾¹å½¢' },
  [PatternType.POLYGON_12]: { name: 'åäºŒè¾¹å½¢', icon: 'â—¯', description: 'åäºŒè¾¹å½¢' },
  
  [PatternType.STAR_5]: { name: 'äº”è§’æ˜Ÿ', icon: 'â­', description: 'äº”è§’æ˜Ÿ' },
  [PatternType.STAR_6]: { name: 'å…­èŠ’æ˜Ÿ', icon: 'âœ¡', description: 'å¤§å«ä¹‹æ˜Ÿ' },
  [PatternType.STAR_8]: { name: 'å…«è§’æ˜Ÿ', icon: 'âœ´', description: 'å…«è§’æ˜Ÿ' },
  
  [PatternType.SPIRAL_ARCHIMEDEAN]: { name: 'é˜¿åŸºç±³å¾·èºæ—‹', icon: 'ğŸŒ€', description: 'ç­‰è·èºæ—‹' },
  [PatternType.SPIRAL_LOG]: { name: 'å¯¹æ•°èºæ—‹', icon: 'ğŸš', description: 'é»„é‡‘èºæ—‹' },
  
  [PatternType.CIRCLE]: { name: 'åœ†ç¯', icon: 'â­•', description: 'ç®€å•åœ†ç¯' },
  [PatternType.GRID]: { name: 'ç½‘æ ¼', icon: '#', description: 'æ–¹æ ¼ç½‘' },
  [PatternType.CROSS]: { name: 'åå­—', icon: 'âœš', description: 'åå­—å½¢' },
  
  [PatternType.CUSTOM]: { name: 'è‡ªå®šä¹‰', icon: 'âœ', description: 'SVG/æ‰‹ç»˜' }
};

/**
 * å›¾æ¡ˆé…ç½®
 */
export interface PatternConfig {
  type: PatternType;
  scale: number;           // ç¼©æ”¾ (0.5 - 5)
  rotation: number;        // æ—‹è½¬è§’åº¦ (å¼§åº¦)
  strokeColor: string;     // æè¾¹é¢œè‰²
  fillColor?: string;      // å¡«å……é¢œè‰²
  opacity: number;         // é€æ˜åº¦
  lineWidth: number;       // çº¿å®½
  animated: boolean;       // æ˜¯å¦åŠ¨ç”»
  animationType?: 'breathe' | 'rotate' | 'pulse';
  customSVG?: string;      // è‡ªå®šä¹‰ SVG è·¯å¾„
}

/**
 * å›¾æ¡ˆç‚¹é›†
 */
export interface PatternPoints {
  lines: Array<THREE.Vector3[]>;  // çº¿æ®µé›†åˆ
  circles: Array<{ center: THREE.Vector3; radius: number }>;
  polygons: Array<THREE.Vector3[]>;
  text: Array<{ position: THREE.Vector3; content: string; size: number }>;
}

/**
 * å›¾æ¡ˆå·¥å‚
 */
export class PatternFactory {
  
  /**
   * ç”Ÿæˆå›¾æ¡ˆç‚¹é›†
   */
  static generate(config: PatternConfig): PatternPoints {
    const result: PatternPoints = {
      lines: [],
      circles: [],
      polygons: [],
      text: []
    };
    
    const scale = config.scale || 1;
    const baseRadius = 100 * scale;
    
    switch (config.type) {
      case PatternType.BAGUA:
        this.generateBagua(result, baseRadius);
        break;
      case PatternType.TAIJI:
        this.generateTaiji(result, baseRadius);
        break;
      case PatternType.WUXING:
        this.generateWuxing(result, baseRadius);
        break;
      case PatternType.JIUGONG:
        this.generateJiugong(result, baseRadius);
        break;
      case PatternType.STAR_5:
      case PatternType.STAR_6:
      case PatternType.STAR_8:
        this.generateStar(result, baseRadius, parseInt(config.type.split('_')[1]));
        break;
      case PatternType.POLYGON_3:
      case PatternType.POLYGON_4:
      case PatternType.POLYGON_5:
      case PatternType.POLYGON_6:
      case PatternType.POLYGON_8:
      case PatternType.POLYGON_12:
        this.generatePolygon(result, baseRadius, parseInt(config.type.split('_')[1]));
        break;
      case PatternType.SPIRAL_ARCHIMEDEAN:
        this.generateSpiral(result, baseRadius, 'archimedean');
        break;
      case PatternType.SPIRAL_LOG:
        this.generateSpiral(result, baseRadius, 'logarithmic');
        break;
      case PatternType.CIRCLE:
        this.generateCircle(result, baseRadius);
        break;
      case PatternType.GRID:
        this.generateGrid(result, baseRadius);
        break;
      case PatternType.CROSS:
        this.generateCross(result, baseRadius);
        break;
    }
    
    // åº”ç”¨æ—‹è½¬
    if (config.rotation !== 0) {
      this.applyRotation(result, config.rotation);
    }
    
    return result;
  }
  
  /**
   * ç”Ÿæˆå…«å¦é˜µ
   */
  private static generateBagua(result: PatternPoints, radius: number): void {
    // å¤–åœ†
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius });
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius * 0.7 });
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius * 0.4 });
    
    // å…«ä¸ªå¦è±¡ä½ç½®
    const trigrams = ['ä¹¾', 'å…‘', 'ç¦»', 'éœ‡', 'å·½', 'å', 'è‰®', 'å¤'];
    const trigramPatterns = [
      [1, 1, 1], // ä¹¾ â˜°
      [0, 1, 1], // å…‘ â˜±
      [1, 0, 1], // ç¦» â˜²
      [0, 0, 1], // éœ‡ â˜³
      [1, 1, 0], // å·½ â˜´
      [0, 1, 0], // å â˜µ
      [1, 0, 0], // è‰® â˜¶
      [0, 0, 0], // å¤ â˜·
    ];
    
    for (let i = 0; i < 8; i++) {
      const angle = (i * Math.PI / 4) - Math.PI / 2;
      const x = Math.cos(angle) * radius * 0.85;
      const z = Math.sin(angle) * radius * 0.85;
      
      // å¦è±¡çº¿æ¡ (é˜³çˆ»å®çº¿ï¼Œé˜´çˆ»è™šçº¿)
      const pattern = trigramPatterns[i];
      for (let j = 0; j < 3; j++) {
        const lineY = (j - 1) * 8;
        const lineLen = 15;
        const perpAngle = angle + Math.PI / 2;
        
        if (pattern[j] === 1) {
          // é˜³çˆ» - å®çº¿
          result.lines.push([
            new THREE.Vector3(
              x + Math.cos(perpAngle) * lineLen,
              0,
              z + Math.sin(perpAngle) * lineLen + lineY * 0.5
            ),
            new THREE.Vector3(
              x - Math.cos(perpAngle) * lineLen,
              0,
              z - Math.sin(perpAngle) * lineLen + lineY * 0.5
            )
          ]);
        } else {
          // é˜´çˆ» - æ–­å¼€
          result.lines.push([
            new THREE.Vector3(x + Math.cos(perpAngle) * lineLen, 0, z + Math.sin(perpAngle) * lineLen + lineY * 0.5),
            new THREE.Vector3(x + Math.cos(perpAngle) * 3, 0, z + Math.sin(perpAngle) * 3 + lineY * 0.5)
          ]);
          result.lines.push([
            new THREE.Vector3(x - Math.cos(perpAngle) * 3, 0, z - Math.sin(perpAngle) * 3 + lineY * 0.5),
            new THREE.Vector3(x - Math.cos(perpAngle) * lineLen, 0, z - Math.sin(perpAngle) * lineLen + lineY * 0.5)
          ]);
        }
      }
      
      // æ–‡å­—æ ‡ç­¾
      result.text.push({
        position: new THREE.Vector3(x * 1.15, 0, z * 1.15),
        content: trigrams[i],
        size: 12
      });
    }
    
    // ä¸­å¿ƒå¤ªæ
    this.generateTaiji(result, radius * 0.35);
  }
  
  /**
   * ç”Ÿæˆå¤ªæå›¾
   */
  private static generateTaiji(result: PatternPoints, radius: number): void {
    // å¤–åœ†
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius });
    
    // Så½¢æ›²çº¿ (ç”¨çº¿æ®µè¿‘ä¼¼)
    const sCurve: THREE.Vector3[] = [];
    for (let t = 0; t <= 1; t += 0.02) {
      const angle = t * Math.PI;
      const r = radius * 0.5;
      const x = Math.sin(angle * 2) * r * 0.5;
      const z = -radius + t * radius * 2;
      sCurve.push(new THREE.Vector3(x, 0, z));
    }
    result.lines.push(sCurve);
    
    // é˜´é˜³çœ¼
    result.circles.push({ center: new THREE.Vector3(0, 0, -radius * 0.5), radius: radius * 0.15 });
    result.circles.push({ center: new THREE.Vector3(0, 0, radius * 0.5), radius: radius * 0.15 });
  }
  
  /**
   * ç”Ÿæˆäº”è¡Œé˜µ
   */
  private static generateWuxing(result: PatternPoints, radius: number): void {
    // äº”è¡Œ: é‡‘æœ¨æ°´ç«åœŸï¼Œå¯¹åº”äº”è§’æ˜Ÿé¡¶ç‚¹
    const elements = ['é‡‘', 'æœ¨', 'æ°´', 'ç«', 'åœŸ'];
    const colors = ['#FFD700', '#228B22', '#1E90FF', '#FF4500', '#8B4513'];
    
    // å¤–åœ†
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius });
    
    // äº”è§’æ˜Ÿ
    const starPoints: THREE.Vector3[] = [];
    for (let i = 0; i < 5; i++) {
      const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
      starPoints.push(new THREE.Vector3(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
      ));
    }
    
    // äº”è§’æ˜Ÿè¿çº¿ (ç›¸ç”Ÿç›¸å…‹)
    for (let i = 0; i < 5; i++) {
      result.lines.push([starPoints[i], starPoints[(i + 2) % 5]]);
    }
    
    // å…ƒç´ æ ‡ç­¾
    for (let i = 0; i < 5; i++) {
      const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
      result.text.push({
        position: new THREE.Vector3(
          Math.cos(angle) * radius * 1.2,
          0,
          Math.sin(angle) * radius * 1.2
        ),
        content: elements[i],
        size: 14
      });
    }
  }
  
  /**
   * ç”Ÿæˆä¹å®«æ ¼
   */
  private static generateJiugong(result: PatternPoints, radius: number): void {
    const size = radius * 2;
    const cellSize = size / 3;
    
    // æ°´å¹³çº¿
    for (let i = 0; i <= 3; i++) {
      const z = -radius + i * cellSize;
      result.lines.push([
        new THREE.Vector3(-radius, 0, z),
        new THREE.Vector3(radius, 0, z)
      ]);
    }
    
    // å‚ç›´çº¿
    for (let i = 0; i <= 3; i++) {
      const x = -radius + i * cellSize;
      result.lines.push([
        new THREE.Vector3(x, 0, -radius),
        new THREE.Vector3(x, 0, radius)
      ]);
    }
    
    // æ´›ä¹¦æ•°å­—
    const luoshu = [
      [4, 9, 2],
      [3, 5, 7],
      [8, 1, 6]
    ];
    
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        result.text.push({
          position: new THREE.Vector3(
            -radius + cellSize * (col + 0.5),
            0,
            -radius + cellSize * (row + 0.5)
          ),
          content: luoshu[row][col].toString(),
          size: 16
        });
      }
    }
  }
  
  /**
   * ç”Ÿæˆå¤šè¾¹å½¢
   */
  private static generatePolygon(result: PatternPoints, radius: number, sides: number): void {
    const points: THREE.Vector3[] = [];
    for (let i = 0; i < sides; i++) {
      const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
      points.push(new THREE.Vector3(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
      ));
    }
    points.push(points[0].clone()); // é—­åˆ
    result.polygons.push(points);
  }
  
  /**
   * ç”Ÿæˆæ˜Ÿå½¢
   */
  private static generateStar(result: PatternPoints, radius: number, points: number): void {
    const outer = radius;
    const inner = radius * 0.4;
    const starPoints: THREE.Vector3[] = [];
    
    for (let i = 0; i < points * 2; i++) {
      const angle = (i * Math.PI / points) - Math.PI / 2;
      const r = i % 2 === 0 ? outer : inner;
      starPoints.push(new THREE.Vector3(
        Math.cos(angle) * r,
        0,
        Math.sin(angle) * r
      ));
    }
    starPoints.push(starPoints[0].clone());
    result.polygons.push(starPoints);
  }
  
  /**
   * ç”Ÿæˆèºæ—‹
   */
  private static generateSpiral(result: PatternPoints, radius: number, type: 'archimedean' | 'logarithmic'): void {
    const spiral: THREE.Vector3[] = [];
    const turns = 5;
    const steps = 200;
    
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const angle = turns * 2 * Math.PI * t;
      
      let r: number;
      if (type === 'archimedean') {
        r = radius * t;
      } else {
        r = radius * 0.1 * Math.exp(0.3 * angle);
        if (r > radius) break;
      }
      
      spiral.push(new THREE.Vector3(
        Math.cos(angle) * r,
        0,
        Math.sin(angle) * r
      ));
    }
    
    result.lines.push(spiral);
  }
  
  /**
   * ç”Ÿæˆåœ†ç¯
   */
  private static generateCircle(result: PatternPoints, radius: number): void {
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius });
    result.circles.push({ center: new THREE.Vector3(0, 0, 0), radius: radius * 0.8 });
  }
  
  /**
   * ç”Ÿæˆç½‘æ ¼
   */
  private static generateGrid(result: PatternPoints, radius: number): void {
    const spacing = radius / 5;
    for (let i = -5; i <= 5; i++) {
      result.lines.push([
        new THREE.Vector3(i * spacing, 0, -radius),
        new THREE.Vector3(i * spacing, 0, radius)
      ]);
      result.lines.push([
        new THREE.Vector3(-radius, 0, i * spacing),
        new THREE.Vector3(radius, 0, i * spacing)
      ]);
    }
  }
  
  /**
   * ç”Ÿæˆåå­—
   */
  private static generateCross(result: PatternPoints, radius: number): void {
    result.lines.push([
      new THREE.Vector3(0, 0, -radius),
      new THREE.Vector3(0, 0, radius)
    ]);
    result.lines.push([
      new THREE.Vector3(-radius, 0, 0),
      new THREE.Vector3(radius, 0, 0)
    ]);
  }
  
  /**
   * åº”ç”¨æ—‹è½¬
   */
  private static applyRotation(points: PatternPoints, angle: number): void {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    
    const rotate = (v: THREE.Vector3) => {
      const x = v.x * cos - v.z * sin;
      const z = v.x * sin + v.z * cos;
      v.x = x;
      v.z = z;
    };
    
    points.lines.forEach(line => line.forEach(rotate));
    points.circles.forEach(c => rotate(c.center));
    points.polygons.forEach(poly => poly.forEach(rotate));
    points.text.forEach(t => rotate(t.position));
  }
  
  /**
   * è·å–æ‰€æœ‰å¯ç”¨å›¾æ¡ˆç±»å‹
   */
  static getAllTypes(): PatternType[] {
    return Object.values(PatternType).filter(t => t !== PatternType.CUSTOM);
  }
  
  /**
   * åˆ›å»º Three.js çº¿æ¡å¯¹è±¡
   */
  static createLineObject(points: PatternPoints, config: PatternConfig): THREE.Group {
    const group = new THREE.Group();
    
    const lineMaterial = new THREE.LineBasicMaterial({
      color: config.strokeColor || '#10b981',
      transparent: true,
      opacity: config.opacity || 0.6,
      linewidth: config.lineWidth || 2
    });
    
    // æ·»åŠ çº¿æ®µ
    points.lines.forEach(linePoints => {
      const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
      const line = new THREE.Line(geometry, lineMaterial);
      group.add(line);
    });
    
    // æ·»åŠ å¤šè¾¹å½¢
    points.polygons.forEach(polyPoints => {
      const geometry = new THREE.BufferGeometry().setFromPoints(polyPoints);
      const line = new THREE.Line(geometry, lineMaterial);
      group.add(line);
    });
    
    // æ·»åŠ åœ†
    points.circles.forEach(circle => {
      const geometry = new THREE.RingGeometry(
        circle.radius - 1,
        circle.radius,
        64
      );
      const mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshBasicMaterial({
          color: config.strokeColor || '#10b981',
          transparent: true,
          opacity: config.opacity || 0.6,
          side: THREE.DoubleSide
        })
      );
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.copy(circle.center);
      group.add(mesh);
    });
    
    group.position.y = -49; // ç•¥é«˜äºåœ°é¢ç½‘æ ¼
    
    return group;
  }
}

// END OF FILE: src/core/patterns/PatternFactory.ts


// =============================================================================
// FILE: src\core\PBRMaterial.ts
// =============================================================================

/**
 * PBRMaterial.ts - ç‰©ç†åŸºç¡€æ¸²æŸ“æè´¨ç³»ç»Ÿ
 * 
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - ç²—ç³™åº¦ (Roughness) - æ§åˆ¶å…‰çº¿æ•£å°„
 * - é‡‘å±åº¦ (Metalness) - æ§åˆ¶é•œé¢åå°„
 * - è‡ªå‘å…‰ (Emissive) - çƒŸèŠ±çš„æ ¸å¿ƒå…‰æº
 * - HDR æ”¯æŒ - è¶…è¿‡1.0çš„äº®åº¦å€¼
 * 
 * ç”¨äºåˆ›å»ºæ— æ³•åŒºåˆ†çœŸå®ä¸è™šæ‹Ÿçš„çƒŸèŠ±æ•ˆæœ
 */

import * as THREE from 'three';

/**
 * ç²’å­ PBR å±æ€§
 */
export interface ParticlePBRProperties {
  roughness: number;      // 0-1, 0=å®Œå…¨å…‰æ»‘(é•œé¢), 1=å®Œå…¨ç²—ç³™(æ¼«åå°„)
  metalness: number;      // 0-1, 0=éé‡‘å±(å¡‘æ–™), 1=é‡‘å±(é«˜åå°„)
  emissiveIntensity: number; // HDR å‘å…‰å¼ºåº¦, å¯è¶…è¿‡ 1.0
  temperature: number;    // è‰²æ¸©æ§åˆ¶, 2000K-10000K
}

/**
 * é¢„è®¾çš„ç²’å­æè´¨ç±»å‹
 */
export enum ParticleMaterialType {
  SPARK = 'spark',           // ç«èŠ± - é«˜é‡‘å±åº¦ï¼Œä¸­ç­‰ç²—ç³™åº¦
  EMBER = 'ember',           // ä½™çƒ¬ - ä½é‡‘å±åº¦ï¼Œé«˜ç²—ç³™åº¦
  GLITTER = 'glitter',       // é—ªç²‰ - é«˜é‡‘å±åº¦ï¼Œä½ç²—ç³™åº¦
  SMOKE = 'smoke',           // çƒŸé›¾ - é€æ˜æ¼«åå°„
  STAR_CORE = 'star_core',   // æ˜ŸèŠ¯ - æé«˜å‘å…‰å¼ºåº¦
  PLASMA = 'plasma',         // ç­‰ç¦»å­ - é«˜å‘å…‰ï¼Œä½ç²—ç³™åº¦
  CRYSTAL = 'crystal',       // æ°´æ™¶ - ä¸­ç­‰é‡‘å±åº¦ï¼Œæä½ç²—ç³™åº¦
}

/**
 * æè´¨é¢„è®¾é…ç½®
 */
export const PBR_PRESETS: Record<ParticleMaterialType, ParticlePBRProperties> = {
  [ParticleMaterialType.SPARK]: {
    roughness: 0.3,
    metalness: 0.9,
    emissiveIntensity: 3.0,
    temperature: 3000
  },
  [ParticleMaterialType.EMBER]: {
    roughness: 0.8,
    metalness: 0.2,
    emissiveIntensity: 1.5,
    temperature: 2000
  },
  [ParticleMaterialType.GLITTER]: {
    roughness: 0.1,
    metalness: 1.0,
    emissiveIntensity: 4.0,
    temperature: 6500
  },
  [ParticleMaterialType.SMOKE]: {
    roughness: 1.0,
    metalness: 0.0,
    emissiveIntensity: 0.0,
    temperature: 5000
  },
  [ParticleMaterialType.STAR_CORE]: {
    roughness: 0.0,
    metalness: 0.5,
    emissiveIntensity: 8.0,
    temperature: 8000
  },
  [ParticleMaterialType.PLASMA]: {
    roughness: 0.05,
    metalness: 0.7,
    emissiveIntensity: 5.0,
    temperature: 10000
  },
  [ParticleMaterialType.CRYSTAL]: {
    roughness: 0.02,
    metalness: 0.6,
    emissiveIntensity: 2.5,
    temperature: 7000
  }
};

/**
 * æ ¹æ®è‰²æ¸©è®¡ç®— RGB é¢œè‰² (Planckian Locus)
 * åŸºäº Tanner Helland çš„è¿‘ä¼¼ç®—æ³•
 */
export function temperatureToRGB(kelvin: number): { r: number; g: number; b: number } {
  const temp = kelvin / 100;
  let r: number, g: number, b: number;
  
  // çº¢è‰²é€šé“
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  
  // ç»¿è‰²é€šé“
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  
  // è“è‰²é€šé“
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  
  return {
    r: r / 255,
    g: g / 255,
    b: b / 255
  };
}

/**
 * HDR é¢œè‰²å¤„ç† - æ”¯æŒè¶…è¿‡ 1.0 çš„äº®åº¦
 */
export function createHDRColor(
  hue: number,
  saturation: number,
  intensity: number
): THREE.Color {
  const color = new THREE.Color();
  color.setHSL(hue / 360, saturation, 0.5);
  
  // HDR å¼ºåº¦ï¼šå…è®¸è¶…è¿‡ 1.0
  color.r *= intensity;
  color.g *= intensity;
  color.b *= intensity;
  
  return color;
}

/**
 * åˆ›å»ºé«˜çº§ç²’å­æè´¨ç€è‰²å™¨
 * æ”¯æŒï¼šPBR å±æ€§ã€HDRã€è‡ªå‘å…‰ã€æŸ”å’Œè¾¹ç¼˜
 */
export function createAdvancedParticleMaterial(): THREE.ShaderMaterial {
  const vertexShader = `
    attribute float size;
    attribute float alpha;
    attribute vec3 particleColor;
    attribute float roughness;
    attribute float metalness;
    attribute float emissive;
    
    varying vec3 vColor;
    varying float vAlpha;
    varying float vRoughness;
    varying float vMetalness;
    varying float vEmissive;
    varying float vDistance;
    
    void main() {
      vColor = particleColor;
      vAlpha = alpha;
      vRoughness = roughness;
      vMetalness = metalness;
      vEmissive = emissive;
      
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      vDistance = -mvPosition.z;
      
      // åŸºäºè·ç¦»çš„å¤§å°è¡°å‡ (æ›´ç‰©ç†å‡†ç¡®)
      float sizeAttenuation = 300.0 / (-mvPosition.z);
      gl_PointSize = size * sizeAttenuation;
      gl_PointSize = clamp(gl_PointSize, 1.0, 128.0);
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `;
  
  const fragmentShader = `
    varying vec3 vColor;
    varying float vAlpha;
    varying float vRoughness;
    varying float vMetalness;
    varying float vEmissive;
    varying float vDistance;
    
    // åŸºäºç‰©ç†çš„å…‰ç…§è®¡ç®—
    vec3 fresnelSchlick(float cosTheta, vec3 F0) {
      return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    }
    
    void main() {
      // è®¡ç®—ç‚¹ç²¾çµçš„åœ†å½¢é®ç½©
      vec2 center = gl_PointCoord - vec2(0.5);
      float dist = length(center);
      
      // æŸ”å’Œè¾¹ç¼˜ - é«˜æ–¯è¡°å‡
      float softness = 0.5 - vRoughness * 0.3; // ç²—ç³™åº¦è¶Šé«˜ï¼Œè¾¹ç¼˜è¶ŠæŸ”å’Œ
      float edgeFalloff = 1.0 - smoothstep(0.0, softness, dist);
      
      // æ ¸å¿ƒå…‰æ™• (è‡ªå‘å…‰æ•ˆæœ)
      float coreGlow = exp(-dist * dist * 8.0) * vEmissive;
      
      // PBR è®¡ç®— - ç®€åŒ–çš„ Fresnel æ•ˆæœ
      vec3 baseColor = vColor;
      vec3 F0 = mix(vec3(0.04), baseColor, vMetalness);
      
      // æ¨¡æ‹Ÿä»ä¸­å¿ƒå‘å¤–çœ‹çš„ Fresnel
      float fresnel = pow(1.0 - max(0.0, 1.0 - dist * 2.0), 5.0);
      vec3 fresnelColor = mix(baseColor, vec3(1.0), fresnel * vMetalness);
      
      // æœ€ç»ˆé¢œè‰² = åŸºç¡€è‰² + æ ¸å¿ƒå…‰æ™• + Fresnel é«˜å…‰
      vec3 finalColor = fresnelColor + vec3(coreGlow);
      
      // HDR è¾“å‡º (ä¸ clampï¼Œè®©åæœŸå¤„ç†çš„ tone mapping æ¥å¤„ç†)
      float finalAlpha = edgeFalloff * vAlpha;
      
      // ä¸¢å¼ƒé€æ˜åƒç´ 
      if (finalAlpha < 0.01) discard;
      
      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;
  
  return new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    uniforms: {}
  });
}

/**
 * åˆ›å»ºç”¨äº PointsMaterial çš„é«˜è´¨é‡ç²’å­è´´å›¾
 * å…·æœ‰ PBR é£æ ¼çš„æŸ”å’Œæ¸å˜å’Œæ ¸å¿ƒå…‰æ™•
 */
export function createPBRParticleTexture(resolution: number = 128): THREE.CanvasTexture {
  const canvas = document.createElement('canvas');
  canvas.width = resolution;
  canvas.height = resolution;
  const ctx = canvas.getContext('2d')!;
  
  const center = resolution / 2;
  
  // å¤šå±‚æ¸å˜å®ç° HDR æ•ˆæœ
  // ç¬¬ä¸€å±‚ï¼šæ ¸å¿ƒå…‰æ™• (é«˜å¼ºåº¦)
  const coreGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.3);
  coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
  coreGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
  coreGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');
  coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = coreGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  // ç¬¬äºŒå±‚ï¼šä¸»å…‰æ™• (ä¸­ç­‰å¼ºåº¦)
  const mainGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.6);
  mainGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
  mainGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)');
  mainGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
  mainGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = mainGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  // ç¬¬ä¸‰å±‚ï¼šå¤–å±‚æŸ”å’Œè¾¹ç¼˜
  const outerGradient = ctx.createRadialGradient(center, center, 0, center, center, center);
  outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
  outerGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
  outerGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.02)');
  outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = outerGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
}

/**
 * åˆ›å»ºå¸¦å‘å…‰æ•ˆæœçš„åœ°é¢ï¼Œç”¨äºæ¥æ”¶çƒŸèŠ±å…‰çº¿åå°„
 */
export function createReflectiveGround(width: number = 8000, height: number = 8000): THREE.Mesh {
  const geometry = new THREE.PlaneGeometry(width, height);
  
  const material = new THREE.MeshStandardMaterial({
    color: 0x1a1a2e,
    roughness: 0.7,
    metalness: 0.3,
    transparent: true,
    opacity: 0.6,
    envMapIntensity: 0.5
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.y = -10;
  mesh.receiveShadow = true;
  
  return mesh;
}

/**
 * æè´¨ç®¡ç†å™¨ - ç®¡ç†æ‰€æœ‰ PBR æè´¨çš„ç”Ÿå‘½å‘¨æœŸ
 */
export class PBRMaterialManager {
  private materials: Map<string, THREE.Material> = new Map();
  private textures: Map<string, THREE.Texture> = new Map();
  
  constructor() {
    // é¢„åˆ›å»ºå¸¸ç”¨çº¹ç†
    this.textures.set('particle_pbr', createPBRParticleTexture(128));
    this.textures.set('particle_pbr_hd', createPBRParticleTexture(256));
  }
  
  /**
   * è·å–ç²’å­ PBR è´´å›¾
   */
  getParticleTexture(highQuality: boolean = false): THREE.Texture {
    return this.textures.get(highQuality ? 'particle_pbr_hd' : 'particle_pbr')!;
  }
  
  /**
   * è·å–é¢„è®¾çš„ PBR å±æ€§
   */
  getPreset(type: ParticleMaterialType): ParticlePBRProperties {
    return { ...PBR_PRESETS[type] };
  }
  
  /**
   * æ··åˆä¸¤ç§æè´¨å±æ€§
   */
  blendPresets(
    typeA: ParticleMaterialType,
    typeB: ParticleMaterialType,
    factor: number
  ): ParticlePBRProperties {
    const a = PBR_PRESETS[typeA];
    const b = PBR_PRESETS[typeB];
    const t = Math.max(0, Math.min(1, factor));
    
    return {
      roughness: a.roughness * (1 - t) + b.roughness * t,
      metalness: a.metalness * (1 - t) + b.metalness * t,
      emissiveIntensity: a.emissiveIntensity * (1 - t) + b.emissiveIntensity * t,
      temperature: a.temperature * (1 - t) + b.temperature * t
    };
  }
  
  /**
   * æ¸…ç†æè´¨èµ„æº
   */
  dispose(): void {
    this.materials.forEach(mat => mat.dispose());
    this.textures.forEach(tex => tex.dispose());
    this.materials.clear();
    this.textures.clear();
  }
}

/**
 * å…¨å±€æè´¨ç®¡ç†å™¨å•ä¾‹
 */
let globalMaterialManager: PBRMaterialManager | null = null;

export function getPBRMaterialManager(): PBRMaterialManager {
  if (!globalMaterialManager) {
    globalMaterialManager = new PBRMaterialManager();
  }
  return globalMaterialManager;
}


// =============================================================================
// FILE: src\core\PhysicsEngine.ts
// =============================================================================

/**
 * PhysicsEngine.ts - é¡¶çº§ç‰©ç†å¼•æ“
 * 
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - Verlet ç§¯åˆ†å™¨ (æ— æ¡ä»¶ç¨³å®š)
 * - Sub-stepping (å¸§å†…å¤šæ¬¡ç‰©ç†è®¡ç®—)
 * - RK4 ç§¯åˆ†å™¨æ”¯æŒ (é¾™æ ¼-åº“å¡”æ³•)
 * 
 * ç›®æ ‡ï¼šå³ä½¿åœ¨ä½å¸§ç‡ä¸‹ï¼ŒçƒŸèŠ±è½¨è¿¹ä¹Ÿä¸æ»‘å¦‚ç»¸ç¼
 */

import { Vector3 } from './Vector3';

/**
 * ç§¯åˆ†å™¨æ¥å£ - æ‰€æœ‰ç§¯åˆ†å™¨å¿…é¡»å®ç°
 */
export interface Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 };
}

/**
 * æ¬§æ‹‰ç§¯åˆ†å™¨ (æœ´ç´ ç‰ˆæœ¬ï¼Œä½œä¸ºå¯¹æ¯”å‚è€ƒ)
 */
export class EulerIntegrator implements Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 } {
    const a = acceleration(position, velocity);
    
    const newVelocity = new Vector3(
      velocity.x + a.x * dt,
      velocity.y + a.y * dt,
      velocity.z + a.z * dt
    );
    
    const newPosition = new Vector3(
      position.x + newVelocity.x * dt,
      position.y + newVelocity.y * dt,
      position.z + newVelocity.z * dt
    );
    
    return { position: newPosition, velocity: newVelocity };
  }
}

/**
 * Verlet ç§¯åˆ†å™¨ - æ—¶é—´å¯é€†, èƒ½é‡å®ˆæ’, ä½ç½®ç²¾ç¡®åº¦æé«˜
 * ç‰¹ç‚¹ï¼šå¯¹äºé•¿æ—¶é—´æ¨¡æ‹Ÿæ¯”æ¬§æ‹‰æ³•ç¨³å®šå¾—å¤š
 */
export class VerletIntegrator implements Integrator {
  private previousPositions: WeakMap<object, Vector3> = new WeakMap();
  
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number,
    particleRef?: object
  ): { position: Vector3; velocity: Vector3 } {
    // å¯¹äºé¦–æ¬¡è°ƒç”¨ï¼Œä½¿ç”¨æ¬§æ‹‰æ³•åˆå§‹åŒ–
    let prevPos = particleRef ? this.previousPositions.get(particleRef) : null;
    
    if (!prevPos) {
      // é¦–æ¬¡è¿­ä»£ï¼šä½¿ç”¨åå‘æ¬§æ‹‰ä¼°è®¡ä¹‹å‰çš„ä½ç½®
      prevPos = new Vector3(
        position.x - velocity.x * dt,
        position.y - velocity.y * dt,
        position.z - velocity.z * dt
      );
    }
    
    const a = acceleration(position, velocity);
    
    // Verlet ç§¯åˆ†: x(t+dt) = 2*x(t) - x(t-dt) + a*dt^2
    const newPosition = new Vector3(
      2 * position.x - prevPos.x + a.x * dt * dt,
      2 * position.y - prevPos.y + a.y * dt * dt,
      2 * position.z - prevPos.z + a.z * dt * dt
    );
    
    // ä»ä½ç½®å·®æ¨å¯¼é€Ÿåº¦ (ç”¨äºå…¶ä»–ç³»ç»Ÿå¦‚ç¢°æ’æ£€æµ‹)
    const newVelocity = new Vector3(
      (newPosition.x - position.x) / dt,
      (newPosition.y - position.y) / dt,
      (newPosition.z - position.z) / dt
    );
    
    // ç¼“å­˜å½“å‰ä½ç½®ä¾›ä¸‹æ¬¡ä½¿ç”¨
    if (particleRef) {
      this.previousPositions.set(particleRef, position.clone());
    }
    
    return { position: newPosition, velocity: newVelocity };
  }
  
  /**
   * æ¸…ç†ç¼“å­˜çš„ä½ç½®ä¿¡æ¯
   */
  clearCache(particleRef: object): void {
    this.previousPositions.delete(particleRef);
  }
}

/**
 * RK4 ç§¯åˆ†å™¨ (é¾™æ ¼-åº“å¡” 4é˜¶æ³•) - ç²¾åº¦æœ€é«˜
 * ç‰¹ç‚¹ï¼šå››æ¬¡é‡‡æ ·ï¼Œè¯¯å·® O(dt^5)ï¼Œä½†è®¡ç®—é‡æ˜¯æ¬§æ‹‰æ³•çš„4å€
 */
export class RK4Integrator implements Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 } {
    // çŠ¶æ€ = [position, velocity]
    // å¯¼æ•° = [velocity, acceleration]
    
    // k1: èµ·ç‚¹çš„æ–œç‡
    const a1 = acceleration(position, velocity);
    const k1_pos = velocity.clone();
    const k1_vel = a1.clone();
    
    // k2: ä¸­ç‚¹çš„æ–œç‡ (ä½¿ç”¨ k1)
    const pos2 = new Vector3(
      position.x + k1_pos.x * dt * 0.5,
      position.y + k1_pos.y * dt * 0.5,
      position.z + k1_pos.z * dt * 0.5
    );
    const vel2 = new Vector3(
      velocity.x + k1_vel.x * dt * 0.5,
      velocity.y + k1_vel.y * dt * 0.5,
      velocity.z + k1_vel.z * dt * 0.5
    );
    const a2 = acceleration(pos2, vel2);
    const k2_pos = vel2.clone();
    const k2_vel = a2.clone();
    
    // k3: å¦ä¸€ä¸ªä¸­ç‚¹çš„æ–œç‡ (ä½¿ç”¨ k2)
    const pos3 = new Vector3(
      position.x + k2_pos.x * dt * 0.5,
      position.y + k2_pos.y * dt * 0.5,
      position.z + k2_pos.z * dt * 0.5
    );
    const vel3 = new Vector3(
      velocity.x + k2_vel.x * dt * 0.5,
      velocity.y + k2_vel.y * dt * 0.5,
      velocity.z + k2_vel.z * dt * 0.5
    );
    const a3 = acceleration(pos3, vel3);
    const k3_pos = vel3.clone();
    const k3_vel = a3.clone();
    
    // k4: ç»ˆç‚¹çš„æ–œç‡ (ä½¿ç”¨ k3)
    const pos4 = new Vector3(
      position.x + k3_pos.x * dt,
      position.y + k3_pos.y * dt,
      position.z + k3_pos.z * dt
    );
    const vel4 = new Vector3(
      velocity.x + k3_vel.x * dt,
      velocity.y + k3_vel.y * dt,
      velocity.z + k3_vel.z * dt
    );
    const a4 = acceleration(pos4, vel4);
    const k4_pos = vel4.clone();
    const k4_vel = a4.clone();
    
    // åŠ æƒå¹³å‡
    const newPosition = new Vector3(
      position.x + (k1_pos.x + 2 * k2_pos.x + 2 * k3_pos.x + k4_pos.x) * dt / 6,
      position.y + (k1_pos.y + 2 * k2_pos.y + 2 * k3_pos.y + k4_pos.y) * dt / 6,
      position.z + (k1_pos.z + 2 * k2_pos.z + 2 * k3_pos.z + k4_pos.z) * dt / 6
    );
    
    const newVelocity = new Vector3(
      velocity.x + (k1_vel.x + 2 * k2_vel.x + 2 * k3_vel.x + k4_vel.x) * dt / 6,
      velocity.y + (k1_vel.y + 2 * k2_vel.y + 2 * k3_vel.y + k4_vel.y) * dt / 6,
      velocity.z + (k1_vel.z + 2 * k2_vel.z + 2 * k3_vel.z + k4_vel.z) * dt / 6
    );
    
    return { position: newPosition, velocity: newVelocity };
  }
}

/**
 * ç§¯åˆ†å™¨ç±»å‹æšä¸¾
 */
export enum IntegratorType {
  EULER = 'euler',
  VERLET = 'verlet',
  RK4 = 'rk4'
}

/**
 * ç‰©ç†ä¸–ç•Œé…ç½®
 */
export interface PhysicsConfig {
  integrator: IntegratorType;
  subSteps: number;        // Sub-stepping æ¬¡æ•° (1 = æ—  sub-stepping)
  fixedTimeStep: number;   // å›ºå®šæ—¶é—´æ­¥é•¿ (ç§’)
  maxDeltaTime: number;    // æœ€å¤§å¸§é—´éš” (é˜²æ­¢çˆ†ç‚¸)
}

/**
 * é»˜è®¤ç‰©ç†é…ç½® - é«˜è´¨é‡è®¾ç½®
 */
export const DEFAULT_PHYSICS_CONFIG: PhysicsConfig = {
  integrator: IntegratorType.VERLET,
  subSteps: 4,             // æ¯å¸§ 4 æ¬¡ç‰©ç†æ›´æ–°
  fixedTimeStep: 1/240,    // 240Hz ç‰©ç†æ›´æ–°ç‡
  maxDeltaTime: 1/30       // æœ€å¤§ 33ms (30fps ä¿æŠ¤)
};

/**
 * ç‰©ç†å¼•æ“ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç‰©ç†è®¡ç®—
 */
export class PhysicsEngine {
  private config: PhysicsConfig;
  private integrator: Integrator;
  private accumulator: number = 0;
  
  constructor(config: Partial<PhysicsConfig> = {}) {
    this.config = { ...DEFAULT_PHYSICS_CONFIG, ...config };
    this.integrator = this.createIntegrator(this.config.integrator);
  }
  
  private createIntegrator(type: IntegratorType): Integrator {
    switch (type) {
      case IntegratorType.EULER:
        return new EulerIntegrator();
      case IntegratorType.VERLET:
        return new VerletIntegrator();
      case IntegratorType.RK4:
        return new RK4Integrator();
      default:
        return new VerletIntegrator();
    }
  }
  
  /**
   * æ›´æ–°é…ç½®
   */
  setConfig(config: Partial<PhysicsConfig>): void {
    this.config = { ...this.config, ...config };
    if (config.integrator) {
      this.integrator = this.createIntegrator(config.integrator);
    }
  }
  
  /**
   * è·å–å½“å‰ç§¯åˆ†å™¨
   */
  getIntegrator(): Integrator {
    return this.integrator;
  }
  
  /**
   * å¸¦ Sub-stepping çš„ç‰©ç†æ›´æ–°
   * 
   * @param deltaTime å®é™…å¸§æ—¶é—´
   * @param updateFn æ¯ä¸ªç‰©ç†æ­¥éª¤çš„æ›´æ–°å‡½æ•°
   */
  update(deltaTime: number, updateFn: (subDt: number) => void): void {
    // é™åˆ¶æœ€å¤§æ—¶é—´æ­¥é•¿é˜²æ­¢çˆ†ç‚¸
    const clampedDelta = Math.min(deltaTime, this.config.maxDeltaTime);
    
    // ç´¯ç§¯æ—¶é—´
    this.accumulator += clampedDelta;
    
    const subDt = this.config.fixedTimeStep;
    const maxSteps = this.config.subSteps * 2; // é˜²æ­¢æ­»å¾ªç¯
    let steps = 0;
    
    // å›ºå®šæ—¶é—´æ­¥é•¿æ›´æ–°
    while (this.accumulator >= subDt && steps < maxSteps) {
      updateFn(subDt);
      this.accumulator -= subDt;
      steps++;
    }
    
    // å¦‚æœè¿˜æœ‰å‰©ä½™æ—¶é—´ï¼Œè¿›è¡Œä¸€æ¬¡æ’å€¼æ›´æ–°
    if (this.accumulator > 0 && steps < maxSteps) {
      // å¯é€‰ï¼šè¿›è¡Œéƒ¨åˆ†æ­¥é•¿æ›´æ–°ä»¥è·å¾—æ›´å¹³æ»‘çš„è§†è§‰æ•ˆæœ
      // updateFn(this.accumulator);
      // this.accumulator = 0;
    }
  }
  
  /**
   * ç®€åŒ–ç‰ˆæ›´æ–° - ç›´æ¥ä½¿ç”¨ sub-stepping
   */
  updateSimple(deltaTime: number, updateFn: (subDt: number) => void): void {
    const clampedDelta = Math.min(deltaTime, this.config.maxDeltaTime);
    const subDt = clampedDelta / this.config.subSteps;
    
    for (let i = 0; i < this.config.subSteps; i++) {
      updateFn(subDt);
    }
  }
  
  /**
   * è®¡ç®—å•ä¸ªç²’å­çš„ç‰©ç†æ›´æ–°
   */
  integrateParticle(
    position: Vector3,
    velocity: Vector3,
    gravity: number,
    friction: number,
    resistance: number,
    dt: number,
    particleRef?: object
  ): { position: Vector3; velocity: Vector3 } {
    // åŠ é€Ÿåº¦å‡½æ•°
    const accelerationFn = (pos: Vector3, vel: Vector3): Vector3 => {
      // é‡åŠ›
      const grav = new Vector3(0, -gravity, 0);
      
      // ç©ºæ°”é˜»åŠ› (ä¸é€Ÿåº¦å¹³æ–¹æˆæ­£æ¯”)
      const speed = vel.length();
      const drag = new Vector3();
      if (speed > 0.001) {
        const dragMag = speed * speed * resistance;
        drag.x = -(vel.x / speed) * dragMag;
        drag.y = -(vel.y / speed) * dragMag;
        drag.z = -(vel.z / speed) * dragMag;
      }
      
      return new Vector3(
        grav.x + drag.x,
        grav.y + drag.y,
        grav.z + drag.z
      );
    };
    
    // ä½¿ç”¨é€‰å®šçš„ç§¯åˆ†å™¨
    const result = (this.integrator as any).integrate(
      position, velocity, accelerationFn, dt, particleRef
    );
    
    // åº”ç”¨æ‘©æ“¦åŠ› (é€Ÿåº¦è¡°å‡)
    const frictionFactor = Math.pow(friction, dt * 60);
    result.velocity.x *= frictionFactor;
    result.velocity.y *= frictionFactor;
    result.velocity.z *= frictionFactor;
    
    return result;
  }
}

/**
 * å…¨å±€ç‰©ç†å¼•æ“å•ä¾‹
 */
let globalPhysicsEngine: PhysicsEngine | null = null;

export function getPhysicsEngine(): PhysicsEngine {
  if (!globalPhysicsEngine) {
    globalPhysicsEngine = new PhysicsEngine();
  }
  return globalPhysicsEngine;
}

export function setPhysicsEngine(engine: PhysicsEngine): void {
  globalPhysicsEngine = engine;
}


// =============================================================================
// FILE: src\core\PostProcessingStack.ts
// =============================================================================

/**
 * PostProcessingStack.ts - ç”µå½±çº§åæœŸå¤„ç†ç®¡çº¿
 * 
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - Unreal Bloom (è™šå¹»å¼•æ“çº§åˆ«çš„è¾‰å…‰)
 * - Chromatic Aberration (è‰²å·®/ç´«è¾¹æ•ˆæœ)
 * - Tone Mapping (HDR â†’ SDR è‰²è°ƒæ˜ å°„)
 * - Film Grain (å¯é€‰ç”µå½±å™ªç‚¹)
 * - Vignette (æš—è§’)
 * 
 * è¿™äº›æ•ˆæœç»„åˆåœ¨ä¸€èµ·ï¼Œè®©ç”»é¢å…·æœ‰çœŸå®æ‘„å½±æœºçš„è´¨æ„Ÿ
 */

import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';

/**
 * è‰²å·®ç€è‰²å™¨ (Chromatic Aberration)
 * æ¨¡æ‹Ÿé•œå¤´è¾¹ç¼˜çš„çº¢è“åˆ†ç¦»æ•ˆæœ
 */
export const ChromaticAberrationShader = {
  name: 'ChromaticAberrationShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.003 },       // è‰²å·®å¼ºåº¦
    radialFalloff: { value: 1.5 },     // ä»ä¸­å¿ƒåˆ°è¾¹ç¼˜çš„è¡°å‡
    center: { value: new THREE.Vector2(0.5, 0.5) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float radialFalloff;
    uniform vec2 center;
    varying vec2 vUv;
    
    void main() {
      // è®¡ç®—ä»ä¸­å¿ƒåˆ°å½“å‰åƒç´ çš„è·ç¦»
      vec2 toCenter = vUv - center;
      float dist = length(toCenter);
      
      // å¾„å‘è¡°å‡ï¼šè¾¹ç¼˜æ•ˆæœæ›´å¼º
      float aberration = dist * dist * intensity * radialFalloff;
      
      // RGB é€šé“åˆ†ç¦»
      vec2 redOffset = toCenter * aberration * 1.2;
      vec2 greenOffset = toCenter * aberration * 0.0;  // ç»¿è‰²é€šé“ä¸åç§»
      vec2 blueOffset = toCenter * aberration * -1.0;
      
      float r = texture2D(tDiffuse, vUv - redOffset).r;
      float g = texture2D(tDiffuse, vUv - greenOffset).g;
      float b = texture2D(tDiffuse, vUv - blueOffset).b;
      
      // ä¿ç•™åŸå§‹ alpha
      float a = texture2D(tDiffuse, vUv).a;
      
      gl_FragColor = vec4(r, g, b, a);
    }
  `
};

/**
 * é«˜çº§è‰²è°ƒæ˜ å°„ç€è‰²å™¨ (ACES Filmic Tone Mapping)
 * æ¯” Three.js å†…ç½®çš„ Reinhard æ›´ç”µå½±åŒ–
 */
export const ACESFilmicToneMappingShader = {
  name: 'ACESFilmicToneMappingShader',
  uniforms: {
    tDiffuse: { value: null },
    exposure: { value: 1.2 },
    saturation: { value: 1.05 },
    contrast: { value: 1.05 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float exposure;
    uniform float saturation;
    uniform float contrast;
    varying vec2 vUv;
    
    // ACES Filmic Tone Mapping Curve
    // æ¥æº: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    vec3 ACESFilm(vec3 x) {
      float a = 2.51;
      float b = 0.03;
      float c = 2.43;
      float d = 0.59;
      float e = 0.14;
      return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
    }
    
    // é¥±å’Œåº¦è°ƒæ•´
    vec3 adjustSaturation(vec3 color, float sat) {
      float grey = dot(color, vec3(0.2126, 0.7152, 0.0722));
      return mix(vec3(grey), color, sat);
    }
    
    // å¯¹æ¯”åº¦è°ƒæ•´
    vec3 adjustContrast(vec3 color, float cont) {
      return (color - 0.5) * cont + 0.5;
    }
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // æ›å…‰è°ƒæ•´
      vec3 color = texel.rgb * exposure;
      
      // ACES è‰²è°ƒæ˜ å°„
      color = ACESFilm(color);
      
      // é¥±å’Œåº¦å’Œå¯¹æ¯”åº¦
      color = adjustSaturation(color, saturation);
      color = adjustContrast(color, contrast);
      
      gl_FragColor = vec4(color, texel.a);
    }
  `
};

/**
 * æš—è§’ç€è‰²å™¨ (Vignette)
 * æ¨¡æ‹ŸçœŸå®é•œå¤´è¾¹ç¼˜å˜æš—çš„æ•ˆæœ
 */
export const VignetteShader = {
  name: 'VignetteShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.3 },
    smoothness: { value: 0.5 },
    center: { value: new THREE.Vector2(0.5, 0.5) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float smoothness;
    uniform vec2 center;
    varying vec2 vUv;
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // è®¡ç®—åˆ°ä¸­å¿ƒçš„è·ç¦»
      vec2 toCenter = (vUv - center) * 2.0;
      float dist = length(toCenter);
      
      // æŸ”å’Œçš„æš—è§’è¡°å‡
      float vignette = 1.0 - smoothstep(1.0 - smoothness, 1.0, dist * intensity);
      
      gl_FragColor = vec4(texel.rgb * vignette, texel.a);
    }
  `
};

/**
 * ç”µå½±å™ªç‚¹ç€è‰²å™¨ (Film Grain)
 * å¢åŠ ç”µå½±è´¨æ„Ÿçš„ç»†å¾®å™ªç‚¹
 */
export const FilmGrainShader = {
  name: 'FilmGrainShader',
  uniforms: {
    tDiffuse: { value: null },
    time: { value: 0 },
    intensity: { value: 0.05 },
    luminanceThreshold: { value: 0.2 }  // åªåœ¨æš—éƒ¨æ·»åŠ å™ªç‚¹
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float time;
    uniform float intensity;
    uniform float luminanceThreshold;
    varying vec2 vUv;
    
    // ä¼ªéšæœºæ•°ç”Ÿæˆ
    float random(vec2 co) {
      return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // è®¡ç®—äº®åº¦
      float luminance = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
      
      // å™ªç‚¹å¼ºåº¦éšäº®åº¦é™ä½è€Œå¢åŠ 
      float noiseStrength = (1.0 - smoothstep(0.0, luminanceThreshold, luminance)) * intensity;
      
      // ç”ŸæˆåŠ¨æ€å™ªç‚¹
      float noise = random(vUv + vec2(time * 0.1)) * 2.0 - 1.0;
      
      vec3 result = texel.rgb + noise * noiseStrength;
      
      gl_FragColor = vec4(result, texel.a);
    }
  `
};

/**
 * åæœŸå¤„ç†é…ç½®æ¥å£
 */
export interface PostProcessingConfig {
  // Bloom è®¾ç½®
  bloomEnabled: boolean;
  bloomStrength: number;     // 0-3
  bloomRadius: number;       // 0-1
  bloomThreshold: number;    // 0-1
  
  // è‰²å·®è®¾ç½®
  chromaticAberrationEnabled: boolean;
  chromaticAberrationIntensity: number;  // 0-0.02
  
  // è‰²è°ƒæ˜ å°„è®¾ç½®
  toneMappingEnabled: boolean;
  exposure: number;          // 0.5-2.0
  saturation: number;        // 0.5-1.5
  contrast: number;          // 0.8-1.2
  
  // æš—è§’è®¾ç½®
  vignetteEnabled: boolean;
  vignetteIntensity: number; // 0-1
  
  // å™ªç‚¹è®¾ç½®
  filmGrainEnabled: boolean;
  filmGrainIntensity: number; // 0-0.15
}

/**
 * é»˜è®¤åæœŸå¤„ç†é…ç½® - ç”µå½±çº§è´¨é‡
 */
export const DEFAULT_POST_PROCESSING_CONFIG: PostProcessingConfig = {
  bloomEnabled: true,
  bloomStrength: 1.5,
  bloomRadius: 0.4,
  bloomThreshold: 0.2,
  
  chromaticAberrationEnabled: true,
  chromaticAberrationIntensity: 0.004,
  
  toneMappingEnabled: true,
  exposure: 1.3,
  saturation: 1.08,
  contrast: 1.05,
  
  vignetteEnabled: true,
  vignetteIntensity: 0.35,
  
  filmGrainEnabled: false,  // é»˜è®¤å…³é—­ï¼Œå¯é€‰å¼€å¯
  filmGrainIntensity: 0.03
};

/**
 * é«˜æ€§èƒ½é¢„è®¾ - ç‰ºç‰²éƒ¨åˆ†æ•ˆæœæ¢å–æ€§èƒ½
 */
export const PERFORMANCE_POST_PROCESSING_CONFIG: PostProcessingConfig = {
  bloomEnabled: true,
  bloomStrength: 1.2,
  bloomRadius: 0.3,
  bloomThreshold: 0.3,
  
  chromaticAberrationEnabled: false,
  chromaticAberrationIntensity: 0,
  
  toneMappingEnabled: true,
  exposure: 1.2,
  saturation: 1.0,
  contrast: 1.0,
  
  vignetteEnabled: false,
  vignetteIntensity: 0,
  
  filmGrainEnabled: false,
  filmGrainIntensity: 0
};

/**
 * ç”µå½±çº§åæœŸå¤„ç†æ ˆ
 */
export class PostProcessingStack {
  private composer: EffectComposer;
  private renderPass: RenderPass;
  private bloomPass: UnrealBloomPass;
  private chromaticPass: ShaderPass;
  private toneMappingPass: ShaderPass;
  private vignettePass: ShaderPass;
  private filmGrainPass: ShaderPass;
  private outputPass: OutputPass;
  
  private config: PostProcessingConfig;
  private startTime: number;
  
  constructor(
    renderer: THREE.WebGLRenderer,
    scene: THREE.Scene,
    camera: THREE.Camera,
    config: Partial<PostProcessingConfig> = {}
  ) {
    this.config = { ...DEFAULT_POST_PROCESSING_CONFIG, ...config };
    this.startTime = performance.now();
    
    // é…ç½®æ¸²æŸ“å™¨
    renderer.toneMapping = THREE.NoToneMapping;  // æˆ‘ä»¬ç”¨è‡ªå®šä¹‰è‰²è°ƒæ˜ å°„
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // åˆ›å»º Effect Composer
    this.composer = new EffectComposer(renderer);
    
    // 1. æ¸²æŸ“é€šé“
    this.renderPass = new RenderPass(scene, camera);
    this.composer.addPass(this.renderPass);
    
    // 2. Unreal Bloom é€šé“
    const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
    this.bloomPass = new UnrealBloomPass(
      resolution,
      this.config.bloomStrength,
      this.config.bloomRadius,
      this.config.bloomThreshold
    );
    this.bloomPass.enabled = this.config.bloomEnabled;
    this.composer.addPass(this.bloomPass);
    
    // 3. è‰²å·®é€šé“
    this.chromaticPass = new ShaderPass(ChromaticAberrationShader);
    this.chromaticPass.uniforms.intensity.value = this.config.chromaticAberrationIntensity;
    this.chromaticPass.enabled = this.config.chromaticAberrationEnabled;
    this.composer.addPass(this.chromaticPass);
    
    // 4. è‰²è°ƒæ˜ å°„é€šé“
    this.toneMappingPass = new ShaderPass(ACESFilmicToneMappingShader);
    this.toneMappingPass.uniforms.exposure.value = this.config.exposure;
    this.toneMappingPass.uniforms.saturation.value = this.config.saturation;
    this.toneMappingPass.uniforms.contrast.value = this.config.contrast;
    this.toneMappingPass.enabled = this.config.toneMappingEnabled;
    this.composer.addPass(this.toneMappingPass);
    
    // 5. æš—è§’é€šé“
    this.vignettePass = new ShaderPass(VignetteShader);
    this.vignettePass.uniforms.intensity.value = this.config.vignetteIntensity;
    this.vignettePass.enabled = this.config.vignetteEnabled;
    this.composer.addPass(this.vignettePass);
    
    // 6. ç”µå½±å™ªç‚¹é€šé“
    this.filmGrainPass = new ShaderPass(FilmGrainShader);
    this.filmGrainPass.uniforms.intensity.value = this.config.filmGrainIntensity;
    this.filmGrainPass.enabled = this.config.filmGrainEnabled;
    this.composer.addPass(this.filmGrainPass);
    
    // 7. è¾“å‡ºé€šé“ (é¢œè‰²ç©ºé—´è½¬æ¢)
    this.outputPass = new OutputPass();
    this.composer.addPass(this.outputPass);
  }
  
  /**
   * æ›´æ–°é…ç½®
   */
  setConfig(config: Partial<PostProcessingConfig>): void {
    this.config = { ...this.config, ...config };
    
    // æ›´æ–° Bloom
    if (config.bloomEnabled !== undefined) this.bloomPass.enabled = config.bloomEnabled;
    if (config.bloomStrength !== undefined) this.bloomPass.strength = config.bloomStrength;
    if (config.bloomRadius !== undefined) this.bloomPass.radius = config.bloomRadius;
    if (config.bloomThreshold !== undefined) this.bloomPass.threshold = config.bloomThreshold;
    
    // æ›´æ–°è‰²å·®
    if (config.chromaticAberrationEnabled !== undefined) {
      this.chromaticPass.enabled = config.chromaticAberrationEnabled;
    }
    if (config.chromaticAberrationIntensity !== undefined) {
      this.chromaticPass.uniforms.intensity.value = config.chromaticAberrationIntensity;
    }
    
    // æ›´æ–°è‰²è°ƒæ˜ å°„
    if (config.toneMappingEnabled !== undefined) {
      this.toneMappingPass.enabled = config.toneMappingEnabled;
    }
    if (config.exposure !== undefined) {
      this.toneMappingPass.uniforms.exposure.value = config.exposure;
    }
    if (config.saturation !== undefined) {
      this.toneMappingPass.uniforms.saturation.value = config.saturation;
    }
    if (config.contrast !== undefined) {
      this.toneMappingPass.uniforms.contrast.value = config.contrast;
    }
    
    // æ›´æ–°æš—è§’
    if (config.vignetteEnabled !== undefined) {
      this.vignettePass.enabled = config.vignetteEnabled;
    }
    if (config.vignetteIntensity !== undefined) {
      this.vignettePass.uniforms.intensity.value = config.vignetteIntensity;
    }
    
    // æ›´æ–°å™ªç‚¹
    if (config.filmGrainEnabled !== undefined) {
      this.filmGrainPass.enabled = config.filmGrainEnabled;
    }
    if (config.filmGrainIntensity !== undefined) {
      this.filmGrainPass.uniforms.intensity.value = config.filmGrainIntensity;
    }
  }
  
  /**
   * è·å–å½“å‰é…ç½®
   */
  getConfig(): PostProcessingConfig {
    return { ...this.config };
  }
  
  /**
   * æ¸²æŸ“å¸§
   */
  render(): void {
    // æ›´æ–°åŠ¨æ€ uniforms
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.filmGrainPass.uniforms.time.value = elapsed;
    
    this.composer.render();
  }
  
  /**
   * æ›´æ–°å°ºå¯¸
   */
  setSize(width: number, height: number): void {
    this.composer.setSize(width, height);
    this.bloomPass.setSize(width, height);
  }
  
  /**
   * è·å– Effect Composer (ç”¨äºé«˜çº§è‡ªå®šä¹‰)
   */
  getComposer(): EffectComposer {
    return this.composer;
  }
  
  /**
   * è·å–å„ä¸ªé€šé“çš„å¼•ç”¨
   */
  getPasses() {
    return {
      render: this.renderPass,
      bloom: this.bloomPass,
      chromatic: this.chromaticPass,
      toneMapping: this.toneMappingPass,
      vignette: this.vignettePass,
      filmGrain: this.filmGrainPass,
      output: this.outputPass
    };
  }
  
  /**
   * æ¸…ç†èµ„æº
   */
  dispose(): void {
    this.composer.dispose();
  }
}

/**
 * åˆ›å»ºç®€åŒ–ç‰ˆåæœŸå¤„ç†æ ˆ (ç”¨äºå¿«é€Ÿé›†æˆ)
 */
export function createSimplePostProcessing(
  renderer: THREE.WebGLRenderer,
  scene: THREE.Scene,
  camera: THREE.Camera,
  quality: 'cinematic' | 'performance' | 'minimal' = 'cinematic'
): PostProcessingStack {
  const configs: Record<string, Partial<PostProcessingConfig>> = {
    cinematic: DEFAULT_POST_PROCESSING_CONFIG,
    performance: PERFORMANCE_POST_PROCESSING_CONFIG,
    minimal: {
      bloomEnabled: true,
      bloomStrength: 1.0,
      bloomRadius: 0.3,
      bloomThreshold: 0.4,
      chromaticAberrationEnabled: false,
      toneMappingEnabled: true,
      exposure: 1.1,
      saturation: 1.0,
      contrast: 1.0,
      vignetteEnabled: false,
      filmGrainEnabled: false
    }
  };
  
  return new PostProcessingStack(renderer, scene, camera, configs[quality]);
}


// =============================================================================
// FILE: src\core\shapes\Shape3DFactory.ts
// =============================================================================

// FILE: src/core/shapes/Shape3DFactory.ts
// çœŸ3Då½¢çŠ¶å·¥å‚ï¼šå®šä¹‰50+ç§çœŸæ­£çš„ä¸‰ç»´å½¢çŠ¶

import { Vector3 } from '../Vector3';

/**
 * 3Då½¢çŠ¶ç±»å‹æšä¸¾
 * åˆ†ç±»ï¼šåŸºç¡€å‡ ä½•ã€è‡ªç„¶ç”Ÿç‰©ã€æŠ½è±¡è‰ºæœ¯ã€å®‡å®™å¤©ä½“ã€æ–‡åŒ–ç¬¦å·ã€ç‰¹æ•ˆç±»
 */
export enum Shape3DType {
  // === åŸºç¡€å‡ ä½• (10ç§) ===
  SPHERE = 'sphere',
  CUBE = 'cube',
  PYRAMID = 'pyramid',
  OCTAHEDRON = 'octahedron',
  DODECAHEDRON = 'dodecahedron',
  ICOSAHEDRON = 'icosahedron',
  CYLINDER = 'cylinder',
  CONE = 'cone',
  TORUS = 'torus',
  TORUS_KNOT = 'torus_knot',
  
  // === é«˜çº§å‡ ä½• (10ç§) ===
  CAPSULE = 'capsule',
  PRISM = 'prism',
  STAR_3D = 'star_3d',
  CROSS_3D = 'cross_3d',
  DIAMOND = 'diamond',
  MOBIUS = 'mobius',
  KLEIN_BOTTLE = 'klein_bottle',
  HELIX_TUBE = 'helix_tube',
  SPRING = 'spring',
  NESTED_SPHERES = 'nested_spheres',
  
  // === è‡ªç„¶ç”Ÿç‰© (10ç§) ===
  BUTTERFLY_3D = 'butterfly_3d',
  FLOWER_3D = 'flower_3d',
  TREE = 'tree',
  FISH_3D = 'fish_3d',
  BIRD = 'bird',
  JELLYFISH = 'jellyfish',
  SHELL = 'shell',
  SNOWFLAKE_3D = 'snowflake_3d',
  LEAF = 'leaf',
  MUSHROOM = 'mushroom',
  
  // === å®‡å®™å¤©ä½“ (10ç§) ===
  GALAXY_SPIRAL = 'galaxy_spiral',
  PLANET_RINGS = 'planet_rings',
  NEBULA = 'nebula',
  BLACK_HOLE = 'black_hole',
  SUPERNOVA = 'supernova',
  COMET = 'comet',
  ASTEROID_BELT = 'asteroid_belt',
  CONSTELLATION = 'constellation',
  PULSAR = 'pulsar',
  WORMHOLE = 'wormhole',
  
  // === æ–‡åŒ–ç¬¦å· (10ç§) ===
  HEART_3D = 'heart_3d',
  CROWN_3D = 'crown_3d',
  DRAGON_3D = 'dragon_3d',
  PHOENIX = 'phoenix',
  YIN_YANG = 'yin_yang',
  LOTUS = 'lotus',
  LANTERN = 'lantern',
  FIREWORK_CLASSIC = 'firework_classic',
  RIBBON = 'ribbon',
  FIREWORK_WILLOW = 'firework_willow',
  
  // === ç‰¹æ•ˆç±» (10ç§) ===
  EXPLOSION_BURST = 'explosion_burst',
  RING_WAVE = 'ring_wave',
  DOUBLE_RING = 'double_ring',
  CASCADE = 'cascade',
  WATERFALL_3D = 'waterfall_3d',
  FOUNTAIN = 'fountain',
  VORTEX = 'vortex',
  SHOCKWAVE = 'shockwave',
  SPARKLE_CLOUD = 'sparkle_cloud',
  CHAOS_SCATTER = 'chaos_scatter',
}

/**
 * å½¢çŠ¶ä¿¡æ¯
 */
export interface Shape3DInfo {
  name: string;
  icon: string;
  category: string;
  description: string;
}

/**
 * å½¢çŠ¶åˆ†ç±»
 */
export const SHAPE_CATEGORIES = {
  BASIC_GEOMETRY: 'åŸºç¡€å‡ ä½•',
  ADVANCED_GEOMETRY: 'é«˜çº§å‡ ä½•',
  NATURE: 'è‡ªç„¶ç”Ÿç‰©',
  COSMOS: 'å®‡å®™å¤©ä½“',
  CULTURE: 'æ–‡åŒ–ç¬¦å·',
  EFFECTS: 'ç‰¹æ•ˆç±»',
};

/**
 * å½¢çŠ¶ä¿¡æ¯æ˜ å°„
 */
export const SHAPE_3D_INFO: Record<Shape3DType, Shape3DInfo> = {
  // åŸºç¡€å‡ ä½•
  [Shape3DType.SPHERE]: { name: 'æ ‡å‡†çƒå½¢', icon: 'ğŸ”®', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å®Œç¾çš„çƒå½¢çˆ†ç‚¸' },
  [Shape3DType.CUBE]: { name: 'é‡å­ç«‹æ–¹', icon: 'ğŸ§Š', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å…­é¢ä½“ç»“æ„' },
  [Shape3DType.PYRAMID]: { name: 'é‡‘å­—å¡”', icon: 'ğŸ”º', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å››é¢ä½“é‡‘å­—å¡”' },
  [Shape3DType.OCTAHEDRON]: { name: 'å…«é¢ä½“', icon: 'ğŸ’', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'å…«ä¸ªä¸‰è§’é¢' },
  [Shape3DType.DODECAHEDRON]: { name: 'åäºŒé¢ä½“', icon: 'â¬¡', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'åäºŒä¸ªäº”è¾¹å½¢é¢' },
  [Shape3DType.ICOSAHEDRON]: { name: 'äºŒåé¢ä½“', icon: 'ğŸ²', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'äºŒåä¸ªä¸‰è§’é¢' },
  [Shape3DType.CYLINDER]: { name: 'åœ†æŸ±ä½“', icon: 'ğŸ›¢ï¸', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'åœ†æŸ±å½¢çŠ¶' },
  [Shape3DType.CONE]: { name: 'åœ†é”¥ä½“', icon: 'ğŸ“', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'é”¥å½¢ç»“æ„' },
  [Shape3DType.TORUS]: { name: 'åœ†ç¯ä½“', icon: 'â­•', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'ç”œç”œåœˆå½¢çŠ¶' },
  [Shape3DType.TORUS_KNOT]: { name: 'ç¯å½¢ç»“', icon: 'ğŸ”—', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: 'æ‰­æ›²çš„ç¯å½¢' },
  
  // é«˜çº§å‡ ä½•
  [Shape3DType.CAPSULE]: { name: 'èƒ¶å›Šä½“', icon: 'ğŸ’Š', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ä¸¤ç«¯åœ†æ¶¦çš„æŸ±ä½“' },
  [Shape3DType.PRISM]: { name: 'æ£±é•œ', icon: 'ğŸ”·', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ä¸‰è§’æ£±é•œ' },
  [Shape3DType.STAR_3D]: { name: '3Dæ˜Ÿå½¢', icon: 'â­', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç«‹ä½“äº”è§’æ˜Ÿ' },
  [Shape3DType.CROSS_3D]: { name: '3Dåå­—', icon: 'âœï¸', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç«‹ä½“åå­—æ¶' },
  [Shape3DType.DIAMOND]: { name: 'é’»çŸ³', icon: 'ğŸ’ ', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'é—ªè€€é’»çŸ³' },
  [Shape3DType.MOBIUS]: { name: 'è«æ¯”ä¹Œæ–¯å¸¦', icon: 'â™¾ï¸', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'æ— é™å¾ªç¯' },
  [Shape3DType.KLEIN_BOTTLE]: { name: 'å…‹è±å› ç“¶', icon: 'ğŸ¾', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'æ‹“æ‰‘å­¦å¥‡è¿¹' },
  [Shape3DType.HELIX_TUBE]: { name: 'DNAåŒèºæ—‹', icon: 'ğŸ§¬', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'ç”Ÿå‘½å¯†ç ' },
  [Shape3DType.SPRING]: { name: 'å¼¹ç°§', icon: 'ğŸ”„', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'èºæ—‹å¼¹ç°§' },
  [Shape3DType.NESTED_SPHERES]: { name: 'åŒå¿ƒçƒ', icon: 'ğŸ¯', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: 'å±‚å±‚åµŒå¥—' },
  
  // è‡ªç„¶ç”Ÿç‰©
  [Shape3DType.BUTTERFLY_3D]: { name: 'å¹»å½©è´è¶', icon: 'ğŸ¦‹', category: SHAPE_CATEGORIES.NATURE, description: 'ç¿©ç¿©èµ·èˆ' },
  [Shape3DType.FLOWER_3D]: { name: 'ç››ä¸–ç‰¡ä¸¹', icon: 'ğŸŒº', category: SHAPE_CATEGORIES.NATURE, description: 'å±‚å±‚èŠ±ç“£' },
  [Shape3DType.TREE]: { name: 'ç”Ÿå‘½ä¹‹æ ‘', icon: 'ğŸŒ³', category: SHAPE_CATEGORIES.NATURE, description: 'æç¹å¶èŒ‚' },
  [Shape3DType.FISH_3D]: { name: 'é”¦é²¤æ¸¸åŠ¨', icon: 'ğŸŸ', category: SHAPE_CATEGORIES.NATURE, description: 'å¹´å¹´æœ‰ä½™' },
  [Shape3DType.BIRD]: { name: 'é£é¸Ÿ', icon: 'ğŸ•Šï¸', category: SHAPE_CATEGORIES.NATURE, description: 'å±•ç¿…é«˜é£' },
  [Shape3DType.JELLYFISH]: { name: 'æ°´æ¯', icon: 'ğŸª¼', category: SHAPE_CATEGORIES.NATURE, description: 'é£˜é€¸çµåŠ¨' },
  [Shape3DType.SHELL]: { name: 'æµ·èº', icon: 'ğŸš', category: SHAPE_CATEGORIES.NATURE, description: 'èºæ—‹è´å£³' },
  [Shape3DType.SNOWFLAKE_3D]: { name: 'å…­è§’é›ªèŠ±', icon: 'â„ï¸', category: SHAPE_CATEGORIES.NATURE, description: 'å†°æ™¶ç»½æ”¾' },
  [Shape3DType.LEAF]: { name: 'è½å¶', icon: 'ğŸ‚', category: SHAPE_CATEGORIES.NATURE, description: 'ç§‹é£è½å¶' },
  [Shape3DType.MUSHROOM]: { name: 'è˜‘è‡', icon: 'ğŸ„', category: SHAPE_CATEGORIES.NATURE, description: 'ç«¥è¯è˜‘è‡' },
  
  // å®‡å®™å¤©ä½“
  [Shape3DType.GALAXY_SPIRAL]: { name: 'é“¶æ²³ç³»', icon: 'ğŸŒŒ', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—‹è‡‚é“¶æ²³' },
  [Shape3DType.PLANET_RINGS]: { name: 'åœŸæ˜Ÿç¯', icon: 'ğŸª', category: SHAPE_CATEGORIES.COSMOS, description: 'è¡Œæ˜Ÿå…‰ç¯' },
  [Shape3DType.NEBULA]: { name: 'æ˜Ÿäº‘', icon: 'â˜ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'ç»šä¸½æ˜Ÿäº‘' },
  [Shape3DType.BLACK_HOLE]: { name: 'é»‘æ´', icon: 'ğŸ•³ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—¶ç©ºæ¼©æ¶¡' },
  [Shape3DType.SUPERNOVA]: { name: 'è¶…æ–°æ˜Ÿ', icon: 'ğŸ’¥', category: SHAPE_CATEGORIES.COSMOS, description: 'æ’æ˜Ÿçˆ†å‘' },
  [Shape3DType.COMET]: { name: 'å½—æ˜Ÿ', icon: 'â˜„ï¸', category: SHAPE_CATEGORIES.COSMOS, description: 'æ‹–å°¾å½—æ˜Ÿ' },
  [Shape3DType.ASTEROID_BELT]: { name: 'å°è¡Œæ˜Ÿå¸¦', icon: 'ğŸŒ‘', category: SHAPE_CATEGORIES.COSMOS, description: 'å²©çŸ³ç¯å¸¦' },
  [Shape3DType.CONSTELLATION]: { name: 'æ˜Ÿåº§', icon: 'âœ¨', category: SHAPE_CATEGORIES.COSMOS, description: 'æ˜Ÿåº§è¿çº¿' },
  [Shape3DType.PULSAR]: { name: 'è„‰å†²æ˜Ÿ', icon: 'ğŸ“¡', category: SHAPE_CATEGORIES.COSMOS, description: 'å°„ç”µè„‰å†²' },
  [Shape3DType.WORMHOLE]: { name: 'è™«æ´', icon: 'ğŸŒ€', category: SHAPE_CATEGORIES.COSMOS, description: 'æ—¶ç©ºéš§é“' },
  
  // æ–‡åŒ–ç¬¦å·
  [Shape3DType.HEART_3D]: { name: 'è·³åŠ¨ä¹‹å¿ƒ', icon: 'â¤ï¸', category: SHAPE_CATEGORIES.CULTURE, description: 'ç«‹ä½“çˆ±å¿ƒ' },
  [Shape3DType.CROWN_3D]: { name: 'çš‡å† ', icon: 'ğŸ‘‘', category: SHAPE_CATEGORIES.CULTURE, description: 'ç‹è€…ä¹‹å† ' },
  [Shape3DType.DRAGON_3D]: { name: 'æ¸¸é¾™æˆç ', icon: 'ğŸ‰', category: SHAPE_CATEGORIES.CULTURE, description: 'ä¸œæ–¹ç¥é¾™' },
  [Shape3DType.PHOENIX]: { name: 'å‡¤å‡°æ¶…æ§ƒ', icon: 'ğŸ”¥', category: SHAPE_CATEGORIES.CULTURE, description: 'æµ´ç«é‡ç”Ÿ' },
  [Shape3DType.YIN_YANG]: { name: 'å¤ªæ', icon: 'â˜¯ï¸', category: SHAPE_CATEGORIES.CULTURE, description: 'é˜´é˜³è°ƒå’Œ' },
  [Shape3DType.LOTUS]: { name: 'è²èŠ±', icon: 'ğŸª·', category: SHAPE_CATEGORIES.CULTURE, description: 'å‡ºæ·¤æ³¥è€Œä¸æŸ“' },
  [Shape3DType.LANTERN]: { name: 'ç¯ç¬¼', icon: 'ğŸ®', category: SHAPE_CATEGORIES.CULTURE, description: 'å–œåº†ç¯ç¬¼' },
  [Shape3DType.FIREWORK_CLASSIC]: { name: 'ç»å…¸çƒŸèŠ±', icon: 'ğŸ†', category: SHAPE_CATEGORIES.CULTURE, description: 'ä¼ ç»Ÿçˆ†ç‚¸' },
  [Shape3DType.RIBBON]: { name: 'å½©å¸¦', icon: 'ğŸ€', category: SHAPE_CATEGORIES.CULTURE, description: 'é£˜é€¸å½©å¸¦' },
  [Shape3DType.FIREWORK_WILLOW]: { name: 'é‡‘æŸ³å‚ä¸', icon: 'ğŸ‹', category: SHAPE_CATEGORIES.CULTURE, description: 'å‚è½ä¸çº¿' },
  
  // ç‰¹æ•ˆç±»
  [Shape3DType.EXPLOSION_BURST]: { name: 'é«˜äº®çˆ†å‘', icon: 'ğŸ’«', category: SHAPE_CATEGORIES.EFFECTS, description: 'è€€çœ¼é—ªå…‰' },
  [Shape3DType.RING_WAVE]: { name: 'ç¯å½¢æ³¢', icon: 'â—', category: SHAPE_CATEGORIES.EFFECTS, description: 'æ‰©æ•£å…‰ç¯' },
  [Shape3DType.DOUBLE_RING]: { name: 'åŒå±‚ç¯', icon: 'âŠ›', category: SHAPE_CATEGORIES.EFFECTS, description: 'å†…å¤–åŒç¯' },
  [Shape3DType.CASCADE]: { name: 'é˜¶æ¢¯ç€‘å¸ƒ', icon: 'ğŸŒŠ', category: SHAPE_CATEGORIES.EFFECTS, description: 'å±‚å ä¸‹è½' },
  [Shape3DType.WATERFALL_3D]: { name: 'ä¹å¤©ç€‘å¸ƒ', icon: 'ğŸ’§', category: SHAPE_CATEGORIES.EFFECTS, description: 'é£æµç›´ä¸‹' },
  [Shape3DType.FOUNTAIN]: { name: 'å–·æ³‰', icon: 'â›²', category: SHAPE_CATEGORIES.EFFECTS, description: 'å‘ä¸Šå–·æ¶Œ' },
  [Shape3DType.VORTEX]: { name: 'æ¼©æ¶¡', icon: 'ğŸŒªï¸', category: SHAPE_CATEGORIES.EFFECTS, description: 'å¿«é€Ÿæ—‹è½¬' },
  [Shape3DType.SHOCKWAVE]: { name: 'å†²å‡»æ³¢', icon: 'ã€œ', category: SHAPE_CATEGORIES.EFFECTS, description: 'éœ‡è¡æ‰©æ•£' },
  [Shape3DType.SPARKLE_CLOUD]: { name: 'é—ªçƒäº‘', icon: 'âœ¨', category: SHAPE_CATEGORIES.EFFECTS, description: 'éšæœºé—ªçƒ' },
  [Shape3DType.CHAOS_SCATTER]: { name: 'æ··æ²Œæ•£å°„', icon: 'ğŸ²', category: SHAPE_CATEGORIES.EFFECTS, description: 'éšæœºå››æ•£' },
};

/**
 * 3Dç‚¹ç”Ÿæˆç»“æœ
 */
export interface Shape3DPoint {
  position: Vector3;
  hue: number;
  size?: number;
  behavior?: string;
  decay?: number;
  friction?: number;
}

/**
 * 3Då½¢çŠ¶ç”Ÿæˆå™¨
 * ç”ŸæˆçœŸæ­£çš„3Dç‚¹åˆ†å¸ƒ
 */
export class Shape3DGenerator {
  /**
   * ç”Ÿæˆå½¢çŠ¶çš„ç‚¹åˆ†å¸ƒ
   * @param type å½¢çŠ¶ç±»å‹
   * @param count ç‚¹æ•°é‡
   * @param scale ç¼©æ”¾æ¯”ä¾‹
   * @param baseHue åŸºç¡€è‰²ç›¸
   * @returns ç‚¹æ•°ç»„
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale: number = 1,
    baseHue: number = 0
  ): Shape3DPoint[] {
    const points: Shape3DPoint[] = [];
    const s = scale;
    
    switch (type) {
      // === åŸºç¡€å‡ ä½• ===
      case Shape3DType.SPHERE:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 30 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue + (i / count) * 60
          });
        }
        break;
        
      case Shape3DType.CUBE: {
        const side = 25 * s;
        // åˆ†é…ç‚¹ï¼šè¾¹ç¼˜çº¿ 40%ï¼Œé¢ 60%
        const edgeCount = Math.floor(count * 0.4);
        const faceCount = count - edgeCount;

        // 1. å¼ºåŒ–è¾¹ç¼˜çº¿ (12æ¡è¾¹)
        for (let i = 0; i < edgeCount; i++) {
          const edge = Math.floor(Math.random() * 12);
          const t = Math.random() * 2 - 1;
          let p: Vector3;
          switch(edge) {
            case 0: p = new Vector3(side, side, t * side); break;
            case 1: p = new Vector3(side, -side, t * side); break;
            case 2: p = new Vector3(-side, side, t * side); break;
            case 3: p = new Vector3(-side, -side, t * side); break;
            case 4: p = new Vector3(side, t * side, side); break;
            case 5: p = new Vector3(side, t * side, -side); break;
            case 6: p = new Vector3(-side, t * side, side); break;
            case 7: p = new Vector3(-side, t * side, -side); break;
            case 8: p = new Vector3(t * side, side, side); break;
            case 9: p = new Vector3(t * side, side, -side); break;
            case 10: p = new Vector3(t * side, -side, side); break;
            default: p = new Vector3(t * side, -side, -side);
          }
          points.push({ position: p, hue: baseHue + (t + 1) * 30, size: 4 });
        }

        // 2. å¡«å……é¢ (6ä¸ªé¢)
        for (let i = 0; i < faceCount; i++) {
          const face = Math.floor(Math.random() * 6);
          const u = Math.random() * 2 - 1;
          const v = Math.random() * 2 - 1;
          let p: Vector3;
          switch(face) {
            case 0: p = new Vector3(side, u * side, v * side); break;
            case 1: p = new Vector3(-side, u * side, v * side); break;
            case 2: p = new Vector3(u * side, side, v * side); break;
            case 3: p = new Vector3(u * side, -side, v * side); break;
            case 4: p = new Vector3(u * side, v * side, side); break;
            default: p = new Vector3(u * side, v * side, -side);
          }
          // å¢åŠ è‰²å½©æ·±åº¦å’Œå‘å…‰æ„Ÿ
          points.push({ 
            position: p, 
            hue: baseHue + (u + v + 2) * 20,
            size: 3,
            decay: 0.008 // æ­£æ–¹å½¢å­˜ç•™æ—¶é—´ç¨é•¿
          });
        }
        break;
      }

      case Shape3DType.PYRAMID: {
        const h = 40 * s;
        const side = 30 * s;
        // 5ä¸ªé¢ï¼š1ä¸ªåº•é¢(æ­£æ–¹å½¢)ï¼Œ4ä¸ªä¾§é¢(ä¸‰è§’å½¢)
        for (let i = 0; i < count; i++) {
          const part = Math.floor(Math.random() * 5);
          let u = Math.random();
          let v = Math.random();
          let p: Vector3;

          if (part === 0) { // åº•é¢
            p = new Vector3((u - 0.5) * 2 * side, 0, (v - 0.5) * 2 * side);
          } else { // ä¾§é¢
            if (u + v > 1) { u = 1 - u; v = 1 - v; } // ä¿æŒåœ¨ä¸‰è§’å½¢å†…
            const tip = new Vector3(0, h, 0);
            const corners = [
              new Vector3(side, 0, side), new Vector3(-side, 0, side),
              new Vector3(-side, 0, -side), new Vector3(side, 0, -side)
            ];
            const c1 = corners[part - 1];
            const c2 = corners[part % 4];
            p = tip.clone().multiplyScalar(1 - u - v).add(c1.clone().multiplyScalar(u)).add(c2.clone().multiplyScalar(v));
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 60 });
        }
        break;
      }
        
      case Shape3DType.OCTAHEDRON: {
        const r = 35 * s;
        // 8ä¸ªé¢ (å…¨ç­‰ä¸‰è§’å½¢)
        for (let i = 0; i < count; i++) {
          const face = Math.floor(Math.random() * 8);
          // é¡¶ç‚¹ï¼š(Â±r, 0, 0), (0, Â±r, 0), (0, 0, Â±r)
          const vertices = [
            new Vector3(r, 0, 0), new Vector3(-r, 0, 0),
            new Vector3(0, r, 0), new Vector3(0, -r, 0),
            new Vector3(0, 0, r), new Vector3(0, 0, -r)
          ];
          // å®šä¹‰8ä¸ªé¢çš„é¡¶ç‚¹ç»„åˆ
          const faceMap = [
            [0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5],
            [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5]
          ];
          const [v1, v2, v3] = faceMap[face].map(idx => vertices[idx]);
          let u = Math.random(), v = Math.random();
          if (u + v > 1) { u = 1 - u; v = 1 - v; }
          const p = v1.clone().multiplyScalar(1 - u - v).add(v2.clone().multiplyScalar(u)).add(v3.clone().multiplyScalar(v));
          points.push({ position: p, hue: baseHue + (p.y / r) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.DODECAHEDRON: {
        const r = 30 * s;
        const phi = (1 + Math.sqrt(5)) / 2;
        // é¡¶ç‚¹å®šä¹‰ (20å¯¹)
        const v = [
          [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
          [0, 1/phi, phi], [0, 1/phi, -phi], [0, -1/phi, phi], [0, -1/phi, -phi],
          [1/phi, phi, 0], [1/phi, -phi, 0], [-1/phi, phi, 0], [-1/phi, -phi, 0],
          [phi, 0, 1/phi], [phi, 0, -1/phi], [-phi, 0, 1/phi], [-phi, 0, -1/phi]
        ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));

        for (let i = 0; i < count; i++) {
          const vIdx = Math.floor(Math.random() * v.length);
          const p = v[vIdx].clone();
          // åœ¨é¡¶ç‚¹åŠå…¶ä¸´è¿‘åŒºåŸŸé‡‡æ ·
          const jitter = (Math.random() - 0.5) * 5 * s;
          p.x += jitter; p.y += jitter; p.z += jitter;
          points.push({ position: p, hue: baseHue + (p.length() / r) * 100, size: 4 });
        }
        break;
      }
      
      case Shape3DType.ICOSAHEDRON: {
        const t = (1 + Math.sqrt(5)) / 2;
        const r = 35 * s;
        // 20ä¸ªé¢ï¼Œé‡‡æ ·ç‚¹åˆ†å¸ƒåœ¨é¢ä¸Š
        for (let i = 0; i < count; i++) {
          const vertices = [
            [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
            [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
            [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
          ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));
          
          const faceIdx = Math.floor(Math.random() * 20);
          // è¿™é‡Œæœ¬åº”å®šä¹‰20ä¸ªé¢ï¼Œç®€åŒ–ä¸ºåœ¨çƒé¢ä¸ŠåŸºäºå¤§åœ†æ­¥è¿›
          const angle = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          // å¢åŠ  icos ç‹¬æœ‰çš„â€œå‡ ä½•æŠ–åŠ¨â€ï¼Œä½¿å…¶æ˜¾å¾—æ£±è§’ç¡¬æœ—
          const p = new Vector3(Math.sin(phi)*Math.cos(angle)*r, Math.sin(phi)*Math.sin(angle)*r, Math.cos(phi)*r);
          p.x=Math.round(p.x/5)*5; p.y=Math.round(p.y/5)*5; p.z=Math.round(p.z/5)*5;
          points.push({ position: p, hue: baseHue + 200, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CYLINDER: {
        const h = 60 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.2) { // é¡¶ç›–
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, h/2, Math.sin(angle) * dist);
          } else if (part < 0.4) { // åº•ç›–
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, -h/2, Math.sin(angle) * dist);
          } else { // ä¾§å£
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * h;
            p = new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
          }
          points.push({ position: p, hue: baseHue + (p.y / h + 0.5) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CONE: {
        const h = 60 * s;
        const r = 30 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.3) { // åº•åº§
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
          } else { // é”¥é¢
            const y = Math.random() * h;
            const currentR = r * (1 - y / h);
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 + (p.x/r)*20, size: 3 });
        }
        break;
      }
      
      case Shape3DType.TORUS: {
        const R = 30 * s; 
        const r = 10 * s;
        // åœ†ç¯ä¸‰å±‚é‡‡æ ·ï¼šå†…åœˆã€å¤–åœˆã€ç®¡å£é¢
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // å¢åŠ è‰²å½©æ¸å˜å¯¹å‘¨é•¿çš„ä¾èµ–
          const hueOffset = (theta / (Math.PI * 2)) * 60;
          points.push({
            position: new Vector3(
              (R + r * Math.cos(phi)) * Math.cos(theta),
              r * Math.sin(phi),
              (R + r * Math.cos(phi)) * Math.sin(theta)
            ),
            hue: (baseHue + hueOffset) % 360,
            size: 4
          });
        }
        break;
      }
      
      case Shape3DType.TORUS_KNOT: {
        const R = 20 * s;
        const r = 6 * s;
        const p = 2, q = 3;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2 * 3;
          const x = (R + r * Math.cos(q * t)) * Math.cos(p * t);
          const y = r * Math.sin(q * t);
          const z = (R + r * Math.cos(q * t)) * Math.sin(p * t);
          points.push({ position: new Vector3(x, y, z), hue: baseHue + (i / count) * 360 });
        }
        break;
      }
      
      // === é«˜çº§å‡ ä½• ===
      case Shape3DType.CAPSULE: {
        const h = 40 * s;
        const r = 15 * s;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const v = Math.random();
          let y: number, currentR: number;
          if (v < 0.3) { // åº•éƒ¨åŠçƒ
            const phi = Math.PI / 2 + Math.random() * Math.PI / 2;
            y = -h / 2 + r * Math.cos(phi - Math.PI / 2);
            currentR = r * Math.sin(phi);
          } else if (v > 0.7) { // é¡¶éƒ¨åŠçƒ
            const phi = Math.random() * Math.PI / 2;
            y = h / 2 + r * Math.sin(phi);
            currentR = r * Math.cos(phi);
          } else { // ä¸­é—´åœ†æŸ±
            y = (v - 0.5) * h;
            currentR = r;
          }
          points.push({
            position: new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR),
            hue: baseHue + (y / h + 0.5) * 60
          });
        }
        break;
      }
      
      case Shape3DType.STAR_3D: {
        const outerR = 30 * s;
        const innerR = 12 * s;
        const pts = 5;
        const depth = 5 * s; // å¢åŠ  3D åšåº¦
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const angle = t * Math.PI * 2;
          const isOuter = Math.floor(t * pts * 2) % 2 === 0;
          const r = isOuter ? outerR : innerR;
          const z = (Math.random() - 0.5) * depth;
          points.push({
            position: new Vector3(Math.cos(angle) * r, Math.sin(angle) * r, z),
            hue: baseHue + (isOuter ? 0 : 40),
            size: isOuter ? 8 : 4
          });
        }
        break;
      }
      
      case Shape3DType.PRISM: {
        const h = 50 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const part = Math.floor(Math.random() * 5); // 2ä¸ªåº•é¢ï¼Œ3ä¸ªä¾§é¢
          let p: Vector3;
          if (part < 2) { // åº•é¢ (ä¸‰è§’å½¢)
             let u = Math.random(), v = Math.random();
             if (u + v > 1) { u = 1 - u; v = 1 - v; }
             const y = part === 0 ? h / 2 : -h / 2;
             // æ­£ä¸‰è§’å½¢åæ ‡
             const v1 = new Vector3(0, y, r);
             const v2 = new Vector3(r * 0.866, y, -r * 0.5);
             const v3 = new Vector3(-r * 0.866, y, -r * 0.5);
             p = v1.multiplyScalar(1 - u - v).add(v2.multiplyScalar(u)).add(v3.multiplyScalar(v));
          } else { // ä¾§é¢
             const side = part - 2;
             const angle1 = (side / 3) * Math.PI * 2;
             const angle2 = ((side + 1) / 3) * Math.PI * 2;
             const u = Math.random();
             const y = (Math.random() - 0.5) * h;
             const x = Math.cos(angle1) * r * (1 - u) + Math.cos(angle2) * r * u;
             const z = Math.sin(angle1) * r * (1 - u) + Math.sin(angle2) * r * u;
             p = new Vector3(x, y, z);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 });
        }
        break;
      }

      case Shape3DType.CROSS_3D: {
        const len = 40 * s;
        const thick = 10 * s;
        for (let i = 0; i < count; i++) {
          const axis = Math.floor(Math.random() * 3);
          const t = (Math.random() - 0.5) * 2 * len;
          const u = (Math.random() - 0.5) * thick;
          const v = (Math.random() - 0.5) * thick;
          let p: Vector3;
          if (axis === 0) p = new Vector3(t, u, v);
          else if (axis === 1) p = new Vector3(u, t, v);
          else p = new Vector3(u, v, t);
          points.push({ position: p, hue: baseHue + (t / len) * 50 });
        }
        break;
      }

      case Shape3DType.DIAMOND: {
        const r = 35 * s;
        const h = 40 * s;
        for (let i = 0; i < count; i++) {
          const v = Math.random();
          const angle = Math.random() * Math.PI * 2;
          let y: number, curR: number;
          if (v < 0.4) { // ä¸Šéƒ¨å°é¢åŠæ–œé¢
             y = (1 - v / 0.4) * h * 0.4;
             curR = r * (0.6 + (v / 0.4) * 0.4);
          } else { // ä¸‹éƒ¨å°–è§’
             y = -(v - 0.4) / 0.6 * h * 1.5;
             curR = r * (1 - (v - 0.4) / 0.6);
          }
          // å¯¹ angle è¿›è¡Œ stepped å¤„ç†æ¨¡æ‹Ÿåˆ‡é¢æ„Ÿ
          const stepAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
          points.push({ position: new Vector3(Math.cos(stepAngle)*curR, y, Math.sin(stepAngle)*curR), hue: 200, size: 2 });
        }
        break;
      }

      case Shape3DType.MOBIUS: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const u = (i / count) * Math.PI * 2;
          const v = (Math.random() - 0.5) * 15 * s;
          const x = (R + v * Math.cos(u/2)) * Math.cos(u);
          const y = (R + v * Math.cos(u/2)) * Math.sin(u);
          const z = v * Math.sin(u/2);
          points.push({ position: new Vector3(x, z, y), hue: baseHue + (u/Math.PI)*60 });
        }
        break;
      }

      case Shape3DType.KLEIN_BOTTLE: {
        for (let i = 0; i < count; i++) {
          const u = Math.random() * Math.PI;
          const v = Math.random() * Math.PI * 2;
          const x = -2/15 * Math.cos(u) * (3*Math.cos(v) - 30*Math.sin(u) + 90*Math.pow(Math.cos(u),4)*Math.sin(u) - 60*Math.pow(Math.cos(u),6)*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u));
          const y = -1/15 * Math.sin(u) * (3*Math.cos(v) - 3*Math.pow(Math.cos(u),2)*Math.cos(v) - 48*Math.pow(Math.cos(u),4)*Math.cos(v) + 48*Math.pow(Math.cos(u),6)*Math.cos(v) - 60*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u) - 5*Math.pow(Math.cos(u),3)*Math.cos(v)*Math.sin(u) - 80*Math.pow(Math.cos(u),5)*Math.cos(v)*Math.sin(u) + 80*Math.pow(Math.cos(u),7)*Math.cos(v)*Math.sin(u));
          const z = 2/15 * (3 + 5*Math.cos(u)*Math.sin(u)) * Math.sin(v);
          points.push({ position: new Vector3(x*15*s, y*15*s, z*15*s), hue: 280 + (u/Math.PI)*80 });
        }
        break;
      }

      case Shape3DType.SPRING: {
        const r = 15 * s;
        const R = 30 * s;
        const turns = 5;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const angle = t * Math.PI * 2 * turns;
          const y = (t - 0.5) * 80 * s;
          const x = Math.cos(angle) * R + (Math.random()-0.5)*5*s;
          const z = Math.sin(angle) * R + (Math.random()-0.5)*5*s;
          points.push({ position: new Vector3(x, y, z), hue: baseHue + t * 360 });
        }
        break;
      }

      case Shape3DType.HELIX_TUBE: {
        const h = 80 * s;
        const r = 20 * s;
        const turns = 3;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const y = (t - 0.5) * h;
          const angle = t * Math.PI * 2 * turns;
          // åŒèºæ—‹
          points.push({
            position: new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle + Math.PI) * r, y, Math.sin(angle + Math.PI) * r),
            hue: (baseHue + 180) % 360
          });
        }
        break;
      }
      
      case Shape3DType.NESTED_SPHERES: {
        const layers = 3;
        for (let layer = 1; layer <= layers; layer++) {
          const r = (layer / layers) * 35 * s;
          const layerCount = Math.floor(count / layers);
          for (let i = 0; i < layerCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            points.push({
              position: new Vector3(
                Math.sin(phi) * Math.cos(theta) * r,
                Math.sin(phi) * Math.sin(theta) * r,
                Math.cos(phi) * r
              ),
              hue: baseHue + (layer - 1) * 60, // æ¯ä¸€å±‚ä½¿ç”¨æˆªç„¶ä¸åŒçš„è‰²ç›¸
              size: 2 + (layers - layer) * 2 // å¤–å±‚ç²’å­æ›´å°æ›´å¯†ï¼Œå†…å±‚æ›´å¤§
            });
          }
        }
        break;
      }
      
      // === è‡ªç„¶ç”Ÿç‰© ===
      case Shape3DType.BUTTERFLY_3D: {
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2;
          const h = (Math.random() - 0.5) * 2;
          // 3D è´è¶æ›²é¢ (åŸºäºæåæ ‡å˜æ¢)
          const m = (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t/12), 5)) * 10 * s;
          const x = Math.sin(t) * m;
          const y = Math.cos(t) * m;
          // ç¿…è†€å¼€åˆ 3D æ„Ÿ
          const wingAngle = Math.abs(Math.sin(t)) * 0.5;
          const z = Math.abs(x) * wingAngle + (Math.random() - 0.5) * 5 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: baseHue + (Math.abs(x) / (20 * s)) * 200 // ç¿…è†€è¾¹ç¼˜å˜è‰²
          });
        }
        break;
      }
      
      case Shape3DType.FLOWER_3D: {
        const petals = 6;
        const layers = 3;
        for (let layer = 0; layer < layers; layer++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + layer * 8) * s;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const petalMod = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.3);
            const y = layer * 5 * s - 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta) * r * petalMod, y, Math.sin(theta) * r * petalMod),
              hue: baseHue + layer * 40
            });
          }
        }
        break;
      }
      
      case Shape3DType.HEART_3D: {
        // çœŸ 3D ä½“ç§¯é‡‡æ ·çˆ±å¿ƒ - Taubin Surface å˜ä½“
        for (let i = 0; i < count; i++) {
          const t = Math.random() * Math.PI * 2;
          const p = Math.acos(2 * Math.random() - 1);
          // ä½¿ç”¨å‚æ•°åŒ–çƒåæ ‡å¹¶è¿›è¡Œå¿ƒè„æ˜ å°„å˜æ¢
          const sinP = Math.sin(p), cosP = Math.cos(p), sinT = Math.sin(t), cosT = Math.cos(t);
          
          let x = 1.2 * sinP * sinT;
          let y = 1.2 * sinP * cosT;
          let z = cosP;
          
          // ç»™çƒä½“æ–½åŠ â€œå¿ƒå½¢æ‹‰ä¼¸â€
          // y å‘ä¸‹å‡¹é™·ï¼Œé¡¶éƒ¨å‘ä¸Šéš†èµ·
          y += Math.pow(Math.abs(x), 0.6) * 0.5;
          // ä¿®æ­£åæ ‡ä½¿å…¶å°–ç«¯å‘ä¸‹ï¼šåè½¬ y çš„æ‹‰ä¼¸æ–¹å‘
          const finalX = x * 25 * s;
          const finalY = y * 22 * s - 10 * s; // ä¿®æ­£åçš„å°–ç«¯å‘ä¸‹é€»è¾‘
          const finalZ = z * 18 * s * Math.pow(Math.abs(sinT), 0.3); // å¢åŠ ä¾§å‘é¥±æ»¡åº¦
          
          points.push({
            position: new Vector3(finalX, finalY, finalZ),
            hue: 340 + Math.random() * 40,
            size: 5 + Math.random() * 3,
            decay: 0.006 // çˆ±å¿ƒå­˜ç•™æ›´ä¹…
          });
        }
        break;
      }
      
      case Shape3DType.SNOWFLAKE_3D: {
        const arms = 6;
        const r = 35 * s;
        for (let i = 0; i < count; i++) {
          const arm = Math.floor(Math.random() * arms);
          const t = Math.random();
          const angle = (arm / arms) * Math.PI * 2;
          // ä¸»è½´
          let pX = Math.cos(angle) * t * r;
          let pY = (Math.random() - 0.5) * 2 * s; // æ‰å¹³ 3D
          let pZ = Math.sin(angle) * t * r;
          // æ”¯å‰
          if (t > 0.4) {
             const subT = Math.random() * 0.3 * t;
             const subAngle = angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3;
             pX += Math.cos(subAngle) * subT * r;
             pZ += Math.sin(subAngle) * subT * r;
          }
          points.push({ position: new Vector3(pX, pY, pZ), hue: 180 + Math.random() * 40 });
        }
        break;
      }
      case Shape3DType.TREE: {
        const h = 50 * s;
        // 1. æ ‘å¹² (20%)
        for (let i = 0; i < count * 0.2; i++) {
          const y = Math.random() * h * 0.4;
          points.push({ position: new Vector3((Math.random()-0.5)*2, y, (Math.random()-0.5)*2), hue: 30, size: 4 });
        }
        // 2. æ ‘å†  (80%) - å¤šä¸ªåˆ†å±‚çƒä½“ç»„æˆçš„äº‘å›¢
        for (let i = 0; i < count * 0.8; i++) {
          const layer = Math.floor(Math.random() * 3);
          const r = (15 + Math.random() * 10) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const center = new Vector3(0, h * 0.6 + layer * 10 * s, 0);
          points.push({
            position: new Vector3(
              center.x + Math.sin(phi) * Math.cos(theta) * r,
              center.y + Math.cos(phi) * r,
              center.z + Math.sin(phi) * Math.sin(theta) * r
            ),
            hue: 120 + Math.random() * 40 // ç»¿è‰²è°ƒ
          });
        }
        break;
      }

      case Shape3DType.BIRD: 
      case Shape3DType.PHOENIX: {
        const isPhoenix = type === Shape3DType.PHOENIX;
        const wingSpan = 50 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * 2 - 1; // -1 to 1
          const x = t * wingSpan;
          // ç¿¼å±•å¼§åº¦: M å‹
          const y = Math.abs(t) * 10 * s + Math.sin(Math.abs(t) * Math.PI) * 15 * s;
          const z = Math.cos(t * Math.PI) * 10 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: isPhoenix ? 20 + Math.random() * 40 : baseHue,
            size: isPhoenix ? 6 : 4,
            behavior: isPhoenix ? 'fire' : undefined
          });

          // å‡¤å‡°å°¾ç¾½
          if (isPhoenix && i % 5 === 0) {
            for(let j=1; j<5; j++) {
              points.push({
                position: new Vector3(x*0.2, -j*15*s, -j*5*s),
                hue: 10,
                behavior: 'willow'
              });
            }
          }
        }
        break;
      }

      case Shape3DType.JELLYFISH: {
        const r = 25 * s;
        // 1. ä¼ç›– (åŠçƒ)
        for (let i = 0; i < count * 0.5; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 0.5; // åªå–ä¸ŠåŠçƒ
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.cos(phi)*r, Math.sin(phi)*Math.sin(theta)*r),
            hue: baseHue + 200,
            behavior: 'glitter'
          });
        }
        // 2. è§¦é¡» (å‚çº¿)
        for (let i = 0; i < count * 0.5; i++) {
          const leg = Math.floor(Math.random() * 8);
          const angle = (leg / 8) * Math.PI * 2;
          const length = Math.random() * 40 * s;
          points.push({
            position: new Vector3(Math.cos(angle)*r*0.6, -length, Math.sin(angle)*r*0.6),
            hue: baseHue + 180,
            behavior: 'willow'
          });
        }
        break;
      }

      case Shape3DType.FISH_3D: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * len;
          // é±¼èº«: æ¤­çƒ
          const r = Math.sin(t * Math.PI) * 12 * s;
          const angle = Math.random() * Math.PI * 2;
          // é±¼å°¾: ä¸‰è§’å½¢ (tæ¥è¿‘1æ—¶)
          let y = Math.cos(angle) * r;
          let z = Math.sin(angle) * r;
          if (t > 0.8) {
             const tailW = (t - 0.8) * 50 * s;
             y = (Math.random() - 0.5) * tailW;
          }
          points.push({ position: new Vector3(x, y, z), hue: 40 + t * 40 });
        }
        break;
      }

      case Shape3DType.SHELL: {
        for (let i = 0; i < count; i++) {
          const t = i / count * Math.PI * 8; // 4åœˆ
          const r = 2 * Math.exp(0.1 * t) * s;
          const angle = t;
          const spiralX = r * Math.cos(angle);
          const spiralY = r * Math.sin(angle);
          const spiralZ = t * 2 * s;
          // ç»™èºæ—‹çº¿åŠ ç‚¹å®½åº¦
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(spiralX + offset, spiralY, spiralZ), hue: 200 + (t/30)*100 });
        }
        break;
      }

      case Shape3DType.LEAF: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const u = Math.random();
          const v = (Math.random() - 0.5) * 2;
          const x = u * len;
          // å¶å½¢: sinæ›²çº¿
          const w = Math.sin(u * Math.PI) * 15 * s;
          const y = v * w;
          const z = Math.sin(u * Math.PI * 2) * 5 * s; // å·æ›²æ„Ÿ
          points.push({ position: new Vector3(x - len/2, y, z), hue: 100 + u * 60 });
        }
        break;
      }

      case Shape3DType.MUSHROOM: {
        const rCap = 30 * s;
        const hStem = 30 * s;
        for (let i = 0; i < count; i++) {
          if (i < count * 0.7) { // èŒç›–
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.4;
            points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*rCap, Math.cos(phi)*rCap*0.5 + hStem, Math.sin(phi)*Math.sin(theta)*rCap), hue: 0 });
          } else { // èŒæŸ„
            const y = Math.random() * hStem;
            const angle = Math.random() * Math.PI * 2;
            const rs = 8 * s;
            points.push({ position: new Vector3(Math.cos(angle)*rs, y, Math.sin(angle)*rs), hue: 40 });
          }
        }
        break;
      }

      // === å®‡å®™å¤©ä½“ (è¡¥å…¨å®ç°) ===
      case Shape3DType.BLACK_HOLE: {
        // 1. å¸ç§¯ç›˜ (æ‰å¹³æ—‹è½¬)
        for (let i = 0; i < count * 0.8; i++) {
          const dist = (15 + Math.random() * 45) * s;
          const angle = Math.random() * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*2, Math.sin(angle)*dist),
            hue: 280 + (dist/60)*80,
            behavior: 'vortex'
          });
        }
        // 2. è§†ç•Œ (æ ¸å¿ƒé»‘ç )
        for (let i = 0; i < count * 0.2; i++) {
          const r = 10 * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: 0,
            size: 2
          });
        }
        break;
      }

      case Shape3DType.PULSAR: {
        const r = 15 * s;
        // 1. æ ¸å¿ƒ
        for (let i = 0; i < count * 0.4; i++) {
           const theta = Math.random()*Math.PI*2;
           const phi = Math.acos(2*Math.random()-1);
           points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r), hue: 200, behavior: 'glitter' });
        }
        // 2. ç£æå–·æµ (ä¸¤ç«¯é«˜èƒ½æŸ±)
        for (let i = 0; i < count * 0.6; i++) {
           const side = Math.random() > 0.5 ? 1 : -1;
           const len = Math.random() * 80 * s;
           const spread = (len / (80*s)) * 5 * s;
           points.push({
             position: new Vector3((Math.random()-0.5)*spread, side * len, (Math.random()-0.5)*spread),
             hue: 240,
             behavior: 'glitter',
             size: 5
           });
        }
        break;
      }

      case Shape3DType.SUPERNOVA: {
        // å¤§çˆ†å‘ï¼šå†…çˆ†ç¬é—´çš„å¤–æ‰©
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isRay = Math.random() > 0.7;
          const r = isRay ? (40 + Math.random() * 60) * s : (20 + Math.random() * 20) * s;
          
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: isRay ? 0 : 40 + Math.random() * 40,
            size: isRay ? 8 : 4,
            behavior: isRay ? 'glitter' : 'fire'
          });
        }
        break;
      }

      case Shape3DType.ASTEROID_BELT: {
        const R = 40 * s;
        const r = 8 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // å—çŠ¶é‡‡æ ·
          const dist = R + (Math.random() - 0.5) * r * 2;
          points.push({
            position: new Vector3(Math.cos(theta)*dist, (Math.random()-0.5)*r, Math.sin(theta)*dist),
            hue: 30 + Math.random() * 20,
            size: Math.random() * 5 + 2,
            friction: 0.98
          });
        }
        break;
      }

      case Shape3DType.COMET: {
        const len = 100 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.pow(Math.random(), 2); // å°¾éƒ¨æ›´ç¨€ç–
          const dist = t * len;
          const spread = t * 20 * s;
          points.push({
            position: new Vector3((Math.random()-0.5)*spread, -dist, (Math.random()-0.5)*spread),
            hue: 180 + t * 60,
            behavior: 'willow',
            size: (1-t) * 8
          });
        }
        break;
      }

      // === æ–‡åŒ–ç¬¦å· (è¡¥å…¨å®ç°) ===
      case Shape3DType.LOTUS: {
        const layers = 4;
        for (let l = 0; l < layers; l++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + l * 10) * s;
          const petals = 8 + l * 4;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const phiLocal = (i / layerCount) * Math.PI * 2; // å±€éƒ¨å˜é‡ç”¨äºæ¨¡æ‹ŸèŠ±ç“£å¼ å¼€åº¦
            const petalCurve = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.5);
            const y = Math.sin(phiLocal * 0.5) * 10 * s + l * 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta)*r*petalCurve, y, Math.sin(theta)*r*petalCurve),
              hue: 330 + l * 20
            });
          }
        }
        break;
      }

      case Shape3DType.CROWN_3D: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const theta = (i / count) * Math.PI * 2;
          const isPoint = Math.floor(theta * 6 / Math.PI) % 2 === 0;
          const y = isPoint ? Math.sin(theta * 6) * 20 * s + 10 * s : 0;
          points.push({
            position: new Vector3(Math.cos(theta)*R, y, Math.sin(theta)*R),
            hue: 50,
            size: 6
          });
        }
        break;
      }

      case Shape3DType.YIN_YANG: {
        const R = 35 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * R;
          const x = Math.cos(theta) * r;
          const z = Math.sin(theta) * r;
          const isWhite = x > 0; // ç®€åŒ–å®ç°
          points.push({ position: new Vector3(x, 0, z), hue: isWhite ? 0 : 200, size: isWhite ? 6 : 4 });
        }
        break;
      }

      case Shape3DType.GALAXY_SPIRAL: {
        const arms = 4;
        const armDensity = 0.8;
        for (let i = 0; i < count; i++) {
          const arm = i % arms;
          const dist = Math.pow(Math.random(), 0.7) * 60 * s;
          const angle = (arm / arms) * Math.PI * 2 + dist * 0.15;
          const scatter = (Math.random() - 0.5) * (60 * s / (dist + 5)) * 5;
          
          const p = new Vector3(
            Math.cos(angle) * dist + (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 8 * s * (1 - dist / (60 * s)),
            Math.sin(angle) * dist + (Math.random() - 0.5) * 5
          );
          
          points.push({
            position: p,
            hue: baseHue + (dist / (60 * s)) * 100,
            size: Math.random() > 0.8 ? 8 : 4,
            behavior: 'glitter'
          });
        }
        break;
      }
      
      case Shape3DType.PLANET_RINGS: {
        // è¡Œæ˜Ÿæœ¬ä½“
        for (let i = 0; i < count * 0.3; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 15 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: 30
          });
        }
        // å…‰ç¯
        for (let i = 0; i < count * 0.7; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 25 + Math.random() * 15;
          points.push({
            position: new Vector3(
              Math.cos(angle) * dist * s,
              Math.cos(angle) * dist * 0.3 * s,
              Math.sin(angle) * dist * s
            ),
            hue: 200
          });
        }
        break;
      }
      
      case Shape3DType.NEBULA: {
        for (let i = 0; i < count; i++) {
          const r = (20 + Math.random() * 30) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const scatter = Math.pow(Math.random(), 2) * 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi)*Math.cos(theta)*r + (Math.random()-0.5)*scatter,
              Math.sin(phi)*Math.sin(theta)*r + (Math.random()-0.5)*scatter,
              Math.cos(phi)*r + (Math.random()-0.5)*scatter
            ),
            hue: baseHue + Math.random() * 80,
            behavior: 'glitter',
            size: Math.random() * 6
          });
        }
        break;
      }

      case Shape3DType.WORMHOLE: {
        for (let i = 0; i < count; i++) {
          const t = (Math.random() - 0.5) * 2;
          const y = t * 60 * s;
          const r = (Math.abs(t) * 20 + 5) * s;
          const angle = (i / count) * Math.PI * 2 + t * 4;
          points.push({
            position: new Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r),
            hue: 240 + t * 60
          });
        }
        break;
      }

      case Shape3DType.CONSTELLATION: {
        const r = 50 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isStar = Math.random() > 0.9;
          const dist = isStar ? r : Math.random() * r;
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*dist, Math.sin(phi)*Math.sin(theta)*dist, Math.cos(phi)*dist),
            hue: isStar ? 0 : 200,
            size: isStar ? 8 : 2,
            behavior: isStar ? 'glitter' : undefined
          });
        }
        break;
      }

      case Shape3DType.LANTERN: {
        const h = 40 * s;
        const r = 20 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const angle = Math.random() * Math.PI * 2;
          const currentR = Math.sin(t * Math.PI) * r + 5 * s;
          const y = (t - 0.5) * h;
          points.push({ position: new Vector3(Math.cos(angle)*currentR, y, Math.sin(angle)*currentR), hue: 0 });
          if (t < 0.1) {
             const tassLen = Math.random() * 20 * s;
             points.push({ position: new Vector3(Math.cos(angle)*r*0.5, -h/2 - tassLen, Math.sin(angle)*r*0.5), hue: 45, behavior: 'willow' });
          }
        }
        break;
      }

      case Shape3DType.RIBBON: {
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * 100 * s;
          const y = Math.sin(t * Math.PI * 2) * 20 * s;
          const z = Math.cos(t * Math.PI * 2) * 20 * s;
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(x, y + offset, z), hue: t * 360, size: 4 });
        }
        break;
      }

      // === ç‰¹æ•ˆç±» ===
      case Shape3DType.EXPLOSION_BURST:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = (20 + Math.random() * 15) * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'glitter'
          });
        }
        break;
        
      case Shape3DType.RING_WAVE:
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const r = 30 * s;
          points.push({
            position: new Vector3(Math.cos(angle) * r, 0, Math.sin(angle) * r),
            hue: baseHue + (i / count) * 360
          });
        }
        break;
        
      case Shape3DType.DOUBLE_RING:
        for (let i = 0; i < count / 2; i++) {
          const angle = (i / (count / 2)) * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle) * 35 * s, 0, Math.sin(angle) * 35 * s),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle) * 20 * s, 0, Math.sin(angle) * 20 * s),
            hue: (baseHue + 180) % 360
          });
        }
        break;
        
      case Shape3DType.FIREWORK_WILLOW:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const r = 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'willow',
            decay: 0.008
          });
        }
        break;
        
      case Shape3DType.CHAOS_SCATTER:
        for (let i = 0; i < count; i++) {
          points.push({
            position: new Vector3(
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s
            ),
            hue: Math.random() * 360
          });
        }
        break;
        
      // é»˜è®¤ï¼šçƒå½¢
      default:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 25 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue
          });
        }
    }
    
    return points;
  }
}

/**
 * Shape3Då·¥å‚
 */
export class Shape3DFactory {
  private static allTypes: Shape3DType[] = Object.values(Shape3DType);
  
  /**
   * ç”ŸæˆæŒ‡å®šå½¢çŠ¶
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale?: number,
    baseHue?: number
  ): Shape3DPoint[] {
    return Shape3DGenerator.generate(type, count, scale, baseHue);
  }
  
  /**
   * æŒ‰æƒé‡éšæœºé€‰æ‹©ä¸€ä¸ªå½¢çŠ¶ç±»å‹ (å¢åŠ å¤æ‚å½¢çŠ¶æƒé‡)
   */
  static getRandomType(): Shape3DType {
    // é™ä½æ™®é€šçƒå½¢å‡ºç°çš„æƒé‡
    const weights: Record<string, number> = {
      [Shape3DType.SPHERE]: 0.1,
      [Shape3DType.NESTED_SPHERES]: 0.1,
      [Shape3DType.HEART_3D]: 1.5,
      [Shape3DType.BUTTERFLY_3D]: 1.5,
      [Shape3DType.GALAXY_SPIRAL]: 2.0,
      [Shape3DType.PLANET_RINGS]: 1.5,
    };
    
    // åŠ¨æ€ç”ŸæˆåŠ æƒåˆ—è¡¨
    const pool: Shape3DType[] = [];
    this.allTypes.forEach(t => {
      const w = weights[t] || 1.0;
      for(let i=0; i<w*10; i++) pool.push(t);
    });
    
    return pool[Math.floor(Math.random() * pool.length)];
  }
  
  /**
   * ä»åˆ—è¡¨ä¸­éšæœºé€‰æ‹©
   */
  static getRandomTypeFrom(types: Shape3DType[]): Shape3DType {
    if (types.length === 0) return Shape3DType.SPHERE;
    return types[Math.floor(Math.random() * types.length)];
  }
  
  /**
   * è·å–æ‰€æœ‰å½¢çŠ¶ç±»å‹
   */
  static getAllTypes(): Shape3DType[] {
    return [...this.allTypes];
  }
  
  /**
   * æŒ‰ç±»åˆ«è·å–å½¢çŠ¶
   */
  static getTypesByCategory(category: string): Shape3DType[] {
    return this.allTypes.filter(type => SHAPE_3D_INFO[type].category === category);
  }
  
  /**
   * è·å–å½¢çŠ¶ä¿¡æ¯
   */
  static getInfo(type: Shape3DType): Shape3DInfo {
    return SHAPE_3D_INFO[type];
  }
  
  /**
   * è·å–æ‰€æœ‰åˆ†ç±»
   */
  static getCategories(): string[] {
    return Object.values(SHAPE_CATEGORIES);
  }
}

// END OF FILE: src/core/shapes/Shape3DFactory.ts


// =============================================================================
// FILE: src\core\stream\CarrierSystem.ts
// =============================================================================

/**
 * CarrierSystem.ts - è¿è½½ç³»ç»Ÿ
 * 
 * è´Ÿè´£ç®¡ç†çƒŸèŠ±ä»å‘å°„åˆ°åˆ°è¾¾ç›®æ ‡ä½ç½®çš„"è¿è½½"é˜¶æ®µ
 * 
 * åŠŸèƒ½ï¼š
 * - 3Dè´å¡å°”æ›²çº¿è·¯å¾„è®¡ç®—
 * - å°¾ç„°ç²’å­å‘å°„
 * - è¿è½½ä½“ä½ç½®æ›´æ–°
 * - åˆ°è¾¾æ£€æµ‹ä¸äº‹ä»¶è§¦å‘
 */

import { Vector3 } from '../Vector3';
import { 
  CarrierConfig, 
  Path3D, 
  PathType, 
  TrailConfig,
  Curve,
  evaluateCurve 
} from './types';

/**
 * è¿è½½ä½“çŠ¶æ€
 */
export interface CarrierState {
  /** å½“å‰ä½ç½® */
  position: Vector3;
  /** å½“å‰é€Ÿåº¦ (æ–¹å‘å‘é‡) */
  velocity: Vector3;
  /** è·¯å¾„è¿›åº¦ (0-1) */
  progress: number;
  /** å·²è¿è¡Œæ—¶é—´ */
  elapsed: number;
  /** æ˜¯å¦å·²åˆ°è¾¾ */
  arrived: boolean;
  /** æ˜¯å¦æ´»è·ƒ */
  active: boolean;
}

/**
 * å°¾ç„°ç²’å­
 */
export interface TrailParticle {
  position: Vector3;
  velocity: Vector3;
  age: number;
  lifeTime: number;
  hue: number;
  saturation: number;
  lightness: number;
  alpha: number;
  size: number;
  isDead: boolean;
}

/**
 * è¿è½½å™¨å®ä¾‹
 */
export interface CarrierInstance {
  id: string;
  config: CarrierConfig;
  state: CarrierState;
  startPosition: Vector3;
  targetPosition: Vector3;
  trailParticles: TrailParticle[];
  onArrive?: () => void;
}

/**
 * è¿è½½ç³»ç»Ÿ
 */
export class CarrierSystem {
  private carriers: Map<string, CarrierInstance> = new Map();
  private nextCarrierId: number = 0;
  private maxTrailParticles: number = 500;

  /**
   * åˆ›å»ºæ–°çš„è¿è½½å™¨
   */
  createCarrier(
    config: CarrierConfig,
    startPosition: Vector3,
    targetPosition: Vector3,
    onArrive?: () => void
  ): string {
    const id = `carrier_${this.nextCarrierId++}`;
    
    const carrier: CarrierInstance = {
      id,
      config,
      state: {
        position: new Vector3(startPosition.x, startPosition.y, startPosition.z),
        velocity: new Vector3(0, 0, 0),
        progress: 0,
        elapsed: 0,
        arrived: false,
        active: true
      },
      startPosition: new Vector3(startPosition.x, startPosition.y, startPosition.z),
      targetPosition: new Vector3(targetPosition.x, targetPosition.y, targetPosition.z),
      trailParticles: [],
      onArrive
    };

    this.carriers.set(id, carrier);
    
    console.log(`[CarrierSystem] Created carrier ${id}: ${startPosition.y.toFixed(1)} â†’ ${targetPosition.y.toFixed(1)}`);
    
    return id;
  }

  /**
   * æ›´æ–°æ‰€æœ‰è¿è½½å™¨
   */
  update(deltaTime: number): void {
    for (const carrier of this.carriers.values()) {
      if (!carrier.state.active) continue;
      
      this.updateCarrier(carrier, deltaTime);
      this.updateTrailParticles(carrier, deltaTime);
    }
  }

  /**
   * æ›´æ–°å•ä¸ªè¿è½½å™¨
   */
  private updateCarrier(carrier: CarrierInstance, deltaTime: number): void {
    const state = carrier.state;
    const config = carrier.config;
    
    // æ›´æ–°æ—¶é—´å’Œè¿›åº¦
    state.elapsed += deltaTime;
    const rawProgress = state.elapsed / config.duration;
    
    // åº”ç”¨é€Ÿåº¦æ›²çº¿
    state.progress = evaluateCurve(config.path.speedCurve, Math.min(rawProgress, 1));
    
    // è®¡ç®—æ–°ä½ç½®
    const prevPosition = new Vector3(state.position.x, state.position.y, state.position.z);
    state.position = this.evaluatePath(carrier, state.progress);
    
    // è®¡ç®—é€Ÿåº¦å‘é‡ (ç”¨äºå°¾ç„°æ–¹å‘)
    if (deltaTime > 0) {
      state.velocity = new Vector3(
        (state.position.x - prevPosition.x) / deltaTime,
        (state.position.y - prevPosition.y) / deltaTime,
        (state.position.z - prevPosition.z) / deltaTime
      );
    }
    
    // å‘å°„å°¾ç„°ç²’å­
    if (config.trail && !state.arrived) {
      this.emitTrailParticles(carrier, deltaTime);
    }
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾
    if (rawProgress >= 1 && !state.arrived) {
      state.arrived = true;
      state.position = carrier.targetPosition;
      
      console.log(`[CarrierSystem] Carrier ${carrier.id} arrived at target`);
      
      if (carrier.onArrive) {
        carrier.onArrive();
      }
    }
  }

  /**
   * è¯„ä¼°è·¯å¾„ä½ç½®
   */
  private evaluatePath(carrier: CarrierInstance, t: number): Vector3 {
    const path = carrier.config.path;
    const start = carrier.startPosition;
    const end = carrier.targetPosition;
    
    switch (path.type) {
      case 'linear':
        return this.evaluateLinearPath(start, end, t);
      
      case 'bezier_3d':
        return this.evaluateBezierPath(path, start, end, t);
      
      case 'spiral':
        return this.evaluateSpiralPath(path, start, end, t);
      
      case 'helix':
        return this.evaluateHelixPath(path, start, end, t);
      
      case 'arc':
        return this.evaluateArcPath(start, end, t);
      
      default:
        return this.evaluateLinearPath(start, end, t);
    }
  }

  /**
   * çº¿æ€§è·¯å¾„
   */
  private evaluateLinearPath(start: Vector3, end: Vector3, t: number): Vector3 {
    return new Vector3(
      start.x + (end.x - start.x) * t,
      start.y + (end.y - start.y) * t,
      start.z + (end.z - start.z) * t
    );
  }

  /**
   * 3Dè´å¡å°”æ›²çº¿è·¯å¾„
   */
  private evaluateBezierPath(path: Path3D, start: Vector3, end: Vector3, t: number): Vector3 {
    const points = path.points || [];
    
    if (points.length === 0) {
      // è‡ªåŠ¨ç”Ÿæˆæ§åˆ¶ç‚¹
      const midY = (start.y + end.y) / 2 + 20;
      const cp1 = new Vector3(start.x, midY, start.z);
      const cp2 = new Vector3(end.x, midY + 10, end.z);
      return this.cubicBezier3D(start, cp1, cp2, end, t);
    }
    
    if (points.length === 1) {
      // äºŒæ¬¡è´å¡å°”
      return this.quadraticBezier3D(start, points[0], end, t);
    }
    
    if (points.length >= 2) {
      // ä¸‰æ¬¡è´å¡å°”
      return this.cubicBezier3D(start, points[0], points[1], end, t);
    }
    
    return this.evaluateLinearPath(start, end, t);
  }

  /**
   * äºŒæ¬¡è´å¡å°”æ›²çº¿
   */
  private quadraticBezier3D(p0: Vector3, p1: Vector3, p2: Vector3, t: number): Vector3 {
    const u = 1 - t;
    return new Vector3(
      u * u * p0.x + 2 * u * t * p1.x + t * t * p2.x,
      u * u * p0.y + 2 * u * t * p1.y + t * t * p2.y,
      u * u * p0.z + 2 * u * t * p1.z + t * t * p2.z
    );
  }

  /**
   * ä¸‰æ¬¡è´å¡å°”æ›²çº¿
   */
  private cubicBezier3D(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, t: number): Vector3 {
    const u = 1 - t;
    const u2 = u * u;
    const u3 = u2 * u;
    const t2 = t * t;
    const t3 = t2 * t;
    
    return new Vector3(
      u3 * p0.x + 3 * u2 * t * p1.x + 3 * u * t2 * p2.x + t3 * p3.x,
      u3 * p0.y + 3 * u2 * t * p1.y + 3 * u * t2 * p2.y + t3 * p3.y,
      u3 * p0.z + 3 * u2 * t * p1.z + 3 * u * t2 * p2.z + t3 * p3.z
    );
  }

  /**
   * èºæ—‹è·¯å¾„
   */
  private evaluateSpiralPath(path: Path3D, start: Vector3, end: Vector3, t: number): Vector3 {
    const radius = path.spiralRadius || 5;
    const freq = path.spiralFrequency || 3;
    
    // åŸºç¡€çº¿æ€§æ’å€¼
    const baseX = start.x + (end.x - start.x) * t;
    const baseY = start.y + (end.y - start.y) * t;
    const baseZ = start.z + (end.z - start.z) * t;
    
    // æ·»åŠ èºæ—‹åç§»
    const angle = t * freq * Math.PI * 2;
    const spiralRadius = radius * (1 - t * 0.5); // åŠå¾„æ¸å°
    
    return new Vector3(
      baseX + Math.cos(angle) * spiralRadius,
      baseY,
      baseZ + Math.sin(angle) * spiralRadius
    );
  }

  /**
   * èºæ—‹çº¿è·¯å¾„ (DNAåŒèºæ—‹)
   */
  private evaluateHelixPath(path: Path3D, start: Vector3, end: Vector3, t: number): Vector3 {
    const radius = path.spiralRadius || 3;
    const freq = path.spiralFrequency || 4;
    
    const baseX = start.x + (end.x - start.x) * t;
    const baseY = start.y + (end.y - start.y) * t;
    const baseZ = start.z + (end.z - start.z) * t;
    
    const angle = t * freq * Math.PI * 2;
    
    return new Vector3(
      baseX + Math.cos(angle) * radius,
      baseY,
      baseZ + Math.sin(angle) * radius
    );
  }

  /**
   * å¼§å½¢è·¯å¾„
   */
  private evaluateArcPath(start: Vector3, end: Vector3, t: number): Vector3 {
    const baseX = start.x + (end.x - start.x) * t;
    const baseY = start.y + (end.y - start.y) * t;
    const baseZ = start.z + (end.z - start.z) * t;
    
    // æ·»åŠ æŠ›ç‰©çº¿å¼§åº¦
    const arcHeight = 30;
    const arc = Math.sin(t * Math.PI) * arcHeight;
    
    return new Vector3(baseX, baseY + arc, baseZ);
  }

  /**
   * å‘å°„å°¾ç„°ç²’å­
   */
  private emitTrailParticles(carrier: CarrierInstance, deltaTime: number): void {
    const trail = carrier.config.trail!;
    const state = carrier.state;
    
    // è®¡ç®—æœ¬å¸§åº”è¯¥å‘å°„çš„ç²’å­æ•°
    const emitCount = Math.floor(trail.emissionRate * deltaTime);
    
    // é™åˆ¶æœ€å¤§å°¾ç„°ç²’å­æ•°
    const currentCount = carrier.trailParticles.filter(p => !p.isDead).length;
    if (currentCount >= this.maxTrailParticles) return;
    
    for (let i = 0; i < emitCount; i++) {
      // è®¡ç®—ç²’å­åˆå§‹ä½ç½® (åœ¨è¿è½½ä½“åæ–¹)
      const offsetX = (Math.random() - 0.5) * 0.5;
      const offsetY = (Math.random() - 0.5) * 0.5;
      const offsetZ = (Math.random() - 0.5) * 0.5;
      
      // é€Ÿåº¦æ–¹å‘ä¸è¿è½½ä½“ç›¸åï¼Œå¸¦ä¸€äº›éšæœºæ‰©æ•£
      const speedScale = 0.3; // å°¾ç„°é€Ÿåº¦æ¯”è¿è½½ä½“æ…¢
      const spread = 5;
      
      const particle: TrailParticle = {
        position: new Vector3(
          state.position.x + offsetX,
          state.position.y + offsetY,
          state.position.z + offsetZ
        ),
        velocity: new Vector3(
          -state.velocity.x * speedScale + (Math.random() - 0.5) * spread,
          -state.velocity.y * speedScale - Math.random() * 10, // å‘ä¸‹é£˜
          -state.velocity.z * speedScale + (Math.random() - 0.5) * spread
        ),
        age: 0,
        lifeTime: trail.lifeTime * (0.8 + Math.random() * 0.4),
        hue: 40 + Math.random() * 20, // é‡‘é»„è‰²
        saturation: 1,
        lightness: 0.6 + Math.random() * 0.2,
        alpha: 1,
        size: trail.size * (0.5 + Math.random()),
        isDead: false
      };
      
      carrier.trailParticles.push(particle);
    }
  }

  /**
   * æ›´æ–°å°¾ç„°ç²’å­
   */
  private updateTrailParticles(carrier: CarrierInstance, deltaTime: number): void {
    const gravity = -30;
    const drag = 0.98;
    
    for (const particle of carrier.trailParticles) {
      if (particle.isDead) continue;
      
      // æ›´æ–°å¹´é¾„
      particle.age += deltaTime;
      
      // åº”ç”¨ç‰©ç†
      particle.velocity.y += gravity * deltaTime;
      particle.velocity.x *= drag;
      particle.velocity.y *= drag;
      particle.velocity.z *= drag;
      
      particle.position.x += particle.velocity.x * deltaTime;
      particle.position.y += particle.velocity.y * deltaTime;
      particle.position.z += particle.velocity.z * deltaTime;
      
      // æ›´æ–°é€æ˜åº¦å’Œé¢œè‰²
      const lifeProgress = particle.age / particle.lifeTime;
      particle.alpha = Math.max(0, 1 - lifeProgress);
      particle.lightness = 0.6 - lifeProgress * 0.4;
      
      // æ£€æŸ¥æ­»äº¡
      if (particle.age > particle.lifeTime || particle.alpha <= 0) {
        particle.isDead = true;
      }
    }
    
    // æ¸…ç†æ­»äº¡ç²’å­ (æ¯ç§’æ¸…ç†ä¸€æ¬¡ä»¥å‡å°‘GCå‹åŠ›)
    if (Math.random() < deltaTime) {
      carrier.trailParticles = carrier.trailParticles.filter(p => !p.isDead);
    }
  }

  /**
   * è·å–è¿è½½å™¨çŠ¶æ€
   */
  getCarrier(id: string): CarrierInstance | undefined {
    return this.carriers.get(id);
  }

  /**
   * è·å–æ‰€æœ‰æ´»è·ƒè¿è½½å™¨
   */
  getActiveCarriers(): CarrierInstance[] {
    return Array.from(this.carriers.values()).filter(c => c.state.active);
  }

  /**
   * è·å–æ‰€æœ‰å°¾ç„°ç²’å­ (ç”¨äºæ¸²æŸ“)
   */
  getAllTrailParticles(): TrailParticle[] {
    const allParticles: TrailParticle[] = [];
    for (const carrier of this.carriers.values()) {
      if (carrier.state.active) {
        allParticles.push(...carrier.trailParticles.filter(p => !p.isDead));
      }
    }
    return allParticles;
  }

  /**
   * ç§»é™¤è¿è½½å™¨
   */
  removeCarrier(id: string): void {
    this.carriers.delete(id);
  }

  /**
   * æ¸…ç†å·²å®Œæˆçš„è¿è½½å™¨
   */
  cleanupArrived(): void {
    for (const [id, carrier] of this.carriers.entries()) {
      if (carrier.state.arrived) {
        // æ£€æŸ¥å°¾ç„°ç²’å­æ˜¯å¦éƒ½æ¶ˆå¤±äº†
        const activeTrail = carrier.trailParticles.filter(p => !p.isDead).length;
        if (activeTrail === 0) {
          this.carriers.delete(id);
        }
      }
    }
  }

  /**
   * é‡ç½®ç³»ç»Ÿ
   */
  reset(): void {
    this.carriers.clear();
    this.nextCarrierId = 0;
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): { carriers: number; trailParticles: number } {
    let trailParticles = 0;
    for (const carrier of this.carriers.values()) {
      trailParticles += carrier.trailParticles.filter(p => !p.isDead).length;
    }
    return {
      carriers: this.carriers.size,
      trailParticles
    };
  }
}

// å¯¼å‡ºå…¨å±€å®ä¾‹
export const globalCarrierSystem = new CarrierSystem();

// END OF FILE: src/core/stream/CarrierSystem.ts


// =============================================================================
// FILE: src\core\stream\Director.ts
// =============================================================================

/**
 * Director.ts - çƒŸèŠ±æ€»å¯¼æ¼”
 * 
 * æ ¸å¿ƒèŒè´£ï¼š
 * 1. ç®¡ç†æ‰€æœ‰çƒŸèŠ±å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸ
 * 2. ç»´æŠ¤å…¨å±€æ—¶é’Ÿ
 * 3. å°† FireworkManifest (JSONé…ç½®) è½¬æ¢ä¸ºè¿è¡Œæ—¶å®ä¾‹
 * 4. åè°ƒå„å­ç³»ç»Ÿ (Carrier, ParticleStream, Morphing)
 * 
 * è¿™æ˜¯"ä¸€åˆ‡çš†æµ"æ¶æ„çš„æ€»è°ƒåº¦ä¸­å¿ƒ
 */

import { Vector3 } from '../Vector3';
import { 
  FireworkManifest, 
  FireworkInstance, 
  PayloadStage,
  CarrierConfig,
  TopologyConfig,
  DynamicsConfig,
  RenderingConfig,
  PRESET_CURVES,
  PRESET_GRADIENTS,
  PRESET_FORCE_FIELDS
} from './types';
import { CarrierSystem, CarrierInstance, TrailParticle } from './CarrierSystem';
import { ParticleStream, StreamParticle, StreamState } from './ParticleStream';
import { Shape3DType } from '../shapes/Shape3DFactory';

/**
 * çƒŸèŠ±è¿è¡Œæ—¶å®ä¾‹ (æ‰©å±•)
 */
interface RuntimeFirework {
  /** å®ä¾‹ID */
  id: string;
  /** é…ç½®æ¸…å• */
  manifest: FireworkManifest;
  /** å‘å°„ä½ç½® */
  launchPosition: Vector3;
  /** ç›®æ ‡ä½ç½® */
  targetPosition: Vector3;
  /** è¿è½½å™¨ID */
  carrierId: string | null;
  /** ç²’å­æµ */
  particleStream: ParticleStream | null;
  /** å½“å‰é˜¶æ®µç´¢å¼• */
  currentStageIndex: number;
  /** å½“å‰é˜¶æ®µå¼€å§‹æ—¶é—´ */
  stageStartTime: number;
  /** æ€»è¿è¡Œæ—¶é—´ */
  elapsed: number;
  /** çŠ¶æ€ */
  state: 'carrier' | 'payload' | 'extinct';
  /** è‰²ç›¸è¦†ç›– */
  hueOverride: number;
}

/**
 * å¯¼æ¼”é…ç½®
 */
export interface DirectorConfig {
  /** æœ€å¤§åŒæ—¶æ´»è·ƒçƒŸèŠ±æ•° */
  maxActiveFireworks: number;
  /** æ¯ä¸ªçƒŸèŠ±çš„æœ€å¤§ç²’å­æ•° */
  maxParticlesPerFirework: number;
  /** æ˜¯å¦å¯ç”¨è°ƒè¯•æ—¥å¿— */
  debug: boolean;
}

const DEFAULT_DIRECTOR_CONFIG: DirectorConfig = {
  maxActiveFireworks: 50,
  maxParticlesPerFirework: 5000,
  debug: false
};

/**
 * çƒŸèŠ±æ€»å¯¼æ¼”
 */
export class Director {
  private config: DirectorConfig;
  private carrierSystem: CarrierSystem;
  private fireworks: Map<string, RuntimeFirework> = new Map();
  private manifests: Map<string, FireworkManifest> = new Map();
  
  private globalTime: number = 0;
  private isPaused: boolean = false;
  private timeScale: number = 1;
  private nextFireworkId: number = 0;

  // ç»Ÿè®¡
  private stats = {
    totalLaunched: 0,
    totalExtinct: 0,
    peakParticles: 0
  };

  constructor(config: Partial<DirectorConfig> = {}) {
    this.config = { ...DEFAULT_DIRECTOR_CONFIG, ...config };
    this.carrierSystem = new CarrierSystem();
    
    // æ³¨å†Œå†…ç½®é¢„è®¾
    this.registerBuiltinManifests();
  }

  /**
   * æ³¨å†Œå†…ç½®çƒŸèŠ±æ¸…å•
   */
  private registerBuiltinManifests(): void {
    // å‡¤å‡°æ¶…æ§ƒ
    this.registerManifest(this.createPhoenixRebirthManifest());
    
    // ç®€å•çƒå½¢çˆ†ç‚¸
    this.registerManifest(this.createSimpleSphereManifest());
    
    // å¿ƒå½¢å˜æ¢
    this.registerManifest(this.createHeartMorphManifest());
    
    // é“¶æ²³èºæ—‹
    this.registerManifest(this.createGalaxyManifest());
  }

  /**
   * åˆ›å»º"å‡¤å‡°æ¶…æ§ƒ"æ¸…å•
   */
  private createPhoenixRebirthManifest(): FireworkManifest {
    return {
      id: 'phoenix_rebirth',
      name: 'å‡¤å‡°æ¶…æ§ƒ',
      description: 'å…ˆç‚¸æˆç«çƒï¼Œå†å˜å½¢ä¸ºå‡¤å‡°ï¼Œæœ€ååŒ–ä½œç°çƒ¬',
      tags: ['ç»å…¸', 'å˜å½¢', 'é«˜çº§'],
      duration: 8,
      
      carrier: {
        type: 'comet',
        path: {
          type: 'spiral',
          points: [],
          speedCurve: PRESET_CURVES.EASE_OUT,
          spiralRadius: 5,
          spiralFrequency: 2
        },
        duration: 2,
        trail: {
          emissionRate: 100,
          lifeTime: 0.5,
          colorGradient: PRESET_GRADIENTS.GOLD,
          texture: 'spark',
          size: 0.3
        }
      },
      
      payload: {
        stages: [
          // é˜¶æ®µ A: ç«çƒçˆ†å‘ (0s - 1s)
          {
            id: 'fireball',
            name: 'ç«çƒçˆ†å‘',
            timeOffset: 0,
            duration: 1,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.SPHERE,
              resolution: 3000,
              scale: 50
            },
            dynamics: {
              transitionMode: 'explode',
              initialVelocity: {
                mode: 'radial',
                speed: [80, 120]
              },
              forceFields: [
                { ...PRESET_FORCE_FIELDS.HEAVY_DRAG },
                { ...PRESET_FORCE_FIELDS.LIGHT_GRAVITY }
              ],
              velocityProfile: PRESET_CURVES.EASE_OUT
            },
            rendering: {
              colorMap: PRESET_GRADIENTS.FIRE,
              sizeCurve: PRESET_CURVES.EASE_OUT,
              baseSize: 1.5,
              blending: 'additive',
              useBlackbodyRadiation: true,
              initialTemperature: 7000,
              coolingRate: 500,
              glowIntensity: 2
            }
          },
          
          // é˜¶æ®µ B: å‡¤å‡°èšå½¢ (1s - 3s)
          {
            id: 'phoenix_form',
            name: 'å‡¤å‡°èšå½¢',
            timeOffset: 1,
            duration: 2,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.PHOENIX,
              resolution: 3000,
              scale: 40,
              rotation: new Vector3(0, 0, 0)
            },
            dynamics: {
              transitionMode: 'morph',
              initialVelocity: {
                mode: 'target_seeking',
                speed: 30
              },
              forceFields: [
                { ...PRESET_FORCE_FIELDS.AIR_DRAG }
              ],
              velocityProfile: PRESET_CURVES.EASE_IN_OUT,
              morphAttractionStrength: 80,
              morphDamping: 0.92
            },
            rendering: {
              colorMap: PRESET_GRADIENTS.PHOENIX,
              sizeCurve: PRESET_CURVES.LINEAR,
              baseSize: 1.2,
              blending: 'additive',
              glowIntensity: 1.5
            },
            reuseParticles: true
          },
          
          // é˜¶æ®µ C: å‡¤å‡°å±•ç¿… (3s - 5s)
          {
            id: 'phoenix_wings',
            name: 'å‡¤å‡°å±•ç¿…',
            timeOffset: 3,
            duration: 2,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.PHOENIX,
              resolution: 3000,
              scale: 45
            },
            dynamics: {
              transitionMode: 'maintain',
              initialVelocity: {
                mode: 'target_seeking',
                speed: 5
              },
              forceFields: [
                { type: 'turbulence', strength: 3, noiseFrequency: 0.3, noiseAmplitude: 1 }
              ],
              velocityProfile: PRESET_CURVES.LINEAR
            },
            rendering: {
              colorMap: PRESET_GRADIENTS.PHOENIX,
              sizeCurve: PRESET_CURVES.LINEAR,
              baseSize: 1.3,
              blending: 'additive',
              glowIntensity: 1.8
            },
            reuseParticles: true,
            shaderAnimation: {
              vertexModifier: 'wing_flap',
              parameters: { frequency: 2, amplitude: 5 }
            }
          },
          
          // é˜¶æ®µ D: ç°çƒ¬é£˜è½ (5s - 8s)
          {
            id: 'ashes',
            name: 'ç°çƒ¬é£˜è½',
            timeOffset: 5,
            duration: 3,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.CHAOS_SCATTER,
              resolution: 3000,
              scale: 80
            },
            dynamics: {
              transitionMode: 'scatter',
              initialVelocity: {
                mode: 'random',
                speed: [5, 15]
              },
              forceFields: [
                { ...PRESET_FORCE_FIELDS.EARTH_GRAVITY },
                { type: 'wind', strength: 5, direction: new Vector3(1, -0.3, 0.5) },
                { type: 'turbulence', strength: 8, noiseFrequency: 0.5, noiseAmplitude: 3 }
              ],
              velocityProfile: PRESET_CURVES.LINEAR
            },
            rendering: {
              colorMap: {
                stops: [
                  { position: 0, hue: 30, saturation: 0.8, lightness: 0.5 },
                  { position: 0.5, hue: 20, saturation: 0.5, lightness: 0.3 },
                  { position: 1, hue: 0, saturation: 0.2, lightness: 0.15, alpha: 0 }
                ]
              },
              sizeCurve: PRESET_CURVES.EASE_OUT,
              baseSize: 0.8,
              blending: 'normal',
              useBlackbodyRadiation: true,
              initialTemperature: 2500,
              coolingRate: 300
            },
            reuseParticles: true
          }
        ]
      }
    };
  }

  /**
   * åˆ›å»ºç®€å•çƒå½¢çˆ†ç‚¸æ¸…å•
   */
  private createSimpleSphereManifest(): FireworkManifest {
    return {
      id: 'simple_sphere',
      name: 'ç»å…¸çƒå½¢',
      description: 'ç»å…¸çš„çƒå½¢çƒŸèŠ±çˆ†ç‚¸',
      tags: ['ç»å…¸', 'åŸºç¡€'],
      duration: 4,
      
      carrier: {
        type: 'projectile',
        path: {
          type: 'linear',
          points: [],
          speedCurve: PRESET_CURVES.EASE_OUT
        },
        duration: 1.5,
        trail: {
          emissionRate: 60,
          lifeTime: 0.4,
          colorGradient: PRESET_GRADIENTS.GOLD,
          texture: 'spark',
          size: 0.2
        }
      },
      
      payload: {
        stages: [
          {
            id: 'explosion',
            name: 'çƒå½¢çˆ†ç‚¸',
            timeOffset: 0,
            duration: 3,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.SPHERE,
              resolution: 2000,
              scale: 40
            },
            dynamics: {
              transitionMode: 'explode',
              initialVelocity: {
                mode: 'radial',
                speed: [60, 100]
              },
              forceFields: [
                { ...PRESET_FORCE_FIELDS.LIGHT_GRAVITY },
                { ...PRESET_FORCE_FIELDS.AIR_DRAG }
              ],
              velocityProfile: PRESET_CURVES.EASE_OUT
            },
            rendering: {
              colorMap: PRESET_GRADIENTS.RAINBOW,
              sizeCurve: PRESET_CURVES.EASE_OUT,
              baseSize: 1,
              blending: 'additive',
              glowIntensity: 1.5
            }
          }
        ]
      }
    };
  }

  /**
   * åˆ›å»ºå¿ƒå½¢å˜æ¢æ¸…å•
   */
  private createHeartMorphManifest(): FireworkManifest {
    return {
      id: 'heart_morph',
      name: 'å¿ƒå¿ƒç›¸å°',
      description: 'ä»çˆ†ç‚¸å˜å½¢ä¸ºå¿ƒå½¢',
      tags: ['æµªæ¼«', 'å˜å½¢'],
      duration: 6,
      
      carrier: {
        type: 'projectile',
        path: {
          type: 'arc',
          points: [],
          speedCurve: PRESET_CURVES.EASE_OUT
        },
        duration: 1.5,
        trail: {
          emissionRate: 80,
          lifeTime: 0.5,
          colorGradient: {
            stops: [
              { position: 0, hue: 350, saturation: 1, lightness: 0.7 },
              { position: 1, hue: 340, saturation: 0.8, lightness: 0.4 }
            ]
          },
          texture: 'spark',
          size: 0.25
        }
      },
      
      payload: {
        stages: [
          {
            id: 'burst',
            name: 'åˆå§‹çˆ†å‘',
            timeOffset: 0,
            duration: 1.5,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.EXPLOSION_BURST,
              resolution: 2500,
              scale: 35
            },
            dynamics: {
              transitionMode: 'explode',
              initialVelocity: { mode: 'radial', speed: [50, 80] },
              forceFields: [{ ...PRESET_FORCE_FIELDS.HEAVY_DRAG }],
              velocityProfile: PRESET_CURVES.EASE_OUT
            },
            rendering: {
              colorMap: {
                stops: [
                  { position: 0, hue: 350, saturation: 1, lightness: 0.8 },
                  { position: 1, hue: 340, saturation: 1, lightness: 0.5 }
                ]
              },
              sizeCurve: PRESET_CURVES.LINEAR,
              baseSize: 1.2,
              blending: 'additive',
              glowIntensity: 2
            }
          },
          {
            id: 'heart',
            name: 'å¿ƒå½¢èšåˆ',
            timeOffset: 1.5,
            duration: 3,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.HEART_3D,
              resolution: 2500,
              scale: 30
            },
            dynamics: {
              transitionMode: 'morph',
              initialVelocity: { mode: 'target_seeking', speed: 20 },
              forceFields: [{ ...PRESET_FORCE_FIELDS.AIR_DRAG }],
              velocityProfile: PRESET_CURVES.EASE_IN_OUT,
              morphAttractionStrength: 60,
              morphDamping: 0.9
            },
            rendering: {
              colorMap: {
                stops: [
                  { position: 0, hue: 355, saturation: 1, lightness: 0.6 },
                  { position: 0.5, hue: 350, saturation: 1, lightness: 0.5 },
                  { position: 1, hue: 345, saturation: 0.9, lightness: 0.45 }
                ]
              },
              sizeCurve: PRESET_CURVES.LINEAR,
              baseSize: 1,
              blending: 'additive',
              glowIntensity: 1.5
            },
            reuseParticles: true
          }
        ]
      }
    };
  }

  /**
   * åˆ›å»ºé“¶æ²³æ¸…å•
   */
  private createGalaxyManifest(): FireworkManifest {
    return {
      id: 'galaxy_spiral',
      name: 'é“¶æ²³è¯ç”Ÿ',
      description: 'å£®è§‚çš„é“¶æ²³èºæ—‹æ•ˆæœ',
      tags: ['å®å¤§', 'å®‡å®™'],
      duration: 7,
      
      carrier: {
        type: 'invisible',
        path: { type: 'linear', points: [], speedCurve: PRESET_CURVES.LINEAR },
        duration: 0.5
      },
      
      payload: {
        stages: [
          {
            id: 'galaxy',
            name: 'é“¶æ²³ç»½æ”¾',
            timeOffset: 0,
            duration: 6,
            topology: {
              type: 'mathematical_shape',
              source: Shape3DType.GALAXY_SPIRAL,
              resolution: 4000,
              scale: 60
            },
            dynamics: {
              transitionMode: 'accumulate',
              initialVelocity: { mode: 'random', speed: [10, 30] },
              forceFields: [
                { type: 'vortex', strength: 20, center: new Vector3(0, 0, 0), radius: 100 },
                { ...PRESET_FORCE_FIELDS.AIR_DRAG },
                { type: 'turbulence', strength: 5, noiseFrequency: 0.2, noiseAmplitude: 2 }
              ],
              velocityProfile: PRESET_CURVES.EASE_IN_OUT
            },
            rendering: {
              colorMap: {
                stops: [
                  { position: 0, hue: 200, saturation: 0.8, lightness: 0.9 },
                  { position: 0.3, hue: 220, saturation: 0.9, lightness: 0.7 },
                  { position: 0.6, hue: 280, saturation: 1, lightness: 0.6 },
                  { position: 1, hue: 320, saturation: 0.8, lightness: 0.5 }
                ]
              },
              sizeCurve: PRESET_CURVES.LINEAR,
              baseSize: 0.8,
              blending: 'additive',
              glowIntensity: 2
            }
          }
        ]
      }
    };
  }

  /**
   * æ³¨å†ŒçƒŸèŠ±æ¸…å•
   */
  registerManifest(manifest: FireworkManifest): void {
    this.manifests.set(manifest.id, manifest);
    if (this.config.debug) {
      console.log(`[Director] Registered manifest: ${manifest.name} (${manifest.id})`);
    }
  }

  /**
   * è·å–æ¸…å•
   */
  getManifest(id: string): FireworkManifest | undefined {
    return this.manifests.get(id);
  }

  /**
   * è·å–æ‰€æœ‰æ¸…å•
   */
  getAllManifests(): FireworkManifest[] {
    return Array.from(this.manifests.values());
  }

  /**
   * å‘å°„çƒŸèŠ±
   */
  launch(
    manifestId: string,
    launchPosition: Vector3,
    targetPosition: Vector3,
    hueOverride?: number
  ): string | null {
    const manifest = this.manifests.get(manifestId);
    if (!manifest) {
      console.error(`[Director] Manifest not found: ${manifestId}`);
      return null;
    }

    // æ£€æŸ¥æ´»è·ƒçƒŸèŠ±æ•°é™åˆ¶
    if (this.fireworks.size >= this.config.maxActiveFireworks) {
      console.warn('[Director] Max active fireworks reached');
      return null;
    }

    const id = `fw_${this.nextFireworkId++}`;
    
    const firework: RuntimeFirework = {
      id,
      manifest,
      launchPosition: new Vector3(launchPosition.x, launchPosition.y, launchPosition.z),
      targetPosition: new Vector3(targetPosition.x, targetPosition.y, targetPosition.z),
      carrierId: null,
      particleStream: null,
      currentStageIndex: -1,
      stageStartTime: 0,
      elapsed: 0,
      state: 'carrier',
      hueOverride: hueOverride ?? Math.random() * 360
    };

    // åˆ›å»ºè¿è½½å™¨
    if (manifest.carrier.type !== 'invisible') {
      firework.carrierId = this.carrierSystem.createCarrier(
        manifest.carrier,
        launchPosition,
        targetPosition,
        () => this.onCarrierArrive(id)
      );
    } else {
      // éšå½¢è¿è½½å™¨ç›´æ¥è§¦å‘è½½è·
      setTimeout(() => {
        this.onCarrierArrive(id);
      }, manifest.carrier.duration * 1000);
    }

    this.fireworks.set(id, firework);
    this.stats.totalLaunched++;

    if (this.config.debug) {
      console.log(`[Director] Launched ${manifest.name} at (${targetPosition.x.toFixed(1)}, ${targetPosition.y.toFixed(1)}, ${targetPosition.z.toFixed(1)})`);
    }

    return id;
  }

  /**
   * è¿è½½å™¨åˆ°è¾¾å›è°ƒ
   */
  private onCarrierArrive(fireworkId: string): void {
    const firework = this.fireworks.get(fireworkId);
    if (!firework) return;

    if (this.config.debug) {
      console.log(`[Director] Carrier arrived for ${firework.manifest.name}`);
    }

    // åˆ‡æ¢åˆ°è½½è·é˜¶æ®µ
    firework.state = 'payload';
    
    // åˆ›å»ºç²’å­æµ
    firework.particleStream = new ParticleStream({
      maxParticles: this.config.maxParticlesPerFirework,
      baseLifeTime: firework.manifest.duration
    });
    firework.particleStream.setSpawnCenter(firework.targetPosition);

    // å¼€å§‹ç¬¬ä¸€ä¸ªé˜¶æ®µ
    this.startStage(firework, 0);
  }

  /**
   * å¼€å§‹æŒ‡å®šé˜¶æ®µ
   */
  private startStage(firework: RuntimeFirework, stageIndex: number): void {
    const stages = firework.manifest.payload.stages;
    if (stageIndex >= stages.length) {
      // æ‰€æœ‰é˜¶æ®µå®Œæˆï¼Œå¼€å§‹æ¶ˆäº¡
      this.startExtinction(firework);
      return;
    }

    const stage = stages[stageIndex];
    const stream = firework.particleStream!;

    firework.currentStageIndex = stageIndex;
    firework.stageStartTime = this.globalTime;

    if (this.config.debug) {
      console.log(`[Director] Starting stage ${stageIndex}: ${stage.name || stage.id}`);
    }

    // æ ¹æ®è¿‡æ¸¡æ¨¡å¼æ‰§è¡Œ
    switch (stage.dynamics.transitionMode) {
      case 'explode':
      case 'accumulate':
      case 'scatter':
        // ç”Ÿæˆæ–°ç²’å­
        stream.spawn(
          stage.topology.resolution,
          stage.topology,
          stage.dynamics,
          stage.rendering
        );
        break;
      
      case 'morph':
        // å˜å½¢åˆ°æ–°å½¢çŠ¶
        if (stream.getParticleCount() > 0) {
          stream.startMorph(stage.topology, {
            duration: Math.min(stage.duration, 2),
            attractionStrength: stage.dynamics.morphAttractionStrength || 50,
            damping: stage.dynamics.morphDamping || 0.9
          });
        } else {
          // å¦‚æœæ²¡æœ‰ç²’å­ï¼Œå…ˆç”Ÿæˆå†å˜å½¢
          stream.spawn(
            stage.topology.resolution,
            stage.topology,
            stage.dynamics,
            stage.rendering
          );
        }
        break;
      
      case 'maintain':
        // ç»´æŒå½“å‰çŠ¶æ€ï¼Œåªæ›´æ–°åŠ›åœº
        stream.getForceFieldSystem().setForceFields(stage.dynamics.forceFields);
        break;
    }
  }

  /**
   * å¼€å§‹æ¶ˆäº¡é˜¶æ®µ
   */
  private startExtinction(firework: RuntimeFirework): void {
    if (firework.particleStream) {
      firework.particleStream.startExtinction();
    }
    firework.state = 'extinct';
    
    if (this.config.debug) {
      console.log(`[Director] ${firework.manifest.name} entering extinction phase`);
    }
  }

  /**
   * æ›´æ–° (æ¯å¸§è°ƒç”¨)
   */
  update(deltaTime: number): void {
    if (this.isPaused) return;

    const scaledDelta = deltaTime * this.timeScale;
    this.globalTime += scaledDelta;

    // æ›´æ–°è¿è½½ç³»ç»Ÿ
    this.carrierSystem.update(scaledDelta);

    // æ›´æ–°æ¯ä¸ªçƒŸèŠ±
    for (const [id, firework] of this.fireworks.entries()) {
      firework.elapsed += scaledDelta;

      if (firework.state === 'payload' && firework.particleStream) {
        // æ›´æ–°ç²’å­æµ
        firework.particleStream.update(scaledDelta);

        // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢é˜¶æ®µ
        this.checkStageTransition(firework);

        // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ¶ˆäº¡
        if (firework.particleStream.getState() === StreamState.EXTINCT) {
          this.removeFirework(id);
        }
      }
    }

    // æ¸…ç†å·²å®Œæˆçš„è¿è½½å™¨
    this.carrierSystem.cleanupArrived();

    // æ›´æ–°ç»Ÿè®¡
    this.updateStats();
  }

  /**
   * æ£€æŸ¥é˜¶æ®µè¿‡æ¸¡
   */
  private checkStageTransition(firework: RuntimeFirework): void {
    const stages = firework.manifest.payload.stages;
    const currentIndex = firework.currentStageIndex;
    
    if (currentIndex < 0 || currentIndex >= stages.length - 1) return;

    const currentStage = stages[currentIndex];
    const nextStage = stages[currentIndex + 1];
    const stageElapsed = this.globalTime - firework.stageStartTime;

    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ä¸‹ä¸€é˜¶æ®µçš„è§¦å‘æ—¶é—´
    if (stageElapsed >= currentStage.duration) {
      // å¦‚æœä¸‹ä¸€é˜¶æ®µé‡ç”¨ç²’å­ï¼Œç›´æ¥å¼€å§‹å˜å½¢
      if (nextStage.reuseParticles) {
        this.startStage(firework, currentIndex + 1);
      } else {
        // å¦åˆ™å¼€å§‹æ¶ˆäº¡ï¼Œç„¶åå¼€å§‹æ–°é˜¶æ®µ
        this.startStage(firework, currentIndex + 1);
      }
    }
  }

  /**
   * ç§»é™¤çƒŸèŠ±
   */
  private removeFirework(id: string): void {
    const firework = this.fireworks.get(id);
    if (firework) {
      if (firework.carrierId) {
        this.carrierSystem.removeCarrier(firework.carrierId);
      }
      if (firework.particleStream) {
        firework.particleStream.destroy();
      }
      this.fireworks.delete(id);
      this.stats.totalExtinct++;

      if (this.config.debug) {
        console.log(`[Director] Removed firework ${id}`);
      }
    }
  }

  /**
   * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   */
  private updateStats(): void {
    let totalParticles = 0;
    for (const firework of this.fireworks.values()) {
      if (firework.particleStream) {
        totalParticles += firework.particleStream.getParticleCount();
      }
    }
    totalParticles += this.carrierSystem.getStats().trailParticles;
    
    if (totalParticles > this.stats.peakParticles) {
      this.stats.peakParticles = totalParticles;
    }
  }

  // ============================================================================
  // æ¸²æŸ“æ•°æ®è·å–æ¥å£
  // ============================================================================

  /**
   * è·å–æ‰€æœ‰ç²’å­æ•°æ® (ç”¨äºæ¸²æŸ“)
   */
  getAllParticles(): StreamParticle[] {
    const allParticles: StreamParticle[] = [];
    for (const firework of this.fireworks.values()) {
      if (firework.particleStream) {
        allParticles.push(...firework.particleStream.getParticleData());
      }
    }
    return allParticles;
  }

  /**
   * è·å–æ‰€æœ‰å°¾ç„°ç²’å­
   */
  getAllTrailParticles(): TrailParticle[] {
    return this.carrierSystem.getAllTrailParticles();
  }

  /**
   * è·å–æ‰€æœ‰è¿è½½å™¨
   */
  getAllCarriers(): CarrierInstance[] {
    return this.carrierSystem.getActiveCarriers();
  }

  // ============================================================================
  // æ§åˆ¶æ¥å£
  // ============================================================================

  /**
   * æš‚åœ
   */
  pause(): void {
    this.isPaused = true;
  }

  /**
   * æ¢å¤
   */
  resume(): void {
    this.isPaused = false;
  }

  /**
   * åˆ‡æ¢æš‚åœçŠ¶æ€
   */
  togglePause(): boolean {
    this.isPaused = !this.isPaused;
    return this.isPaused;
  }

  /**
   * è®¾ç½®æ—¶é—´ç¼©æ”¾
   */
  setTimeScale(scale: number): void {
    this.timeScale = Math.max(0.1, Math.min(5, scale));
  }

  /**
   * è·å–æ—¶é—´ç¼©æ”¾
   */
  getTimeScale(): number {
    return this.timeScale;
  }

  /**
   * è·å–å…¨å±€æ—¶é—´
   */
  getGlobalTime(): number {
    return this.globalTime;
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStats(): {
    activeFireworks: number;
    totalParticles: number;
    trailParticles: number;
    totalLaunched: number;
    totalExtinct: number;
    peakParticles: number;
  } {
    let totalParticles = 0;
    for (const firework of this.fireworks.values()) {
      if (firework.particleStream) {
        totalParticles += firework.particleStream.getParticleCount();
      }
    }
    const carrierStats = this.carrierSystem.getStats();

    return {
      activeFireworks: this.fireworks.size,
      totalParticles,
      trailParticles: carrierStats.trailParticles,
      ...this.stats
    };
  }

  /**
   * é‡ç½®ç³»ç»Ÿ
   */
  reset(): void {
    for (const firework of this.fireworks.values()) {
      if (firework.particleStream) {
        firework.particleStream.destroy();
      }
    }
    this.fireworks.clear();
    this.carrierSystem.reset();
    this.globalTime = 0;
    this.stats = {
      totalLaunched: 0,
      totalExtinct: 0,
      peakParticles: 0
    };
  }
}

// å¯¼å‡ºå…¨å±€å®ä¾‹
export const globalDirector = new Director({ debug: true });

// END OF FILE: src/core/stream/Director.ts


// =============================================================================
// FILE: src\core\stream\ForceFieldSystem.ts
// =============================================================================

/**
 * ForceFieldSystem.ts - åŠ›åœºç³»ç»Ÿ
 * 
 * è´Ÿè´£ç®¡ç†æ‰€æœ‰ä½œç”¨äºç²’å­çš„åŠ›:
 * - é‡åŠ› (Gravity)
 * - å¸å¼•åŠ›/æ–¥åŠ› (Attraction/Repulsion)
 * - ç©ºæ°”é˜»åŠ› (Drag)
 * - é£åŠ› (Wind)
 * - æŸæ—å™ªå£°åŠ›åœº (Noise)
 * - æ¶¡æ—‹åŠ› (Vortex)
 * - æ¹æµ (Turbulence)
 */

import { Vector3 } from '../Vector3';
import { ForceField, ForceFieldType, evaluateCurve, Curve } from './types';

/**
 * 3DæŸæ—å™ªå£°å®ç°
 * ç”¨äºç”Ÿæˆè‡ªç„¶çš„éšæœºåŠ›åœº
 */
class PerlinNoise3D {
  private permutation: number[] = [];
  private p: number[] = [];

  constructor(seed: number = 0) {
    // åˆå§‹åŒ–æ’åˆ—è¡¨
    this.permutation = [];
    for (let i = 0; i < 256; i++) {
      this.permutation[i] = i;
    }

    // ä½¿ç”¨ç§å­æ‰“ä¹±
    const random = this.seededRandom(seed);
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
    }

    // å¤åˆ¶æ’åˆ—è¡¨
    this.p = [...this.permutation, ...this.permutation];
  }

  private seededRandom(seed: number): () => number {
    return () => {
      seed = (seed * 1103515245 + 12345) & 0x7fffffff;
      return seed / 0x7fffffff;
    };
  }

  private fade(t: number): number {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  private lerp(a: number, b: number, t: number): number {
    return a + t * (b - a);
  }

  private grad(hash: number, x: number, y: number, z: number): number {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  noise(x: number, y: number, z: number): number {
    // æ‰¾åˆ°å•å…ƒæ ¼åæ ‡
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    // å•å…ƒæ ¼å†…ç›¸å¯¹ä½ç½®
    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    // è®¡ç®—æ¸å˜æ›²çº¿
    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    // å“ˆå¸Œåæ ‡
    const A = this.p[X] + Y;
    const AA = this.p[A] + Z;
    const AB = this.p[A + 1] + Z;
    const B = this.p[X + 1] + Y;
    const BA = this.p[B] + Z;
    const BB = this.p[B + 1] + Z;

    // æ··åˆç»“æœ
    return this.lerp(
      this.lerp(
        this.lerp(
          this.grad(this.p[AA], x, y, z),
          this.grad(this.p[BA], x - 1, y, z),
          u
        ),
        this.lerp(
          this.grad(this.p[AB], x, y - 1, z),
          this.grad(this.p[BB], x - 1, y - 1, z),
          u
        ),
        v
      ),
      this.lerp(
        this.lerp(
          this.grad(this.p[AA + 1], x, y, z - 1),
          this.grad(this.p[BA + 1], x - 1, y, z - 1),
          u
        ),
        this.lerp(
          this.grad(this.p[AB + 1], x, y - 1, z - 1),
          this.grad(this.p[BB + 1], x - 1, y - 1, z - 1),
          u
        ),
        v
      ),
      w
    );
  }

  /**
   * è·å–3Då™ªå£°å‘é‡
   * ä½¿ç”¨ä¸åŒåç§»é‡ç”Ÿæˆä¸‰ä¸ªå™ªå£°å€¼
   */
  noiseVector(x: number, y: number, z: number): Vector3 {
    return new Vector3(
      this.noise(x, y, z),
      this.noise(x + 100, y + 100, z + 100),
      this.noise(x + 200, y + 200, z + 200)
    );
  }
}

/**
 * åŠ›åœºç³»ç»Ÿ
 * ç»Ÿä¸€ç®¡ç†å’Œè®¡ç®—æ‰€æœ‰ä½œç”¨äºç²’å­çš„åŠ›
 */
export class ForceFieldSystem {
  private forceFields: ForceField[] = [];
  private globalTime: number = 0;
  private noise: PerlinNoise3D;

  constructor() {
    this.noise = new PerlinNoise3D(Date.now());
  }

  /**
   * æ·»åŠ åŠ›åœº
   */
  addForceField(field: ForceField): void {
    this.forceFields.push({ ...field, enabled: field.enabled ?? true });
  }

  /**
   * ç§»é™¤åŠ›åœº
   */
  removeForceField(index: number): void {
    this.forceFields.splice(index, 1);
  }

  /**
   * æ¸…é™¤æ‰€æœ‰åŠ›åœº
   */
  clearForces(): void {
    this.forceFields = [];
  }

  /**
   * è®¾ç½®åŠ›åœºåˆ—è¡¨
   */
  setForceFields(fields: ForceField[]): void {
    this.forceFields = fields.map(f => ({ ...f, enabled: f.enabled ?? true }));
  }

  /**
   * è·å–å½“å‰åŠ›åœºåˆ—è¡¨
   */
  getForceFields(): ForceField[] {
    return [...this.forceFields];
  }

  /**
   * æ›´æ–°å…¨å±€æ—¶é—´ (ç”¨äºæ—¶é—´ç›¸å…³çš„åŠ›åœº)
   */
  updateTime(deltaTime: number): void {
    this.globalTime += deltaTime;
  }

  /**
   * è®¡ç®—ä½œç”¨äºç²’å­çš„æ€»åŠ›
   * 
   * @param position ç²’å­ä½ç½®
   * @param velocity ç²’å­é€Ÿåº¦
   * @param mass ç²’å­è´¨é‡ (é»˜è®¤ 1)
   * @returns æ€»åŠ›å‘é‡
   */
  calculateTotalForce(position: Vector3, velocity: Vector3, mass: number = 1): Vector3 {
    const totalForce = new Vector3(0, 0, 0);

    for (const field of this.forceFields) {
      if (!field.enabled) continue;

      const force = this.calculateSingleForce(field, position, velocity, mass);
      totalForce.x += force.x;
      totalForce.y += force.y;
      totalForce.z += force.z;
    }

    return totalForce;
  }

  /**
   * è®¡ç®—å•ä¸ªåŠ›åœºçš„åŠ›
   */
  private calculateSingleForce(
    field: ForceField,
    position: Vector3,
    velocity: Vector3,
    mass: number
  ): Vector3 {
    switch (field.type) {
      case 'gravity':
        return this.calculateGravity(field, mass);
      
      case 'attraction':
        return this.calculateAttraction(field, position);
      
      case 'repulsion':
        return this.calculateRepulsion(field, position);
      
      case 'drag':
        return this.calculateDrag(field, velocity);
      
      case 'wind':
        return this.calculateWind(field);
      
      case 'noise':
        return this.calculateNoise(field, position);
      
      case 'vortex':
        return this.calculateVortex(field, position);
      
      case 'turbulence':
        return this.calculateTurbulence(field, position);
      
      default:
        return new Vector3(0, 0, 0);
    }
  }

  /**
   * é‡åŠ›: F = m * g * direction
   */
  private calculateGravity(field: ForceField, mass: number): Vector3 {
    const dir = field.direction || new Vector3(0, -1, 0);
    const strength = field.strength;
    
    return new Vector3(
      dir.x * strength * mass,
      dir.y * strength * mass,
      dir.z * strength * mass
    );
  }

  /**
   * å¸å¼•åŠ›: F = k / dÂ² * (center - position)
   */
  private calculateAttraction(field: ForceField, position: Vector3): Vector3 {
    const center = field.center || new Vector3(0, 0, 0);
    const dx = center.x - position.x;
    const dy = center.y - position.y;
    const dz = center.z - position.z;
    
    const distSq = dx * dx + dy * dy + dz * dz;
    const dist = Math.sqrt(distSq);
    
    // æ£€æŸ¥åŠå¾„é™åˆ¶
    if (field.radius && field.radius > 0 && dist > field.radius) {
      return new Vector3(0, 0, 0);
    }

    // é¿å…é™¤é›¶å’Œè¿‡å¤§çš„åŠ›
    const minDist = 1;
    const safeDist = Math.max(dist, minDist);
    const safeDistSq = safeDist * safeDist;

    // åº”ç”¨è¡°å‡æ›²çº¿
    let falloff = 1;
    if (field.falloff && field.radius && field.radius > 0) {
      const normalizedDist = dist / field.radius;
      falloff = 1 - evaluateCurve(field.falloff, normalizedDist);
    }

    const forceMagnitude = (field.strength * falloff) / safeDistSq;
    
    // å½’ä¸€åŒ–æ–¹å‘å¹¶åº”ç”¨åŠ›
    return new Vector3(
      (dx / safeDist) * forceMagnitude,
      (dy / safeDist) * forceMagnitude,
      (dz / safeDist) * forceMagnitude
    );
  }

  /**
   * æ–¥åŠ›: F = -k / dÂ² * (center - position)
   */
  private calculateRepulsion(field: ForceField, position: Vector3): Vector3 {
    const attraction = this.calculateAttraction(field, position);
    return new Vector3(-attraction.x, -attraction.y, -attraction.z);
  }

  /**
   * ç©ºæ°”é˜»åŠ›: F = -k * vÂ²
   * æ–¹å‘ä¸é€Ÿåº¦ç›¸å
   */
  private calculateDrag(field: ForceField, velocity: Vector3): Vector3 {
    const speed = Math.sqrt(
      velocity.x * velocity.x +
      velocity.y * velocity.y +
      velocity.z * velocity.z
    );

    if (speed === 0) {
      return new Vector3(0, 0, 0);
    }

    // é˜»åŠ›ä¸é€Ÿåº¦å¹³æ–¹æˆæ­£æ¯”
    const dragMagnitude = field.strength * speed * speed;

    // æ–¹å‘ä¸é€Ÿåº¦ç›¸å
    return new Vector3(
      -(velocity.x / speed) * dragMagnitude,
      -(velocity.y / speed) * dragMagnitude,
      -(velocity.z / speed) * dragMagnitude
    );
  }

  /**
   * é£åŠ›: F = strength * direction
   */
  private calculateWind(field: ForceField): Vector3 {
    const dir = field.direction || new Vector3(1, 0, 0);
    const strength = field.strength;

    // æ·»åŠ ä¸€äº›æ—¶é—´æ³¢åŠ¨ä½¿é£åŠ›æ›´è‡ªç„¶
    const timeVariation = 1 + 0.3 * Math.sin(this.globalTime * 2);

    return new Vector3(
      dir.x * strength * timeVariation,
      dir.y * strength * timeVariation,
      dir.z * strength * timeVariation
    );
  }

  /**
   * å™ªå£°åŠ›åœº: ä½¿ç”¨æŸæ—å™ªå£°ç”Ÿæˆéšæœºä½†å¹³æ»‘çš„åŠ›
   */
  private calculateNoise(field: ForceField, position: Vector3): Vector3 {
    const freq = field.noiseFrequency || 0.1;
    const amp = field.noiseAmplitude || 1;
    const strength = field.strength;

    // ä½¿ç”¨ä½ç½® + æ—¶é—´ç”Ÿæˆå™ªå£°
    const noiseVec = this.noise.noiseVector(
      position.x * freq + this.globalTime * 0.5,
      position.y * freq,
      position.z * freq
    );

    return new Vector3(
      noiseVec.x * strength * amp,
      noiseVec.y * strength * amp,
      noiseVec.z * strength * amp
    );
  }

  /**
   * æ¶¡æ—‹åŠ›: ç»•ä¸­å¿ƒè½´æ—‹è½¬çš„åŠ›
   */
  private calculateVortex(field: ForceField, position: Vector3): Vector3 {
    const center = field.center || new Vector3(0, 0, 0);
    
    // ç›¸å¯¹äºä¸­å¿ƒçš„ä½ç½® (XZ å¹³é¢)
    const rx = position.x - center.x;
    const rz = position.z - center.z;
    const r = Math.sqrt(rx * rx + rz * rz);

    if (r === 0) {
      return new Vector3(0, 0, 0);
    }

    // æ£€æŸ¥åŠå¾„é™åˆ¶
    if (field.radius && field.radius > 0 && r > field.radius) {
      return new Vector3(0, 0, 0);
    }

    // æ¶¡æ—‹åŠ›å‚ç›´äºåŠå¾„æ–¹å‘
    // åœ¨ XZ å¹³é¢ä¸Š: (rx, rz) çš„å‚ç›´æ–¹å‘æ˜¯ (-rz, rx)
    const tangentX = -rz / r;
    const tangentZ = rx / r;

    // åŠ›å¤§å°éšè·ç¦»è¡°å‡
    const falloff = field.radius && field.radius > 0 
      ? Math.max(0, 1 - r / field.radius)
      : 1 / (1 + r * 0.1);

    const forceMagnitude = field.strength * falloff;

    return new Vector3(
      tangentX * forceMagnitude,
      0,
      tangentZ * forceMagnitude
    );
  }

  /**
   * æ¹æµ: å¤šå±‚æ¬¡å™ªå£°çš„ç»„åˆ
   */
  private calculateTurbulence(field: ForceField, position: Vector3): Vector3 {
    const baseFreq = field.noiseFrequency || 0.1;
    const amp = field.noiseAmplitude || 1;
    const strength = field.strength;

    let totalForce = new Vector3(0, 0, 0);
    let amplitude = amp;
    let frequency = baseFreq;

    // 4 å±‚å™ªå£°å åŠ 
    for (let i = 0; i < 4; i++) {
      const noiseVec = this.noise.noiseVector(
        position.x * frequency + this.globalTime * 0.3,
        position.y * frequency + this.globalTime * 0.2,
        position.z * frequency + this.globalTime * 0.1
      );

      totalForce.x += noiseVec.x * amplitude;
      totalForce.y += noiseVec.y * amplitude;
      totalForce.z += noiseVec.z * amplitude;

      frequency *= 2;
      amplitude *= 0.5;
    }

    return new Vector3(
      totalForce.x * strength,
      totalForce.y * strength,
      totalForce.z * strength
    );
  }

  /**
   * è®¡ç®—åŠ é€Ÿåº¦ (F / m)
   */
  calculateAcceleration(position: Vector3, velocity: Vector3, mass: number = 1): Vector3 {
    const force = this.calculateTotalForce(position, velocity, mass);
    return new Vector3(
      force.x / mass,
      force.y / mass,
      force.z / mass
    );
  }

  /**
   * è·å–å…¨å±€æ—¶é—´
   */
  getTime(): number {
    return this.globalTime;
  }

  /**
   * é‡ç½®æ—¶é—´
   */
  resetTime(): void {
    this.globalTime = 0;
  }
}

// å¯¼å‡ºå…¨å±€å®ä¾‹
export const globalForceFieldSystem = new ForceFieldSystem();

// END OF FILE: src/core/stream/ForceFieldSystem.ts


// =============================================================================
// FILE: src\core\stream\index.ts
// =============================================================================

/**
 * Stream Architecture - Main Entry Point
 * 
 * "ä¸€åˆ‡çš†æµ" (Everything is a Stream) çƒŸèŠ±å¼•æ“
 * 
 * å¯¼å‡ºæ‰€æœ‰æ ¸å¿ƒæ¨¡å—ä¾›å¤–éƒ¨ä½¿ç”¨
 */

// ============================================================================
// ç±»å‹å®šä¹‰
// ============================================================================
export * from './types';

// ============================================================================
// æ ¸å¿ƒç³»ç»Ÿ
// ============================================================================
export { Director, globalDirector } from './Director';
export type { DirectorConfig } from './Director';

export { CarrierSystem, globalCarrierSystem } from './CarrierSystem';
export type { CarrierState, CarrierInstance, TrailParticle } from './CarrierSystem';

export { ParticleStream, StreamState } from './ParticleStream';
export type { StreamParticle, StreamConfig } from './ParticleStream';

export { ForceFieldSystem, globalForceFieldSystem } from './ForceFieldSystem';

export { MorphingEngine, globalMorphingEngine, DEFAULT_MORPH_CONFIG } from './MorphingEngine';
export type { MorphParticle, MorphConfig } from './MorphingEngine';

// ============================================================================
// æ¸²æŸ“å™¨
// ============================================================================
export { StreamRenderer } from './StreamRenderer';
export type { StreamRendererConfig } from './StreamRenderer';

// END OF FILE: src/core/stream/index.ts


// =============================================================================
// FILE: src\core\stream\MorphingEngine.ts
// =============================================================================

/**
 * MorphingEngine.ts - å½¢æ€å˜å½¢å¼•æ“
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * - ç²’å­åˆ°ç›®æ ‡ç‚¹çš„æœ€ä¼˜åŒ¹é… (åŸºäºæœ€å°æ€»è·ç¦»)
 * - å¹³æ»‘çš„å½¢æ€è¿‡æ¸¡åŠ¨ç”»
 * - GPUåŠ é€Ÿçš„é¡¶ç‚¹åŠ¨ç”»æ”¯æŒ
 * 
 * è¿™æ˜¯"å‡¤å‡°æ¶…æ§ƒ"æ•ˆæœçš„æ ¸å¿ƒ - ä»ç«çƒæµåŠ¨å˜å½¢ä¸ºå‡¤å‡°
 */

import { Vector3 } from '../Vector3';
import { Curve, evaluateCurve, PRESET_CURVES } from './types';

/**
 * ç²’å­çŠ¶æ€
 */
export interface MorphParticle {
  /** å½“å‰ä½ç½® */
  position: Vector3;
  /** å½“å‰é€Ÿåº¦ */
  velocity: Vector3;
  /** ç›®æ ‡ä½ç½® (æ¥è‡ªå½¢çŠ¶) */
  targetPosition: Vector3;
  /** åŸå§‹ä½ç½® (å˜å½¢å¼€å§‹æ—¶çš„ä½ç½®) */
  originPosition: Vector3;
  /** å˜å½¢è¿›åº¦ (0-1) */
  morphProgress: number;
  /** æ˜¯å¦æ­£åœ¨å˜å½¢ */
  isMorphing: boolean;
  /** ç²’å­å”¯ä¸€ID */
  id: number;
}

/**
 * å˜å½¢é…ç½®
 */
export interface MorphConfig {
  /** å˜å½¢æŒç»­æ—¶é—´ (ç§’) */
  duration: number;
  /** è¿‡æ¸¡æ›²çº¿ */
  easingCurve: Curve;
  /** å¸å¼•åŠ›å¼ºåº¦ */
  attractionStrength: number;
  /** é˜»å°¼ç³»æ•° */
  damping: number;
  /** å˜å½¢æ¨¡å¼ */
  mode: 'smooth' | 'snap' | 'physics';
  /** æœ€å¤§é€Ÿåº¦é™åˆ¶ */
  maxSpeed: number;
  /** åˆ°ä½é˜ˆå€¼ (è·ç¦»ç›®æ ‡å¤šè¿‘ç®—åˆ°ä½) */
  arrivalThreshold: number;
}

/**
 * é»˜è®¤å˜å½¢é…ç½®
 */
export const DEFAULT_MORPH_CONFIG: MorphConfig = {
  duration: 1.5,
  easingCurve: PRESET_CURVES.EASE_IN_OUT,
  attractionStrength: 50,
  damping: 0.95,
  mode: 'physics',
  maxSpeed: 200,
  arrivalThreshold: 0.5
};

/**
 * ç›®æ ‡ç‚¹åŒ¹é…ç»“æœ
 */
interface MatchingResult {
  /** ç²’å­ç´¢å¼•åˆ°ç›®æ ‡ç‚¹ç´¢å¼•çš„æ˜ å°„ */
  mapping: Map<number, number>;
  /** æ€»è·ç¦» */
  totalDistance: number;
}

/**
 * å½¢æ€å˜å½¢å¼•æ“
 */
export class MorphingEngine {
  private config: MorphConfig;
  private particles: MorphParticle[] = [];
  private targetPoints: Vector3[] = [];
  private morphStartTime: number = 0;
  private morphElapsed: number = 0;
  private isMorphingActive: boolean = false;

  constructor(config: Partial<MorphConfig> = {}) {
    this.config = { ...DEFAULT_MORPH_CONFIG, ...config };
  }

  /**
   * è®¾ç½®ç²’å­æ•°ç»„
   */
  setParticles(particles: MorphParticle[]): void {
    this.particles = particles;
  }

  /**
   * è·å–ç²’å­æ•°ç»„
   */
  getParticles(): MorphParticle[] {
    return this.particles;
  }

  /**
   * è®¾ç½®ç›®æ ‡å½¢çŠ¶ç‚¹
   */
  setTargetPoints(points: Vector3[]): void {
    this.targetPoints = points;
  }

  /**
   * å¼€å§‹å˜å½¢
   * å°†å½“å‰ç²’å­ä½ç½®ä½œä¸ºèµ·ç‚¹ï¼Œå˜å½¢åˆ°ç›®æ ‡å½¢çŠ¶
   * 
   * @param targetPoints ç›®æ ‡å½¢çŠ¶çš„ç‚¹é›†
   * @param config å¯é€‰çš„å˜å½¢é…ç½®è¦†ç›–
   */
  startMorph(targetPoints: Vector3[], config?: Partial<MorphConfig>): void {
    if (config) {
      this.config = { ...this.config, ...config };
    }

    this.targetPoints = targetPoints;
    this.morphStartTime = Date.now();
    this.morphElapsed = 0;
    this.isMorphingActive = true;

    // åŒ¹é…ç²’å­åˆ°ç›®æ ‡ç‚¹
    this.matchParticlesToTargets();

    // è®°å½•æ¯ä¸ªç²’å­çš„èµ·å§‹ä½ç½®
    for (const particle of this.particles) {
      particle.originPosition = new Vector3(
        particle.position.x,
        particle.position.y,
        particle.position.z
      );
      particle.morphProgress = 0;
      particle.isMorphing = true;
    }

    console.log(`[MorphingEngine] Started morph: ${this.particles.length} particles â†’ ${targetPoints.length} targets`);
  }

  /**
   * ç²’å­åˆ°ç›®æ ‡ç‚¹çš„æœ€ä¼˜åŒ¹é…
   * 
   * ç®—æ³•é€‰æ‹©:
   * - å¯¹äºå°è§„æ¨¡ (<100): ä½¿ç”¨è´ªå¿ƒç®—æ³•
   * - å¯¹äºå¤§è§„æ¨¡ (>100): ä½¿ç”¨ç©ºé—´åˆ†åŒº + å±€éƒ¨è´ªå¿ƒ
   * 
   * æ³¨: å®Œæ•´åŒˆç‰™åˆ©ç®—æ³• O(nÂ³) å¤ªæ…¢ï¼Œè¿™é‡Œä½¿ç”¨è¿‘ä¼¼ç®—æ³•
   */
  private matchParticlesToTargets(): void {
    const numParticles = this.particles.length;
    const numTargets = this.targetPoints.length;

    if (numParticles === 0 || numTargets === 0) return;

    // å¦‚æœç²’å­æ•°å’Œç›®æ ‡ç‚¹æ•°ç›¸åŒæˆ–æ¥è¿‘ï¼Œä½¿ç”¨æŒ‰è·ç¦»è´ªå¿ƒåŒ¹é…
    if (numParticles <= 500) {
      this.greedyMatch();
    } else {
      // å¯¹äºå¤§é‡ç²’å­ï¼Œä½¿ç”¨ç©ºé—´ç½‘æ ¼åŠ é€Ÿ
      this.spatialMatch();
    }
  }

  /**
   * è´ªå¿ƒåŒ¹é…ç®—æ³•
   * æ¯ä¸ªç²’å­é€‰æ‹©æœ€è¿‘çš„æœªè¢«å ç”¨çš„ç›®æ ‡ç‚¹
   */
  private greedyMatch(): void {
    const usedTargets = new Set<number>();
    const numParticles = this.particles.length;
    const numTargets = this.targetPoints.length;

    // è®¡ç®—æ‰€æœ‰ç²’å­-ç›®æ ‡è·ç¦»ï¼Œæ’åºåè´ªå¿ƒé€‰æ‹©
    const distanceList: Array<{ particleIdx: number; targetIdx: number; dist: number }> = [];

    for (let i = 0; i < numParticles; i++) {
      const p = this.particles[i].position;
      for (let j = 0; j < numTargets; j++) {
        const t = this.targetPoints[j];
        const dx = p.x - t.x;
        const dy = p.y - t.y;
        const dz = p.z - t.z;
        distanceList.push({
          particleIdx: i,
          targetIdx: j,
          dist: dx * dx + dy * dy + dz * dz
        });
      }
    }

    // æŒ‰è·ç¦»æ’åº
    distanceList.sort((a, b) => a.dist - b.dist);

    const assignedParticles = new Set<number>();

    // è´ªå¿ƒåˆ†é…
    for (const item of distanceList) {
      if (assignedParticles.has(item.particleIdx) || usedTargets.has(item.targetIdx)) {
        continue;
      }

      this.particles[item.particleIdx].targetPosition = new Vector3(
        this.targetPoints[item.targetIdx].x,
        this.targetPoints[item.targetIdx].y,
        this.targetPoints[item.targetIdx].z
      );

      assignedParticles.add(item.particleIdx);
      usedTargets.add(item.targetIdx);

      // æ‰€æœ‰ç²’å­éƒ½åˆ†é…å®Œæ¯•
      if (assignedParticles.size >= numParticles) break;
    }

    // å¤„ç†å‰©ä½™æœªåˆ†é…çš„ç²’å­ (å¦‚æœç›®æ ‡ç‚¹ä¸å¤Ÿ)
    for (let i = 0; i < numParticles; i++) {
      if (!assignedParticles.has(i)) {
        // åˆ†é…åˆ°éšæœºç›®æ ‡ç‚¹ (å…è®¸å¤šå¯¹ä¸€)
        const targetIdx = i % numTargets;
        this.particles[i].targetPosition = new Vector3(
          this.targetPoints[targetIdx].x,
          this.targetPoints[targetIdx].y,
          this.targetPoints[targetIdx].z
        );
      }
    }
  }

  /**
   * ç©ºé—´åˆ†åŒºåŒ¹é…ç®—æ³•
   * å°†ç©ºé—´åˆ’åˆ†ä¸ºç½‘æ ¼ï¼Œç²’å­åªä¸é™„è¿‘çš„ç›®æ ‡ç‚¹åŒ¹é…
   */
  private spatialMatch(): void {
    const numParticles = this.particles.length;
    const numTargets = this.targetPoints.length;

    // ç®€åŒ–: å¯¹äºå¤§é‡ç²’å­ï¼Œä½¿ç”¨ç´¢å¼•å–æ¨¡ç›´æ¥åˆ†é…
    // è¿™ç‰ºç‰²äº†ä¸€äº›"æœ€ä¼˜ç§»åŠ¨è·ç¦»"ï¼Œä½†æ¢æ¥ O(n) çš„æ€§èƒ½
    for (let i = 0; i < numParticles; i++) {
      const targetIdx = i % numTargets;
      
      // æ·»åŠ ä¸€äº›éšæœºæ‰°åŠ¨ï¼Œé¿å…æ‰€æœ‰ç²’å­èµ°å‘åŒä¸€ç‚¹
      const jitter = (Math.random() - 0.5) * 2;
      const target = this.targetPoints[targetIdx];
      
      this.particles[i].targetPosition = new Vector3(
        target.x + jitter,
        target.y + jitter,
        target.z + jitter
      );
    }
  }

  /**
   * æ›´æ–°å˜å½¢åŠ¨ç”»
   * 
   * @param deltaTime æ—¶é—´å¢é‡ (ç§’)
   */
  update(deltaTime: number): void {
    if (!this.isMorphingActive) return;

    this.morphElapsed += deltaTime;
    const progress = Math.min(1, this.morphElapsed / this.config.duration);

    for (const particle of this.particles) {
      if (!particle.isMorphing) continue;

      this.updateParticle(particle, deltaTime, progress);
    }

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç²’å­éƒ½åˆ°è¾¾ç›®æ ‡
    if (progress >= 1) {
      this.completeMorph();
    }
  }

  /**
   * æ›´æ–°å•ä¸ªç²’å­
   */
  private updateParticle(particle: MorphParticle, deltaTime: number, globalProgress: number): void {
    switch (this.config.mode) {
      case 'smooth':
        this.updateSmooth(particle, globalProgress);
        break;
      
      case 'snap':
        this.updateSnap(particle, globalProgress);
        break;
      
      case 'physics':
      default:
        this.updatePhysics(particle, deltaTime);
        break;
    }
  }

  /**
   * å¹³æ»‘æ’å€¼æ¨¡å¼
   * ç›´æ¥ä»èµ·ç‚¹æ’å€¼åˆ°ç»ˆç‚¹ï¼Œæ— ç‰©ç†æ¨¡æ‹Ÿ
   */
  private updateSmooth(particle: MorphParticle, progress: number): void {
    const easedProgress = evaluateCurve(this.config.easingCurve, progress);

    particle.position.x = this.lerp(particle.originPosition.x, particle.targetPosition.x, easedProgress);
    particle.position.y = this.lerp(particle.originPosition.y, particle.targetPosition.y, easedProgress);
    particle.position.z = this.lerp(particle.originPosition.z, particle.targetPosition.z, easedProgress);

    particle.morphProgress = progress;
  }

  /**
   * ç¬ç§»æ¨¡å¼
   * åˆ°è¾¾ä¸€å®šè¿›åº¦åç›´æ¥è·³åˆ°ç›®æ ‡ä½ç½®
   */
  private updateSnap(particle: MorphParticle, progress: number): void {
    if (progress < 0.3) {
      // å‰30%æ—¶é—´ä¿æŒåŸä½
      return;
    }

    // ç›´æ¥ç§»åŠ¨åˆ°ç›®æ ‡
    particle.position.x = particle.targetPosition.x;
    particle.position.y = particle.targetPosition.y;
    particle.position.z = particle.targetPosition.z;
    particle.morphProgress = 1;
    particle.isMorphing = false;
  }

  /**
   * ç‰©ç†å¸å¼•åŠ›æ¨¡å¼ (æ¨è)
   * ç²’å­å—ç›®æ ‡ç‚¹å¸å¼•åŠ›é©±åŠ¨ï¼Œäº§ç”Ÿè‡ªç„¶çš„è¿åŠ¨è½¨è¿¹
   */
  private updatePhysics(particle: MorphParticle, deltaTime: number): void {
    const target = particle.targetPosition;
    const pos = particle.position;
    const vel = particle.velocity;

    // è®¡ç®—åˆ°ç›®æ ‡çš„å‘é‡
    const dx = target.x - pos.x;
    const dy = target.y - pos.y;
    const dz = target.z - pos.z;
    const distSq = dx * dx + dy * dy + dz * dz;
    const dist = Math.sqrt(distSq);

    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾
    if (dist < this.config.arrivalThreshold) {
      particle.position.x = target.x;
      particle.position.y = target.y;
      particle.position.z = target.z;
      particle.velocity.x = 0;
      particle.velocity.y = 0;
      particle.velocity.z = 0;
      particle.morphProgress = 1;
      particle.isMorphing = false;
      return;
    }

    // è®¡ç®—å¸å¼•åŠ› (ç±»å¼¹ç°§åŠ›: F = k * d)
    const forceMagnitude = this.config.attractionStrength;
    
    // å½’ä¸€åŒ–æ–¹å‘
    const fx = (dx / dist) * forceMagnitude;
    const fy = (dy / dist) * forceMagnitude;
    const fz = (dz / dist) * forceMagnitude;

    // æ›´æ–°é€Ÿåº¦: v += a * dt
    vel.x += fx * deltaTime;
    vel.y += fy * deltaTime;
    vel.z += fz * deltaTime;

    // åº”ç”¨é˜»å°¼
    vel.x *= this.config.damping;
    vel.y *= this.config.damping;
    vel.z *= this.config.damping;

    // é™åˆ¶æœ€å¤§é€Ÿåº¦
    const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
    if (speed > this.config.maxSpeed) {
      const scale = this.config.maxSpeed / speed;
      vel.x *= scale;
      vel.y *= scale;
      vel.z *= scale;
    }

    // æ›´æ–°ä½ç½®: p += v * dt
    pos.x += vel.x * deltaTime;
    pos.y += vel.y * deltaTime;
    pos.z += vel.z * deltaTime;

    // æ›´æ–°è¿›åº¦ (åŸºäºè·ç¦»)
    const initialDist = Math.sqrt(
      (target.x - particle.originPosition.x) ** 2 +
      (target.y - particle.originPosition.y) ** 2 +
      (target.z - particle.originPosition.z) ** 2
    );
    particle.morphProgress = initialDist > 0 ? 1 - (dist / initialDist) : 1;
  }

  /**
   * å®Œæˆå˜å½¢
   */
  private completeMorph(): void {
    this.isMorphingActive = false;
    
    for (const particle of this.particles) {
      particle.isMorphing = false;
      particle.morphProgress = 1;
    }

    console.log('[MorphingEngine] Morph completed');
  }

  /**
   * åœæ­¢å˜å½¢
   */
  stopMorph(): void {
    this.isMorphingActive = false;
    
    for (const particle of this.particles) {
      particle.isMorphing = false;
    }
  }

  /**
   * æ˜¯å¦æ­£åœ¨å˜å½¢
   */
  isAnimating(): boolean {
    return this.isMorphingActive;
  }

  /**
   * è·å–å˜å½¢è¿›åº¦ (0-1)
   */
  getProgress(): number {
    return Math.min(1, this.morphElapsed / this.config.duration);
  }

  /**
   * è·å–é…ç½®
   */
  getConfig(): MorphConfig {
    return { ...this.config };
  }

  /**
   * æ›´æ–°é…ç½®
   */
  setConfig(config: Partial<MorphConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * çº¿æ€§æ’å€¼
   */
  private lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
  }

  /**
   * é‡ç½®å¼•æ“çŠ¶æ€
   */
  reset(): void {
    this.particles = [];
    this.targetPoints = [];
    this.isMorphingActive = false;
    this.morphElapsed = 0;
  }
}

// å¯¼å‡ºå…¨å±€å®ä¾‹
export const globalMorphingEngine = new MorphingEngine();

// END OF FILE: src/core/stream/MorphingEngine.ts


// =============================================================================
// FILE: src\core\stream\ParticleStream.ts
// =============================================================================

/**
 * ParticleStream.ts - ç²’å­æµç®¡ç†å™¨
 * 
 * æ ¸å¿ƒæ¦‚å¿µï¼šç²’å­æµæ˜¯ä¸€ä¸ªæ—¶é—´è½´ä¸Šçš„ç²’å­é›†åˆ
 * 
 * èŒè´£ï¼š
 * - ç®¡ç†ç²’å­ç”Ÿå‘½å‘¨æœŸ
 * - å¤„ç†é˜¶æ®µè¿‡æ¸¡ (State Mutations)
 * - åè°ƒç‰©ç†å¼•æ“å’Œå˜å½¢å¼•æ“
 * - å®ç°ç²’å­é‡ç”¨ (ä¸é”€æ¯å†ç”Ÿæˆï¼Œè€Œæ˜¯æµåŠ¨)
 */

import { Vector3 } from '../Vector3';
import { 
  PayloadStage, 
  TopologyConfig, 
  DynamicsConfig, 
  RenderingConfig,
  ForceField,
  evaluateCurve,
  evaluateGradient,
  Gradient,
  Curve,
  PRESET_CURVES
} from './types';
import { ForceFieldSystem } from './ForceFieldSystem';
import { MorphingEngine, MorphParticle, MorphConfig } from './MorphingEngine';
import { Shape3DGenerator, Shape3DType } from '../shapes/Shape3DFactory';

/**
 * æµç²’å­ - æ‰©å±•çš„ç²’å­æ•°æ®ç»“æ„
 */
export interface StreamParticle {
  // === åŸºç¡€ç‰©ç†å±æ€§ ===
  id: number;
  position: Vector3;
  velocity: Vector3;
  acceleration: Vector3;
  mass: number;
  
  // === æ¸²æŸ“å±æ€§ ===
  hue: number;
  saturation: number;
  lightness: number;
  alpha: number;
  size: number;
  temperature: number;  // ç”¨äºé»‘ä½“è¾å°„ç€è‰²
  
  // === ç”Ÿå‘½å‘¨æœŸ ===
  age: number;          // å·²å­˜æ´»æ—¶é—´
  lifeTime: number;     // æ€»ç”Ÿå‘½æ—¶é—´
  stageAge: number;     // å½“å‰é˜¶æ®µå·²å­˜æ´»æ—¶é—´
  isDead: boolean;
  
  // === å˜å½¢å±æ€§ ===
  targetPosition: Vector3;
  originPosition: Vector3;
  morphProgress: number;
  isMorphing: boolean;
  
  // === è‡ªå®šä¹‰å±æ€§ ===
  userData: Record<string, any>;
}

/**
 * ç²’å­æµçŠ¶æ€
 */
export enum StreamState {
  IDLE = 'idle',
  SPAWNING = 'spawning',
  ACTIVE = 'active',
  MORPHING = 'morphing',
  FADING = 'fading',
  EXTINCT = 'extinct'
}

/**
 * ç²’å­æµé…ç½®
 */
export interface StreamConfig {
  /** æœ€å¤§ç²’å­æ•° */
  maxParticles: number;
  /** åˆå§‹ç²’å­æ•° */
  initialParticles: number;
  /** åŸºç¡€ç”Ÿå‘½å‘¨æœŸ (ç§’) */
  baseLifeTime: number;
  /** ç”Ÿå‘½å‘¨æœŸå˜åŒ–èŒƒå›´ */
  lifeTimeVariance: number;
  /** æ˜¯å¦ä½¿ç”¨å¯¹è±¡æ±  */
  usePool: boolean;
}

const DEFAULT_STREAM_CONFIG: StreamConfig = {
  maxParticles: 5000,
  initialParticles: 0,
  baseLifeTime: 5,
  lifeTimeVariance: 1,
  usePool: true
};

/**
 * ç²’å­æµç®¡ç†å™¨
 */
export class ParticleStream {
  private config: StreamConfig;
  private particles: StreamParticle[] = [];
  private particlePool: StreamParticle[] = []; // å¯¹è±¡æ± 
  private state: StreamState = StreamState.IDLE;
  
  private forceFieldSystem: ForceFieldSystem;
  private morphingEngine: MorphingEngine;
  
  private currentStage: PayloadStage | null = null;
  private stageIndex: number = 0;
  private stageElapsed: number = 0;
  private totalElapsed: number = 0;
  
  private nextParticleId: number = 0;
  private spawnCenter: Vector3 = new Vector3(0, 0, 0);
  
  // äº‹ä»¶å›è°ƒ
  private onStageChangeCallbacks: Array<(stageIndex: number) => void> = [];
  private onParticleDeathCallbacks: Array<(particle: StreamParticle) => void> = [];

  constructor(config: Partial<StreamConfig> = {}) {
    this.config = { ...DEFAULT_STREAM_CONFIG, ...config };
    this.forceFieldSystem = new ForceFieldSystem();
    this.morphingEngine = new MorphingEngine();
    
    // é¢„åˆ†é…ç²’å­æ± 
    if (this.config.usePool) {
      this.preallocatePool();
    }
  }

  /**
   * é¢„åˆ†é…ç²’å­å¯¹è±¡æ± 
   */
  private preallocatePool(): void {
    for (let i = 0; i < Math.min(this.config.maxParticles, 1000); i++) {
      this.particlePool.push(this.createEmptyParticle());
    }
  }

  /**
   * åˆ›å»ºç©ºç²’å­
   */
  private createEmptyParticle(): StreamParticle {
    return {
      id: 0,
      position: new Vector3(0, 0, 0),
      velocity: new Vector3(0, 0, 0),
      acceleration: new Vector3(0, 0, 0),
      mass: 1,
      hue: 0,
      saturation: 1,
      lightness: 0.5,
      alpha: 1,
      size: 1,
      temperature: 6000,
      age: 0,
      lifeTime: 5,
      stageAge: 0,
      isDead: true,
      targetPosition: new Vector3(0, 0, 0),
      originPosition: new Vector3(0, 0, 0),
      morphProgress: 0,
      isMorphing: false,
      userData: {}
    };
  }

  /**
   * ä»æ± ä¸­è·å–æˆ–åˆ›å»ºç²’å­
   */
  private acquireParticle(): StreamParticle {
    let particle: StreamParticle;
    
    if (this.config.usePool && this.particlePool.length > 0) {
      particle = this.particlePool.pop()!;
    } else {
      particle = this.createEmptyParticle();
    }
    
    particle.id = this.nextParticleId++;
    particle.isDead = false;
    return particle;
  }

  /**
   * é‡Šæ”¾ç²’å­å›æ± 
   */
  private releaseParticle(particle: StreamParticle): void {
    if (this.config.usePool && this.particlePool.length < this.config.maxParticles) {
      particle.isDead = true;
      this.particlePool.push(particle);
    }
  }

  /**
   * è®¾ç½®ç”Ÿæˆä¸­å¿ƒç‚¹
   */
  setSpawnCenter(center: Vector3): void {
    this.spawnCenter = center;
  }

  /**
   * åœ¨æŒ‡å®šä½ç½®ç”Ÿæˆä¸€æ‰¹ç²’å­
   * æ ¹æ®æ‹“æ‰‘é…ç½®ç”Ÿæˆç›®æ ‡ç‚¹ï¼Œæ ¹æ®åŠ¨åŠ›å­¦é…ç½®è®¾ç½®åˆå§‹é€Ÿåº¦
   * 
   * å…³é”®ä¿®å¤ï¼šå¢åŠ  'structure_preserve' æ¨¡å¼ï¼Œç²’å­ç›´æ¥å‡ºç°åœ¨å½¢çŠ¶ä½ç½®
   */
  spawn(
    count: number,
    topology: TopologyConfig,
    dynamics: DynamicsConfig,
    rendering: RenderingConfig
  ): void {
    this.state = StreamState.SPAWNING;
    
    // ç”Ÿæˆç›®æ ‡ç‚¹åˆ†å¸ƒ
    const targetPoints = this.generateTargetPoints(topology);
    
    // æ ¹æ®ç²’å­æ•°å’Œç›®æ ‡ç‚¹æ•°å†³å®šç”Ÿæˆç­–ç•¥
    const actualCount = Math.min(count, this.config.maxParticles - this.particles.length);
    
    // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨ç»“æ„ä¿æŒæ¨¡å¼
    const isStructurePreserve = dynamics.initialVelocity.mode === 'structure_preserve';
    
    for (let i = 0; i < actualCount; i++) {
      const particle = this.acquireParticle();
      const targetPoint = targetPoints[i % targetPoints.length];
      
      // å…³é”®ä¿®å¤ï¼šç»“æ„ä¿æŒæ¨¡å¼ä¸‹ï¼Œç²’å­ç›´æ¥å‡ºç°åœ¨ç›®æ ‡ä½ç½®ï¼
      if (isStructurePreserve) {
        // ç²’å­ç›´æ¥å‡ºç°åœ¨å½¢çŠ¶ä½ç½®
        particle.position = new Vector3(
          targetPoint.x + this.spawnCenter.x,
          targetPoint.y + this.spawnCenter.y,
          targetPoint.z + this.spawnCenter.z
        );
        // åªæœ‰éå¸¸å¾®å°çš„éšæœºæ‰°åŠ¨
        const jitter = 0.5;
        particle.velocity = new Vector3(
          (Math.random() - 0.5) * jitter,
          (Math.random() - 0.5) * jitter,
          (Math.random() - 0.5) * jitter
        );
      } else {
        // ä¼ ç»Ÿæ¨¡å¼ï¼šç²’å­ä»ä¸­å¿ƒç”Ÿæˆï¼Œé£å‘ç›®æ ‡
        particle.position = new Vector3(
          this.spawnCenter.x,
          this.spawnCenter.y,
          this.spawnCenter.z
        );
        // è®¾ç½®åˆå§‹é€Ÿåº¦
        this.setInitialVelocity(particle, dynamics, targetPoint);
      }
      
      // è®¾ç½®ç›®æ ‡ä½ç½®
      particle.targetPosition = new Vector3(
        targetPoint.x + this.spawnCenter.x,
        targetPoint.y + this.spawnCenter.y,
        targetPoint.z + this.spawnCenter.z
      );
      
      // è®¾ç½®æ¸²æŸ“å±æ€§
      this.setRenderingProperties(particle, rendering, i / actualCount);
      
      // ç”Ÿå‘½å‘¨æœŸ
      particle.age = 0;
      particle.stageAge = 0;
      particle.lifeTime = this.config.baseLifeTime + 
        (Math.random() - 0.5) * 2 * this.config.lifeTimeVariance;
      
      this.particles.push(particle);
    }
    
    // è®¾ç½®åŠ›åœº
    this.forceFieldSystem.setForceFields(dynamics.forceFields);
    
    this.state = StreamState.ACTIVE;
    console.log(`[ParticleStream] Spawned ${actualCount} particles (mode: ${dynamics.initialVelocity.mode}), total: ${this.particles.length}`);
  }

  /**
   * ç”Ÿæˆç›®æ ‡ç‚¹åˆ†å¸ƒ
   */
  private generateTargetPoints(topology: TopologyConfig): Vector3[] {
    const type = topology.source as Shape3DType;
    const points = Shape3DGenerator.generate(
      type,
      topology.resolution,
      topology.scale
    );
    
    // åº”ç”¨æ—‹è½¬å’Œåç§»
    const result: Vector3[] = [];
    for (const point of points) {
      let pos = point.position;
      
      // åº”ç”¨åç§»
      if (topology.offset) {
        pos = new Vector3(
          pos.x + topology.offset.x,
          pos.y + topology.offset.y,
          pos.z + topology.offset.z
        );
      }
      
      result.push(pos);
    }
    
    return result;
  }

  /**
   * è®¾ç½®ç²’å­åˆå§‹é€Ÿåº¦
   */
  private setInitialVelocity(
    particle: StreamParticle,
    dynamics: DynamicsConfig,
    targetOffset: Vector3
  ): void {
    const vel = dynamics.initialVelocity;
    let speed: number;
    
    if (Array.isArray(vel.speed)) {
      // èŒƒå›´é€Ÿåº¦
      speed = vel.speed[0] + Math.random() * (vel.speed[1] - vel.speed[0]);
    } else {
      speed = vel.speed;
    }
    
    switch (vel.mode) {
      case 'radial':
        // å¾„å‘çˆ†ç‚¸
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        particle.velocity = new Vector3(
          Math.sin(phi) * Math.cos(theta) * speed,
          Math.sin(phi) * Math.sin(theta) * speed,
          Math.cos(phi) * speed
        );
        break;
      
      case 'directional':
        // æ–¹å‘é€Ÿåº¦
        const dir = vel.direction || new Vector3(0, 1, 0);
        const len = Math.sqrt(dir.x ** 2 + dir.y ** 2 + dir.z ** 2);
        particle.velocity = new Vector3(
          (dir.x / len) * speed,
          (dir.y / len) * speed,
          (dir.z / len) * speed
        );
        break;
      
      case 'random':
        // éšæœºæ–¹å‘
        particle.velocity = new Vector3(
          (Math.random() - 0.5) * speed * 2,
          (Math.random() - 0.5) * speed * 2,
          (Math.random() - 0.5) * speed * 2
        );
        break;
      
      case 'target_seeking':
        // æŒ‡å‘ç›®æ ‡çš„åˆå§‹é€Ÿåº¦
        const dx = targetOffset.x;
        const dy = targetOffset.y;
        const dz = targetOffset.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (dist > 0) {
          particle.velocity = new Vector3(
            (dx / dist) * speed,
            (dy / dist) * speed,
            (dz / dist) * speed
          );
        }
        break;
    }
  }

  /**
   * è®¾ç½®ç²’å­æ¸²æŸ“å±æ€§
   */
  private setRenderingProperties(
    particle: StreamParticle,
    rendering: RenderingConfig,
    normalizedIndex: number
  ): void {
    // ä»é¢œè‰²æ¸å˜è·å–é¢œè‰²
    const color = evaluateGradient(rendering.colorMap, normalizedIndex);
    particle.hue = color.h;
    particle.saturation = color.s;
    particle.lightness = color.l;
    particle.alpha = color.a;
    
    // å¤§å°
    particle.size = rendering.baseSize;
    
    // æ¸©åº¦ (ç”¨äºé»‘ä½“è¾å°„)
    if (rendering.useBlackbodyRadiation) {
      particle.temperature = rendering.initialTemperature || 6000;
    }
  }

  /**
   * å¼€å§‹å½¢æ€å˜å½¢
   */
  startMorph(
    targetTopology: TopologyConfig,
    config?: Partial<MorphConfig>
  ): void {
    this.state = StreamState.MORPHING;
    
    // ç”Ÿæˆæ–°çš„ç›®æ ‡ç‚¹
    const targetPoints = this.generateTargetPoints(targetTopology);
    
    // å°†ç²’å­æ·»åŠ åç§»åˆ°ç»å¯¹ä½ç½®
    const absoluteTargets = targetPoints.map(p => new Vector3(
      p.x + this.spawnCenter.x,
      p.y + this.spawnCenter.y,
      p.z + this.spawnCenter.z
    ));
    
    // è½¬æ¢ä¸ºå˜å½¢å¼•æ“éœ€è¦çš„æ ¼å¼
    const morphParticles: MorphParticle[] = this.particles.map(p => ({
      position: p.position,
      velocity: p.velocity,
      targetPosition: p.targetPosition,
      originPosition: new Vector3(p.position.x, p.position.y, p.position.z),
      morphProgress: 0,
      isMorphing: true,
      id: p.id
    }));
    
    this.morphingEngine.setParticles(morphParticles);
    this.morphingEngine.startMorph(absoluteTargets, config);
    
    console.log(`[ParticleStream] Started morphing to ${targetTopology.source}`);
  }

  /**
   * å¼€å§‹æ¶ˆäº¡é˜¶æ®µ
   * @param config æ¶ˆäº¡é…ç½® - å…è®¸ç”¨æˆ·è‡ªå®šä¹‰è€Œéç¡¬ç¼–ç 
   */
  startExtinction(config?: {
    useGravity?: boolean;
    gravityStrength?: number;
    windStrength?: number;
    fadeMode?: 'fall' | 'float' | 'dissolve' | 'explode' | 'implode';
  }): void {
    this.state = StreamState.FADING;
    
    // å…³é—­å˜å½¢å¸å¼•åŠ›
    this.morphingEngine.stopMorph();
    
    // æ›´æ–°åŠ›åœº - æ ¹æ®é…ç½®è€Œéç¡¬ç¼–ç !
    this.forceFieldSystem.clearForces();
    
    const useGravity = config?.useGravity ?? true;
    const gravityStrength = config?.gravityStrength ?? 15;
    const windStrength = config?.windStrength ?? 3;
    const fadeMode = config?.fadeMode ?? 'fall';
    
    switch (fadeMode) {
      case 'fall':
        // æ­£å¸¸å è½
        if (useGravity && gravityStrength > 0) {
          this.forceFieldSystem.addForceField({
            type: 'gravity',
            strength: gravityStrength,
            direction: new Vector3(0, -1, 0)
          });
        }
        this.forceFieldSystem.addForceField({
          type: 'drag',
          strength: 0.02
        });
        if (windStrength > 0) {
          this.forceFieldSystem.addForceField({
            type: 'wind',
            strength: windStrength,
            direction: new Vector3(1, 0, 0.5)
          });
        }
        break;
      
      case 'float':
        // æ¼‚æµ®æ¶ˆå¤± - æ— é‡åŠ›ï¼Œåªæœ‰è½»å¾®æ‰°åŠ¨
        this.forceFieldSystem.addForceField({
          type: 'drag',
          strength: 0.1
        });
        this.forceFieldSystem.addForceField({
          type: 'turbulence',
          strength: 2,
          noiseFrequency: 0.5,
          noiseAmplitude: 1
        });
        break;
      
      case 'dissolve':
        // æº¶è§£æ¶ˆå¤± - åŸåœ°æ¶ˆå¤±
        this.forceFieldSystem.addForceField({
          type: 'drag',
          strength: 0.5 // é«˜é˜»åŠ›è®©ç²’å­å‡ ä¹é™æ­¢
        });
        break;
      
      case 'explode':
        // äºŒæ¬¡çˆ†ç‚¸æ¶ˆå¤±
        for (const p of this.particles) {
          const speed = 20 + Math.random() * 30;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          p.velocity = new Vector3(
            Math.sin(phi) * Math.cos(theta) * speed,
            Math.sin(phi) * Math.sin(theta) * speed,
            Math.cos(phi) * speed
          );
        }
        this.forceFieldSystem.addForceField({
          type: 'drag',
          strength: 0.05
        });
        break;
      
      case 'implode':
        // å‘ä¸­å¿ƒæ”¶ç¼©æ¶ˆå¤±
        this.forceFieldSystem.addForceField({
          type: 'attraction',
          strength: 30,
          center: this.spawnCenter,
          radius: 200
        });
        break;
    }
    
    console.log(`[ParticleStream] Started extinction phase (mode: ${fadeMode})`);
  }

  /**
   * æ›´æ–°ç²’å­æµ
   */
  update(deltaTime: number): void {
    if (this.state === StreamState.IDLE || this.state === StreamState.EXTINCT) {
      return;
    }
    
    this.totalElapsed += deltaTime;
    this.stageElapsed += deltaTime;
    this.forceFieldSystem.updateTime(deltaTime);
    
    // æ›´æ–°å˜å½¢å¼•æ“
    if (this.state === StreamState.MORPHING && this.morphingEngine.isAnimating()) {
      this.morphingEngine.update(deltaTime);
      
      // åŒæ­¥å˜å½¢å¼•æ“çš„ç²’å­ä½ç½®åˆ°ä¸»ç²’å­æ•°ç»„
      const morphParticles = this.morphingEngine.getParticles();
      for (let i = 0; i < morphParticles.length && i < this.particles.length; i++) {
        const mp = morphParticles[i];
        const p = this.particles[i];
        p.position = mp.position;
        p.velocity = mp.velocity;
        p.morphProgress = mp.morphProgress;
        p.isMorphing = mp.isMorphing;
      }
      
      // å˜å½¢å®Œæˆååˆ‡æ¢çŠ¶æ€
      if (!this.morphingEngine.isAnimating()) {
        this.state = StreamState.ACTIVE;
      }
    }
    
    // æ›´æ–°æ¯ä¸ªç²’å­
    const deadIndices: number[] = [];
    
    for (let i = 0; i < this.particles.length; i++) {
      const particle = this.particles[i];
      
      if (particle.isDead) {
        deadIndices.push(i);
        continue;
      }
      
      // æ›´æ–°å¹´é¾„
      particle.age += deltaTime;
      particle.stageAge += deltaTime;
      
      // ç‰©ç†æ›´æ–° (é™¤éåœ¨å˜å½¢æ¨¡å¼)
      if (this.state !== StreamState.MORPHING || !particle.isMorphing) {
        this.updatePhysics(particle, deltaTime);
      }
      
      // æ¸²æŸ“å±æ€§æ›´æ–°
      this.updateRenderingProperties(particle, deltaTime);
      
      // æ£€æŸ¥æ­»äº¡æ¡ä»¶
      if (this.shouldParticleDie(particle)) {
        particle.isDead = true;
        deadIndices.push(i);
        this.onParticleDeathCallbacks.forEach(cb => cb(particle));
      }
    }
    
    // æ¸…ç†æ­»äº¡ç²’å­
    this.removeDead(deadIndices);
    
    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ¶ˆäº¡
    if (this.state === StreamState.FADING && this.particles.length === 0) {
      this.state = StreamState.EXTINCT;
      console.log('[ParticleStream] All particles extinct');
    }
  }

  /**
   * æ›´æ–°ç²’å­ç‰©ç†
   */
  private updatePhysics(particle: StreamParticle, deltaTime: number): void {
    // è®¡ç®—åŠ é€Ÿåº¦
    const accel = this.forceFieldSystem.calculateAcceleration(
      particle.position,
      particle.velocity,
      particle.mass
    );
    
    particle.acceleration = accel;
    
    // Verlet ç§¯åˆ†
    // è¿™é‡Œä½¿ç”¨é€Ÿåº¦Verlet: v += a*dt, p += v*dt
    particle.velocity.x += accel.x * deltaTime;
    particle.velocity.y += accel.y * deltaTime;
    particle.velocity.z += accel.z * deltaTime;
    
    particle.position.x += particle.velocity.x * deltaTime;
    particle.position.y += particle.velocity.y * deltaTime;
    particle.position.z += particle.velocity.z * deltaTime;
  }

  /**
   * æ›´æ–°ç²’å­æ¸²æŸ“å±æ€§
   */
  private updateRenderingProperties(particle: StreamParticle, deltaTime: number): void {
    const lifeProgress = particle.age / particle.lifeTime;
    
    // é»‘ä½“è¾å°„: æ¸©åº¦éšæ—¶é—´é™ä½
    if (particle.temperature > 0) {
      particle.temperature -= 500 * deltaTime; // æ¯ç§’é™ä½500K
      particle.temperature = Math.max(particle.temperature, 800); // æœ€ä½800K
      
      // æ ¹æ®æ¸©åº¦è®¡ç®—é¢œè‰² (ç®€åŒ–çš„é»‘ä½“è¾å°„)
      this.applyBlackbodyColor(particle);
    }
    
    // é€æ˜åº¦æ¸å˜
    if (this.state === StreamState.FADING) {
      particle.alpha = Math.max(0, 1 - lifeProgress);
    }
    
    // å¤§å°å˜åŒ–
    if (lifeProgress > 0.8) {
      particle.size *= 0.98; // åæœŸç¼©å°
    }
  }

  /**
   * åº”ç”¨é»‘ä½“è¾å°„é¢œè‰²
   * æ¸©åº¦ä»é«˜åˆ°ä½: ç™½ â†’ è“ç™½ â†’ ç™½ â†’ é»„ â†’ æ©™ â†’ çº¢ â†’ æš—çº¢
   */
  private applyBlackbodyColor(particle: StreamParticle): void {
    const temp = particle.temperature;
    
    if (temp > 7000) {
      // æé«˜æ¸©: è“ç™½
      particle.hue = 200 + (temp - 7000) / 100;
      particle.lightness = 0.9;
    } else if (temp > 5500) {
      // é«˜æ¸©: ç™½åˆ°é»„ç™½
      particle.hue = 50 + (7000 - temp) / 50;
      particle.lightness = 0.85;
    } else if (temp > 4000) {
      // ä¸­æ¸©: é»„åˆ°æ©™
      particle.hue = 30 + (5500 - temp) / 75;
      particle.lightness = 0.65;
    } else if (temp > 2500) {
      // ä½æ¸©: æ©™åˆ°çº¢
      particle.hue = 10 + (4000 - temp) / 150;
      particle.lightness = 0.5;
    } else {
      // æä½æ¸©: æš—çº¢ (ç°çƒ¬)
      particle.hue = 0;
      particle.saturation = 0.3;
      particle.lightness = 0.2 + (temp - 800) / 5000;
    }
  }

  /**
   * åˆ¤æ–­ç²’å­æ˜¯å¦åº”è¯¥æ­»äº¡
   */
  private shouldParticleDie(particle: StreamParticle): boolean {
    // ç”Ÿå‘½å‘¨æœŸç»“æŸ
    if (particle.age > particle.lifeTime) return true;
    
    // é€æ˜åº¦å½’é›¶
    if (particle.alpha <= 0) return true;
    
    // è½åˆ°åœ°é¢ä»¥ä¸‹
    if (particle.position.y < -50) return true;
    
    // é£å¤ªè¿œ
    const distFromCenter = Math.sqrt(
      particle.position.x ** 2 +
      particle.position.y ** 2 +
      particle.position.z ** 2
    );
    if (distFromCenter > 500) return true;
    
    return false;
  }

  /**
   * ç§»é™¤æ­»äº¡ç²’å­
   */
  private removeDead(indices: number[]): void {
    // ä»åå¾€å‰ç§»é™¤ï¼Œé¿å…ç´¢å¼•åç§»
    const sorted = indices.sort((a, b) => b - a);
    for (const i of sorted) {
      const particle = this.particles[i];
      this.particles.splice(i, 1);
      this.releaseParticle(particle);
    }
  }

  /**
   * è·å–æ´»è·ƒç²’å­æ•°æ® (ç”¨äºæ¸²æŸ“)
   */
  getParticleData(): StreamParticle[] {
    return this.particles.filter(p => !p.isDead);
  }

  /**
   * è·å–ç²’å­æ•°é‡
   */
  getParticleCount(): number {
    return this.particles.filter(p => !p.isDead).length;
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getState(): StreamState {
    return this.state;
  }

  /**
   * è·å–åŠ›åœºç³»ç»Ÿ
   */
  getForceFieldSystem(): ForceFieldSystem {
    return this.forceFieldSystem;
  }

  /**
   * è·å–å˜å½¢å¼•æ“
   */
  getMorphingEngine(): MorphingEngine {
    return this.morphingEngine;
  }

  /**
   * æ³¨å†Œé˜¶æ®µå˜åŒ–å›è°ƒ
   */
  onStageChange(callback: (stageIndex: number) => void): () => void {
    this.onStageChangeCallbacks.push(callback);
    return () => {
      this.onStageChangeCallbacks = this.onStageChangeCallbacks.filter(cb => cb !== callback);
    };
  }

  /**
   * æ³¨å†Œç²’å­æ­»äº¡å›è°ƒ
   */
  onParticleDeath(callback: (particle: StreamParticle) => void): () => void {
    this.onParticleDeathCallbacks.push(callback);
    return () => {
      this.onParticleDeathCallbacks = this.onParticleDeathCallbacks.filter(cb => cb !== callback);
    };
  }

  /**
   * å®Œå…¨é‡ç½®
   */
  reset(): void {
    // é‡Šæ”¾æ‰€æœ‰ç²’å­å›æ± 
    for (const particle of this.particles) {
      this.releaseParticle(particle);
    }
    this.particles = [];
    
    this.state = StreamState.IDLE;
    this.stageIndex = 0;
    this.stageElapsed = 0;
    this.totalElapsed = 0;
    this.currentStage = null;
    
    this.forceFieldSystem.clearForces();
    this.morphingEngine.reset();
    
    console.log('[ParticleStream] Reset complete');
  }

  /**
   * é”€æ¯
   */
  destroy(): void {
    this.reset();
    this.particlePool = [];
  }
}

// END OF FILE: src/core/stream/ParticleStream.ts


// =============================================================================
// FILE: src\core\stream\presets\DragonDance.json
// =============================================================================

{
  "id": "dragon_dance",
  "name": "æ¸¸é¾™æˆç ",
  "description": "ä¸œæ–¹ç¥é¾™ç›˜æ—‹é£èˆï¼Œæ°”åŠ¿ç£…ç¤´",
  "tags": ["ä¸­å›½é£", "ç”Ÿç‰©", "å®å¤§"],
  "duration": 9,
  
  "carrier": {
    "type": "comet",
    "path": {
      "type": "helix",
      "points": [],
      "speedCurve": { "type": "easeOut" },
      "spiralRadius": 8,
      "spiralFrequency": 3
    },
    "duration": 2.5,
    "trail": {
      "emissionRate": 120,
      "lifeTime": 0.6,
      "colorGradient": {
        "stops": [
          { "position": 0, "hue": 45, "saturation": 1, "lightness": 0.9 },
          { "position": 0.4, "hue": 30, "saturation": 1, "lightness": 0.6 },
          { "position": 1, "hue": 0, "saturation": 1, "lightness": 0.3 }
        ]
      },
      "texture": "flame",
      "size": 0.4
    }
  },
  
  "payload": {
    "stages": [
      {
        "id": "dragon_appear",
        "name": "ç¥é¾™åˆç°",
        "timeOffset": 0,
        "duration": 1.5,
        "topology": {
          "type": "mathematical_shape",
          "source": "explosion_burst",
          "resolution": 4000,
          "scale": 45
        },
        "dynamics": {
          "transitionMode": "explode",
          "initialVelocity": {
            "mode": "radial",
            "speed": [60, 90]
          },
          "forceFields": [
            { "type": "drag", "strength": 0.12 },
            { "type": "vortex", "strength": 15, "center": { "x": 0, "y": 0, "z": 0 }, "radius": 80 }
          ],
          "velocityProfile": { "type": "easeOut" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 50, "saturation": 1, "lightness": 0.95 },
              { "position": 0.3, "hue": 40, "saturation": 1, "lightness": 0.7 },
              { "position": 0.7, "hue": 0, "saturation": 1, "lightness": 0.5 },
              { "position": 1, "hue": 350, "saturation": 0.9, "lightness": 0.35 }
            ]
          },
          "sizeCurve": { "type": "easeOut" },
          "baseSize": 1.4,
          "blending": "additive",
          "useBlackbodyRadiation": true,
          "initialTemperature": 6500,
          "glowIntensity": 2.2
        }
      },
      {
        "id": "dragon_form",
        "name": "é¾™å½¢èšåˆ",
        "timeOffset": 1.5,
        "duration": 2.5,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "dragon_3d",
          "resolution": 4000,
          "scale": 50
        },
        "dynamics": {
          "transitionMode": "morph",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 35
          },
          "forceFields": [
            { "type": "drag", "strength": 0.02 },
            { "type": "vortex", "strength": 8, "center": { "x": 0, "y": 0, "z": 0 }, "radius": 100 }
          ],
          "velocityProfile": { "type": "easeInOut" },
          "morphAttractionStrength": 90,
          "morphDamping": 0.93
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 45, "saturation": 1, "lightness": 0.8 },
              { "position": 0.3, "hue": 30, "saturation": 1, "lightness": 0.65 },
              { "position": 0.6, "hue": 10, "saturation": 1, "lightness": 0.55 },
              { "position": 1, "hue": 0, "saturation": 0.9, "lightness": 0.45 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.2,
          "blending": "additive",
          "glowIntensity": 1.8
        }
      },
      {
        "id": "dragon_dance",
        "name": "é¾™è…¾ä¹å¤©",
        "timeOffset": 4,
        "duration": 3,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "dragon_3d",
          "resolution": 4000,
          "scale": 55
        },
        "dynamics": {
          "transitionMode": "maintain",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 8
          },
          "forceFields": [
            { "type": "vortex", "strength": 12, "center": { "x": 0, "y": 10, "z": 0 }, "radius": 120 },
            { "type": "turbulence", "strength": 6, "noiseFrequency": 0.25, "noiseAmplitude": 2 }
          ],
          "velocityProfile": { "type": "linear" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 50, "saturation": 1, "lightness": 0.85 },
              { "position": 0.4, "hue": 25, "saturation": 1, "lightness": 0.65 },
              { "position": 1, "hue": 0, "saturation": 1, "lightness": 0.5 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.3,
          "blending": "additive",
          "glowIntensity": 2
        },
        "shaderAnimation": {
          "vertexModifier": "dragon_undulate",
          "parameters": { "frequency": 1.5, "amplitude": 8, "waveSpeed": 2 }
        }
      },
      {
        "id": "dragon_scatter",
        "name": "åŒ–é¾™å½’å¤©",
        "timeOffset": 7,
        "duration": 2,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "chaos_scatter",
          "resolution": 4000,
          "scale": 100
        },
        "dynamics": {
          "transitionMode": "scatter",
          "initialVelocity": {
            "mode": "random",
            "speed": [10, 25]
          },
          "forceFields": [
            { "type": "gravity", "strength": 6, "direction": { "x": 0, "y": -1, "z": 0 } },
            { "type": "wind", "strength": 8, "direction": { "x": 0.7, "y": 0.3, "z": 0.5 } },
            { "type": "turbulence", "strength": 10, "noiseFrequency": 0.4, "noiseAmplitude": 4 }
          ],
          "velocityProfile": { "type": "linear" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 40, "saturation": 1, "lightness": 0.6, "alpha": 1 },
              { "position": 0.4, "hue": 20, "saturation": 0.8, "lightness": 0.4, "alpha": 0.6 },
              { "position": 1, "hue": 0, "saturation": 0.3, "lightness": 0.2, "alpha": 0 }
            ]
          },
          "sizeCurve": { "type": "easeOut" },
          "baseSize": 0.9,
          "blending": "additive",
          "useBlackbodyRadiation": true,
          "initialTemperature": 2000,
          "coolingRate": 400
        }
      }
    ]
  }
}


// =============================================================================
// FILE: src\core\stream\presets\HeartToText.json
// =============================================================================

{
  "id": "heart_to_text",
  "name": "çˆ±çš„ç®´è¨€",
  "description": "ä»çˆ±å¿ƒå˜å½¢ä¸ºæ–‡å­—'LOVE'ï¼Œä¼ é€’çˆ±çš„ä¿¡æ¯",
  "tags": ["æµªæ¼«", "å˜å½¢", "æ–‡å­—"],
  "duration": 7,
  
  "carrier": {
    "type": "projectile",
    "path": {
      "type": "arc",
      "points": [],
      "speedCurve": { "type": "easeOut" }
    },
    "duration": 1.5,
    "trail": {
      "emissionRate": 80,
      "lifeTime": 0.4,
      "colorGradient": {
        "stops": [
          { "position": 0, "hue": 350, "saturation": 1, "lightness": 0.8 },
          { "position": 1, "hue": 340, "saturation": 0.8, "lightness": 0.4 }
        ]
      },
      "texture": "spark",
      "size": 0.25
    }
  },
  
  "payload": {
    "stages": [
      {
        "id": "heart_burst",
        "name": "çˆ±å¿ƒç»½æ”¾",
        "timeOffset": 0,
        "duration": 2,
        "topology": {
          "type": "mathematical_shape",
          "source": "heart_3d",
          "resolution": 2000,
          "scale": 35
        },
        "dynamics": {
          "transitionMode": "explode",
          "initialVelocity": {
            "mode": "radial",
            "speed": [40, 70]
          },
          "forceFields": [
            { "type": "drag", "strength": 0.08 }
          ],
          "velocityProfile": { "type": "easeOut" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 350, "saturation": 1, "lightness": 0.7 },
              { "position": 0.5, "hue": 345, "saturation": 1, "lightness": 0.55 },
              { "position": 1, "hue": 340, "saturation": 0.9, "lightness": 0.45 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.3,
          "blending": "additive",
          "glowIntensity": 1.8
        }
      },
      {
        "id": "morph_to_text",
        "name": "åŒ–ä½œæ–‡å­—",
        "timeOffset": 2,
        "duration": 2.5,
        "reuseParticles": true,
        "topology": {
          "type": "text_points",
          "source": "LOVE",
          "resolution": 2000,
          "scale": 25
        },
        "dynamics": {
          "transitionMode": "morph",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 25
          },
          "forceFields": [
            { "type": "drag", "strength": 0.015 }
          ],
          "velocityProfile": { "type": "easeInOut" },
          "morphAttractionStrength": 70,
          "morphDamping": 0.88
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 355, "saturation": 1, "lightness": 0.65 },
              { "position": 0.5, "hue": 20, "saturation": 1, "lightness": 0.6 },
              { "position": 1, "hue": 45, "saturation": 1, "lightness": 0.55 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.1,
          "blending": "additive",
          "glowIntensity": 1.5
        }
      },
      {
        "id": "text_glow",
        "name": "æ–‡å­—é—ªçƒ",
        "timeOffset": 4.5,
        "duration": 2.5,
        "reuseParticles": true,
        "topology": {
          "type": "text_points",
          "source": "LOVE",
          "resolution": 2000,
          "scale": 25
        },
        "dynamics": {
          "transitionMode": "maintain",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 3
          },
          "forceFields": [
            { "type": "turbulence", "strength": 2, "noiseFrequency": 0.2, "noiseAmplitude": 0.8 }
          ],
          "velocityProfile": { "type": "linear" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 50, "saturation": 1, "lightness": 0.8 },
              { "position": 0.5, "hue": 355, "saturation": 1, "lightness": 0.6 },
              { "position": 1, "hue": 340, "saturation": 0.8, "lightness": 0.4, "alpha": 0.3 }
            ]
          },
          "sizeCurve": { "type": "easeOut" },
          "baseSize": 1.0,
          "blending": "additive",
          "glowIntensity": 2
        }
      }
    ]
  }
}


// =============================================================================
// FILE: src\core\stream\presets\PhoenixRebirth.json
// =============================================================================

{
  "id": "phoenix_rebirth",
  "name": "å‡¤å‡°æ¶…æ§ƒ",
  "description": "ç»å…¸çš„å‡¤å‡°æ¶…æ§ƒæ•ˆæœï¼šä»ç«çƒå˜å½¢ä¸ºå‡¤å‡°ï¼Œå±•ç¿…ç¿±ç¿”ï¼Œæœ€ååŒ–ä½œç°çƒ¬é£˜è½",
  "tags": ["ç»å…¸", "å˜å½¢", "é«˜çº§", "ç”Ÿç‰©"],
  "duration": 8,
  "metadata": {
    "author": "Aetheris",
    "version": "1.0.0",
    "createdAt": "2026-01-04"
  },
  
  "carrier": {
    "type": "comet",
    "path": {
      "type": "spiral",
      "points": [],
      "speedCurve": { "type": "easeOut" },
      "spiralRadius": 5,
      "spiralFrequency": 2
    },
    "duration": 2,
    "trail": {
      "emissionRate": 100,
      "lifeTime": 0.5,
      "colorGradient": {
        "stops": [
          { "position": 0, "hue": 50, "saturation": 1, "lightness": 0.8 },
          { "position": 0.5, "hue": 45, "saturation": 1, "lightness": 0.6 },
          { "position": 1, "hue": 35, "saturation": 0.8, "lightness": 0.4 }
        ]
      },
      "texture": "spark",
      "size": 0.3
    }
  },
  
  "payload": {
    "stages": [
      {
        "id": "fireball",
        "name": "ç«çƒçˆ†å‘",
        "timeOffset": 0,
        "duration": 1,
        "topology": {
          "type": "mathematical_shape",
          "source": "sphere",
          "resolution": 3000,
          "scale": 50
        },
        "dynamics": {
          "transitionMode": "explode",
          "initialVelocity": {
            "mode": "radial",
            "speed": [80, 120]
          },
          "forceFields": [
            { "type": "drag", "strength": 0.1 },
            { "type": "gravity", "strength": 2, "direction": { "x": 0, "y": -1, "z": 0 } }
          ],
          "velocityProfile": { "type": "easeOut" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 60, "saturation": 1, "lightness": 0.9 },
              { "position": 0.3, "hue": 45, "saturation": 1, "lightness": 0.6 },
              { "position": 0.6, "hue": 20, "saturation": 1, "lightness": 0.5 },
              { "position": 1, "hue": 0, "saturation": 1, "lightness": 0.3 }
            ]
          },
          "sizeCurve": { "type": "easeOut" },
          "baseSize": 1.5,
          "blending": "additive",
          "useBlackbodyRadiation": true,
          "initialTemperature": 7000,
          "coolingRate": 500,
          "glowIntensity": 2
        }
      },
      {
        "id": "phoenix_form",
        "name": "å‡¤å‡°èšå½¢",
        "timeOffset": 1,
        "duration": 2,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "phoenix",
          "resolution": 3000,
          "scale": 40
        },
        "dynamics": {
          "transitionMode": "morph",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 30
          },
          "forceFields": [
            { "type": "drag", "strength": 0.02 }
          ],
          "velocityProfile": { "type": "easeInOut" },
          "morphAttractionStrength": 80,
          "morphDamping": 0.92
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 60, "saturation": 1, "lightness": 1 },
              { "position": 0.2, "hue": 50, "saturation": 1, "lightness": 0.7 },
              { "position": 0.5, "hue": 30, "saturation": 1, "lightness": 0.6 },
              { "position": 0.8, "hue": 15, "saturation": 1, "lightness": 0.5 },
              { "position": 1, "hue": 0, "saturation": 0.6, "lightness": 0.2 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.2,
          "blending": "additive",
          "glowIntensity": 1.5
        }
      },
      {
        "id": "phoenix_wings",
        "name": "å‡¤å‡°å±•ç¿…",
        "timeOffset": 3,
        "duration": 2,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "phoenix",
          "resolution": 3000,
          "scale": 45
        },
        "dynamics": {
          "transitionMode": "maintain",
          "initialVelocity": {
            "mode": "target_seeking",
            "speed": 5
          },
          "forceFields": [
            { "type": "turbulence", "strength": 3, "noiseFrequency": 0.3, "noiseAmplitude": 1 }
          ],
          "velocityProfile": { "type": "linear" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 60, "saturation": 1, "lightness": 1 },
              { "position": 0.5, "hue": 30, "saturation": 1, "lightness": 0.6 },
              { "position": 1, "hue": 0, "saturation": 0.6, "lightness": 0.2 }
            ]
          },
          "sizeCurve": { "type": "linear" },
          "baseSize": 1.3,
          "blending": "additive",
          "glowIntensity": 1.8
        },
        "shaderAnimation": {
          "vertexModifier": "wing_flap",
          "parameters": { "frequency": 2, "amplitude": 5 }
        }
      },
      {
        "id": "ashes",
        "name": "ç°çƒ¬é£˜è½",
        "timeOffset": 5,
        "duration": 3,
        "reuseParticles": true,
        "topology": {
          "type": "mathematical_shape",
          "source": "chaos_scatter",
          "resolution": 3000,
          "scale": 80
        },
        "dynamics": {
          "transitionMode": "scatter",
          "initialVelocity": {
            "mode": "random",
            "speed": [5, 15]
          },
          "forceFields": [
            { "type": "gravity", "strength": 9.8, "direction": { "x": 0, "y": -1, "z": 0 } },
            { "type": "wind", "strength": 5, "direction": { "x": 1, "y": -0.3, "z": 0.5 } },
            { "type": "turbulence", "strength": 8, "noiseFrequency": 0.5, "noiseAmplitude": 3 }
          ],
          "velocityProfile": { "type": "linear" }
        },
        "rendering": {
          "colorMap": {
            "stops": [
              { "position": 0, "hue": 30, "saturation": 0.8, "lightness": 0.5, "alpha": 1 },
              { "position": 0.5, "hue": 20, "saturation": 0.5, "lightness": 0.3, "alpha": 0.7 },
              { "position": 1, "hue": 0, "saturation": 0.2, "lightness": 0.15, "alpha": 0 }
            ]
          },
          "sizeCurve": { "type": "easeOut" },
          "baseSize": 0.8,
          "blending": "normal",
          "useBlackbodyRadiation": true,
          "initialTemperature": 2500,
          "coolingRate": 300
        }
      }
    ]
  }
}


// =============================================================================
// FILE: src\core\stream\StreamRenderer.ts
// =============================================================================

/**
 * StreamRenderer.ts - æµçƒŸèŠ±æ¸²æŸ“å™¨
 * 
 * èŒè´£ï¼š
 * - ä½¿ç”¨ Three.js InstancedMesh é«˜æ•ˆæ¸²æŸ“å¤§é‡ç²’å­
 * - æ”¯æŒ GPU ç²’å­åŠ¨ç”»
 * - é»‘ä½“è¾å°„é¢œè‰²è®¡ç®—
 * - ä¸åå¤„ç†æ ˆåä½œäº§ç”Ÿ Bloom æ•ˆæœ
 */

import * as THREE from 'three';
import { StreamParticle } from './ParticleStream';
import { TrailParticle, CarrierInstance } from './CarrierSystem';
import { Director } from './Director';

/**
 * æ¸²æŸ“å™¨é…ç½®
 */
export interface StreamRendererConfig {
  /** æœ€å¤§ç²’å­æ•° */
  maxParticles: number;
  /** æœ€å¤§å°¾ç„°ç²’å­æ•° */
  maxTrailParticles: number;
  /** ç²’å­çº¹ç†ç±»å‹ */
  particleTexture: 'circle' | 'star' | 'spark' | 'soft';
  /** æ˜¯å¦å¯ç”¨ HDR é¢œè‰² */
  useHDR: boolean;
  /** å‘å…‰å¼ºåº¦ä¹˜æ•° */
  glowMultiplier: number;
  /** ç²’å­åŸºç¡€å¤§å° */
  particleSize: number;
  /** æ˜¯å¦å¯ç”¨ Bloom */
  enableBloom: boolean;
  /** Bloom å¼ºåº¦ */
  bloomIntensity: number;
}

const DEFAULT_RENDERER_CONFIG: StreamRendererConfig = {
  maxParticles: 50000,
  maxTrailParticles: 10000,
  particleTexture: 'soft',
  useHDR: true,
  glowMultiplier: 1.5,
  particleSize: 8,
  enableBloom: true,
  bloomIntensity: 2.0
};

/**
 * æµçƒŸèŠ±æ¸²æŸ“å™¨
 */
export class StreamRenderer {
  private config: StreamRendererConfig;
  private scene: THREE.Scene;
  private director: Director;

  // ä¸»ç²’å­ç³»ç»Ÿ
  private particleMesh: THREE.InstancedMesh | null = null;
  private particleGeometry: THREE.BufferGeometry | null = null;
  private particleMaterial: THREE.ShaderMaterial | null = null;
  private particleColors: Float32Array;
  private particleSizes: Float32Array;
  private dummy: THREE.Object3D;

  // å°¾ç„°ç²’å­ç³»ç»Ÿ
  private trailMesh: THREE.InstancedMesh | null = null;
  private trailMaterial: THREE.ShaderMaterial | null = null;
  private trailColors: Float32Array;
  private trailSizes: Float32Array;

  // è¿è½½å™¨å‘å…‰ç‚¹
  private carrierPoints: THREE.Points | null = null;
  private carrierMaterial: THREE.PointsMaterial | null = null;

  // çº¹ç†
  private particleTexture: THREE.Texture | null = null;

  constructor(
    scene: THREE.Scene,
    director: Director,
    config: Partial<StreamRendererConfig> = {}
  ) {
    this.config = { ...DEFAULT_RENDERER_CONFIG, ...config };
    this.scene = scene;
    this.director = director;

    this.particleColors = new Float32Array(this.config.maxParticles * 3);
    this.particleSizes = new Float32Array(this.config.maxParticles);
    this.trailColors = new Float32Array(this.config.maxTrailParticles * 3);
    this.trailSizes = new Float32Array(this.config.maxTrailParticles);
    this.dummy = new THREE.Object3D();

    this.init();
  }

  /**
   * åˆå§‹åŒ–æ¸²æŸ“èµ„æº
   */
  private init(): void {
    this.createParticleTexture();
    this.createMainParticleSystem();
    this.createTrailParticleSystem();
    this.createCarrierPoints();

    console.log('[StreamRenderer] Initialized with max particles:', this.config.maxParticles);
  }

  /**
   * åˆ›å»ºç²’å­çº¹ç†
   */
  private createParticleTexture(): void {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d')!;

    const centerX = 32;
    const centerY = 32;
    const radius = 30;

    switch (this.config.particleTexture) {
      case 'circle':
        // ç¡¬è¾¹åœ†å½¢
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'star':
        // æ˜Ÿå½¢
        ctx.fillStyle = '#ffffff';
        this.drawStar(ctx, centerX, centerY, 5, radius, radius / 2);
        break;

      case 'spark':
        // ç«èŠ± (å¸¦å…‰æ™•çš„äº®ç‚¹)
        const sparkGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        sparkGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        sparkGradient.addColorStop(0.1, 'rgba(255, 255, 200, 0.9)');
        sparkGradient.addColorStop(0.4, 'rgba(255, 200, 100, 0.4)');
        sparkGradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
        ctx.fillStyle = sparkGradient;
        ctx.fillRect(0, 0, 64, 64);
        break;

      case 'soft':
      default:
        // æŸ”å’Œçš„æ¸å˜åœ†
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        break;
    }

    this.particleTexture = new THREE.CanvasTexture(canvas);
    this.particleTexture.needsUpdate = true;
  }

  /**
   * ç»˜åˆ¶æ˜Ÿå½¢
   */
  private drawStar(
    ctx: CanvasRenderingContext2D,
    cx: number, cy: number,
    spikes: number,
    outerRadius: number,
    innerRadius: number
  ): void {
    let rot = (Math.PI / 2) * 3;
    const step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);

    for (let i = 0; i < spikes; i++) {
      ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
      rot += step;
      ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
      rot += step;
    }

    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
  }

  /**
   * åˆ›å»ºä¸»ç²’å­ç³»ç»Ÿ
   */
  private createMainParticleSystem(): void {
    // ä½¿ç”¨å¹³é¢å‡ ä½•ä½“ä½œä¸ºç²’å­
    this.particleGeometry = new THREE.PlaneGeometry(1, 1);

    // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨
    this.particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        map: { value: this.particleTexture },
        time: { value: 0 }
      },
      vertexShader: `
        attribute vec3 instanceColor;
        attribute float instanceSize;
        
        varying vec3 vColor;
        varying vec2 vUv;
        
        void main() {
          vColor = instanceColor;
          vUv = uv;
          
          // ä½¿ç”¨å®ä¾‹å¤§å°ç¼©æ”¾
          vec3 scaled = position * instanceSize;
          
          // Billboard: å§‹ç»ˆé¢å‘æ‘„åƒæœº
          vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
          mvPosition.xy += scaled.xy;
          
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        
        varying vec3 vColor;
        varying vec2 vUv;
        
        void main() {
          vec4 texColor = texture2D(map, vUv);
          
          // åº”ç”¨å®ä¾‹é¢œè‰²
          vec3 finalColor = vColor * texColor.rgb;
          
          // HDR å‘å…‰
          finalColor *= 1.5;
          
          float alpha = texColor.a;
          
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      side: THREE.DoubleSide
    });

    // åˆ›å»ºå®ä¾‹åŒ–ç½‘æ ¼
    this.particleMesh = new THREE.InstancedMesh(
      this.particleGeometry,
      this.particleMaterial,
      this.config.maxParticles
    );
    this.particleMesh.frustumCulled = false;
    this.particleMesh.count = 0;

    // æ·»åŠ å®ä¾‹å±æ€§
    this.particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    
    const colorAttr = new THREE.InstancedBufferAttribute(this.particleColors, 3);
    colorAttr.setUsage(THREE.DynamicDrawUsage);
    this.particleGeometry.setAttribute('instanceColor', colorAttr);

    const sizeAttr = new THREE.InstancedBufferAttribute(this.particleSizes, 1);
    sizeAttr.setUsage(THREE.DynamicDrawUsage);
    this.particleGeometry.setAttribute('instanceSize', sizeAttr);

    this.scene.add(this.particleMesh);
  }

  /**
   * åˆ›å»ºå°¾ç„°ç²’å­ç³»ç»Ÿ
   */
  private createTrailParticleSystem(): void {
    const geometry = new THREE.PlaneGeometry(0.5, 0.5);

    this.trailMaterial = new THREE.ShaderMaterial({
      uniforms: {
        map: { value: this.particleTexture }
      },
      vertexShader: `
        attribute vec3 instanceColor;
        attribute float instanceSize;
        
        varying vec3 vColor;
        varying vec2 vUv;
        
        void main() {
          vColor = instanceColor;
          vUv = uv;
          
          vec3 scaled = position * instanceSize;
          vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
          mvPosition.xy += scaled.xy;
          
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        
        varying vec3 vColor;
        varying vec2 vUv;
        
        void main() {
          vec4 texColor = texture2D(map, vUv);
          vec3 finalColor = vColor * texColor.rgb * 2.0;
          gl_FragColor = vec4(finalColor, texColor.a * 0.8);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    this.trailMesh = new THREE.InstancedMesh(
      geometry,
      this.trailMaterial,
      this.config.maxTrailParticles
    );
    this.trailMesh.frustumCulled = false;
    this.trailMesh.count = 0;

    const colorAttr = new THREE.InstancedBufferAttribute(this.trailColors, 3);
    colorAttr.setUsage(THREE.DynamicDrawUsage);
    geometry.setAttribute('instanceColor', colorAttr);

    const sizeAttr = new THREE.InstancedBufferAttribute(this.trailSizes, 1);
    sizeAttr.setUsage(THREE.DynamicDrawUsage);
    geometry.setAttribute('instanceSize', sizeAttr);

    this.scene.add(this.trailMesh);
  }

  /**
   * åˆ›å»ºè¿è½½å™¨å‘å…‰ç‚¹
   */
  private createCarrierPoints(): void {
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute([], 3));

    this.carrierMaterial = new THREE.PointsMaterial({
      size: 3,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      sizeAttenuation: true
    });

    this.carrierPoints = new THREE.Points(geometry, this.carrierMaterial);
    this.scene.add(this.carrierPoints);
  }

  /**
   * æ›´æ–°æ¸²æŸ“ (æ¯å¸§è°ƒç”¨)
   */
  update(deltaTime: number): void {
    this.updateMainParticles();
    this.updateTrailParticles();
    this.updateCarrierPoints();

    // æ›´æ–°ç€è‰²å™¨æ—¶é—´
    if (this.particleMaterial) {
      this.particleMaterial.uniforms.time.value += deltaTime;
    }
  }

  /**
   * æ›´æ–°ä¸»ç²’å­
   */
  private updateMainParticles(): void {
    if (!this.particleMesh) return;

    const particles = this.director.getAllParticles();
    const count = Math.min(particles.length, this.config.maxParticles);

    for (let i = 0; i < count; i++) {
      const p = particles[i];

      // è®¾ç½®å˜æ¢çŸ©é˜µ
      this.dummy.position.set(p.position.x, p.position.y, p.position.z);
      this.dummy.updateMatrix();
      this.particleMesh.setMatrixAt(i, this.dummy.matrix);

      // è®¾ç½®é¢œè‰² (HSL to RGB)
      const rgb = this.hslToRgb(p.hue / 360, p.saturation, p.lightness);
      this.particleColors[i * 3] = rgb.r * this.config.glowMultiplier;
      this.particleColors[i * 3 + 1] = rgb.g * this.config.glowMultiplier;
      this.particleColors[i * 3 + 2] = rgb.b * this.config.glowMultiplier;

      // è®¾ç½®å¤§å°
      this.particleSizes[i] = p.size * p.alpha;
    }

    this.particleMesh.count = count;
    this.particleMesh.instanceMatrix.needsUpdate = true;

    const colorAttr = this.particleGeometry!.getAttribute('instanceColor') as THREE.BufferAttribute;
    colorAttr.needsUpdate = true;

    const sizeAttr = this.particleGeometry!.getAttribute('instanceSize') as THREE.BufferAttribute;
    sizeAttr.needsUpdate = true;
  }

  /**
   * æ›´æ–°å°¾ç„°ç²’å­
   */
  private updateTrailParticles(): void {
    if (!this.trailMesh) return;

    const particles = this.director.getAllTrailParticles();
    const count = Math.min(particles.length, this.config.maxTrailParticles);

    for (let i = 0; i < count; i++) {
      const p = particles[i];

      this.dummy.position.set(p.position.x, p.position.y, p.position.z);
      this.dummy.updateMatrix();
      this.trailMesh.setMatrixAt(i, this.dummy.matrix);

      const rgb = this.hslToRgb(p.hue / 360, p.saturation, p.lightness);
      this.trailColors[i * 3] = rgb.r * 2;
      this.trailColors[i * 3 + 1] = rgb.g * 2;
      this.trailColors[i * 3 + 2] = rgb.b * 2;

      this.trailSizes[i] = p.size * p.alpha;
    }

    this.trailMesh.count = count;
    this.trailMesh.instanceMatrix.needsUpdate = true;

    const geometry = this.trailMesh.geometry as THREE.BufferGeometry;
    (geometry.getAttribute('instanceColor') as THREE.BufferAttribute).needsUpdate = true;
    (geometry.getAttribute('instanceSize') as THREE.BufferAttribute).needsUpdate = true;
  }

  /**
   * æ›´æ–°è¿è½½å™¨å‘å…‰ç‚¹
   */
  private updateCarrierPoints(): void {
    if (!this.carrierPoints) return;

    const carriers = this.director.getAllCarriers();
    const positions: number[] = [];
    const colors: number[] = [];

    for (const carrier of carriers) {
      if (carrier.state.arrived) continue;

      const pos = carrier.state.position;
      positions.push(pos.x, pos.y, pos.z);

      // ç™½è‰²å‘å…‰
      colors.push(1, 1, 0.9);
    }

    const geometry = this.carrierPoints.geometry as THREE.BufferGeometry;
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
  }

  /**
   * HSL è½¬ RGB
   */
  private hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
    let r, g, b;

    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p: number, q: number, t: number) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return { r, g, b };
  }

  /**
   * è·å–æ¸²æŸ“ç»Ÿè®¡
   */
  getStats(): { mainParticles: number; trailParticles: number; carriers: number } {
    return {
      mainParticles: this.particleMesh?.count || 0,
      trailParticles: this.trailMesh?.count || 0,
      carriers: this.director.getAllCarriers().length
    };
  }

  /**
   * é”€æ¯æ¸²æŸ“å™¨
   */
  dispose(): void {
    if (this.particleMesh) {
      this.scene.remove(this.particleMesh);
      this.particleGeometry?.dispose();
      this.particleMaterial?.dispose();
    }

    if (this.trailMesh) {
      this.scene.remove(this.trailMesh);
      this.trailMesh.geometry.dispose();
      this.trailMaterial?.dispose();
    }

    if (this.carrierPoints) {
      this.scene.remove(this.carrierPoints);
      this.carrierPoints.geometry.dispose();
      this.carrierMaterial?.dispose();
    }

    if (this.particleTexture) {
      this.particleTexture.dispose();
    }

    console.log('[StreamRenderer] Disposed');
  }
}

// END OF FILE: src/core/stream/StreamRenderer.ts


// =============================================================================
// FILE: src\core\stream\types.ts
// =============================================================================

/**
 * Stream Architecture Types
 * 
 * "ä¸€åˆ‡çš†æµ" (Everything is a Stream) - çƒŸèŠ±å¼•æ“æ ¸å¿ƒæ•°æ®ç»“æ„
 * 
 * è®¾è®¡ç†å¿µï¼š
 * - çƒŸèŠ±æ˜¯æ—¶é—´è½´å®¹å™¨ (Timeline Container)
 * - å®¹å™¨å†…åŒ…å«ç²’å­æµ (Particle Streams)
 * - çˆ†ç‚¸åªæ˜¯çŠ¶æ€çªå˜ (State Mutation)
 */

import { Vector3 } from '../Vector3';
import { Shape3DType } from '../shapes/Shape3DFactory';

// ============================================================================
// åŸºç¡€æ•°å­¦ç±»å‹
// ============================================================================

/**
 * æ›²çº¿ç±»å‹ - ç”¨äºæè¿°éšæ—¶é—´å˜åŒ–çš„å€¼
 */
export type CurveType = 
  | 'linear'      // çº¿æ€§
  | 'easeIn'      // åŠ é€Ÿ
  | 'easeOut'     // å‡é€Ÿ
  | 'easeInOut'   // å…ˆåŠ é€Ÿåå‡é€Ÿ
  | 'bounce'      // å¼¹è·³
  | 'elastic'     // å¼¹æ€§
  | 'bezier';     // è´å¡å°”æ›²çº¿

/**
 * æ›²çº¿é…ç½®
 */
export interface Curve {
  type: CurveType;
  /** è´å¡å°”æ§åˆ¶ç‚¹ (ä»… bezier ç±»å‹éœ€è¦) */
  controlPoints?: [number, number, number, number];
  /** è‡ªå®šä¹‰å…³é”®å¸§ */
  keyframes?: Array<{ time: number; value: number }>;
}

/**
 * é¢œè‰²æ¸å˜
 */
export interface Gradient {
  /** æ¸å˜åœæ­¢ç‚¹ */
  stops: Array<{
    position: number;  // 0-1
    hue: number;       // 0-360
    saturation: number; // 0-1
    lightness: number;  // 0-1
    alpha?: number;     // 0-1
  }>;
  /** æ˜¯å¦å¾ªç¯ */
  loop?: boolean;
}

/**
 * 3Dè·¯å¾„ç±»å‹
 */
export type PathType = 
  | 'linear'      // ç›´çº¿
  | 'bezier_3d'   // 3Dè´å¡å°”æ›²çº¿
  | 'spiral'      // èºæ—‹
  | 'helix'       // èºæ—‹çº¿ (DNA)
  | 'arc';        // å¼§å½¢

/**
 * 3Dè·¯å¾„é…ç½®
 */
export interface Path3D {
  type: PathType;
  /** æ§åˆ¶ç‚¹æ•°ç»„ */
  points: Vector3[];
  /** é€Ÿåº¦æ›²çº¿ */
  speedCurve: Curve;
  /** èºæ—‹å‚æ•° (ä»… spiral/helix ç±»å‹) */
  spiralRadius?: number;
  spiralFrequency?: number;
}

// ============================================================================
// åŠ›åœºç³»ç»Ÿ
// ============================================================================

/**
 * åŠ›åœºç±»å‹
 */
export type ForceFieldType = 
  | 'gravity'     // é‡åŠ›
  | 'attraction'  // å¸å¼•åŠ› (å‘å¿ƒ)
  | 'repulsion'   // æ–¥åŠ› (ç¦»å¿ƒ)
  | 'drag'        // ç©ºæ°”é˜»åŠ›
  | 'wind'        // é£åŠ›
  | 'noise'       // å™ªç‚¹åŠ›åœº (æŸæ—å™ªå£°)
  | 'vortex'      // æ¶¡æ—‹åŠ›
  | 'turbulence'; // æ¹æµ

/**
 * åŠ›åœºé…ç½®
 */
export interface ForceField {
  type: ForceFieldType;
  /** åŠ›åœºå¼ºåº¦ */
  strength: number;
  /** åŠ›åœºä¸­å¿ƒ (å¸å¼•/æ–¥åŠ›/æ¶¡æ—‹éœ€è¦) */
  center?: Vector3;
  /** åŠ›åœºæ–¹å‘ (é‡åŠ›/é£åŠ›éœ€è¦) */
  direction?: Vector3;
  /** å½±å“åŠå¾„ (0 = æ— é™) */
  radius?: number;
  /** è¡°å‡æ›²çº¿ */
  falloff?: Curve;
  /** å™ªå£°é¢‘ç‡ (noise/turbulence éœ€è¦) */
  noiseFrequency?: number;
  /** å™ªå£°å¹…åº¦ */
  noiseAmplitude?: number;
  /** æ˜¯å¦å¯ç”¨ */
  enabled?: boolean;
}

// ============================================================================
// è¿è½½ç³»ç»Ÿ (Carrier)
// ============================================================================

/**
 * è¿è½½å™¨ç±»å‹
 */
export type CarrierType = 
  | 'projectile'  // å®ä½“å¼¹ä¸¸ (å¯è§æ‹–å°¾)
  | 'invisible'   // éšå½¢ä¼ é€ (ç›´æ¥åˆ°è¾¾)
  | 'comet';      // å½—æ˜Ÿå¼ (é•¿æ‹–å°¾)

/**
 * å°¾ç„°é…ç½®
 */
export interface TrailConfig {
  /** å‘å°„é€Ÿç‡ (ç²’å­/ç§’) */
  emissionRate: number;
  /** ç²’å­ç”Ÿå‘½å‘¨æœŸ */
  lifeTime: number;
  /** é¢œè‰²æ¸å˜ */
  colorGradient: Gradient;
  /** çº¹ç†ç±»å‹ */
  texture: 'spark' | 'smoke' | 'flame' | 'star';
  /** ç²’å­å¤§å° */
  size: number;
  /** å¤§å°éšæ—¶é—´å˜åŒ– */
  sizeCurve?: Curve;
}

/**
 * è¿è½½å™¨é…ç½®
 */
export interface CarrierConfig {
  type: CarrierType;
  /** é£è¡Œè·¯å¾„ */
  path: Path3D;
  /** é£è¡Œæ—¶é•¿ (ç§’) */
  duration: number;
  /** å°¾ç„°é…ç½® */
  trail?: TrailConfig;
  /** å‘å°„æ—¶çš„éŸ³æ•ˆ ID */
  launchSoundId?: string;
}

// ============================================================================
// æ‹“æ‰‘ç³»ç»Ÿ (Topology) - å½¢çŠ¶
// ============================================================================

/**
 * æ‹“æ‰‘æ¥æºç±»å‹
 */
export type TopologySourceType = 
  | 'mathematical_shape'  // æ•°å­¦å½¢çŠ¶ (çƒã€ç¯ã€èºæ—‹ç­‰)
  | 'model_mesh'          // 3Dæ¨¡å‹ç½‘æ ¼
  | 'text_points'         // æ–‡å­—ç‚¹é˜µ
  | 'image_points'        // å›¾ç‰‡è½®å»“ç‚¹
  | 'custom_points';      // è‡ªå®šä¹‰ç‚¹é›†

/**
 * æ‹“æ‰‘é…ç½®
 */
export interface TopologyConfig {
  type: TopologySourceType;
  /** å½¢çŠ¶æ ‡è¯† (Shape3DType æˆ–æ¨¡å‹æ–‡ä»¶å) */
  source: Shape3DType | string;
  /** ç²’å­åˆ†è¾¨ç‡ (ç›®æ ‡ç‚¹æ•°é‡) */
  resolution: number;
  /** ç¼©æ”¾æ¯”ä¾‹ */
  scale: number;
  /** æ—‹è½¬ (æ¬§æ‹‰è§’, åº¦) */
  rotation?: Vector3;
  /** ä¸­å¿ƒåç§» */
  offset?: Vector3;
}

// ============================================================================
// åŠ¨åŠ›å­¦ç³»ç»Ÿ (Dynamics) - è¿åŠ¨
// ============================================================================

/**
 * è¿‡æ¸¡æ¨¡å¼
 */
export type TransitionMode = 
  | 'explode'     // çˆ†ç‚¸ (å‘å¤–æ‰©æ•£)
  | 'implode'     // å†…çˆ† (å‘å†…æ”¶ç¼©)
  | 'morph'       // å˜å½¢ (å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡å½¢çŠ¶)
  | 'accumulate'  // æ±‡èš (ä»å››é¢å…«æ–¹é£å‘ç›®æ ‡)
  | 'scatter'     // æ•£å°„ (éšæœºé£æ•£)
  | 'maintain';   // ç»´æŒ (ä¿æŒå½“å‰å½¢çŠ¶)

/**
 * åŠ¨åŠ›å­¦é…ç½®
 */
export interface DynamicsConfig {
  /** è¿‡æ¸¡æ¨¡å¼ */
  transitionMode: TransitionMode;
  /** åˆå§‹é€Ÿåº¦é…ç½® */
  initialVelocity: {
    /** é€Ÿåº¦æ¨¡å¼ */
    mode: 'radial' | 'directional' | 'random' | 'target_seeking' | 'structure_preserve';
    /** é€Ÿåº¦å€¼æˆ–èŒƒå›´ */
    speed: number | [number, number];
    /** æ–¹å‘ (radial æ—¶ä¸ºä¸­å¿ƒç‚¹, directional æ—¶ä¸ºæ–¹å‘å‘é‡) */
    direction?: Vector3;
  };
  /** æ´»è·ƒçš„åŠ›åœº */
  forceFields: ForceField[];
  /** é€Ÿåº¦éšæ—¶é—´å˜åŒ–æ›²çº¿ */
  velocityProfile: Curve;
  /** å˜å½¢å¸å¼•åŠ›å¼ºåº¦ (morph æ¨¡å¼ç”¨) */
  morphAttractionStrength?: number;
  /** å˜å½¢é˜»å°¼ */
  morphDamping?: number;
}

// ============================================================================
// æ¸²æŸ“ç³»ç»Ÿ (Rendering)
// ============================================================================

/**
 * æ··åˆæ¨¡å¼
 */
export type BlendMode = 'additive' | 'normal' | 'multiply' | 'screen';

/**
 * æ¸²æŸ“é…ç½®
 */
export interface RenderingConfig {
  /** é¢œè‰²æ˜ å°„ */
  colorMap: Gradient;
  /** å¤§å°æ›²çº¿ */
  sizeCurve: Curve;
  /** åˆå§‹å¤§å° */
  baseSize: number;
  /** æ··åˆæ¨¡å¼ */
  blending: BlendMode;
  /** é€æ˜åº¦æ›²çº¿ */
  alphaCurve?: Curve;
  /** æ˜¯å¦å¯ç”¨é»‘ä½“è¾å°„ç€è‰² */
  useBlackbodyRadiation?: boolean;
  /** åˆå§‹æ¸©åº¦ (å¼€å°”æ–‡, é»‘ä½“è¾å°„ç”¨) */
  initialTemperature?: number;
  /** å†·å´é€Ÿç‡ */
  coolingRate?: number;
  /** å‘å…‰å¼ºåº¦ */
  glowIntensity?: number;
  /** çº¹ç†ç±»å‹ */
  texture?: 'circle' | 'star' | 'spark' | 'smoke';
}

// ============================================================================
// æœ‰æ•ˆè½½è·é˜¶æ®µ (Payload Stage)
// ============================================================================

/**
 * è½½è·é˜¶æ®µ - æè¿°ä¸€ä¸ªæ—¶é—´æ®µå†…çš„ç²’å­è¡Œä¸º
 */
export interface PayloadStage {
  /** é˜¶æ®µID */
  id: string;
  /** é˜¶æ®µåç§° */
  name?: string;
  /** ç›¸å¯¹äºè¿è½½ç»“æŸçš„æ—¶é—´åç§» (ç§’) */
  timeOffset: number;
  /** é˜¶æ®µæŒç»­æ—¶é—´ (ç§’) */
  duration: number;
  /** æ‹“æ‰‘é…ç½® (å½¢çŠ¶) */
  topology: TopologyConfig;
  /** åŠ¨åŠ›å­¦é…ç½® (è¿åŠ¨) */
  dynamics: DynamicsConfig;
  /** æ¸²æŸ“é…ç½® (æ ·å­) */
  rendering: RenderingConfig;
  /** é˜¶æ®µå¼€å§‹æ—¶çš„éŸ³æ•ˆ */
  soundId?: string;
  /** æ˜¯å¦é‡ç”¨ä¸Šä¸€é˜¶æ®µçš„ç²’å­ */
  reuseParticles?: boolean;
  /** è‡ªå®šä¹‰ç€è‰²å™¨åŠ¨ç”» */
  shaderAnimation?: {
    /** é¡¶ç‚¹ç€è‰²å™¨ä¿®æ”¹å™¨ */
    vertexModifier?: string;
    /** åŠ¨ç”»å‚æ•° */
    parameters?: Record<string, number>;
  };
}

// ============================================================================
// çƒŸèŠ±æ¸…å• (Firework Manifest) - é¡¶çº§é…ç½®
// ============================================================================

/**
 * å®Œæ•´çš„çƒŸèŠ±é…ç½®æ¸…å•
 * è¿™ä¸ªé…ç½®å¯ä»¥æè¿°ä¸–ç•Œä¸Šä»»ä½•ä¸€ç§çƒŸèŠ±
 */
export interface FireworkManifest {
  /** å”¯ä¸€ID */
  id: string;
  /** åç§° */
  name: string;
  /** æè¿° */
  description?: string;
  /** åˆ†ç±»æ ‡ç­¾ */
  tags?: string[];
  /** é¢„è®¡æ€»æ—¶é•¿ (ç§’) */
  duration: number;
  /** ç¼©ç•¥å›¾ URL */
  thumbnail?: string;
  
  // === é˜¶æ®µ 1: è¿è½½ç³»ç»Ÿ ===
  carrier: CarrierConfig;
  
  // === é˜¶æ®µ 2 & 3: æœ‰æ•ˆè½½è· (æ—¶é—´è§¦å‘çš„äº‹ä»¶é˜Ÿåˆ—) ===
  payload: {
    /** æŒ‰æ—¶é—´æ’åºçš„é˜¶æ®µæ•°ç»„ */
    stages: PayloadStage[];
  };
  
  // === å…ƒæ•°æ® ===
  metadata?: {
    author?: string;
    version?: string;
    createdAt?: string;
    updatedAt?: string;
  };
}

// ============================================================================
// è¿è¡Œæ—¶å®ä¾‹ç±»å‹ (Runtime Instance Types)
// ============================================================================

/**
 * ç²’å­æµçŠ¶æ€ - è¿è¡Œæ—¶çš„ç²’å­æ•°æ®
 */
export interface ParticleStreamState {
  /** å½“å‰ç²’å­æ•°é‡ */
  count: number;
  /** æ˜¯å¦æ´»è·ƒ */
  active: boolean;
  /** å½“å‰é˜¶æ®µç´¢å¼• */
  currentStageIndex: number;
  /** é˜¶æ®µå†…ç»è¿‡çš„æ—¶é—´ */
  stageElapsed: number;
  /** æ€»ç»è¿‡æ—¶é—´ */
  totalElapsed: number;
}

/**
 * è¿è¡Œæ—¶çƒŸèŠ±å®ä¾‹
 */
export interface FireworkInstance {
  /** å®ä¾‹ID */
  instanceId: string;
  /** å¯¹åº”çš„æ¸…å• */
  manifest: FireworkManifest;
  /** å‘å°„ä½ç½® */
  launchPosition: Vector3;
  /** ç›®æ ‡ä½ç½® */
  targetPosition: Vector3;
  /** å½“å‰çŠ¶æ€ */
  state: 'carrier' | 'payload' | 'extinct';
  /** ç²’å­æµçŠ¶æ€ */
  streamState: ParticleStreamState;
  /** åˆ›å»ºæ—¶é—´æˆ³ */
  createdAt: number;
  /** è‰²ç›¸è¦†ç›– */
  hueOverride?: number;
}

// ============================================================================
// æ›²çº¿è®¡ç®—å·¥å…·
// ============================================================================

/**
 * è¯„ä¼°æ›²çº¿å€¼
 */
export function evaluateCurve(curve: Curve, t: number): number {
  // é™åˆ¶ t åœ¨ 0-1 èŒƒå›´å†…
  t = Math.max(0, Math.min(1, t));
  
  switch (curve.type) {
    case 'linear':
      return t;
    
    case 'easeIn':
      return t * t;
    
    case 'easeOut':
      return 1 - (1 - t) * (1 - t);
    
    case 'easeInOut':
      return t < 0.5 
        ? 2 * t * t 
        : 1 - Math.pow(-2 * t + 2, 2) / 2;
    
    case 'bounce':
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      } else if (t < 2 / 2.75) {
        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      } else if (t < 2.5 / 2.75) {
        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      } else {
        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      }
    
    case 'elastic':
      if (t === 0 || t === 1) return t;
      const p = 0.3;
      return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
    
    case 'bezier':
      if (curve.controlPoints) {
        return cubicBezier(curve.controlPoints, t);
      }
      return t;
    
    default:
      return t;
  }
}

/**
 * ä¸‰æ¬¡è´å¡å°”æ›²çº¿è®¡ç®—
 */
function cubicBezier(points: [number, number, number, number], t: number): number {
  const [p1, p2, p3, p4] = points;
  const u = 1 - t;
  return u * u * u * p1 + 3 * u * u * t * p2 + 3 * u * t * t * p3 + t * t * t * p4;
}

/**
 * è¯„ä¼°æ¸å˜é¢œè‰²
 */
export function evaluateGradient(gradient: Gradient, t: number): { h: number; s: number; l: number; a: number } {
  // å¤„ç†å¾ªç¯
  if (gradient.loop) {
    t = t % 1;
  }
  t = Math.max(0, Math.min(1, t));
  
  const stops = gradient.stops;
  if (stops.length === 0) {
    return { h: 0, s: 1, l: 0.5, a: 1 };
  }
  if (stops.length === 1) {
    const s = stops[0];
    return { h: s.hue, s: s.saturation, l: s.lightness, a: s.alpha ?? 1 };
  }
  
  // æ‰¾åˆ° t æ‰€åœ¨çš„åŒºé—´
  let lower = stops[0];
  let upper = stops[stops.length - 1];
  
  for (let i = 0; i < stops.length - 1; i++) {
    if (t >= stops[i].position && t <= stops[i + 1].position) {
      lower = stops[i];
      upper = stops[i + 1];
      break;
    }
  }
  
  // æ’å€¼
  const range = upper.position - lower.position;
  const localT = range > 0 ? (t - lower.position) / range : 0;
  
  return {
    h: lerp(lower.hue, upper.hue, localT),
    s: lerp(lower.saturation, upper.saturation, localT),
    l: lerp(lower.lightness, upper.lightness, localT),
    a: lerp(lower.alpha ?? 1, upper.alpha ?? 1, localT)
  };
}

function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

// ============================================================================
// é¢„è®¾æ›²çº¿
// ============================================================================

export const PRESET_CURVES = {
  LINEAR: { type: 'linear' } as Curve,
  EASE_IN: { type: 'easeIn' } as Curve,
  EASE_OUT: { type: 'easeOut' } as Curve,
  EASE_IN_OUT: { type: 'easeInOut' } as Curve,
  BOUNCE: { type: 'bounce' } as Curve,
  ELASTIC: { type: 'elastic' } as Curve,
  FAST_THEN_SLOW: { type: 'easeOut' } as Curve,
  SLOW_THEN_FAST: { type: 'easeIn' } as Curve,
};

// ============================================================================
// é¢„è®¾æ¸å˜
// ============================================================================

export const PRESET_GRADIENTS = {
  FIRE: {
    stops: [
      { position: 0, hue: 60, saturation: 1, lightness: 0.9 },    // ç™½é»„
      { position: 0.3, hue: 45, saturation: 1, lightness: 0.6 },  // é‡‘é»„
      { position: 0.6, hue: 20, saturation: 1, lightness: 0.5 },  // æ©™çº¢
      { position: 1, hue: 0, saturation: 1, lightness: 0.3 },     // æ·±çº¢
    ]
  } as Gradient,
  
  GOLD: {
    stops: [
      { position: 0, hue: 50, saturation: 1, lightness: 0.8 },
      { position: 0.5, hue: 45, saturation: 1, lightness: 0.6 },
      { position: 1, hue: 35, saturation: 0.8, lightness: 0.4 },
    ]
  } as Gradient,
  
  RAINBOW: {
    stops: [
      { position: 0, hue: 0, saturation: 1, lightness: 0.5 },
      { position: 0.17, hue: 30, saturation: 1, lightness: 0.5 },
      { position: 0.33, hue: 60, saturation: 1, lightness: 0.5 },
      { position: 0.5, hue: 120, saturation: 1, lightness: 0.5 },
      { position: 0.67, hue: 240, saturation: 1, lightness: 0.5 },
      { position: 0.83, hue: 280, saturation: 1, lightness: 0.5 },
      { position: 1, hue: 330, saturation: 1, lightness: 0.5 },
    ],
    loop: true
  } as Gradient,
  
  ICE: {
    stops: [
      { position: 0, hue: 200, saturation: 1, lightness: 0.9 },
      { position: 0.5, hue: 210, saturation: 0.8, lightness: 0.6 },
      { position: 1, hue: 220, saturation: 0.5, lightness: 0.3 },
    ]
  } as Gradient,
  
  PHOENIX: {
    stops: [
      { position: 0, hue: 60, saturation: 1, lightness: 1 },      // ç™½è‰²æ ¸å¿ƒ
      { position: 0.2, hue: 50, saturation: 1, lightness: 0.7 },  // é‡‘é»„
      { position: 0.5, hue: 30, saturation: 1, lightness: 0.6 },  // æ©™è‰²
      { position: 0.8, hue: 15, saturation: 1, lightness: 0.5 },  // æ·±æ©™
      { position: 1, hue: 0, saturation: 0.6, lightness: 0.2 },   // ç°çƒ¬
    ]
  } as Gradient,
};

// ============================================================================
// é¢„è®¾åŠ›åœº
// ============================================================================

export const PRESET_FORCE_FIELDS = {
  EARTH_GRAVITY: {
    type: 'gravity',
    strength: 9.8,
    direction: { x: 0, y: -1, z: 0 } as Vector3,
  } as ForceField,
  
  LIGHT_GRAVITY: {
    type: 'gravity',
    strength: 2,
    direction: { x: 0, y: -1, z: 0 } as Vector3,
  } as ForceField,
  
  AIR_DRAG: {
    type: 'drag',
    strength: 0.02,
  } as ForceField,
  
  HEAVY_DRAG: {
    type: 'drag',
    strength: 0.1,
  } as ForceField,
  
  GENTLE_WIND: {
    type: 'wind',
    strength: 1,
    direction: { x: 1, y: 0, z: 0.3 } as Vector3,
  } as ForceField,
  
  TURBULENCE: {
    type: 'turbulence',
    strength: 5,
    noiseFrequency: 0.5,
    noiseAmplitude: 2,
  } as ForceField,
};

// END OF FILE: src/core/stream/types.ts


// =============================================================================
// FILE: src\core\TimeController.ts
// =============================================================================

// FILE: src/core/TimeController.ts
// æ—¶é—´æ§åˆ¶å™¨ - ç®¡ç†æ¨¡æ‹Ÿæ—¶é—´æµ

export class TimeController {
  public isPaused: boolean = false;
  public timeScale: number = 1.0;
  public virtualTime: number = 0;
  public deltaTime: number = 0;
  
  private lastRealTime: number = 0;
  private accumulatedTime: number = 0;

  constructor() {
    this.reset();
  }

  reset(): void {
    this.isPaused = false;
    this.timeScale = 1.0;
    this.virtualTime = 0;
    this.deltaTime = 0;
    this.lastRealTime = performance.now() / 1000;
    this.accumulatedTime = 0;
  }

  update(): void {
    const currentRealTime = performance.now() / 1000;
    const realDelta = currentRealTime - this.lastRealTime;
    this.lastRealTime = currentRealTime;

    if (this.isPaused) {
      this.deltaTime = 0;
      return;
    }

    this.deltaTime = realDelta * this.timeScale;
    this.virtualTime += this.deltaTime;
    this.accumulatedTime += this.deltaTime;
  }

  pause(): void {
    this.isPaused = true;
  }

  play(): void {
    this.isPaused = false;
    this.lastRealTime = performance.now() / 1000;
  }

  togglePause(): boolean {
    if (this.isPaused) {
      this.play();
    } else {
      this.pause();
    }
    return this.isPaused;
  }

  setTimeScale(scale: number): void {
    this.timeScale = Math.max(0.1, Math.min(10, scale));
  }

  getFormattedTime(): string {
    const totalSeconds = Math.floor(this.virtualTime);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  getProgress(duration: number): number {
    return duration > 0 ? Math.min(1, this.virtualTime / duration) : 0;
  }

  seekTo(time: number): void {
    this.virtualTime = Math.max(0, time);
    this.accumulatedTime = this.virtualTime;
  }
}

// END OF FILE: src/core/TimeController.ts


// =============================================================================
// FILE: src\core\timeline\TimelineManager.ts
// =============================================================================

// FILE: src/core/timeline/TimelineManager.ts
// æ—¶é—´çº¿ç®¡ç†å™¨ï¼šæ”¯æŒæ—¶é—´è½´æ§åˆ¶ã€å…³é”®å¸§æ ‡è®°ã€çŠ¶æ€å¿«ç…§

export interface TimelineKeyframe {
  id: string;
  time: number;           // ç§’
  label: string;
  type: 'launch' | 'explosion' | 'carnival' | 'custom';
  color: string;
  data?: any;             // é¢å¤–æ•°æ® (å¦‚å‘å°„å‚æ•°)
}

export interface TimelineState {
  currentTime: number;    // å½“å‰æ—¶é—´ (ç§’)
  duration: number;       // æ€»æ—¶é•¿ (ç§’)
  isPlaying: boolean;
  timeScale: number;      // 1x, 2x, 5x, 10x
  keyframes: TimelineKeyframe[];
}

export interface TimelineSnapshot {
  time: number;
  fireworkPositions: Array<{ id: string; x: number; y: number; z: number }>;
  particleCount: number;
  cameraPosition?: { x: number; y: number; z: number };
}

/**
 * æ—¶é—´çº¿ç®¡ç†å™¨
 * æ ¸å¿ƒèŒè´£ï¼š
 * 1. ç»´æŠ¤æ—¶é—´è½´çŠ¶æ€
 * 2. ç®¡ç†å…³é”®å¸§
 * 3. æ”¯æŒæ—¶é—´è·³è½¬å’Œå›æº¯
 * 4. æä¾›çŠ¶æ€å¿«ç…§æœºåˆ¶
 */
export class TimelineManager {
  private state: TimelineState;
  private snapshots: Map<number, TimelineSnapshot> = new Map();
  private snapshotInterval: number = 0.5; // æ¯0.5ç§’è‡ªåŠ¨å¿«ç…§
  private lastSnapshotTime: number = 0;
  private keyframeIdCounter: number = 0;
  
  // äº‹ä»¶å›è°ƒ
  private onTimeChangeCallbacks: Array<(time: number) => void> = [];
  private onKeyframeAddCallbacks: Array<(kf: TimelineKeyframe) => void> = [];
  private onSeekCallbacks: Array<(time: number) => void> = [];

  constructor() {
    this.state = {
      currentTime: 0,
      duration: 60, // é»˜è®¤60ç§’æ—¶é—´è½´
      isPlaying: true,
      timeScale: 1,
      keyframes: []
    };
  }

  // === åŸºç¡€æ§åˆ¶ ===
  
  play(): void {
    this.state.isPlaying = true;
  }

  pause(): void {
    this.state.isPlaying = false;
  }

  togglePlay(): boolean {
    this.state.isPlaying = !this.state.isPlaying;
    return this.state.isPlaying;
  }

  setTimeScale(scale: number): void {
    // é™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´
    this.state.timeScale = Math.max(0.1, Math.min(10, scale));
  }

  getTimeScale(): number {
    return this.state.timeScale;
  }

  // === æ—¶é—´æ“ä½œ ===

  /**
   * æ›´æ–°æ—¶é—´ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
   */
  update(deltaTime: number): void {
    if (!this.state.isPlaying) return;
    
    const scaledDelta = deltaTime * this.state.timeScale;
    this.state.currentTime += scaledDelta;
    
    // è‡ªåŠ¨å¿«ç…§
    if (this.state.currentTime - this.lastSnapshotTime >= this.snapshotInterval) {
      this.lastSnapshotTime = this.state.currentTime;
      // å¿«ç…§é€»è¾‘ç”±å¤–éƒ¨æä¾›
    }
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.onTimeChangeCallbacks.forEach(cb => cb(this.state.currentTime));
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šæ—¶é—´
   */
  seekTo(time: number): void {
    const clampedTime = Math.max(0, Math.min(this.state.duration, time));
    this.state.currentTime = clampedTime;
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.onSeekCallbacks.forEach(cb => cb(clampedTime));
    this.onTimeChangeCallbacks.forEach(cb => cb(clampedTime));
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šè¿›åº¦ (0-1)
   */
  seekToProgress(progress: number): void {
    this.seekTo(progress * this.state.duration);
  }

  /**
   * å¾®è°ƒæ—¶é—´ (ç”¨äºé”®ç›˜å¿«æ·é”®)
   */
  nudge(seconds: number): void {
    this.seekTo(this.state.currentTime + seconds);
  }

  getCurrentTime(): number {
    return this.state.currentTime;
  }

  getProgress(): number {
    return this.state.duration > 0 ? this.state.currentTime / this.state.duration : 0;
  }

  getDuration(): number {
    return this.state.duration;
  }

  setDuration(duration: number): void {
    this.state.duration = Math.max(10, duration);
  }

  isPlaying(): boolean {
    return this.state.isPlaying;
  }

  // === å…³é”®å¸§ç®¡ç† ===

  /**
   * æ·»åŠ å…³é”®å¸§
   */
  addKeyframe(label: string, type: TimelineKeyframe['type'], time?: number, data?: any): TimelineKeyframe {
    const kf: TimelineKeyframe = {
      id: `kf_${++this.keyframeIdCounter}`,
      time: time ?? this.state.currentTime,
      label,
      type,
      color: this.getKeyframeColor(type),
      data
    };
    
    this.state.keyframes.push(kf);
    this.state.keyframes.sort((a, b) => a.time - b.time);
    
    // è‡ªåŠ¨æ‰©å±•æ—¶é—´è½´
    if (kf.time > this.state.duration * 0.9) {
      this.state.duration = kf.time * 1.2;
    }
    
    this.onKeyframeAddCallbacks.forEach(cb => cb(kf));
    return kf;
  }

  /**
   * ç§»é™¤å…³é”®å¸§
   */
  removeKeyframe(id: string): void {
    this.state.keyframes = this.state.keyframes.filter(kf => kf.id !== id);
  }

  /**
   * è·å–æ‰€æœ‰å…³é”®å¸§
   */
  getKeyframes(): TimelineKeyframe[] {
    return [...this.state.keyframes];
  }

  /**
   * è·å–å½“å‰æ—¶é—´é™„è¿‘çš„å…³é”®å¸§
   */
  getNearbyKeyframes(range: number = 1): TimelineKeyframe[] {
    const t = this.state.currentTime;
    return this.state.keyframes.filter(kf => Math.abs(kf.time - t) <= range);
  }

  /**
   * è·³è½¬åˆ°ä¸‹ä¸€ä¸ªå…³é”®å¸§
   */
  jumpToNextKeyframe(): void {
    const next = this.state.keyframes.find(kf => kf.time > this.state.currentTime);
    if (next) this.seekTo(next.time);
  }

  /**
   * è·³è½¬åˆ°ä¸Šä¸€ä¸ªå…³é”®å¸§
   */
  jumpToPrevKeyframe(): void {
    const reversed = [...this.state.keyframes].reverse();
    const prev = reversed.find(kf => kf.time < this.state.currentTime - 0.1);
    if (prev) this.seekTo(prev.time);
  }

  private getKeyframeColor(type: TimelineKeyframe['type']): string {
    switch (type) {
      case 'launch': return '#10b981';    // ç»¿è‰²
      case 'explosion': return '#f59e0b'; // æ©™è‰²
      case 'carnival': return '#8b5cf6';  // ç´«è‰²
      case 'custom': return '#3b82f6';    // è“è‰²
      default: return '#6b7280';
    }
  }

  // === çŠ¶æ€å¿«ç…§ (ç”¨äºæ—¶é—´å›æº¯) ===

  /**
   * ä¿å­˜å½“å‰çŠ¶æ€å¿«ç…§
   */
  saveSnapshot(snapshot: Omit<TimelineSnapshot, 'time'>): void {
    const key = Math.floor(this.state.currentTime * 2) / 2; // 0.5ç§’ç²’åº¦
    this.snapshots.set(key, {
      time: this.state.currentTime,
      ...snapshot
    });
    
    // é™åˆ¶å¿«ç…§æ•°é‡ (ä¿ç•™æœ€è¿‘120ç§’)
    const maxSnapshots = 240;
    if (this.snapshots.size > maxSnapshots) {
      const oldest = Array.from(this.snapshots.keys()).sort((a, b) => a - b)[0];
      this.snapshots.delete(oldest);
    }
  }

  /**
   * è·å–æœ€è¿‘çš„å¿«ç…§
   */
  getNearestSnapshot(time: number): TimelineSnapshot | null {
    const key = Math.floor(time * 2) / 2;
    return this.snapshots.get(key) || null;
  }

  // === äº‹ä»¶è®¢é˜… ===

  onTimeChange(callback: (time: number) => void): () => void {
    this.onTimeChangeCallbacks.push(callback);
    return () => {
      this.onTimeChangeCallbacks = this.onTimeChangeCallbacks.filter(cb => cb !== callback);
    };
  }

  onKeyframeAdd(callback: (kf: TimelineKeyframe) => void): () => void {
    this.onKeyframeAddCallbacks.push(callback);
    return () => {
      this.onKeyframeAddCallbacks = this.onKeyframeAddCallbacks.filter(cb => cb !== callback);
    };
  }

  onSeek(callback: (time: number) => void): () => void {
    this.onSeekCallbacks.push(callback);
    return () => {
      this.onSeekCallbacks = this.onSeekCallbacks.filter(cb => cb !== callback);
    };
  }

  // === çŠ¶æ€è·å– ===

  getState(): Readonly<TimelineState> {
    return { ...this.state };
  }

  // === é‡ç½® ===

  reset(): void {
    this.state.currentTime = 0;
    this.state.keyframes = [];
    this.snapshots.clear();
    this.lastSnapshotTime = 0;
    this.keyframeIdCounter = 0;
  }
}

// å•ä¾‹å¯¼å‡º
export const timelineManager = new TimelineManager();

// END OF FILE: src/core/timeline/TimelineManager.ts


// =============================================================================
// FILE: src\core\trajectories\TrajectoryConfig.ts
// =============================================================================

// FILE: src/core/trajectories/TrajectoryConfig.ts
// è½¨è¿¹é…ç½®ç³»ç»Ÿ - æ‰©å±•å‚æ•°å’Œé¢„è®¾æ¨¡æ¿

import { TrajectoryType } from './TrajectoryFactory';

/**
 * åŠ é€Ÿåº¦æ¨¡å¼
 */
export enum AccelerationMode {
  CONSTANT = 'constant',       // æ’å®šåŠ é€Ÿåº¦
  INCREASING = 'increasing',   // æ¸å¢
  DECREASING = 'decreasing',   // æ¸å‡
  SINUSOIDAL = 'sinusoidal',   // æ­£å¼¦å˜åŒ–
  RANDOM = 'random',           // éšæœº
}

/**
 * é¢œè‰²æ¸å˜æ¨¡å¼
 */
export enum ColorGradientMode {
  NONE = 'none',               // å•è‰²
  LINEAR = 'linear',           // çº¿æ€§æ¸å˜
  RAINBOW = 'rainbow',         // å½©è™¹æ¸å˜
  FIRE = 'fire',               // ç«ç„°è‰²
  ICE = 'ice',                 // å†°è“è‰²
  GOLD = 'gold',               // é‡‘è‰²
  CUSTOM = 'custom',           // è‡ªå®šä¹‰
}

/**
 * è½¨è¿¹å®Œæ•´é…ç½®
 */
export interface TrajectoryConfig {
  // åŸºç¡€ç±»å‹
  type: TrajectoryType;
  
  // === å‘å°„æ§åˆ¶ ===
  launchRadius: number;        // å‘å°„èŒƒå›´åŠå¾„ (0-100m)
  launchCount: number;         // å‘å°„æ¬¡æ•° (1-100)
  launchInterval: number;      // å‘å°„é—´éš” (0.1-5s)
  
  // === è½¨è¿¹æ§åˆ¶ ===
  accelerationMode: AccelerationMode;
  rotationAngle: number;       // æ—‹è½¬è§’åº¦ (0-360Â°)
  waveAmplitude: number;       // æ³¢åŠ¨å¹…åº¦ (0-50m)
  waveFrequency: number;       // æ³¢åŠ¨é¢‘ç‡ (0.1-10)
  spiralRadius: number;        // èºæ—‹åŠå¾„ (0-30m)
  spiralSpeed: number;         // èºæ—‹é€Ÿåº¦ (0.1-20)
  
  // === ç‰©ç†å‚æ•° ===
  initialSpeed: number;        // åˆå§‹é€Ÿåº¦ (1-50)
  maxSpeed: number;            // æœ€å¤§é€Ÿåº¦ (1-100)
  gravityMultiplier: number;   // é‡åŠ›ç³»æ•° (0-3)
  dragCoefficient: number;     // é˜»åŠ›ç³»æ•° (0-1)
  
  // === è§†è§‰å‚æ•° ===
  trailWidth: number;          // è½¨è¿¹å®½åº¦ (0.1-5m)
  trailLength: number;         // æ‹–å°¾é•¿åº¦ (1-50)
  colorGradient: ColorGradientMode;
  primaryHue: number;          // ä¸»è‰²è°ƒ (0-360)
  secondaryHue: number;        // å‰¯è‰²è°ƒ (0-360)
  glowIntensity: number;       // å‘å…‰å¼ºåº¦ (0-5)
  particleDensity: number;     // ç²’å­å¯†åº¦ (0.1-3)
}

/**
 * è½¨è¿¹é…ç½®é»˜è®¤å€¼
 */
export const DEFAULT_TRAJECTORY_CONFIG: TrajectoryConfig = {
  type: TrajectoryType.LINEAR,
  
  // å‘å°„æ§åˆ¶
  launchRadius: 10,
  launchCount: 1,
  launchInterval: 0.5,
  
  // è½¨è¿¹æ§åˆ¶
  accelerationMode: AccelerationMode.CONSTANT,
  rotationAngle: 0,
  waveAmplitude: 0,
  waveFrequency: 1,
  spiralRadius: 5,
  spiralSpeed: 8,
  
  // ç‰©ç†å‚æ•°
  initialSpeed: 15,
  maxSpeed: 30,
  gravityMultiplier: 1,
  dragCoefficient: 0.02,
  
  // è§†è§‰å‚æ•°
  trailWidth: 1,
  trailLength: 20,
  colorGradient: ColorGradientMode.LINEAR,
  primaryHue: 45,
  secondaryHue: 60,
  glowIntensity: 1.5,
  particleDensity: 1,
};

/**
 * é¢„è®¾æ¨¡æ¿
 */
export interface TrajectoryPreset {
  id: string;
  name: string;
  icon: string;
  description: string;
  config: Partial<TrajectoryConfig>;
}

/**
 * å†…ç½®é¢„è®¾æ¨¡æ¿
 */
export const TRAJECTORY_PRESETS: TrajectoryPreset[] = [
  // === ç»å…¸è½¨è¿¹ ===
  {
    id: 'classic_straight',
    name: 'ç»å…¸ç›´çº¿',
    icon: 'â¬†ï¸',
    description: 'ç¬”ç›´å‘ä¸Šçš„ç»å…¸çƒŸèŠ±',
    config: {
      type: TrajectoryType.LINEAR,
      accelerationMode: AccelerationMode.CONSTANT,
      colorGradient: ColorGradientMode.FIRE,
    }
  },
  {
    id: 'golden_spiral',
    name: 'é»„é‡‘èºæ—‹',
    icon: 'ğŸŒ€',
    description: 'ä¼˜é›…çš„èºæ—‹ä¸Šå‡',
    config: {
      type: TrajectoryType.SPIRAL,
      spiralRadius: 12,
      spiralSpeed: 10,
      colorGradient: ColorGradientMode.GOLD,
      primaryHue: 45,
    }
  },
  {
    id: 'dragon_wave',
    name: 'é¾™èˆæ³¢æµª',
    icon: 'ğŸ‰',
    description: 'å¦‚é¾™è›‡èœ¿èœ’çš„Så‹è½¨è¿¹',
    config: {
      type: TrajectoryType.ZIGZAG,
      waveAmplitude: 25,
      waveFrequency: 4,
      colorGradient: ColorGradientMode.RAINBOW,
    }
  },
  {
    id: 'rocket_boost',
    name: 'ç«ç®­æ¨è¿›',
    icon: 'ğŸš€',
    description: 'å¤šçº§åŠ é€Ÿçš„ç«ç®­æ•ˆæœ',
    config: {
      type: TrajectoryType.TRIPLE_ACCELERATE,
      accelerationMode: AccelerationMode.INCREASING,
      colorGradient: ColorGradientMode.FIRE,
      glowIntensity: 3,
      trailWidth: 2,
    }
  },
  {
    id: 'phoenix_rise',
    name: 'å‡¤å‡°æ¶…æ§ƒ',
    icon: 'ğŸ”¥',
    description: 'å…ˆä¸‹å åæ€¥å‡çš„æˆå‰§æ€§è½¨è¿¹',
    config: {
      type: TrajectoryType.FALL_RISE,
      colorGradient: ColorGradientMode.FIRE,
      primaryHue: 15,
      secondaryHue: 45,
      glowIntensity: 4,
    }
  },
  {
    id: 'dna_helix',
    name: 'DNAåŒèºæ—‹',
    icon: 'ğŸ§¬',
    description: 'ç”Ÿå‘½çš„å¯†ç ',
    config: {
      type: TrajectoryType.HELIX,
      spiralRadius: 8,
      spiralSpeed: 12,
      colorGradient: ColorGradientMode.ICE,
      primaryHue: 180,
    }
  },
  
  // === é«˜çº§ç»„åˆ ===
  {
    id: 'chaos_wobble',
    name: 'æ··æ²Œæ‰°åŠ¨',
    icon: 'ğŸŒªï¸',
    description: 'ä¸å¯é¢„æµ‹çš„éšæœºè·¯å¾„',
    config: {
      type: TrajectoryType.WOBBLE,
      waveAmplitude: 15,
      colorGradient: ColorGradientMode.RAINBOW,
    }
  },
  {
    id: 'orbit_dance',
    name: 'è½¨é“ä¹‹èˆ',
    icon: 'ğŸª',
    description: 'å›´ç»•ä¸­å¿ƒæ—‹è½¬ä¸Šå‡',
    config: {
      type: TrajectoryType.ORBIT,
      spiralRadius: 15,
      colorGradient: ColorGradientMode.ICE,
    }
  },
];

/**
 * è½¨è¿¹é…ç½®ç®¡ç†å™¨
 */
export class TrajectoryConfigManager {
  private configs: Map<string, TrajectoryConfig> = new Map();
  private presets: TrajectoryPreset[] = [...TRAJECTORY_PRESETS];
  
  /**
   * è·å–é»˜è®¤é…ç½®
   */
  static getDefaultConfig(): TrajectoryConfig {
    return { ...DEFAULT_TRAJECTORY_CONFIG };
  }
  
  /**
   * åº”ç”¨é¢„è®¾
   */
  static applyPreset(preset: TrajectoryPreset): TrajectoryConfig {
    return {
      ...DEFAULT_TRAJECTORY_CONFIG,
      ...preset.config,
    };
  }
  
  /**
   * ä¿å­˜è‡ªå®šä¹‰é…ç½®
   */
  saveConfig(id: string, config: TrajectoryConfig): void {
    this.configs.set(id, { ...config });
  }
  
  /**
   * åŠ è½½é…ç½®
   */
  loadConfig(id: string): TrajectoryConfig | null {
    return this.configs.get(id) || null;
  }
  
  /**
   * è·å–æ‰€æœ‰é¢„è®¾
   */
  getPresets(): TrajectoryPreset[] {
    return [...this.presets];
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰é¢„è®¾
   */
  addPreset(preset: TrajectoryPreset): void {
    this.presets.push(preset);
  }
  
  /**
   * éªŒè¯é…ç½®æœ‰æ•ˆæ€§
   */
  static validateConfig(config: Partial<TrajectoryConfig>): boolean {
    if (config.launchRadius !== undefined) {
      if (config.launchRadius < 0 || config.launchRadius > 100) return false;
    }
    if (config.launchCount !== undefined) {
      if (config.launchCount < 1 || config.launchCount > 100) return false;
    }
    if (config.waveAmplitude !== undefined) {
      if (config.waveAmplitude < 0 || config.waveAmplitude > 50) return false;
    }
    return true;
  }
  
  /**
   * ç”Ÿæˆè½¨è¿¹æè¿°
   */
  static describeConfig(config: TrajectoryConfig): string {
    const parts: string[] = [];
    
    if (config.type) {
      parts.push(`è½¨è¿¹: ${config.type}`);
    }
    if (config.waveAmplitude > 0) {
      parts.push(`æ³¢å¹…: ${config.waveAmplitude}m`);
    }
    if (config.spiralRadius > 0 && (config.type === TrajectoryType.SPIRAL || config.type === TrajectoryType.HELIX)) {
      parts.push(`èºæ—‹: ${config.spiralRadius}m`);
    }
    if (config.colorGradient !== ColorGradientMode.NONE) {
      parts.push(`æ¸å˜: ${config.colorGradient}`);
    }
    
    return parts.join(' | ');
  }
}

// å•ä¾‹
export const trajectoryConfigManager = new TrajectoryConfigManager();

// END OF FILE: src/core/trajectories/TrajectoryConfig.ts


// =============================================================================
// FILE: src\core\trajectories\TrajectoryFactory.ts
// =============================================================================

// FILE: src/core/trajectories/TrajectoryFactory.ts
// è½¨è¿¹å·¥å‚ï¼šå®šä¹‰10+ç§çƒŸèŠ±ä¸Šå‡è½¨è¿¹

import { Vector3 } from '../Vector3';

/**
 * è½¨è¿¹ç±»å‹æšä¸¾
 * å®šä¹‰å„ç§ä¸Šå‡æ–¹å¼
 */
export enum TrajectoryType {
  // === åŸºç¡€è½¨è¿¹ ===
  LINEAR = 'linear',                     // ç›´çº¿ä¸Šå‡
  SPIRAL = 'spiral',                     // èºæ—‹ç›˜æ—‹
  ZIGZAG = 'zigzag',                     // Så‹æ‘‡æ‘†
  
  // === åŠ é€Ÿç±» ===
  ACCELERATE = 'accelerate',             // å•æ¬¡åŠ é€Ÿ
  DOUBLE_ACCELERATE = 'double_accelerate', // äºŒæ¬¡åŠ é€Ÿ
  TRIPLE_ACCELERATE = 'triple_accelerate', // ä¸‰æ¬¡åŠ é€Ÿ
  DECELERATE = 'decelerate',             // å‡é€Ÿ
  MIXED_SPEED = 'mixed_speed',           // æ··åˆå˜é€Ÿ
  
  // === æ›²çº¿ç±» ===
  BEZIER_CURVE = 'bezier_curve',         // è´å¡å°”æ›²çº¿
  PARABOLA = 'parabola',                 // æŠ›ç‰©çº¿
  SINE_WAVE = 'sine_wave',               // æ­£å¼¦æ³¢
  HELIX = 'helix',                       // èºæ—‹çº¿
  
  // === ç»„åˆç±» ===
  LINEAR_TO_CURVE = 'linear_to_curve',   // ç›´çº¿å˜æ›²çº¿
  CURVE_TO_LINEAR = 'curve_to_linear',   // æ›²çº¿å˜ç›´çº¿
  MULTI_SEGMENT = 'multi_segment',       // å¤šæ®µè½¨è¿¹
  
  // === ç‰¹æ®Šç±» ===
  WOBBLE = 'wobble',                     // éšæœºæ‰°åŠ¨
  FALL_RISE = 'fall_rise',               // å…ˆè½åå‡
  ORBIT = 'orbit',                       // ç»•åœˆä¸Šå‡
}

/**
 * è½¨è¿¹æ˜¾ç¤ºä¿¡æ¯
 */
export const TRAJECTORY_INFO: Record<TrajectoryType, { name: string; icon: string; description: string }> = {
  [TrajectoryType.LINEAR]: { name: 'ç›´çº¿å‡ç©º', icon: 'â¬†ï¸', description: 'ç¬”ç›´å‘ä¸Šé£è¡Œ' },
  [TrajectoryType.SPIRAL]: { name: 'èºæ—‹ç›˜æ—‹', icon: 'ğŸŒ€', description: 'æ—‹è½¬ä¸Šå‡å¦‚é¾™å·é£' },
  [TrajectoryType.ZIGZAG]: { name: 'Så‹æ‘‡æ‘†', icon: 'ã€°ï¸', description: 'å·¦å³æ‘†åŠ¨ä¸Šå‡' },
  
  [TrajectoryType.ACCELERATE]: { name: 'æé€Ÿæ¨è¿›', icon: 'ğŸš€', description: 'ä¸­é€”çªç„¶åŠ é€Ÿ' },
  [TrajectoryType.DOUBLE_ACCELERATE]: { name: 'äºŒæ¬¡åŠ é€Ÿ', icon: 'âš¡âš¡', description: 'ä¸¤æ¬¡çˆ†å‘åŠ é€Ÿ' },
  [TrajectoryType.TRIPLE_ACCELERATE]: { name: 'ä¸‰æ¬¡åŠ é€Ÿ', icon: 'âš¡âš¡âš¡', description: 'ä¸‰çº§ç«ç®­æ¨è¿›' },
  [TrajectoryType.DECELERATE]: { name: 'æ¸è¡Œæ¸ç¼“', icon: 'ğŸ¢', description: 'è¶Šæ¥è¶Šæ…¢ç„¶åçˆ†ç‚¸' },
  [TrajectoryType.MIXED_SPEED]: { name: 'æ··åˆå˜é€Ÿ', icon: 'ğŸ¢', description: 'åŠ é€Ÿå‡é€Ÿäº¤æ›¿' },
  
  [TrajectoryType.BEZIER_CURVE]: { name: 'è´å¡å°”æ›²çº¿', icon: 'ğŸ“', description: 'å¹³æ»‘å¼§çº¿è½¨è¿¹' },
  [TrajectoryType.PARABOLA]: { name: 'æŠ›ç‰©çº¿', icon: 'ğŸ¹', description: 'æ–œæŠ›+ä¸Šå‡' },
  [TrajectoryType.SINE_WAVE]: { name: 'æ­£å¼¦æ³¢', icon: 'ğŸ“Š', description: 'æ­£å¼¦æ³¢åŠ¨ä¸Šå‡' },
  [TrajectoryType.HELIX]: { name: '3Dèºæ—‹', icon: 'ğŸ§¬', description: 'DNAåŒèºæ—‹ä¸Šå‡' },
  
  [TrajectoryType.LINEAR_TO_CURVE]: { name: 'ç›´åå¼¯', icon: 'â†—ï¸', description: 'ç›´çº¿åè½¬å¼¯' },
  [TrajectoryType.CURVE_TO_LINEAR]: { name: 'å¼¯åç›´', icon: 'â†–ï¸', description: 'å¼¯æ›²åå˜ç›´' },
  [TrajectoryType.MULTI_SEGMENT]: { name: 'å¤šæ®µæŠ˜çº¿', icon: 'ğŸ“ˆ', description: 'å¤šç‚¹è½¬æŠ˜' },
  
  [TrajectoryType.WOBBLE]: { name: 'éšæœºæ‰°åŠ¨', icon: 'ğŸ«¨', description: 'ä¸è§„åˆ™æŠ–åŠ¨' },
  [TrajectoryType.FALL_RISE]: { name: 'å…ˆè½åèµ·', icon: 'â¤µï¸', description: 'å…ˆä¸‹å å†æ€¥å‡' },
  [TrajectoryType.ORBIT]: { name: 'ç»•åœˆä¸Šå‡', icon: 'ğŸ”„', description: 'å›´ç»•ä¸­å¿ƒèºæ—‹' },
};

/**
 * è½¨è¿¹çŠ¶æ€
 */
export interface TrajectoryState {
  lifeTime: number;
  phase: number;        // å½“å‰é˜¶æ®µ(0-1)
  segmentIndex: number; // å¤šæ®µè½¨è¿¹æ®µç´¢å¼•
}

/**
 * è½¨è¿¹è®¡ç®—å™¨
 * æ ¹æ®è½¨è¿¹ç±»å‹è®¡ç®—é€Ÿåº¦ä¿®æ­£
 */
export class TrajectoryCalculator {
  private type: TrajectoryType;
  private state: TrajectoryState;
  
  // è½¨è¿¹å‚æ•°
  private spiralFrequency: number = 10;
  private spiralAmplitude: number = 0.6;
  private waveFrequency: number = 8;
  private waveAmplitude: number = 0.8;
  
  constructor(type: TrajectoryType) {
    this.type = type;
    this.state = {
      lifeTime: 0,
      phase: 0,
      segmentIndex: 0
    };
  }
  
  /**
   * è®¡ç®—å½“å‰å¸§çš„é€Ÿåº¦ä¿®æ­£
   * @param velocity å½“å‰é€Ÿåº¦
   * @param gravity é‡åŠ›ç³»æ•°
   * @param deltaTime æ—¶é—´å¢é‡
   * @returns ä¿®æ­£åçš„é€Ÿåº¦
   */
  calculate(
    velocity: Vector3,
    gravity: number,
    deltaTime: number
  ): Vector3 {
    const dt = deltaTime * 60;
    this.state.lifeTime += deltaTime;
    const t = this.state.lifeTime;
    
    const result = velocity.clone();
    
    // ç¼©æ”¾ç³»æ•°ï¼šé˜²æ­¢æ°´å¹³åŠ›è¿‡å¤§å¯¼è‡´æ— æ³•å‡ç©º
    // åŸæ¥çš„ç³»æ•° (0.3-0.6) å¤ªå¤§ï¼Œç›¸å½“äºæ¯å¸§å¢åŠ å·¨å¤§é€Ÿåº¦ï¼Œå¯¼è‡´ç¬é—´å¹³ç§»
    // è°ƒæ•´ä¸º 0.02 - 0.05 çº§åˆ«ï¼Œé…åˆ gravity (~0.005)
    
    switch (this.type) {
      // === åŸºç¡€è½¨è¿¹ ===
      case TrajectoryType.LINEAR:
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.SPIRAL: {
        const angle = t * this.spiralFrequency;
        // ä¿®æ­£ï¼šå¢åŠ  * dtï¼Œä¸”å¤§å¹…å‡å°å¹…åº¦
        result.x += Math.cos(angle) * 0.04 * dt;
        result.z += Math.sin(angle) * 0.04 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.ZIGZAG: {
        result.x += Math.cos(t * this.waveFrequency) * 0.05 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === åŠ é€Ÿç±» ===
      case TrajectoryType.ACCELERATE:
        // å‡å°åŠ é€Ÿå¹…åº¦ï¼Œæ›´ç¬¦åˆç‰©ç†æƒ¯æ€§
        if (t < 0.5) result.y -= gravity * 1.5 * dt;
        else if (t < 1.0) result.y += 0.08 * dt; // åŸ 0.3
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DOUBLE_ACCELERATE:
        if (t < 0.3) result.y -= gravity * 1.2 * dt;
        else if (t < 0.5) result.y += 0.1 * dt;  
        else if (t < 0.8) result.y -= gravity * 1.0 * dt;
        else if (t < 1.0) result.y += 0.15 * dt;  
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.TRIPLE_ACCELERATE:
        if (t < 0.2) result.y -= gravity * 1.0 * dt;
        else if (t < 0.3) result.y += 0.1 * dt;  
        else if (t < 0.5) result.y -= gravity * 0.8 * dt;
        else if (t < 0.6) result.y += 0.12 * dt; 
        else if (t < 0.8) result.y -= gravity * 0.6 * dt;
        else if (t < 0.9) result.y += 0.15 * dt; 
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DECELERATE: {
        const decel = Math.max(0.9, 1 - t * 0.1); // å‡ç¼“é˜»å°¼
        result.y -= gravity * 1.5 * dt;
        result.x *= decel;
        result.z *= decel;
        break;
      }
      
      case TrajectoryType.MIXED_SPEED: {
        const cycle = Math.sin(t * 4) * 0.5 + 0.5;
        result.y -= gravity * (0.8 + cycle * 0.8) * dt;
        if (cycle > 0.7) result.y += 0.05 * dt;
        break;
      }
      
      // === æ›²çº¿ç±» ===
      case TrajectoryType.BEZIER_CURVE: {
        const bezierT = Math.min(1, t / 2);
        const curveOffset = Math.sin(bezierT * Math.PI) * 2;
        result.x += curveOffset * 0.02 * dt; 
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.PARABOLA: {
        const paraT = Math.min(1, t / 1.5);
        result.x += (1 - paraT) * 0.05 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.SINE_WAVE: {
        const sinOffset = Math.sin(t * 6) * 1.5;
        result.x += sinOffset * 0.03 * dt;
        result.z += Math.cos(t * 6) * 0.8 * 0.03 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.HELIX: {
        const helixAngle = t * 8;
        const helixRadius = 0.4 + t * 0.1;
        result.x += Math.cos(helixAngle) * helixRadius * 0.1 * dt; // åŸä¹˜æ•° implicit 1.0
        result.z += Math.sin(helixAngle) * helixRadius * 0.1 * dt;
        result.y -= gravity * 1.2 * dt;
        break;
      }
      
      // === ç»„åˆç±» ===
      case TrajectoryType.LINEAR_TO_CURVE:
        if (t < 1.0) {
          result.y -= gravity * 1.5 * dt;
        } else {
          const curveAngle = (t - 1.0) * 5;
          result.x += Math.sin(curveAngle) * 0.06 * dt;
          result.z += Math.cos(curveAngle) * 0.04 * dt;
          result.y -= gravity * 1.8 * dt;
        }
        break;
        
      case TrajectoryType.CURVE_TO_LINEAR:
        if (t < 1.0) {
          const curveAngle = t * 5;
          result.x += Math.sin(curveAngle) * 0.06 * dt;
          result.z += Math.cos(curveAngle) * 0.04 * dt;
          result.y -= gravity * 1.2 * dt;
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.MULTI_SEGMENT: {
        const segment = Math.floor(t / 0.5);
        const angles = [0, Math.PI/4, -Math.PI/4, Math.PI/2, 0];
        const idx = Math.min(segment, angles.length - 1);
        result.x += Math.sin(angles[idx]) * 0.06 * dt; // åŸ 0.3
        result.z += Math.cos(angles[idx]) * 0.04 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === ç‰¹æ®Šç±» ===
      case TrajectoryType.WOBBLE:
        result.x += (Math.random() - 0.5) * 0.1 * dt; // åŸ 1.0
        result.z += (Math.random() - 0.5) * 0.1 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.FALL_RISE:
        if (t < 0.3) {
          result.y -= gravity * 2.5 * dt; 
        } else if (t < 0.6) {
          result.y += 0.2 * dt; // åŸ 0.8
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.ORBIT: {
        const orbitAngle = t * 6;
        const orbitRadius = 0.6;
        result.x = Math.cos(orbitAngle) * orbitRadius * 0.05 * dt;
        result.z = Math.sin(orbitAngle) * orbitRadius * 0.05 * dt;
        result.y -= gravity * 1.3 * dt;
        break;
      }
      
      default:
        result.y -= gravity * 1.5 * dt;
    }
    
    return result;
  }
  
  /**
   * è·å–è½¨è¿¹ç±»å‹
   */
  getType(): TrajectoryType {
    return this.type;
  }
  
  /**
   * è·å–å½“å‰è¿è¡Œæ—¶é—´
   */
  getLifeTime(): number {
    return this.state.lifeTime;
  }
}

/**
 * è½¨è¿¹å·¥å‚
 * åˆ›å»ºå’Œç®¡ç†è½¨è¿¹è®¡ç®—å™¨
 */
export class TrajectoryFactory {
  private static allTypes: TrajectoryType[] = Object.values(TrajectoryType);
  
  /**
   * åˆ›å»ºæŒ‡å®šç±»å‹çš„è½¨è¿¹è®¡ç®—å™¨
   */
  static create(type: TrajectoryType): TrajectoryCalculator {
    return new TrajectoryCalculator(type);
  }
  
  /**
   * åˆ›å»ºéšæœºç±»å‹çš„è½¨è¿¹è®¡ç®—å™¨
   */
  static createRandom(): TrajectoryCalculator {
    const randomType = this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * ä»ç»™å®šåˆ—è¡¨ä¸­éšæœºåˆ›å»º
   */
  static createFromList(types: TrajectoryType[]): TrajectoryCalculator {
    if (types.length === 0) return this.create(TrajectoryType.LINEAR);
    const randomType = types[Math.floor(Math.random() * types.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * è·å–æ‰€æœ‰è½¨è¿¹ç±»å‹
   */
  static getAllTypes(): TrajectoryType[] {
    return [...this.allTypes];
  }
  
  /**
   * è·å–è½¨è¿¹ä¿¡æ¯
   */
  static getInfo(type: TrajectoryType): { name: string; icon: string; description: string } {
    return TRAJECTORY_INFO[type];
  }
}

// END OF FILE: src/core/trajectories/TrajectoryFactory.ts


// =============================================================================
// FILE: src\core\Vector2.ts
// =============================================================================


export class Vector2 {
  constructor(public x: number = 0, public y: number = 0) {}

  add(v: Vector2): Vector2 {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  multiply(scalar: number): Vector2 {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  static fromAngle(angle: number, length: number): Vector2 {
    return new Vector2(Math.cos(angle) * length, Math.sin(angle) * length);
  }

  clone(): Vector2 {
    return new Vector2(this.x, this.y);
  }
}


// =============================================================================
// FILE: src\core\Vector3.ts
// =============================================================================

/**
 * 3D Vector class for the 3D firework system
 */
export class Vector3 {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  add(v: Vector3): Vector3 {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  sub(v: Vector3): Vector3 {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  multiply(scalar: number): Vector3 {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  // Alias for compatibility with THREE.js-like APIs
  multiplyScalar(scalar: number): Vector3 {
    return this.multiply(scalar);
  }

  length(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  normalize(): Vector3 {
    const len = this.length();
    if (len > 0) {
      this.x /= len;
      this.y /= len;
      this.z /= len;
    }
    return this;
  }

  distanceTo(v: Vector3): number {
    const dx = this.x - v.x;
    const dy = this.y - v.y;
    const dz = this.z - v.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  static fromSpherical(theta: number, phi: number, radius: number): Vector3 {
    return new Vector3(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  clone(): Vector3 {
    return new Vector3(this.x, this.y, this.z);
  }

  toArray(): [number, number, number] {
    return [this.x, this.y, this.z];
  }
}


// =============================================================================
// FILE: src\main.tsx
// =============================================================================


import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './styles/index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// =============================================================================
// FILE: src\styles\index.css
// =============================================================================

/* Main styles for Celestial Fireworks Pro */
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #050505;
  user-select: none;
}

.custom-scrollbar::-webkit-scrollbar { width: 4px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }


// =============================================================================
// FILE: src\three-examples.d.ts
// =============================================================================

declare module 'three/examples/jsm/controls/OrbitControls' {
    import { Camera, EventDispatcher, MOUSE, TOUCH, Vector3 } from 'three';
    export class OrbitControls extends EventDispatcher {
        constructor(camera: Camera, domElement?: HTMLElement);
        object: Camera;
        domElement: HTMLElement | HTMLDocument;
        enabled: boolean;
        target: Vector3;
        minDistance: number;
        maxDistance: number;
        minZoom: number;
        maxZoom: number;
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        enableDamping: boolean;
        dampingFactor: number;
        enableZoom: boolean;
        zoomSpeed: number;
        enableRotate: boolean;
        rotateSpeed: number;
        enablePan: boolean;
        panSpeed: number;
        screenSpacePanning: boolean;
        keyPanSpeed: number;
        autoRotate: boolean;
        autoRotateSpeed: number;
        enableKeys: boolean;
        keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number };
        mouseButtons: { LEFT: MOUSE; MIDDLE: MOUSE; RIGHT: MOUSE };
        touches: { ONE: TOUCH; TWO: TOUCH };
        update(): boolean;
        saveState(): void;
        reset(): void;
        dispose(): void;
        getPolarAngle(): number;
        getAzimuthalAngle(): number;
        // EventDispatcher mixins
        addEventListener(type: string, listener: (event: any) => void): void;
        hasEventListener(type: string, listener: (event: any) => void): boolean;
        removeEventListener(type: string, listener: (event: any) => void): void;
        dispatchEvent(event: { type: string; [key: string]: any }): void;
    }
}

declare module 'three/examples/jsm/postprocessing/EffectComposer' {
    import { WebGLRenderer, WebGLRenderTarget, Scene, Camera } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class EffectComposer {
        constructor(renderer: WebGLRenderer, renderTarget?: WebGLRenderTarget);
        renderTarget1: WebGLRenderTarget;
        renderTarget2: WebGLRenderTarget;
        writeBuffer: WebGLRenderTarget;
        readBuffer: WebGLRenderTarget;
        passes: Pass[];
        copyPass: Pass;
        clock: any;
        renderToScreen: boolean;
        addPass(pass: Pass): void;
        insertPass(pass: Pass, index: number): void;
        removePass(pass: Pass): void;
        render(deltaTime?: number): void;
        reset(renderTarget?: WebGLRenderTarget): void;
        setSize(width: number, height: number): void;
        setPixelRatio(pixelRatio: number): void;
        dispose(): void;
    }
}

declare module 'three/examples/jsm/postprocessing/RenderPass' {
    import { Scene, Camera, Color, Material } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class RenderPass extends Pass {
        constructor(scene: Scene, camera: Camera, overrideMaterial?: Material, clearColor?: Color, clearAlpha?: number);
        scene: Scene;
        camera: Camera;
        overrideMaterial: Material;
        clearColor: Color;
        clearAlpha: number;
        clear: boolean;
    }
}

declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
    import { Vector2, Color } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class UnrealBloomPass extends Pass {
        constructor(resolution: Vector2, strength: number, radius: number, threshold: number);
        resolution: Vector2;
        strength: number;
        radius: number;
        threshold: number;
        compositeMaterial: any;
        bloomTintColors: Color[];
        copyUniforms: any;
        materialCopy: any;
        oldClearColor: Color;
        oldClearAlpha: number;
    }
}

declare module 'three/examples/jsm/postprocessing/ShaderPass' {
    import { ShaderMaterial, WebGLRenderer, WebGLRenderTarget } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class ShaderPass extends Pass {
        constructor(shader: any, textureID?: string);
        textureID: string;
        uniforms: { [uniform: string]: { value: any } };
        material: ShaderMaterial;
        fsQuad: any;
        render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    }
}

declare module 'three/examples/jsm/postprocessing/OutputPass' {
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class OutputPass extends Pass {
        constructor();
    }
}

declare module 'three/examples/jsm/postprocessing/Pass' {
    import { WebGLRenderer, WebGLRenderTarget } from 'three';
    export class Pass {
        constructor();
        enabled: boolean;
        needsSwap: boolean;
        clear: boolean;
        renderToScreen: boolean;
        setSize(width: number, height: number): void;
        render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    }
}



// =============================================================================
// FILE: src\types\index.ts
// =============================================================================

// FILE: src/types/index.ts

export enum ExplosionType {
  // === ç»å…¸ ===
  SPHERE = 'æ ‡å‡†çƒå½¢',
  BURST = 'é«˜äº®çˆ†å‘',
  RING = 'æ˜Ÿç¯',
  DOUBLE_RING = 'åŒå±‚ç¯',
  WILLOW = 'é‡‘æŸ³å‚ä¸',
  STAGED = 'å­æ¯è¿çˆ†',
  FLASH = 'é›·éœ†é—ªå…‰',
  GLITTER = 'ç’€ç’¨æ˜Ÿå°˜',

  // === è‡ªç„¶ ===
  FLOWER = 'ç››ä¸–ç‰¡ä¸¹',
  BUTTERFLY = 'å¹»å½©è´è¶',
  FALLING_LEAVES = 'æ¼«å¤©è½å¶',
  SNOWFLAKE = 'å…­è§’é›ªèŠ±',
  FISH = 'é”¦é²¤æ¸¸åŠ¨',
  CAT_FACE = 'çŒ«å’ªç¬‘è„¸',

  // === å‡ ä½•/æŠ½è±¡ ===
  CUBE = 'é‡å­ç«‹æ–¹',
  PYRAMID = 'é‡‘å­—å¡”',
  STAR = 'äº”è§’æ˜Ÿ',
  HEART = 'çˆ±å¿ƒ',
  HEART_BEAT = 'è·³åŠ¨ä¹‹å¿ƒ',
  SMILE = 'ç¬‘è„¸',
  SPIRAL = 'é˜¿åŸºç±³å¾·',

  // === å®å¤§ ===
  GALAXY = 'é“¶æ²³ç³»',
  SATURN = 'åœŸæ˜Ÿç¯',
  HELIX = 'DNAåŒèºæ—‹',
  DRAGON = 'æ¸¸é¾™æˆç ',
  GREAT_WALL = 'ä¸‡é‡Œé•¿åŸ',
  ZODIAC = 'çµè›‡ç‹‚èˆ',
  GHOST = 'å¹½çµé­…å½±',
  CROSS_STEP = 'åå­—å˜è‰²',

  // === åˆ›æ„ ===
  ATOM = 'åŸå­ç»“æ„',
  FAN = 'å­”é›€å¼€å±',
  WATERFALL = 'ä¹å¤©ç€‘å¸ƒ',
  CHAOS = 'æ··æ²Œç†è®º',
  TEXT_HI = 'å­—å½¢:Hi',
  CROWN = 'çš‡å† '
}

// å›¾æ ‡æ˜ å°„ï¼šå®ç°"å›¾æ–‡å¹¶èŒ‚"
export const SHAPE_ICONS: Record<ExplosionType, string> = {
  [ExplosionType.SPHERE]: 'ğŸ’¥', [ExplosionType.BURST]: 'âœ¨',
  [ExplosionType.RING]: 'â­•', [ExplosionType.DOUBLE_RING]: 'â—',
  [ExplosionType.WILLOW]: 'ğŸ‹', [ExplosionType.STAGED]: 'ğŸ†',
  [ExplosionType.FLASH]: 'âš¡', [ExplosionType.GLITTER]: 'âœ¨', [ExplosionType.FLOWER]: 'ğŸŒº',
  [ExplosionType.BUTTERFLY]: 'ğŸ¦‹', [ExplosionType.FALLING_LEAVES]: 'ğŸ‚',
  [ExplosionType.SNOWFLAKE]: 'â„ï¸', [ExplosionType.FISH]: 'ğŸŸ',
  [ExplosionType.CAT_FACE]: 'ğŸ±', [ExplosionType.CUBE]: 'ğŸ§Š',
  [ExplosionType.PYRAMID]: 'ğŸ”º', [ExplosionType.STAR]: 'â­',
  [ExplosionType.SMILE]: 'ğŸ™‚', [ExplosionType.SPIRAL]: 'ğŸ¥',
  [ExplosionType.HEART]: 'â¤ï¸', [ExplosionType.HEART_BEAT]: 'ğŸ’“',
  [ExplosionType.GALAXY]: 'ğŸŒŒ', [ExplosionType.SATURN]: 'ğŸª', [ExplosionType.HELIX]: 'ğŸ§¬',
  [ExplosionType.DRAGON]: 'ğŸ‰', [ExplosionType.GREAT_WALL]: 'ğŸ§±',
  [ExplosionType.ZODIAC]: 'ğŸ', [ExplosionType.GHOST]: 'ğŸ‘»',
  [ExplosionType.CROSS_STEP]: 'âœ¥', [ExplosionType.ATOM]: 'âš›ï¸',
  [ExplosionType.FAN]: 'ğŸª­', [ExplosionType.WATERFALL]: 'ğŸŒŠ',
  [ExplosionType.CHAOS]: 'ğŸ²', [ExplosionType.TEXT_HI]: 'H',
  [ExplosionType.CROWN]: 'ğŸ‘‘'
};

export enum AscensionType {
  LINEAR = 'ç›´çº¿å‡ç©º',
  SPIRAL = 'èºæ—‹ç›˜æ—‹',
  ZIGZAG = 'Så‹æ‘‡æ‘†',
  ACCELERATE = 'æé€Ÿæ¨è¿›',
  DRAWING = 'ç©ºä¸­ç»˜å›¾',
  WOBBLE = 'éšæœºæ‰°åŠ¨'
}

export const ASCENSION_ICONS: Record<AscensionType, string> = {
  [AscensionType.LINEAR]: 'â¬†ï¸',
  [AscensionType.SPIRAL]: 'ğŸŒ€',
  [AscensionType.ZIGZAG]: 'ã€°ï¸',
  [AscensionType.ACCELERATE]: 'ğŸš€',
  [AscensionType.DRAWING]: 'ğŸ–Œï¸',
  [AscensionType.WOBBLE]: 'ğŸ«¨'
};

export enum ColorStyle {
  SINGLE = 'çº¯å‡€å•è‰²',
  DUAL = 'åŒè‰²äº’è¡¥',
  RAINBOW = 'ä¸ƒå½©è™¹å…‰',
  GRADIENT = 'åŒç³»æ¸å˜',
  GOLDEN = 'æµé‡‘å²æœˆ',
  PASTEL = 'é©¬å¡é¾™è‰²'
}

export const COLOR_ICONS: Record<ColorStyle, string> = {
  [ColorStyle.SINGLE]: 'ğŸ”´',
  [ColorStyle.DUAL]: 'ğŸŒ—',
  [ColorStyle.RAINBOW]: 'ğŸŒˆ',
  [ColorStyle.GRADIENT]: 'ğŸ§',
  [ColorStyle.GOLDEN]: 'ğŸ†',
  [ColorStyle.PASTEL]: 'ğŸ¬'
};

export type ParticleBehavior = 'default' | 'willow' | 'glitter' | 'ghost' | 'firefly' | 'comet' | 'galaxy' | 'stationary' | 'falling';

export type CameraMode = 'orbit' | 'firstPerson';

// 2D Particle Options (for legacy 2D canvas version)
export interface ParticleOptions {
  x: number;
  y: number;
  hue: number;
  angle?: number;
  speed?: number;
  friction?: number;
  gravity?: number;
  resistance?: number;
  size?: number;
  decay?: number;
  behavior?: ParticleBehavior;
  originX?: number;
  originY?: number;
}

// 2D Firework Options (for legacy 2D canvas version)
export interface FireworkOptions {
  startX: number;
  targetX: number;
  targetY: number;
  hue: number;
  charge: number;
}

// 3D Particle Options
export interface ParticleOptions3D {
  x: number; y: number; z: number;
  hue: number; speed?: number;
  theta?: number; phi?: number;
  friction?: number; gravity?: number;
  resistance?: number; size?: number;
  decay?: number; behavior?: ParticleBehavior;
  originX?: number; originY?: number; originZ?: number;
}

export interface AppSettings {
  gravity: number;
  friction: number;
  autoLaunchDelay: number; // åŸºç¡€éšæœºé—´éš”
  particleCountMultiplier: number;
  explosionSizeMultiplier: number;
  starBlinkSpeed: number;
  trailLength: number;
  // æ–°å¢ï¼šå˜‰å¹´åæ§åˆ¶
  enableAutoCarnival: boolean; // æ˜¯å¦å¼€å¯è‡ªåŠ¨å¾ªç¯
  carnivalInterval: number;    // è‡ªåŠ¨å¾ªç¯é—´éš”(ç§’)
}

// å˜‰å¹´åé…ç½® (ç™½åå•)
import { Shape3DType } from '../core/shapes/Shape3DFactory';
import { TrajectoryType } from '../core/trajectories/TrajectoryFactory';
import { ComboType } from '../core/combos/ComboManager';

export enum LaunchFormation {
  SINGLE = 'å•ç‚¹å‘å°„',
  RANDOM = 'éšæœºæ•£å¸ƒ',
  CIRCLE = 'åœ†å½¢é½å°„',
  LINE = 'ä¸€å­—æ’å¼€',
  CROSS = 'åå­—äº¤å‰',
  V_SHAPE = 'Vå­—ç¼–é˜Ÿ'
}

export interface CarnivalStage {
  id: string;
  name: string;
  count: number;
  trajectory: TrajectoryType | 'RANDOM';
  shape: Shape3DType | ExplosionType | 'RANDOM';
  combo: ComboType | 'RANDOM';
  delay: number; // è·ç¦»ä¸Šä¸€é˜¶æ®µçš„å»¶è¿Ÿ(ms)
  
  // æ–°å¢é«˜çº§å‚æ•°
  formation?: LaunchFormation;
  interval?: number; // è¯¥æ³¢æ¬¡å†…æ¯å‘çƒŸèŠ±çš„é—´éš” (ms), 0è¡¨ç¤ºå®Œå…¨åŒæ—¶
  duration?: number; // çƒŸèŠ±åœç•™æ—¶é—´ (s), 0è¡¨ç¤ºé»˜è®¤
}

export interface FireworkConfig {
  enabledShapes: ExplosionType[];
  enabledAscensions: AscensionType[];
  enabledColors: ColorStyle[];
  // æ–°æ¶æ„æ”¯æŒ
  enabledShape3Ds?: Shape3DType[];
  enabledTrajectories?: TrajectoryType[];
  enabledCombos?: ComboType[];
  carnivalSequence?: CarnivalStage[];
  manualSequence?: CarnivalStage[]; // æ‰‹åŠ¨äº¤äº’å‰§æœ¬æ¸…å• (ä¿ç•™ç”¨äºå¤æ‚äº¤äº’)
}

// å•å‘é…ç½® (æŒ‡å®šæ ·å¼)
export interface ManualConfig {
  lockedShape: ExplosionType | Shape3DType | 'RANDOM';
  lockedColor: ColorStyle | 'RANDOM';
  lockedTrajectory?: TrajectoryType | 'RANDOM';
  lockedCombo?: ComboType | 'RANDOM';
  
  // æ–°å¢æ‰‹åŠ¨å‚æ•°
  lockedFormation: LaunchFormation; // å‘å°„é˜Ÿå½¢
  lockedCount: number; // æ¯æ¬¡ç‚¹å‡»å‘å°„æ•°é‡
  lockedDuration: number; // çƒŸèŠ±å­˜ç»­æ—¶é—´ (s)
  lockedInterval: number; // å‘å°„é—´éš” (ms)

  currentStepIndex?: number; // å½“å‰æ‰‹åŠ¨å‰§æœ¬è¿›åº¦
}

export const DEFAULT_SETTINGS: AppSettings = {
  gravity: 0.12,
  friction: 0.96,
  autoLaunchDelay: 2000,
  particleCountMultiplier: 1.0,
  explosionSizeMultiplier: 1.0,
  starBlinkSpeed: 0.001,
  trailLength: 15,
  enableAutoCarnival: false,
  carnivalInterval: 5
};

export const DEFAULT_CONFIG: FireworkConfig = {
  enabledShapes: Object.values(ExplosionType),
  enabledAscensions: Object.values(AscensionType),
  enabledColors: Object.values(ColorStyle),
  enabledShape3Ds: Object.values(Shape3DType),
  enabledTrajectories: Object.values(TrajectoryType),
  enabledCombos: Object.values(ComboType),
  carnivalSequence: [
    { id: '1', name: 'åºå¹•: ç¹æ˜Ÿç‚¹ç‚¹', count: 5, trajectory: TrajectoryType.LINEAR, shape: Shape3DType.SPARKLE_CLOUD, combo: ComboType.SINGLE, delay: 0, formation: LaunchFormation.RANDOM, interval: 300, duration: 3 },
    { id: '2', name: 'è¿‡æ¸¡: èºæ—‹å‡å', count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.RING_WAVE, combo: ComboType.STAGED, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 4 },
    { id: '3', name: 'é«˜æ½®: é“¶æ²³è¯ç”Ÿ', count: 1, trajectory: TrajectoryType.ACCELERATE, shape: Shape3DType.GALAXY_SPIRAL, combo: ComboType.GALAXY_BIRTH, delay: 3000, formation: LaunchFormation.SINGLE, interval: 0, duration: 8 }
  ],
  manualSequence: []
};

export const DEFAULT_MANUAL_CONFIG: ManualConfig = {
  lockedShape: 'RANDOM',
  lockedColor: 'RANDOM',
  lockedTrajectory: 'RANDOM',
  lockedCombo: 'RANDOM',
  lockedFormation: LaunchFormation.SINGLE,
  lockedCount: 1,
  lockedDuration: 0,
  lockedInterval: 100,
  currentStepIndex: 0
};

// END OF FILE: src/types/index.ts

// =============================================================================
// FILE: src\types\lifecycle.ts
// =============================================================================

/**
 * Lifecycle Configuration Types - å®Œæ•´ç‰ˆ
 * 
 * äº”é˜¶æ®µç”Ÿå‘½å‘¨æœŸé…ç½®å™¨ç±»å‹å®šä¹‰
 * æ¯ä¸ªé˜¶æ®µ 5 å¤§ç±»ï¼Œæ¯ç±» 5-10 ç§é€‰æ‹©
 */

// ============================================================================
// é˜¶æ®µæšä¸¾
// ============================================================================

export type LifecyclePhase = 'ascent' | 'explosion' | 'action' | 'hover' | 'fade';

// ============================================================================
// ===== ä¸Šå‡é˜¶æ®µ (Ascent) é…ç½® =====
// ============================================================================

// å°¾ç„°æ•ˆæœå¤§ç±»
export type TrailCategory = 'classic' | 'energy' | 'nature';

// ç»å…¸ç±»å°¾ç„°
export type ClassicTrailEffect = 
  | 'simple'        // ç®€å•æ‹–å°¾
  | 'comet'         // å½—æ˜Ÿå°¾
  | 'spark'         // ç«èŠ±å–·å°„
  | 'smoke'         // çƒŸé›¾å°¾
  | 'ribbon';       // ä¸å¸¦å°¾

// èƒ½é‡ç±»å°¾ç„°
export type EnergyTrailEffect = 
  | 'plasma'        // ç­‰ç¦»å­ä½“
  | 'lightning'     // é—ªç”µé“¾
  | 'laser'         // æ¿€å…‰æŸ
  | 'particle_jet'  // ç²’å­å–·æµ
  | 'energy_ring';  // èƒ½é‡ç¯

// è‡ªç„¶ç±»å°¾ç„°
export type NatureTrailEffect = 
  | 'firefly'       // è¤ç«è™«
  | 'stardust'      // æ˜Ÿå°˜
  | 'aurora'        // æå…‰
  | 'butterfly_trail' // è´è¶è½¨è¿¹
  | 'petal_fall';   // èŠ±ç“£é£˜è½

export type TrailEffect = ClassicTrailEffect | EnergyTrailEffect | NatureTrailEffect;

// è·¯å¾„å¤§ç±»
export type PathCategory = 'linear' | 'curved' | 'spiral';

// ç›´çº¿ç±»è·¯å¾„
export type LinearPath = 
  | 'straight'      // ç›´çº¿
  | 'accelerate'    // åŠ é€Ÿç›´çº¿
  | 'decelerate'    // å‡é€Ÿç›´çº¿
  | 'pulse'         // è„‰å†²å¼
  | 'multi_stage';  // å¤šçº§æ¨è¿›

// æ›²çº¿ç±»è·¯å¾„
export type CurvedPath = 
  | 'bezier'        // è´å¡å°”æ›²çº¿
  | 'arc'           // å¼§å½¢
  | 'sine_wave'     // æ­£å¼¦æ³¢
  | 'zigzag'        // Zå­—å½¢
  | 's_curve';      // Sæ›²çº¿

// èºæ—‹ç±»è·¯å¾„
export type SpiralPath = 
  | 'helix'         // èºæ—‹ä¸Šå‡
  | 'double_helix'  // DNAåŒèºæ—‹
  | 'tornado'       // é¾™å·é£
  | 'corkscrew'     // å¼€ç“¶å™¨
  | 'galaxy_arm';   // é“¶æ²³è‡‚

export type AscentPath = LinearPath | CurvedPath | SpiralPath;

// é€Ÿåº¦æ›²çº¿
export type VelocityCurve = 'linear' | 'easeIn' | 'easeOut' | 'easeInOut' | 'bounce' | 'elastic';

// ============================================================================
// ===== çˆ†ç‚¸é˜¶æ®µ (Explosion) é…ç½® =====
// ============================================================================

// å½¢çŠ¶å¤§ç±»
export type ShapeCategory = 'geometry' | 'nature' | 'culture' | 'cosmos' | 'effects';

// å‡ ä½•ç±»å½¢çŠ¶ (10ç§)
export type GeometryShape = 
  | 'sphere'        // çƒå½¢
  | 'cube'          // ç«‹æ–¹ä½“
  | 'pyramid'       // é‡‘å­—å¡”
  | 'octahedron'    // å…«é¢ä½“
  | 'torus'         // åœ†ç¯
  | 'cylinder'      // åœ†æŸ±
  | 'cone'          // åœ†é”¥
  | 'star_3d'       // 3Dæ˜Ÿå½¢
  | 'diamond'       // é’»çŸ³
  | 'mobius';       // è«æ¯”ä¹Œæ–¯ç¯

// è‡ªç„¶ç±»å½¢çŠ¶ (10ç§)
export type NatureShape = 
  | 'butterfly_3d'  // è´è¶
  | 'flower_3d'     // èŠ±æœµ
  | 'tree'          // æ ‘
  | 'bird'          // é£é¸Ÿ
  | 'jellyfish'     // æ°´æ¯
  | 'shell'         // è´å£³
  | 'snowflake_3d'  // é›ªèŠ±
  | 'leaf'          // å¶å­
  | 'mushroom'      // è˜‘è‡
  | 'fish_3d';      // é±¼

// æ–‡åŒ–ç±»å½¢çŠ¶ (10ç§)
export type CultureShape = 
  | 'heart_3d'      // å¿ƒå½¢
  | 'phoenix'       // å‡¤å‡°
  | 'dragon_3d'     // é¾™
  | 'crown_3d'      // çš‡å† 
  | 'lotus'         // è²èŠ±
  | 'lantern'       // ç¯ç¬¼
  | 'yin_yang'      // å¤ªæ
  | 'ribbon'        // å½©å¸¦
  | 'firework_classic' // ç»å…¸çƒŸèŠ±
  | 'firework_willow'; // æŸ³å¶çƒŸèŠ±

// å®‡å®™ç±»å½¢çŠ¶ (10ç§)
export type CosmosShape = 
  | 'galaxy_spiral' // é“¶æ²³
  | 'planet_rings'  // åœŸæ˜Ÿç¯
  | 'nebula'        // æ˜Ÿäº‘
  | 'black_hole'    // é»‘æ´
  | 'supernova'     // è¶…æ–°æ˜Ÿ
  | 'comet'         // å½—æ˜Ÿ
  | 'constellation' // æ˜Ÿåº§
  | 'pulsar'        // è„‰å†²æ˜Ÿ
  | 'wormhole'      // è™«æ´
  | 'asteroid_belt';// å°è¡Œæ˜Ÿå¸¦

// ç‰¹æ•ˆç±»å½¢çŠ¶ (10ç§)
export type EffectsShape = 
  | 'explosion_burst' // çˆ†å‘
  | 'ring_wave'     // ç¯å½¢æ³¢
  | 'double_ring'   // åŒç¯
  | 'cascade'       // ç€‘å¸ƒ
  | 'fountain'      // å–·æ³‰
  | 'vortex'        // æ¼©æ¶¡
  | 'shockwave'     // å†²å‡»æ³¢
  | 'sparkle_cloud' // é—ªçƒäº‘
  | 'chaos_scatter' // æ··æ²Œæ•£å°„
  | 'nested_spheres';// åµŒå¥—çƒ

export type ExplosionShape = GeometryShape | NatureShape | CultureShape | CosmosShape | EffectsShape;

// ============================================================================
// ===== åŠ¨ä½œé˜¶æ®µ (Action) é…ç½® =====
// ============================================================================

// åŠ¨ä½œå¤§ç±»
export type ActionCategory = 'static' | 'motion' | 'transform' | 'rhythm' | 'physics';

// é™æ€ç±»åŠ¨ä½œ
export type StaticAction = 
  | 'none'          // æ— 
  | 'glow'          // å‘å…‰
  | 'shimmer'       // é—ªçƒ
  | 'sparkle'       // ç«èŠ±
  | 'halo';         // å…‰æ™•

// è¿åŠ¨ç±»åŠ¨ä½œ
export type MotionAction = 
  | 'rotate'        // æ—‹è½¬
  | 'orbit'         // å…¬è½¬
  | 'swing'         // æ‘†åŠ¨
  | 'wave'          // æ³¢åŠ¨
  | 'spiral_motion';// èºæ—‹è¿åŠ¨

// å˜å½¢ç±»åŠ¨ä½œ
export type TransformAction = 
  | 'morph'         // å˜å½¢
  | 'expand'        // è†¨èƒ€
  | 'contract'      // æ”¶ç¼©
  | 'split'         // åˆ†è£‚
  | 'merge';        // åˆå¹¶

// èŠ‚å¥ç±»åŠ¨ä½œ
export type RhythmAction = 
  | 'pulse'         // è„‰åŠ¨
  | 'heartbeat'     // å¿ƒè·³
  | 'breathe'       // å‘¼å¸
  | 'flicker'       // é—ªåŠ¨
  | 'strobe';       // é¢‘é—ª

// ç‰©ç†ç±»åŠ¨ä½œ
export type PhysicsAction = 
  | 'gravity_wave'  // é‡åŠ›æ³¢
  | 'magnetic'      // ç£åœº
  | 'turbulence'    // æ¹æµ
  | 'vortex_pull'   // æ¼©æ¶¡æ‹‰æ‰¯
  | 'repulsion';    // æ–¥åŠ›

export type ActionType = StaticAction | MotionAction | TransformAction | RhythmAction | PhysicsAction;

// ============================================================================
// ===== æ‚¬åœé˜¶æ®µ (Hover) é…ç½® =====
// ============================================================================

// æ‚¬åœæ¨¡å¼å¤§ç±»
export type HoverCategory = 'float' | 'drift' | 'dance' | 'stable' | 'dynamic';

// æ¼‚æµ®ç±»æ‚¬åœ
export type FloatHover = 
  | 'gentle_float'  // è½»æŸ”æ¼‚æµ®
  | 'cloud_drift'   // äº‘æœµé£˜åŠ¨
  | 'balloon'       // æ°”çƒå¼
  | 'feather'       // ç¾½æ¯›å¼
  | 'bubble';       // æ°”æ³¡å¼

// å¾®åŠ¨ç±»æ‚¬åœ
export type DriftHover = 
  | 'micro_drift'   // å¾®æ¼‚ç§»
  | 'sway'          // æ‘‡æ›³
  | 'oscillate'     // æŒ¯è¡
  | 'tremor'        // å¾®é¢¤
  | 'bob';          // ä¸Šä¸‹æµ®åŠ¨

// èˆåŠ¨ç±»æ‚¬åœ
export type DanceHover = 
  | 'waltz'         // åå°”å…¹
  | 'firefly_dance' // è¤ç«è™«èˆ
  | 'aurora_wave'   // æå…‰æ³¢
  | 'ribbon_dance'  // å½©å¸¦èˆ
  | 'particle_swarm';// ç²’å­ç¾¤èˆ

// ç¨³å®šç±»æ‚¬åœ
export type StableHover = 
  | 'lock'          // é”å®š
  | 'freeze'        // å†»ç»“
  | 'anchor'        // é”šå®š
  | 'suspend'       // æ‚¬æŒ‚
  | 'levitate';     // æ‚¬æµ®

// åŠ¨æ€ç±»æ‚¬åœ
export type DynamicHover = 
  | 'wind_affected' // å—é£å½±å“
  | 'turbulent'     // æ¹æµ
  | 'magnetic_field'// ç£åœº
  | 'gravity_well'  // é‡åŠ›äº•
  | 'attractor';    // å¸å¼•å­

export type HoverMode = FloatHover | DriftHover | DanceHover | StableHover | DynamicHover;

// ============================================================================
// ===== æ¶ˆå¤±é˜¶æ®µ (Fade) é…ç½® =====
// ============================================================================

// æ¶ˆå¤±æ•ˆæœå¤§ç±»
export type FadeCategory = 'gradual' | 'dramatic' | 'natural' | 'magical' | 'physics';

// æ¸å˜ç±»æ¶ˆå¤±
export type GradualFade = 
  | 'fade_out'      // æ¸éš
  | 'dissolve'      // æº¶è§£
  | 'evaporate'     // è’¸å‘
  | 'dim'           // å˜æš—
  | 'shrink';       // ç¼©å°

// æˆå‰§ç±»æ¶ˆå¤±
export type DramaticFade = 
  | 'burnout'       // ç‡ƒå°½
  | 'explosion_end' // çˆ†æ•£
  | 'flash_out'     // é—ªç­
  | 'implosion'     // å†…çˆ†
  | 'shatter';      // ç ´ç¢

// è‡ªç„¶ç±»æ¶ˆå¤±
export type NaturalFade = 
  | 'gravity_fall'  // é‡åŠ›å è½
  | 'wind_scatter'  // é£å¹æ•£
  | 'rain_drop'     // é›¨æ»´è½
  | 'snow_settle'   // é›ªèŠ±é£˜è½
  | 'ash_drift';    // ç°çƒ¬é£˜æ•£

// é­”æ³•ç±»æ¶ˆå¤±
export type MagicalFade = 
  | 'twinkle_out'   // é—ªçƒæ¶ˆå¤±
  | 'star_burst'    // æ˜Ÿçˆ†
  | 'pixelate'      // åƒç´ åŒ–
  | 'portal'        // ä¼ é€é—¨
  | 'warp';         // æ‰­æ›²

// ç‰©ç†ç±»æ¶ˆå¤±
export type PhysicsFade = 
  | 'entropy'       // ç†µå¢
  | 'decay'         // è¡°å˜
  | 'diffusion'     // æ‰©æ•£
  | 'absorption'    // å¸æ”¶
  | 'annihilation'; // æ¹®ç­

export type FadeEffect = GradualFade | DramaticFade | NaturalFade | MagicalFade | PhysicsFade;

// ============================================================================
// å®Œæ•´é˜¶æ®µé…ç½®
// ============================================================================

export interface AscentConfig {
  // å°¾ç„°
  trailCategory: TrailCategory;
  trailEffect: TrailEffect;
  trailDensity: number;      // 0-1
  trailSize: number;         // 0.5-3
  
  // è·¯å¾„
  pathCategory: PathCategory;
  path: AscentPath;
  
  // é€Ÿåº¦
  duration: number;          // 0.5-4ç§’
  velocityCurve: VelocityCurve;
  
  // é«˜çº§å‚æ•°
  spiralRadius?: number;
  spiralFrequency?: number;
  wobbleAmplitude?: number;
}

export interface ExplosionConfig {
  // å½¢çŠ¶
  shapeCategory: ShapeCategory;
  shape: ExplosionShape;
  
  // å‚æ•°
  particleCount: number;     // 500-5000
  power: number;             // 0-1
  scale: number;             // 0.5-2
  
  // é¢œè‰²
  colorMode: 'single' | 'gradient' | 'rainbow' | 'temperature';
  primaryHue: number;        // 0-360
  
  // é«˜çº§
  burstPattern: 'radial' | 'directional' | 'spiral' | 'random';
}

export interface ActionConfig {
  // åŠ¨ä½œ
  actionCategory: ActionCategory;
  actionType: ActionType;
  
  // å‚æ•°
  intensity: number;         // 0-1
  frequency: number;         // 0.1-5 Hz
  
  // å˜å½¢ç›®æ ‡ï¼ˆå¦‚æœæ˜¯morphç±»å‹ï¼‰
  morphTarget?: ExplosionShape;
  morphDuration?: number;
}

export interface HoverConfig {
  // æ‚¬åœæ¨¡å¼
  hoverCategory: HoverCategory;
  hoverMode: HoverMode;
  
  // å‚æ•°
  duration: number;          // 0-10ç§’
  stability: number;         // 0-1 ç¨³å®šæ€§ï¼ˆ1=å®Œå…¨æ‚¬åœï¼‰
  
  // ç‰©ç†
  gravityResistance: number; // 0-1 (1=å®Œå…¨æŠµæŠ—é‡åŠ›)
  windInfluence: number;     // 0-1
  turbulence: number;        // 0-1
}

export interface FadeConfig {
  // æ¶ˆå¤±æ•ˆæœ
  fadeCategory: FadeCategory;
  fadeEffect: FadeEffect;
  
  // å‚æ•°
  duration: number;          // 0.5-5ç§’
  
  // ç‰©ç†
  useGravity: boolean;
  gravityStrength: number;   // 0-1
  windStrength: number;      // 0-1
  
  // æ¸²æŸ“
  useBlackbody: boolean;
  coolingRate: number;       // 0-1
}

// ============================================================================
// å®Œæ•´ç”Ÿå‘½å‘¨æœŸé…ç½®
// ============================================================================

export interface FireworkLifecycleConfig {
  id: string;
  name: string;
  
  ascent: AscentConfig;
  explosion: ExplosionConfig;
  action: ActionConfig;
  hover: HoverConfig;
  fade: FadeConfig;
  
  // å…¨å±€æ¸²æŸ“æ§åˆ¶
  rendering: {
    exposure: number;       // 0.1-2.0 (æ›å…‰åº¦)
    bloomStrength: number;  // 0-3 (è¾‰å…‰å¼ºåº¦)
    particleSize: number;   // 0.5-5 (ç²’å­åŸºç¡€å¤§å°)
    glowIntensity: number;  // 0-3 (å‘å…‰å¼ºåº¦)
  };
  
  // å…¨å±€è¦†ç›–
  hueOverride?: number;
}

// ============================================================================
// åˆ†ç±»ä¿¡æ¯
// ============================================================================

export const TRAIL_CATEGORIES = {
  classic: { label: 'ç»å…¸', icon: 'ğŸ”¥', items: ['simple', 'comet', 'spark', 'smoke', 'ribbon'] },
  energy: { label: 'èƒ½é‡', icon: 'âš¡', items: ['plasma', 'lightning', 'laser', 'particle_jet', 'energy_ring'] },
  nature: { label: 'è‡ªç„¶', icon: 'ğŸŒ¿', items: ['firefly', 'stardust', 'aurora', 'butterfly_trail', 'petal_fall'] },
} as const;

export const PATH_CATEGORIES = {
  linear: { label: 'ç›´çº¿', icon: 'â¡ï¸', items: ['straight', 'accelerate', 'decelerate', 'pulse', 'multi_stage'] },
  curved: { label: 'æ›²çº¿', icon: 'ã€°ï¸', items: ['bezier', 'arc', 'sine_wave', 'zigzag', 's_curve'] },
  spiral: { label: 'èºæ—‹', icon: 'ğŸŒ€', items: ['helix', 'double_helix', 'tornado', 'corkscrew', 'galaxy_arm'] },
} as const;

export const SHAPE_CATEGORIES = {
  geometry: { label: 'å‡ ä½•', icon: 'ğŸ”·', items: ['sphere', 'cube', 'pyramid', 'octahedron', 'torus', 'cylinder', 'cone', 'star_3d', 'diamond', 'mobius'] },
  nature: { label: 'è‡ªç„¶', icon: 'ğŸ¦‹', items: ['butterfly_3d', 'flower_3d', 'tree', 'bird', 'jellyfish', 'shell', 'snowflake_3d', 'leaf', 'mushroom', 'fish_3d'] },
  culture: { label: 'æ–‡åŒ–', icon: 'ğŸ®', items: ['heart_3d', 'phoenix', 'dragon_3d', 'crown_3d', 'lotus', 'lantern', 'yin_yang', 'ribbon', 'firework_classic', 'firework_willow'] },
  cosmos: { label: 'å®‡å®™', icon: 'ğŸŒŒ', items: ['galaxy_spiral', 'planet_rings', 'nebula', 'black_hole', 'supernova', 'comet', 'constellation', 'pulsar', 'wormhole', 'asteroid_belt'] },
  effects: { label: 'ç‰¹æ•ˆ', icon: 'âœ¨', items: ['explosion_burst', 'ring_wave', 'double_ring', 'cascade', 'fountain', 'vortex', 'shockwave', 'sparkle_cloud', 'chaos_scatter', 'nested_spheres'] },
} as const;

export const ACTION_CATEGORIES = {
  static: { label: 'é™æ€', icon: 'âœ¦', items: ['none', 'glow', 'shimmer', 'sparkle', 'halo'] },
  motion: { label: 'è¿åŠ¨', icon: 'ğŸ”„', items: ['rotate', 'orbit', 'swing', 'wave', 'spiral_motion'] },
  transform: { label: 'å˜å½¢', icon: 'ğŸ¦‹', items: ['morph', 'expand', 'contract', 'split', 'merge'] },
  rhythm: { label: 'èŠ‚å¥', icon: 'ğŸ’“', items: ['pulse', 'heartbeat', 'breathe', 'flicker', 'strobe'] },
  physics: { label: 'ç‰©ç†', icon: 'ğŸŒŠ', items: ['gravity_wave', 'magnetic', 'turbulence', 'vortex_pull', 'repulsion'] },
} as const;

export const HOVER_CATEGORIES = {
  float: { label: 'æ¼‚æµ®', icon: 'â˜ï¸', items: ['gentle_float', 'cloud_drift', 'balloon', 'feather', 'bubble'] },
  drift: { label: 'å¾®åŠ¨', icon: 'ğŸƒ', items: ['micro_drift', 'sway', 'oscillate', 'tremor', 'bob'] },
  dance: { label: 'èˆåŠ¨', icon: 'ğŸ’ƒ', items: ['waltz', 'firefly_dance', 'aurora_wave', 'ribbon_dance', 'particle_swarm'] },
  stable: { label: 'ç¨³å®š', icon: 'âš“', items: ['lock', 'freeze', 'anchor', 'suspend', 'levitate'] },
  dynamic: { label: 'åŠ¨æ€', icon: 'ğŸŒ€', items: ['wind_affected', 'turbulent', 'magnetic_field', 'gravity_well', 'attractor'] },
} as const;

export const FADE_CATEGORIES = {
  gradual: { label: 'æ¸å˜', icon: 'ğŸŒ…', items: ['fade_out', 'dissolve', 'evaporate', 'dim', 'shrink'] },
  dramatic: { label: 'æˆå‰§', icon: 'ğŸ’¥', items: ['burnout', 'explosion_end', 'flash_out', 'implosion', 'shatter'] },
  natural: { label: 'è‡ªç„¶', icon: 'ğŸ‚', items: ['gravity_fall', 'wind_scatter', 'rain_drop', 'snow_settle', 'ash_drift'] },
  magical: { label: 'é­”æ³•', icon: 'âœ¨', items: ['twinkle_out', 'star_burst', 'pixelate', 'portal', 'warp'] },
  physics: { label: 'ç‰©ç†', icon: 'âš›ï¸', items: ['entropy', 'decay', 'diffusion', 'absorption', 'annihilation'] },
} as const;

// ============================================================================
// æ•ˆæœåç§°æ˜ å°„
// ============================================================================

export const EFFECT_LABELS: Record<string, string> = {
  // å°¾ç„° - ç»å…¸
  simple: 'ç®€å•æ‹–å°¾', comet: 'å½—æ˜Ÿå°¾', spark: 'ç«èŠ±å–·å°„', smoke: 'çƒŸé›¾å°¾', ribbon: 'ä¸å¸¦å°¾',
  // å°¾ç„° - èƒ½é‡
  plasma: 'ç­‰ç¦»å­ä½“', lightning: 'é—ªç”µé“¾', laser: 'æ¿€å…‰æŸ', particle_jet: 'ç²’å­å–·æµ', energy_ring: 'èƒ½é‡ç¯',
  // å°¾ç„° - è‡ªç„¶
  firefly: 'è¤ç«è™«', stardust: 'æ˜Ÿå°˜', aurora: 'æå…‰', butterfly_trail: 'è´è¶è½¨è¿¹', petal_fall: 'èŠ±ç“£é£˜è½',
  
  // è·¯å¾„ - ç›´çº¿
  straight: 'ç›´çº¿', accelerate: 'åŠ é€Ÿç›´çº¿', decelerate: 'å‡é€Ÿç›´çº¿', pulse: 'è„‰å†²å¼', multi_stage: 'å¤šçº§æ¨è¿›',
  // è·¯å¾„ - æ›²çº¿
  bezier: 'è´å¡å°”', arc: 'å¼§å½¢', sine_wave: 'æ­£å¼¦æ³¢', zigzag: 'Zå­—å½¢', s_curve: 'Sæ›²çº¿',
  // è·¯å¾„ - èºæ—‹
  helix: 'èºæ—‹ä¸Šå‡', double_helix: 'DNAåŒèºæ—‹', tornado: 'é¾™å·é£', corkscrew: 'å¼€ç“¶å™¨', galaxy_arm: 'é“¶æ²³è‡‚',
  
  // å½¢çŠ¶
  sphere: 'çƒå½¢', cube: 'ç«‹æ–¹ä½“', pyramid: 'é‡‘å­—å¡”', octahedron: 'å…«é¢ä½“', torus: 'åœ†ç¯',
  cylinder: 'åœ†æŸ±', cone: 'åœ†é”¥', star_3d: '3Dæ˜Ÿå½¢', diamond: 'é’»çŸ³', mobius: 'è«æ¯”ä¹Œæ–¯ç¯',
  butterfly_3d: 'è´è¶', flower_3d: 'èŠ±æœµ', tree: 'ç”Ÿå‘½æ ‘', bird: 'é£é¸Ÿ', jellyfish: 'æ°´æ¯',
  shell: 'è´å£³', snowflake_3d: 'é›ªèŠ±', leaf: 'å¶å­', mushroom: 'è˜‘è‡', fish_3d: 'é”¦é²¤',
  heart_3d: 'çˆ±å¿ƒ', phoenix: 'å‡¤å‡°', dragon_3d: 'ç¥é¾™', crown_3d: 'çš‡å† ', lotus: 'è²èŠ±',
  lantern: 'ç¯ç¬¼', yin_yang: 'å¤ªæ', firework_classic: 'ç»å…¸çƒŸèŠ±', firework_willow: 'é‡‘æŸ³å‚ä¸',
  galaxy_spiral: 'é“¶æ²³ç³»', planet_rings: 'åœŸæ˜Ÿç¯', nebula: 'æ˜Ÿäº‘', black_hole: 'é»‘æ´', supernova: 'è¶…æ–°æ˜Ÿ',
  comet_shape: 'å½—æ˜Ÿ', constellation: 'æ˜Ÿåº§', pulsar: 'è„‰å†²æ˜Ÿ', wormhole: 'è™«æ´', asteroid_belt: 'å°è¡Œæ˜Ÿå¸¦',
  explosion_burst: 'çˆ†å‘', ring_wave: 'ç¯å½¢æ³¢', double_ring: 'åŒç¯', cascade: 'ç€‘å¸ƒ', fountain: 'å–·æ³‰',
  vortex: 'æ¼©æ¶¡', shockwave: 'å†²å‡»æ³¢', sparkle_cloud: 'é—ªçƒäº‘', chaos_scatter: 'æ··æ²Œæ•£å°„', nested_spheres: 'åµŒå¥—çƒ',
  
  // åŠ¨ä½œ
  none: 'æ— ', glow: 'å‘å…‰', shimmer: 'é—ªçƒ', sparkle: 'ç«èŠ±', halo: 'å…‰æ™•',
  rotate: 'æ—‹è½¬', orbit: 'å…¬è½¬', swing: 'æ‘†åŠ¨', wave: 'æ³¢åŠ¨', spiral_motion: 'èºæ—‹è¿åŠ¨',
  morph: 'å˜å½¢', expand: 'è†¨èƒ€', contract: 'æ”¶ç¼©', split: 'åˆ†è£‚', merge: 'åˆå¹¶',
  heartbeat: 'å¿ƒè·³', breathe: 'å‘¼å¸', flicker: 'é—ªåŠ¨', strobe: 'é¢‘é—ª',
  gravity_wave: 'é‡åŠ›æ³¢', magnetic: 'ç£åœº', turbulence: 'æ¹æµ', vortex_pull: 'æ¼©æ¶¡æ‹‰æ‰¯', repulsion: 'æ–¥åŠ›',
  
  // æ‚¬åœ
  gentle_float: 'è½»æŸ”æ¼‚æµ®', cloud_drift: 'äº‘æœµé£˜åŠ¨', balloon: 'æ°”çƒå¼', feather: 'ç¾½æ¯›å¼', bubble: 'æ°”æ³¡å¼',
  micro_drift: 'å¾®æ¼‚ç§»', sway: 'æ‘‡æ›³', oscillate: 'æŒ¯è¡', tremor: 'å¾®é¢¤', bob: 'ä¸Šä¸‹æµ®åŠ¨',
  waltz: 'åå°”å…¹', firefly_dance: 'è¤ç«è™«èˆ', aurora_wave: 'æå…‰æ³¢', ribbon_dance: 'å½©å¸¦èˆ', particle_swarm: 'ç²’å­ç¾¤èˆ',
  lock: 'é”å®š', freeze: 'å†»ç»“', anchor: 'é”šå®š', suspend: 'æ‚¬æŒ‚', levitate: 'æ‚¬æµ®',
  wind_affected: 'å—é£å½±å“', turbulent: 'æ¹æµ', magnetic_field: 'ç£åœº', gravity_well: 'é‡åŠ›äº•', attractor: 'å¸å¼•å­',
  
  // æ¶ˆå¤±
  fade_out: 'æ¸éš', dissolve: 'æº¶è§£', evaporate: 'è’¸å‘', dim: 'å˜æš—', shrink: 'ç¼©å°',
  burnout: 'ç‡ƒå°½', explosion_end: 'çˆ†æ•£', flash_out: 'é—ªç­', implosion: 'å†…çˆ†', shatter: 'ç ´ç¢',
  gravity_fall: 'é‡åŠ›å è½', wind_scatter: 'é£å¹æ•£', rain_drop: 'é›¨æ»´è½', snow_settle: 'é›ªèŠ±é£˜è½', ash_drift: 'ç°çƒ¬é£˜æ•£',
  twinkle_out: 'é—ªçƒæ¶ˆå¤±', star_burst: 'æ˜Ÿçˆ†', pixelate: 'åƒç´ åŒ–', portal: 'ä¼ é€é—¨', warp: 'æ‰­æ›²',
  entropy: 'ç†µå¢', decay: 'è¡°å˜', diffusion: 'æ‰©æ•£', absorption: 'å¸æ”¶', annihilation: 'æ¹®ç­',
};

// ============================================================================
// é»˜è®¤é…ç½®
// ============================================================================

export const DEFAULT_LIFECYCLE_CONFIG: FireworkLifecycleConfig = {
  id: 'default',
  name: 'ç»å…¸çƒŸèŠ±',
  
  ascent: {
    trailCategory: 'classic',
    trailEffect: 'comet',
    trailDensity: 0.7,
    trailSize: 1,
    pathCategory: 'linear',
    path: 'straight',
    duration: 2,
    velocityCurve: 'easeOut',
  },
  
  explosion: {
    shapeCategory: 'geometry',
    shape: 'sphere',
    particleCount: 2000,
    power: 0.7,
    scale: 1,
    colorMode: 'gradient',
    primaryHue: 30,
    burstPattern: 'radial',
  },
  
  action: {
    actionCategory: 'static',
    actionType: 'shimmer',
    intensity: 0.5,
    frequency: 1,
  },
  
  hover: {
    hoverCategory: 'stable',
    hoverMode: 'levitate',
    duration: 2,
    stability: 0.9,
    gravityResistance: 1.0, // å®Œå…¨æŠµæŠ—é‡åŠ›
    windInfluence: 0.1,
    turbulence: 0.05,
  },
  
  fade: {
    fadeCategory: 'natural',
    fadeEffect: 'ash_drift',
    duration: 2.5,
    useGravity: true,
    gravityStrength: 0.8,
    windStrength: 0.3,
    useBlackbody: true,
    coolingRate: 0.5,
  },
  
  rendering: {
    exposure: 0.4,        // é»˜è®¤è¾ƒä½æ›å…‰
    bloomStrength: 0.3,   // é»˜è®¤è¾ƒä½è¾‰å…‰
    particleSize: 2,      // é»˜è®¤ç²’å­å¤§å°
    glowIntensity: 1.5,   // é»˜è®¤å‘å…‰å¼ºåº¦
  },
};

// ============================================================================
// é¢„è®¾é…ç½®
// ============================================================================

export const LIFECYCLE_PRESETS: FireworkLifecycleConfig[] = [
  {
    ...DEFAULT_LIFECYCLE_CONFIG,
    id: 'phoenix',
    name: 'å‡¤å‡°æ¶…æ§ƒ',
    ascent: {
      ...DEFAULT_LIFECYCLE_CONFIG.ascent,
      trailCategory: 'energy',
      trailEffect: 'plasma',
      pathCategory: 'spiral',
      path: 'helix',
      spiralRadius: 8,
    },
    explosion: {
      ...DEFAULT_LIFECYCLE_CONFIG.explosion,
      shapeCategory: 'culture',
      shape: 'phoenix',
      particleCount: 3000,
      power: 0.9,
    },
    action: {
      ...DEFAULT_LIFECYCLE_CONFIG.action,
      actionCategory: 'motion',
      actionType: 'wave',
      intensity: 0.8,
    },
  },
  {
    ...DEFAULT_LIFECYCLE_CONFIG,
    id: 'heart',
    name: 'å¿ƒå¿ƒç›¸å°',
    explosion: {
      ...DEFAULT_LIFECYCLE_CONFIG.explosion,
      shapeCategory: 'culture',
      shape: 'heart_3d',
      colorMode: 'single',
      primaryHue: 340,
    },
    action: {
      ...DEFAULT_LIFECYCLE_CONFIG.action,
      actionCategory: 'rhythm',
      actionType: 'heartbeat',
    },
  },
  {
    ...DEFAULT_LIFECYCLE_CONFIG,
    id: 'galaxy',
    name: 'æ˜Ÿæ²³æ¼«æ­¥',
    ascent: {
      ...DEFAULT_LIFECYCLE_CONFIG.ascent,
      trailCategory: 'nature',
      trailEffect: 'stardust',
      pathCategory: 'spiral',
      path: 'galaxy_arm',
    },
    explosion: {
      ...DEFAULT_LIFECYCLE_CONFIG.explosion,
      shapeCategory: 'cosmos',
      shape: 'galaxy_spiral',
      particleCount: 4000,
      colorMode: 'rainbow',
    },
    action: {
      ...DEFAULT_LIFECYCLE_CONFIG.action,
      actionCategory: 'motion',
      actionType: 'rotate',
    },
    hover: {
      ...DEFAULT_LIFECYCLE_CONFIG.hover,
      duration: 4,
      hoverMode: 'particle_swarm',
    },
  },
];

// ============================================================================
// é˜¶æ®µä¸»é¢˜é¢œè‰²
// ============================================================================

export const PHASE_THEMES = {
  ascent: {
    accent: 'blue-400',
    background: 'blue-950/40',
    border: 'blue-700/30',
    text: 'blue-300',
    icon: 'ğŸš€',
    label: 'ä¸Šå‡',
  },
  explosion: {
    accent: 'rose-400',
    background: 'rose-950/40',
    border: 'rose-700/30',
    text: 'rose-300',
    icon: 'âœ¨',
    label: 'çˆ†ç‚¸',
  },
  action: {
    accent: 'violet-400',
    background: 'violet-950/40',
    border: 'violet-700/30',
    text: 'violet-300',
    icon: 'ğŸª„',
    label: 'åŠ¨ä½œ',
  },
  hover: {
    accent: 'emerald-400',
    background: 'emerald-950/40',
    border: 'emerald-700/30',
    text: 'emerald-300',
    icon: 'â¸ï¸',
    label: 'æ‚¬åœ',
  },
  fade: {
    accent: 'amber-400',
    background: 'amber-950/40',
    border: 'amber-700/30',
    text: 'amber-300',
    icon: 'ğŸŒ«ï¸',
    label: 'æ¶ˆå¤±',
  },
} as const;
