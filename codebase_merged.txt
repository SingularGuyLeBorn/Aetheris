

====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\CustomSelect.tsx ======
// FILE: src/components/ui/CustomSelect.tsx
// 鑷畾涔変笅鎷夐€夋嫨妗?- 褰诲簳鏇夸唬鍘熺敓涓戦檵鐨?select
// 瑙嗚椋庢牸锛氭恫鎬佺幓鐠冿紝鎮诞鑿滃崟锛岀簿鑷村姩鐢?

import React, { useState, useRef, useEffect } from "react";

interface Option {
  label: string;
  value: string;
}

interface CustomSelectProps {
  value: string;
  options: Option[];
  onChange: (value: string) => void;
  icon?: string;
  className?: string;
}

export const CustomSelect: React.FC<CustomSelectProps> = ({
  value,
  options,
  onChange,
  icon,
  className = "",
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // 鏌ユ壘褰撳墠閫変腑鐨?label
  const selectedLabel = options.find((o) => o.value === value)?.label || value;

  // 鐐瑰嚮澶栭儴鍏抽棴
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  return (
    <div className={`relative group ${className}`} ref={containerRef}>
      {/* 瑙﹀彂鎸夐挳 */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          w-full flex items-center justify-between
          px-3 py-2.5 rounded-xl
          bg-white/40 backdrop-blur-md
          border border-white/60
          text-[10px] font-black text-slate-700
          shadow-sm transition-all duration-300
          hover:bg-white/60 hover:border-emerald-300 hover:shadow-emerald-100/30
          focus:outline-none focus:ring-2 focus:ring-emerald-500/20
          ${
            isOpen
              ? "border-emerald-400 bg-white/80 ring-2 ring-emerald-500/20"
              : ""
          }
        `}
      >
        <div className="flex items-center gap-2 truncate">
          {icon && <span className="text-lg opacity-80">{icon}</span>}
          <span className="truncate">{selectedLabel}</span>
        </div>
        <div
          className={`
           text-[8px] text-slate-400 transition-transform duration-300 ml-2
           ${
             isOpen
               ? "rotate-180 text-emerald-500"
               : "group-hover:text-emerald-400"
           }
        `}
        >
          鈻?
        </div>
      </button>

      {/* 涓嬫媺鑿滃崟 (Portal like behavior but simplified for this context, assume z-index is high enough) */}
      <div
        className={`
          absolute left-0 right-0 top-full mt-2
          bg-white/90 backdrop-blur-xl
          border border-white/60 rounded-xl
          shadow-xl shadow-slate-200/50
          max-h-60 overflow-y-auto custom-scrollbar
          z-50 transform origin-top transition-all duration-200 cubic-bezier(0.2, 0.8, 0.2, 1)
          ${
            isOpen
              ? "opacity-100 scale-100 translate-y-0 visible"
              : "opacity-0 scale-95 -translate-y-2 invisible pointer-events-none"
          }
        `}
      >
        <div className="p-1.5 space-y-0.5">
          {options.map((option) => {
            const isSelected = option.value === value;
            return (
              <button
                key={option.value}
                onClick={() => {
                  onChange(option.value);
                  setIsOpen(false);
                }}
                className={`
                  w-full text-left px-3 py-2 rounded-lg text-[10px] font-bold transition-all
                  flex items-center justify-between
                  ${
                    isSelected
                      ? "bg-emerald-50 text-emerald-700"
                      : "text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                  }
                `}
              >
                <span>{option.label}</span>
                {isSelected && <span className="text-emerald-500">鉁?/span>}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
};


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\CustomSelectWithPreview.tsx ======
// FILE: src/components/ui/CustomSelectWithPreview.tsx
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { ShapePreview3D } from './ShapePreviewCard';
import { TrajectoryPreviewCanvas } from './TrajectoryPreview3D';
import { Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';

interface Option {
  label: string;
  value: string;
  icon?: string;
}

type PreviewType = 'shape' | 'trajectory' | 'none';

interface CustomSelectWithPreviewProps {
  value: string;
  options: Option[];
  onChange: (value: string) => void;
  previewType: PreviewType;
  icon?: string;
  className?: string;
  placeholder?: string;
}

/**
 * 涓嬫媺閫夋嫨缁勪欢 (甯?Portal 鎮诞棰勮)
 * - 棰勮妗嗕娇鐢?Portal 娓叉煋鍒?body锛屽交搴曡В鍐?overflow 瑁佸壀闂
 * - 鏅鸿兘璁＄畻浣嶇疆锛屽缁堣窡闅忛紶鏍?閫夐」浣嶇疆
 */
export const CustomSelectWithPreview: React.FC<CustomSelectWithPreviewProps> = ({
  value,
  options,
  onChange,
  previewType,
  icon,
  className = '',
  placeholder = '閫夋嫨...'
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [hoveredValue, setHoveredValue] = useState<string | null>(null);
  const [previewPos, setPreviewPos] = useState<{ top: number; left: number; side: 'left' | 'right' } | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // 閫変腑椤瑰洖鏄?
  const selectedOption = options.find(o => o.value === value);
  const selectedLabel = selectedOption?.label || placeholder;

  // 鐐瑰嚮澶栭儴鍏抽棴
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      // 濡傛灉鐐瑰嚮鐨勬槸 Portal 鍐呴儴鍏冪礌锛屼篃涓嶅鐞?(铏界劧 Portal 鍦?body锛屼絾浜嬩欢鍐掓场...)
      // 杩欓噷绠€鍖栵細鍙涓嶆槸鐐瑰嚮 containerRef 鍐呴儴锛屽氨鍏抽棴
      // 娉ㄦ剰锛歅ortal 閲岀殑浜嬩欢浼氬啋娉″埌 React 鏍戠殑鐖剁骇锛屾墍浠ヨ鍒ゆ柇
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setHoveredValue(null);
        setPreviewPos(null);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelect = useCallback((optionValue: string) => {
    onChange(optionValue);
    setIsOpen(false);
    setHoveredValue(null);
    setPreviewPos(null);
  }, [onChange]);

  // 澶勭悊閫夐」鎮仠锛氳绠楀苟璁剧疆棰勮妗嗕綅缃?
  const handleOptionHover = (e: React.MouseEvent<HTMLButtonElement>, val: string) => {
    setHoveredValue(val);
    
    // 鑾峰彇褰撳墠閫夐」鐨勪綅缃?
    const rect = e.currentTarget.getBoundingClientRect();
    const PREVIEW_SIZE = 200; // 棰勮妗嗗ぇ姒傚昂瀵?
    const GAP = 10;
    
    let left = rect.right + GAP;
    let side: 'left' | 'right' = 'right';

    // 鏅鸿兘鍒ゆ柇宸﹀彸锛氬鏋滃彸杈规斁涓嶄笅锛屽氨鏀惧乏杈?
    if (left + PREVIEW_SIZE > window.innerWidth) {
        left = rect.left - PREVIEW_SIZE - GAP;
        side = 'left';
    }

    // 鍨傜洿瀵归綈锛氬敖閲忓眳涓簬閫夐」锛屼絾涓嶈兘瓒呭嚭灞忓箷
    let top = rect.top + rect.height/2 - PREVIEW_SIZE/2;
    if (top < 10) top = 10;
    if (top + PREVIEW_SIZE > window.innerHeight) top = window.innerHeight - PREVIEW_SIZE - 10;

    setPreviewPos({ top, left, side });
  };

  const clearHover = () => {
    setHoveredValue(null);
    setPreviewPos(null);
  };

  const previewValue = hoveredValue || value;
  const showPreview = isOpen && previewType !== 'none' && previewValue && previewValue !== 'RANDOM' && previewPos;

  return (
    <div className={`relative ${className}`} ref={containerRef}>
      {/* 瑙﹀彂鍣?*/}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          w-full flex items-center justify-between
          px-3 py-2.5 rounded-xl
          bg-white/40 backdrop-blur-md
          border border-white/60
          text-[10px] font-black text-slate-700
          shadow-sm transition-all duration-300
          hover:bg-white/60 hover:border-emerald-300 hover:shadow-emerald-100/30
          focus:outline-none focus:ring-2 focus:ring-emerald-500/20
          ${isOpen 
            ? 'border-emerald-400 bg-white/80 ring-2 ring-emerald-500/20' 
            : ''
          }
        `}
      >
        <div className="flex items-center gap-2 truncate">
          {icon && <span className="text-lg opacity-80">{icon}</span>}
          <span className="truncate">{selectedLabel}</span>
        </div>
        <div className={`
          text-[8px] text-slate-400 transition-transform duration-300 ml-2
          ${isOpen ? 'rotate-180 text-emerald-500' : 'group-hover:text-emerald-400'}
        `}>鈻?/div>
      </button>

      {/* 涓嬫媺鑿滃崟 (缁濆瀹氫綅) */}
      <div className={`
        absolute left-0 top-full mt-2 w-full z-50
        transform origin-top transition-all duration-200
        ${isOpen 
          ? 'opacity-100 scale-100 translate-y-0 visible' 
          : 'opacity-0 scale-95 -translate-y-2 invisible pointer-events-none'
        }
      `}>
        <div className="
          bg-white/95 backdrop-blur-xl
          border border-white/70 rounded-2xl
          shadow-2xl shadow-slate-300/30
          max-h-72 overflow-y-auto custom-scrollbar
        ">
          <div className="p-1.5 space-y-0.5">
            {options.map(option => {
              const isSelected = option.value === value;
              const isHovered = option.value === hoveredValue;
              
              return (
                <button
                  key={option.value}
                  onClick={() => handleSelect(option.value)}
                  onMouseEnter={(e) => handleOptionHover(e, option.value)}
                  // onMouseLeave={clearHover} // 涓嶉渶瑕侊紝淇濇寔鏈€鍚庝竴娆℃偓鍋?
                  className={`
                    w-full text-left px-3 py-2.5 rounded-xl text-[10px] font-bold transition-all
                    flex items-center justify-between gap-2
                    ${isHovered 
                      ? 'bg-gradient-to-r from-emerald-50 to-cyan-50 text-emerald-700 scale-[1.02] shadow-sm' 
                      : isSelected 
                        ? 'bg-emerald-50 text-emerald-700' 
                        : 'text-slate-600 hover:bg-slate-50 hover:text-slate-900'
                    }
                  `}
                >
                  <span className="flex items-center gap-2">
                    {option.icon && <span className="text-base">{option.icon}</span>}
                    <span>{option.label}</span>
                  </span>
                  {isSelected && <span className="text-emerald-500 text-sm">鉁?/span>}
                </button>
              );
            })}
          </div>
        </div>
      </div>

      {/* 鎮诞棰勮妗?(Portal) */}
      {showPreview && createPortal(
        <div 
          className="fixed z-[9999] pointer-events-none w-48 h-48 animate-slideInFade"
          style={{
             top: previewPos.top,
             left: previewPos.left,
          }}
        >
          <div className="
            w-full h-full bg-slate-900/95 backdrop-blur-2xl
            border border-emerald-500/30 rounded-2xl
            shadow-[0_10px_40px_-10px_rgba(0,0,0,0.5)]
            overflow-hidden relative
          ">
            {previewType === 'shape' && (
              <ShapePreview3D 
                shapeType={previewValue as Shape3DType} 
                className="w-full h-full"
              />
            )}
            {previewType === 'trajectory' && (
              <TrajectoryPreviewCanvas
                trajectoryType={previewValue as TrajectoryType}
                className="w-full h-full"
              />
            )}
            
            {/* 鏍囩 */}
            <div className="absolute bottom-3 left-0 right-0 flex justify-center">
               <div className="bg-black/50 backdrop-blur px-3 py-1 rounded-full border border-white/10">
                 <span className="text-[9px] font-black text-emerald-400 uppercase tracking-widest">
                   {previewType === 'shape' && SHAPE_3D_INFO[previewValue as Shape3DType]?.name}
                   {previewType === 'trajectory' && TRAJECTORY_INFO[previewValue as TrajectoryType]?.name}
                 </span>
               </div>
            </div>
          </div>
        </div>,
        document.body
      )}
      
      <style>{`
        @keyframes slideInFade {
          from { opacity: 0; transform: scale(0.95); }
          to { opacity: 1; transform: scale(1); }
        }
        .animate-slideInFade { animation: slideInFade 0.15s ease-out forwards; }
      `}</style>
    </div>
  );
};


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\DirectionIndicator.tsx ======
// FILE: src/components/ui/DirectionIndicator.tsx
// 涓荤敾闈㈡柟鍚戞寚绀哄櫒 - 鏄剧ず XYZ 鍧愭爣杞存柟鍚?
// 鍖呭惈涓€涓悜涓婄殑绠ご鎸囩ず +Z 鏂瑰悜

import React from 'react';

interface DirectionIndicatorProps {
  className?: string;
}

/**
 * 3D 鏂瑰悜鎸囩ず鍣?
 * 鏄剧ず鍦ㄤ富鐢婚潰搴曢儴锛屾寚绀哄綋鍓嶇殑鍧愭爣绯绘柟鍚?
 */
export const DirectionIndicator: React.FC<DirectionIndicatorProps> = ({
  className = ''
}) => {
  return (
    <div className={`fixed left-8 bottom-72 z-20 pointer-events-none ${className}`}>
      {/* 3D 鎮诞鎸囩ず鍣ㄥ鍣?*/}
      <div className="relative group">
        
        {/* ========= 鏍稿績锛氬悜涓婄殑鎸囧紩绠ご ========= */}
        <div className="absolute -top-24 left-1/2 -translate-x-1/2 flex flex-col items-center animate-bounce-slow">
            <div className="relative">
                {/* 绠ご涓讳綋 - 闇撹櫣鍙戝厜 */}
                <svg width="40" height="60" viewBox="0 0 40 60" className="drop-shadow-[0_0_15px_rgba(16,185,129,0.8)]">
                    <defs>
                        <linearGradient id="neonGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                           <stop offset="0%" stopColor="#059669" stopOpacity="0" />
                           <stop offset="50%" stopColor="#10b981" stopOpacity="0.8" />
                           <stop offset="100%" stopColor="#34d399" stopOpacity="1" />
                        </linearGradient>
                    </defs>
                    <path d="M20 0 L35 25 L24 25 L24 60 L16 60 L16 25 L5 25 Z" fill="url(#neonGradient)" />
                </svg>
                {/* 椤剁鍏夌偣 */}
                <div className="absolute top-0 left-1/2 -translate-x-1/2 w-8 h-8 bg-emerald-400 rounded-full blur-xl opacity-60"></div>
            </div>
            <div className="mt-1 text-[10px] font-black tracking-[0.2em] text-emerald-400 uppercase drop-shadow-md">UP</div>
        </div>

        {/* ========= 鍧愭爣杞?Gizmo ========= */}
        <div className="w-24 h-24 relative perspective-500">
            {/* 鐜荤拑鎬佽儗鏅渾鐩?*/}
            <div className="absolute inset-0 bg-gradient-to-tr from-slate-900/80 to-slate-800/80 rounded-full border border-white/10 backdrop-blur-md shadow-2xl"></div>
            <div className="absolute inset-2 border border-dashed border-white/5 rounded-full animate-spin-slow-reverse"></div>
            
            {/* 鍧愭爣杞?SVG */}
            <svg viewBox="0 0 100 100" className="w-full h-full p-4 overflow-visible">
                {/* Y Axis (Up) */}
                <line x1="50" y1="50" x2="50" y2="10" stroke="#10b981" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(16,185,129,0.8)]" />
                <text x="54" y="15" fill="#10b981" fontSize="10" fontWeight="900">Y+</text>

                {/* X Axis (Right) */}
                <line x1="50" y1="50" x2="90" y2="50" stroke="#f43f5e" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(244,63,94,0.8)]" />
                <text x="92" y="54" fill="#f43f5e" fontSize="10" fontWeight="900">X+</text>

                {/* Z Axis (Forward - Projected) */}
                <line x1="50" y1="50" x2="20" y2="85" stroke="#3b82f6" strokeWidth="3" strokeLinecap="round" className="drop-shadow-[0_0_8px_rgba(59,130,246,0.8)]" />
                <text x="10" y="90" fill="#3b82f6" fontSize="10" fontWeight="900">Z+</text>

                {/* Center Point */}
                <circle cx="50" cy="50" r="4" fill="white" className="drop-shadow-[0_0_5px_rgba(255,255,255,1)]" />
            </svg>
        </div>
      </div>
      
      {/* 搴曢儴鏂囧瓧淇℃伅 */}
      <div className="mt-2 text-center">
        <div className="text-[9px] font-bold text-slate-400/80 tracking-widest uppercase">System Ready</div>
      </div>

      <style>{`
        .perspective-500 { perspective: 500px; }
        .animate-spin-slow-reverse { animation: spin 10s linear infinite reverse; }
        .animate-bounce-slow { animation: bounceSlow 3s infinite ease-in-out; }
        @keyframes bounceSlow {
            0%, 100% { transform: translate(-50%, 0); }
            50% { transform: translate(-50%, -10px); }
        }
      `}</style>
    </div>
  );
};

/**
 * 绠€鍖栫増锛氫粎鏄剧ず鍧愭爣杞存爣璇?(澶囩敤)
 */
export const AxisIndicator: React.FC<{ className?: string }> = ({ className = '' }) => (
  <div className={`fixed left-6 bottom-6 z-20 pointer-events-none ${className}`}>
     {/* 绠€鍗曠殑鎸囩ず鍣ㄥ唴瀹癸紝淇濇寔鍘熸牱鎴栫暐寰紭鍖?*/}
     <div className="w-12 h-12 bg-white/10 rounded-full border border-white/20"></div>
  </div>
);


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\FireworkInfoPanel.tsx ======
// FILE: src/components/ui/FireworkInfoPanel.tsx
// 淇℃伅闈㈡澘锛氭樉绀哄綋鍓嶇儫鑺辩殑褰㈢姸鍜岃建杩圭被鍨?
// 褰撶敤鎴锋斁鎱㈤€熷害鏃跺彲浠ユ竻妤氬湴鐪嬪埌姣忎釜鐑熻姳鐨勮缁嗕俊鎭?

import React from 'react';
import { Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';

export interface FireworkInfo {
  id: string;
  shape: Shape3DType;
  trajectory: TrajectoryType;
  position: { x: number; y: number; z: number };
  velocity: number;
  particleCount: number;
  progress: number;  // 0-1, 鐢熷懡杩涘害
}

interface FireworkInfoPanelProps {
  fireworks: FireworkInfo[];
  timeScale: number;  // 褰撳墠鏃堕棿缂╂斁
  show: boolean;
}

/**
 * 鐑熻姳淇℃伅闈㈡澘
 * 褰撴椂闂存斁鎱㈡椂鏄剧ず姣忎釜鐑熻姳鐨勮缁嗕俊鎭?
 */
export const FireworkInfoPanel: React.FC<FireworkInfoPanelProps> = ({
  fireworks,
  timeScale,
  show
}) => {
  // 鍙湪鎱㈤€熸椂鏄剧ず锛坱imeScale < 0.5锛?
  const shouldShow = show && timeScale < 0.5 && fireworks.length > 0;
  
  if (!shouldShow) return null;
  
  return (
    <div className="absolute left-8 top-1/2 -translate-y-1/2 z-20 pointer-events-none">
      <div className="bg-black/70 backdrop-blur-xl rounded-2xl border border-white/10 p-4 max-h-[60vh] overflow-y-auto custom-scrollbar">
        {/* 鏍囬 */}
        <div className="flex items-center gap-2 mb-3 pb-2 border-b border-white/10">
          <div className="w-2 h-2 rounded-full bg-cyan-400 animate-pulse"></div>
          <span className="text-[9px] font-black text-cyan-400 uppercase tracking-wider">
            Slow Motion Analysis
          </span>
        </div>
        
        {/* 鏃堕棿缂╂斁鎸囩ず鍣?*/}
        <div className="mb-3 p-2 bg-white/5 rounded-lg">
          <div className="text-[8px] text-white/50 uppercase tracking-wider">Time Scale</div>
          <div className="text-lg font-black text-white">{(timeScale * 100).toFixed(0)}%</div>
        </div>
        
        {/* 鐑熻姳鍒楄〃 */}
        <div className="space-y-2">
          {fireworks.slice(0, 5).map((fw, i) => (
            <div 
              key={fw.id}
              className="p-3 bg-white/5 rounded-xl border border-white/5 hover:border-white/20 transition-colors"
            >
              {/* 褰㈢姸淇℃伅 */}
              <div className="flex items-center gap-2 mb-1">
                <span className="text-lg">{SHAPE_3D_INFO[fw.shape]?.icon || '鉁?}</span>
                <div>
                  <div className="text-xs font-bold text-white">
                    {SHAPE_3D_INFO[fw.shape]?.name || fw.shape}
                  </div>
                  <div className="text-[8px] text-white/40">SHAPE</div>
                </div>
              </div>
              
              {/* 杞ㄨ抗淇℃伅 */}
              <div className="flex items-center gap-2 mb-2">
                <span className="text-lg">{TRAJECTORY_INFO[fw.trajectory]?.icon || '馃殌'}</span>
                <div>
                  <div className="text-xs font-bold text-emerald-400">
                    {TRAJECTORY_INFO[fw.trajectory]?.name || fw.trajectory}
                  </div>
                  <div className="text-[8px] text-white/40">TRAJECTORY</div>
                </div>
              </div>
              
              {/* 瀹炴椂鏁版嵁 */}
              <div className="grid grid-cols-2 gap-2 text-[8px] font-mono text-white/50">
                <div>
                  <span className="text-white/30">POS: </span>
                  <span className="text-cyan-300">
                    {fw.position.x.toFixed(0)}, {fw.position.y.toFixed(0)}
                  </span>
                </div>
                <div>
                  <span className="text-white/30">VEL: </span>
                  <span className="text-orange-300">{fw.velocity.toFixed(1)} m/s</span>
                </div>
                <div className="col-span-2">
                  <span className="text-white/30">PARTICLES: </span>
                  <span className="text-purple-300">{fw.particleCount}</span>
                </div>
              </div>
              
              {/* 杩涘害鏉?*/}
              <div className="mt-2 h-1 bg-white/10 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-cyan-500 to-emerald-500 transition-all"
                  style={{ width: `${fw.progress * 100}%` }}
                />
              </div>
            </div>
          ))}
          
          {fireworks.length > 5 && (
            <div className="text-center text-[9px] text-white/30 py-2">
              +{fireworks.length - 5} more fireworks...
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

/**
 * 绠€鍖栫増锛氬崟涓儫鑺辨爣绛撅紙鐢ㄤ簬璺熻釜鏄剧ず锛?
 */
export const FireworkLabel: React.FC<{
  shape: Shape3DType;
  trajectory: TrajectoryType;
  position: { x: number; y: number };
}> = ({ shape, trajectory, position }) => {
  return (
    <div 
      className="absolute pointer-events-none z-30"
      style={{ 
        left: position.x, 
        top: position.y,
        transform: 'translate(-50%, -100%) translateY(-10px)'
      }}
    >
      <div className="bg-black/80 backdrop-blur-sm rounded-lg px-2 py-1 border border-white/20 whitespace-nowrap">
        <div className="text-[10px] font-bold text-white flex items-center gap-1">
          <span>{SHAPE_3D_INFO[shape]?.icon}</span>
          <span>{SHAPE_3D_INFO[shape]?.name}</span>
        </div>
        <div className="text-[8px] text-emerald-400 flex items-center gap-1">
          <span>{TRAJECTORY_INFO[trajectory]?.icon}</span>
          <span>{TRAJECTORY_INFO[trajectory]?.name}</span>
        </div>
      </div>
    </div>
  );
};


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\HUD.tsx ======

import React from 'react';

export const HUD: React.FC = () => {
  return (
    <>
      {/* 澶撮儴淇℃伅 */}
      <div className="absolute top-10 left-10 z-10 pointer-events-none">
        <div className="flex items-center gap-4 mb-2">
          <div className="w-1.5 h-12 bg-cyan-500 rounded-full shadow-[0_0_20px_rgba(6,182,212,1)] animate-pulse"></div>
          <div>
            <h1 className="text-5xl font-black tracking-tighter italic leading-none">
              鐠€鐠?span className="text-cyan-400">鏄熻景</span> V4
            </h1>
            <p className="text-[10px] text-cyan-500/50 tracking-[0.5em] font-bold uppercase mt-1">
              Deep Space Particle System 鈥?Pro Edition
            </p>
          </div>
        </div>
      </div>

      {/* 搴曢儴娴爣 */}
      <footer className="absolute bottom-10 left-0 right-0 flex justify-center items-center gap-12 pointer-events-none opacity-20">
        <div className="h-[1px] w-40 bg-gradient-to-r from-transparent via-white/40 to-transparent"></div>
        <div className="text-[10px] text-white uppercase tracking-[1em] font-light flex gap-8">
          <span>琛屾槦</span><span>钂插叕鑻?/span><span>钀ょ伀铏?/span><span>鍦熸槦鐜?/span><span>鏄熻姃</span><span>娉㈡氮</span>
        </div>
        <div className="h-[1px] w-40 bg-gradient-to-l from-transparent via-white/40 to-transparent"></div>
      </footer>

      {/* 浜掑姩鎻愮ず */}
      <div className="absolute bottom-10 left-10 text-[9px] text-white/30 tracking-[0.2em] font-medium pointer-events-none space-y-1">
        <p>鈥?鐐瑰嚮/瑙︽懜鍙戝皠</p>
        <p>鈥?闀挎寜钃勫姏澶ф嫑</p>
        <p>鈥?绉诲姩榧犳爣浜х敓鏄熷皹</p>
      </div>

      <div className="absolute inset-0 bg-gradient-to-t from-cyan-950/20 via-transparent to-transparent pointer-events-none"></div>
    </>
  );
};


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\HUD3D.tsx ======
// FILE: src/components/ui/HUD3D.tsx

import React from 'react';

export const HUD3D: React.FC = () => {
    return (
        <>
            {/* 澶撮儴淇℃伅 - 娴呰壊鏋佺畝椋庢牸 */}
            <div className="absolute top-8 left-8 z-10 pointer-events-none select-none">
                <div className="flex items-center gap-4">
                    <div className="w-1.5 h-12 bg-gradient-to-b from-gray-800 to-gray-400 rounded-full"></div>
                    <div>
                        <h1 className="text-4xl font-black tracking-tight text-gray-800">
                            Celestial <span className="text-gray-400 font-light">Fireworks</span>
                        </h1>
                        <p className="text-[10px] text-gray-500 tracking-[0.4em] font-medium uppercase mt-1">
                            Interactive 3D Simulation
                        </p>
                    </div>
                </div>
            </div>

            {/* 鍙充笅浜掑姩鎻愮ず - 鍗＄墖寮忚璁?*/}
            <div className="absolute bottom-8 right-8 pointer-events-none">
                <div className="bg-white/80 backdrop-blur-md p-5 rounded-2xl shadow-lg border border-white/50 text-gray-600">
                    <p className="text-gray-900 font-bold text-xs mb-3 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-green-400"></span>
                        CONTROL GUIDE
                    </p>
                    <div className="space-y-1.5 text-[10px] font-medium tracking-wide">
                        <div className="flex justify-between w-40">
                            <span>Rotate View</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">LMB / Drag</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Launch</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Click Ground</span>
                        </div>
                        <div className="flex justify-between w-40">
                            <span>Zoom</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">Scroll</span>
                        </div>
                        <div className="flex justify-between w-40 mt-2 pt-2 border-t border-gray-200">
                            <span>Pause / Play</span>
                            <span className="font-bold bg-gray-200 px-1.5 rounded text-gray-700">P</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* 搴曢儴瑁呴グ绾?*/}
            <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-gray-300 to-transparent opacity-50 pointer-events-none"></div>
        </>
    );
};

// END OF FILE: src/components/ui/HUD3D.tsx

====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\ModernSettingsPanel.tsx ======
// FILE: src/components/ui/ModernSettingsPanel.tsx
// 鐜颁唬鍖栬缃潰鏉?- 娴呰壊涓婚锛屾暣鍚堟柊绯荤粺 - 娑叉€佺幓鐠冮鏍?

import React, { useState, useMemo } from 'react';
import { ShapePreviewCard, ShapePreview3D } from './ShapePreviewCard';
import { TrajectoryPreview3D } from './TrajectoryPreview3D';
import { CustomSelect } from './CustomSelect';
import { CustomSelectWithPreview } from './CustomSelectWithPreview';
import { Shape3DType, SHAPE_3D_INFO, SHAPE_CATEGORIES } from '../../core/shapes/Shape3DFactory';
import { TrajectoryType, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { ComboType } from '../../core/combos/ComboManager';

// 瀵煎叆鐜版湁绫诲瀷浠ヤ繚鎸佸吋瀹?
import { 
  AppSettings, 
  FireworkConfig, 
  ManualConfig, 
  CarnivalStage,
  LaunchFormation
} from '../../types';

interface ModernSettingsPanelProps {
  show: boolean;
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  onClose: () => void;
  onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
  onUpdateConfig: (config: FireworkConfig) => void;
  onUpdateManual: (config: ManualConfig) => void;
  onRandomize: () => void;
  onReset: () => void;
  onLaunchCarnival: () => void;
}

type TabId = 'shapes' | 'trajectories' | 'manual' | 'carnival' | 'physics';

export const ModernSettingsPanel: React.FC<ModernSettingsPanelProps> = ({
  show,
  settings,
  config,
  manualConfig,
  onClose,
  onUpdate,
  onUpdateConfig,
  onUpdateManual,
  onRandomize,
  onReset,
  onLaunchCarnival
}) => {
  const [activeTab, setActiveTab] = useState<TabId>('shapes');
  
  // 鏍稿績鐘舵€侊細褰撳墠姝ｅ湪棰勮鐨勯」 (鏉ヨ嚜 Grid Hover 鎴?Dropdown Hover)
  // 濡傛灉娌℃湁 Hover锛屽垯鏄剧ず褰撳墠閫変腑鐨勶紙濡傜涓€涓惎鐢ㄧ殑褰㈢姸鎴栬建杩癸級
  const [previewShape, setPreviewShape] = useState<Shape3DType | null>(null);
  const [previewTrajectory, setPreviewTrajectory] = useState<TrajectoryType | null>(null);

  const [selectedCategory, setSelectedCategory] = useState<string>(SHAPE_CATEGORIES.BASIC_GEOMETRY);
  
  // 鐘舵€佸悓姝ヤ紭鍖?
  const [localSeq, setLocalSeq] = useState<CarnivalStage[]>(config.carnivalSequence || []);
  const [hasChanges, setHasChanges] = useState(false);

  // 褰撳閮?config 鍙樺寲涓旈潪鏈湴缂栬緫瀵艰嚧鏃讹紝鍚屾鏁版嵁
  React.useEffect(() => {
    if (!hasChanges) {
      setLocalSeq(config.carnivalSequence || []);
    }
  }, [config.carnivalSequence, hasChanges]);

  const handleUpdateLocal = (newSeq: CarnivalStage[]) => {
    setLocalSeq(newSeq);
    setHasChanges(true);
  };

  const handleApplySequence = () => {
    onUpdateConfig({ ...config, carnivalSequence: localSeq });
    setHasChanges(false);
  };
  
  // 鎸夌被鍒垎缁勫舰鐘?
  const shapesByCategory = useMemo(() => {
    const groups: Record<string, Shape3DType[]> = {};
    Object.values(Shape3DType).forEach(type => {
      const info = SHAPE_3D_INFO[type];
      if (!groups[info.category]) groups[info.category] = [];
      groups[info.category].push(type);
    });
    return groups;
  }, []);
  
  const [selectedNewShapes, setSelectedNewShapes] = useState<Shape3DType[]>(config.enabledShape3Ds || []);
  const [selectedTrajectories, setSelectedTrajectories] = useState<TrajectoryType[]>(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  
  React.useEffect(() => {
    setSelectedNewShapes(config.enabledShape3Ds || []);
    setSelectedTrajectories(config.enabledTrajectories || [TrajectoryType.LINEAR]);
  }, [config.enabledShape3Ds, config.enabledTrajectories]);

  const toggleNewShape = (type: Shape3DType) => {
    const next = selectedNewShapes.includes(type) 
      ? selectedNewShapes.filter(t => t !== type)
      : [...selectedNewShapes, type];
    setSelectedNewShapes(next);
    onUpdateConfig({ ...config, enabledShape3Ds: next });
  };
  
  const toggleTrajectory = (type: TrajectoryType) => {
    const next = selectedTrajectories.includes(type) 
      ? selectedTrajectories.filter(t => t !== type)
      : [...selectedTrajectories, type];
    setSelectedTrajectories(next);
    onUpdateConfig({ ...config, enabledTrajectories: next });
  };
  
  const tabs = [
    { id: 'shapes' as TabId, label: 'Shape Lab', icon: '馃帹', title: '褰㈢姸瀹為獙瀹? },
    { id: 'trajectories' as TabId, label: 'Path', icon: '馃殌', title: '杞ㄨ抗瑙勫垝' },
    { id: 'manual' as TabId, label: 'Interaction', icon: '馃憜', title: '鎵嬪姩浜や簰閰嶇疆' },
    { id: 'carnival' as TabId, label: 'Show', icon: '馃幀', title: '澶х缂栨帓' },
    { id: 'physics' as TabId, label: 'Engine', icon: '鈿欙笍', title: '鐗╃悊寮曟搸' },
  ];

  // 璁＄畻褰撳墠搴旇鍦ㄩ《閮ㄥ浐瀹氶瑙堟樉绀虹殑椤?
  const activeShapeToShow = previewShape || (selectedNewShapes.length > 0 ? selectedNewShapes[0] : Shape3DType.SPHERE);
  const activeTrajectoryToShow = previewTrajectory || (selectedTrajectories.length > 0 ? selectedTrajectories[0] : TrajectoryType.LINEAR);
  
  // 鍐冲畾鏄剧ず鍝棰勮 (Shape 杩樻槸 Trajectory)
  // 瑙勫垯锛氬湪 Trajectories Tab 鏄剧ず杞ㄨ抗锛屽叾浠栨儏鍐甸粯璁ゆ樉绀哄舰鐘讹紙鎴栨牴鎹笂涓嬫枃锛?
  const showTrajectoryPreview = activeTab === 'trajectories';

  return (
    <div 
      className={`
        fixed top-0 right-0 h-full w-[480px] 
        bg-slate-50/90 backdrop-blur-3xl 
        shadow-[0_0_50px_rgba(0,0,0,0.2)] z-40 
        transform transition-all duration-500 cubic-bezier(0.2, 0.8, 0.2, 1)
        border-l border-white/60
        flex flex-col
        ${show ? 'translate-x-0' : 'translate-x-full'}
      `}
    >
      {/* ========== Header ========== */}
      <div className="px-6 pt-6 pb-2 border-b border-white/50 bg-gradient-to-b from-white/60 to-transparent">
        <div className="flex justify-between items-start mb-4">
          <div>
            <h2 className="text-2xl font-black text-slate-800 tracking-tight drop-shadow-sm flex items-center gap-2">
              <span className="text-3xl">鉁?/span>
              Aetheris
            </h2>
            <p className="text-[10px] text-slate-400 font-bold tracking-[0.2em] uppercase ml-1">
              Universal Particle System
            </p>
          </div>
          <button 
            onClick={onClose}
            className="w-10 h-10 rounded-full flex items-center justify-center text-slate-400 hover:text-white hover:bg-slate-800 transition-all shadow-sm border border-white/50"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Tabs */}
        <div className="flex gap-2 bg-slate-200/50 p-1.5 rounded-2xl border border-white/50 shadow-inner overflow-x-auto custom-scrollbar">
          {tabs.map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`
                flex-1 min-w-[70px] py-3 px-2 rounded-xl text-[10px] font-black uppercase tracking-wider
                transition-all relative overflow-hidden group
                ${activeTab === tab.id 
                  ? 'bg-white text-emerald-600 shadow-[0_4px_12px_rgba(16,185,129,0.15)] ring-1 ring-emerald-100' 
                  : 'text-slate-400 hover:text-slate-600 hover:bg-white/40'
                }
              `}
            >
              <div className="flex flex-col items-center gap-1">
                <span className="text-xl filter drop-shadow-sm transition-transform group-hover:scale-110">{tab.icon}</span>
                <span className="scale-90">{tab.label}</span>
              </div>
            </button>
          ))}
        </div>
      </div>
      
      {/* ========== Unified Fixed Preview Area (Sticky Top) ========== */}
      <div className="relative z-10 bg-gradient-to-b from-slate-100/50 to-white/30 border-b border-white/60">
        {showTrajectoryPreview ? (
           <div className="h-48 w-full bg-slate-900 border-y border-white/10 relative overflow-hidden group">
              <TrajectoryPreview3D 
                trajectoryType={activeTrajectoryToShow}
                speed={15}
                height={250}
                angle={0}
              />
              <div className="absolute top-2 left-3 bg-black/50 backdrop-blur px-2 py-1 rounded-lg text-[9px] font-bold text-cyan-400 border border-cyan-500/30">
                PATH PREVIEW
              </div>
           </div>
        ) : (
           <ShapePreview3D 
              shapeType={activeShapeToShow} 
              className="h-48 border-b border-white/40 bg-gradient-to-b from-slate-50/50 to-white/50 shadow-inner"
           />
        )}
      </div>
      
      {/* ========== Content ========== */}
      <div className="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar bg-white/30">
        
        {/* ===== Tab: Shapes ===== */}
        {activeTab === 'shapes' && (
          <div className="space-y-6 animate-slideUp">
            <div className="flex flex-wrap gap-2 sticky top-0 bg-white/80 backdrop-blur p-2 -mx-2 rounded-xl z-10 border border-white/50 shadow-sm">
              {Object.values(SHAPE_CATEGORIES).map(cat => (
                <button
                  key={cat}
                  onClick={() => setSelectedCategory(cat)}
                  className={`
                    px-4 py-2 rounded-xl text-[10px] font-bold transition-all border
                    ${selectedCategory === cat 
                      ? 'bg-emerald-500 border-emerald-500 text-white shadow-lg shadow-emerald-500/30' 
                      : 'bg-white border-white text-slate-500 hover:bg-emerald-50 hover:text-emerald-600'
                    }
                  `}
                >
                  {cat}
                </button>
              ))}
            </div>
            
            <div className="grid grid-cols-2 gap-3">
              {shapesByCategory[selectedCategory]?.map(type => (
                <ShapePreviewCard
                  key={type}
                  type={type}
                  active={selectedNewShapes.includes(type)}
                  onClick={() => toggleNewShape(type)}
                  onPreview={(shape) => setPreviewShape(shape)}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Trajectories ===== */}
        {activeTab === 'trajectories' && (
          <div className="space-y-4 animate-slideUp">
             <div className="bg-blue-50/50 p-4 rounded-2xl border border-blue-100 text-[10px] text-blue-600 font-medium">
                閫夋嫨宸插惎鐢ㄧ殑涓婂崌杞ㄨ抗銆傜郴缁熷皢鍦ㄥ彂灏勬椂浠庝腑闅忔満閫夋嫨銆?
             </div>
             <div className="grid grid-cols-1 gap-2">
              {Object.values(TrajectoryType).map(type => {
                const info = TRAJECTORY_INFO[type];
                const isSelected = selectedTrajectories.includes(type);
                const isHovered = previewTrajectory === type;
                
                return (
                  <button
                    key={type}
                    onClick={() => toggleTrajectory(type)}
                    onMouseEnter={() => setPreviewTrajectory(type)}
                    onMouseLeave={() => setPreviewTrajectory(null)}
                    className={`
                      w-full p-4 rounded-2xl border text-left transition-all duration-300 flex items-center justify-between group
                      ${isHovered 
                        ? 'border-cyan-300 bg-gradient-to-r from-cyan-50 to-emerald-50 shadow-lg scale-[1.02]'
                        : isSelected 
                          ? 'border-emerald-200 bg-white shadow-lg shadow-emerald-100/50 scale-[1.01]' 
                          : 'border-white/60 bg-white/60 hover:bg-white hover:border-emerald-100'
                      }
                    `}
                  >
                    <div className="flex items-center gap-4">
                      <div className={`
                        w-11 h-11 rounded-2xl flex items-center justify-center text-xl
                        ${isHovered || isSelected ? 'bg-emerald-50 text-emerald-600' : 'bg-slate-50 text-slate-400'}
                      `}>
                        {info.icon}
                      </div>
                      <div>
                        <div className="text-sm font-black text-slate-700">{info.name}</div>
                        <p className="text-[10px] text-slate-400 font-medium">{info.description}</p>
                      </div>
                    </div>
                    {isSelected && <span className="text-emerald-500 text-lg">鉁?/span>}
                  </button>
                );
              })}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Manual Interaction ===== */}
        {activeTab === 'manual' && (
          <div className="space-y-8 animate-slideUp">
             {/* Locked Configuration for Manual Click */}
             <div className="bg-white/60 backdrop-blur-xl p-6 rounded-3xl border border-white shadow-sm space-y-5">
                <div className="flex items-center gap-3 mb-2">
                   <div className="p-2 bg-orange-100 text-orange-500 rounded-lg text-lg">馃憞</div>
                   <div>
                      <h3 className="text-sm font-black text-slate-800">鐐瑰嚮浜や簰閰嶇疆</h3>
                      <p className="text-[10px] text-slate-400 font-bold">閰嶇疆榧犳爣鐐瑰嚮绌虹櫧澶勬椂鐨勫彂灏勮涓?/p>
                   </div>
                </div>

                {/* 1. 鍙戝皠闃熷舰涓庢暟閲?*/}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="鍙戝皠闃熷舰" />
                      <CustomSelect 
                         value={manualConfig.lockedFormation || LaunchFormation.SINGLE}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedFormation: v as LaunchFormation })}
                         options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="鍗曟鏁伴噺" />
                      <div className="h-10 flex items-center bg-white/50 rounded-xl px-2 border border-white/50">
                         <input 
                           type="range" min="1" max="20" step="1" 
                           value={manualConfig.lockedCount || 1}
                           onChange={e => onUpdateManual({ ...manualConfig, lockedCount: parseInt(e.target.value) })}
                           className="w-full h-1.5 bg-gray-200 rounded-full appearance-none accent-orange-500 cursor-pointer"
                         />
                         <span className="ml-2 text-xs font-black min-w-[20px] text-right">{manualConfig.lockedCount || 1}</span>
                      </div>
                   </div>
                </div>

                {/* 2. 褰㈢姸涓庤建杩归攣瀹?- 浣跨敤甯﹂瑙堢殑 Select */}
                <div className="grid grid-cols-2 gap-4">
                   <div className="space-y-1.5">
                      <Label text="閿佸畾褰㈢姸 (Hover Preview)" />
                      <CustomSelectWithPreview 
                         value={manualConfig.lockedShape as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedShape: v as any })}
                         options={[{ label: '馃幉 闅忔満', value: 'RANDOM' }, ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))]}
                         previewType="shape"
                         placeholder="闅忔満"
                      />
                   </div>
                   <div className="space-y-1.5">
                      <Label text="閿佸畾杞ㄨ抗 (Hover Preview)" />
                      <CustomSelectWithPreview 
                         value={manualConfig.lockedTrajectory as string}
                         onChange={v => onUpdateManual({ ...manualConfig, lockedTrajectory: v as any })}
                         options={[{ label: '馃幉 闅忔満', value: 'RANDOM' }, ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))]}
                         previewType="trajectory"
                         placeholder="闅忔満"
                      />
                   </div>
                </div>

                {/* 3. 楂樼骇鍙傛暟 */}
                 <div className="space-y-4 pt-4 border-t border-gray-100">
                    <Label text="楂樼骇鍙傛暟 (Advanced)" />
                    <div className="grid grid-cols-2 gap-4">
                       <Slider label="鍙戝皠闂撮殧 (ms)" value={manualConfig.lockedInterval || 0} min={0} max={500} step={10} onChange={v => onUpdateManual({ ...manualConfig, lockedInterval: v })} color="orange" />
                       <Slider label="瀛樼画鏃堕棿 (s)" value={manualConfig.lockedDuration || 0} min={0} max={10} step={0.5} unit="s" onChange={v => onUpdateManual({ ...manualConfig, lockedDuration: v })} color="orange" />
                    </div>
                </div>
             </div>
          </div>
        )}
        
        {/* ===== Tab: Carnival ===== */}
        {activeTab === 'carnival' && (
          <div className="space-y-6">
            <div className="bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-500 p-6 rounded-[32px] shadow-2xl text-white relative overflow-hidden group">
               {/* Background Glow */}
               <div className="absolute top-0 right-0 w-64 h-64 bg-white/10 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2 group-hover:bg-white/20 transition-all duration-1000" />
               
               <div className="relative z-10">
                  <div className="flex justify-between items-start mb-6">
                    <div>
                      <h3 className="text-xl font-black tracking-tight">澶х缂栨帓</h3>
                      <p className="text-[10px] font-bold opacity-60 uppercase tracking-widest mt-1">Direct Your Masterpiece</p>
                    </div>
                   <div className="flex flex-col items-end gap-2">
                      <div className="flex items-center gap-2 bg-black/20 backdrop-blur rounded-full px-1 py-1">
                         <label className="text-[9px] font-black px-3 uppercase opacity-80">Auto Loop</label>
                         <ToggleSwitch checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} color="emerald" customClass="scale-75 origin-right" />
                      </div>
                      {/* 鑷姩鎾斁闂撮殧鎺у埗 */}
                      {settings.enableAutoCarnival && (
                        <div className="flex items-center gap-2 bg-white/10 backdrop-blur rounded-lg px-2 py-1 animate-slideUp">
                           <span className="text-[9px] font-bold opacity-70">Interval</span>
                           <input 
                             type="range" min="1" max="10" step="1" 
                             value={settings.carnivalInterval} 
                             onChange={e => onUpdate('carnivalInterval', parseFloat(e.target.value))}
                             className="w-16 h-1 bg-white/30 rounded-full appearance-none accent-white cursor-pointer"
                           />
                           <span className="text-[9px] font-bold w-4">{settings.carnivalInterval}s</span>
                        </div>
                      )}
                   </div>
                  </div>
                  
                  <div className="flex gap-3">
                     <button 
                       onClick={handleApplySequence}
                       disabled={!hasChanges}
                       className={`
                          flex-1 py-3 rounded-2xl text-xs font-black transition-all border
                          ${hasChanges ? 'bg-white text-indigo-600 border-white shadow-lg' : 'bg-black/20 text-white/40 border-transparent cursor-not-allowed'}
                       `}
                     >
                       {hasChanges ? '鉁?鍚屾鍓ф湰' : '宸插悓姝?}
                     </button>
                     <button 
                       onClick={onLaunchCarnival}
                       className="flex-[2] py-3 bg-white text-slate-900 rounded-2xl text-xs font-black shadow-lg hover:scale-105 active:scale-95 transition-all flex items-center justify-center gap-2"
                     >
                        <span>馃幀</span> 绔嬪嵆鍚姩澶х
                     </button>
                  </div>
               </div>
            </div>

            <div className="space-y-3 pb-20">
              <div className="flex justify-between items-end px-2">
                 <Label text="WAVE SEQUENCE" />
                 <button
                    onClick={() => {
                      const id = Math.random().toString(36).substr(2, 9);
                      handleUpdateLocal([...localSeq, { id, name: `Wave ${localSeq.length + 1}`, count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.SPHERE, combo: ComboType.SINGLE, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 0 }]);
                    }}
                    className="text-[10px] font-black bg-indigo-50 text-indigo-600 px-3 py-1.5 rounded-lg hover:bg-indigo-100 transition-colors"
                  >
                    + 娣诲姞娉㈡
                  </button>
              </div>

              {localSeq.map((stage, idx) => (
                <div key={stage.id} className="bg-white p-5 rounded-[24px] border border-gray-100 shadow-sm hover:shadow-md transition-all flex flex-col gap-4 group">
                  <div className="flex justify-between items-center text-[12px] font-black text-slate-700">
                    <div className="flex items-center gap-3 flex-1">
                       <div className="w-6 h-6 rounded-full bg-slate-100 flex items-center justify-center text-[10px] text-slate-400 font-mono">{idx+1}</div>
                       <input 
                          value={stage.name} 
                          onChange={e => {
                            const next = [...localSeq];
                            next[idx] = { ...stage, name: e.target.value };
                            handleUpdateLocal(next);
                          }} 
                          className="bg-transparent outline-none w-full hover:bg-slate-50 focus:bg-slate-50 px-2 rounded transition-colors" 
                       />
                    </div>
                    <button onClick={() => {
                      const next = [...localSeq];
                      next.splice(idx, 1);
                      handleUpdateLocal(next);
                    }} className="text-gray-200 hover:text-red-400 text-lg px-2">脳</button>
                  </div>
                  
                  {/* 涓昏鍙傛暟 - 浣跨敤甯﹂瑙堢殑 Select */}
                  <div className="grid grid-cols-2 gap-3">
                     <CustomSelectWithPreview
                        value={stage.trajectory}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, trajectory: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: '馃幉 闅忔満杞ㄨ抗', value: 'RANDOM' },
                          ...Object.values(TrajectoryType).map(t => ({ label: TRAJECTORY_INFO[t].name, value: t }))
                        ]}
                        previewType="trajectory"
                        placeholder="閫夋嫨杞ㄨ抗"
                     />
                     <CustomSelectWithPreview
                        value={stage.shape}
                        onChange={v => {
                          const next = [...localSeq];
                          next[idx] = { ...stage, shape: v as any };
                          handleUpdateLocal(next);
                        }}
                        options={[
                          { label: '馃幉 闅忔満褰㈢姸', value: 'RANDOM' },
                          ...Object.values(Shape3DType).map(s => ({ label: SHAPE_3D_INFO[s].name, value: s }))
                        ]}
                        previewType="shape"
                        placeholder="閫夋嫨褰㈢姸"
                     />
                  </div>
                  
                  {/* 璇︾粏鍙傛暟鍖?- 榛樿鏄剧ず绠€鍗曠殑 Grid */}
                  <div className="grid grid-cols-2 gap-x-4 gap-y-3 p-3 bg-slate-50/50 rounded-2xl border border-slate-100">
                      <div className="col-span-2">
                        <Label text="LAUNCH FORMATION" />
                        <CustomSelect
                          value={stage.formation || LaunchFormation.RANDOM}
                          onChange={v => {
                             const next = [...localSeq];
                             next[idx] = { ...stage, formation: v as any };
                             handleUpdateLocal(next);
                          }}
                          options={Object.values(LaunchFormation).map(f => ({ label: f, value: f }))}
                        />
                      </div>
                      <Slider label="鏁伴噺" value={stage.count} min={1} max={50} step={1} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, count: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="娉㈡寤惰繜 (ms)" value={stage.delay} min={0} max={5000} step={100} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, delay: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="闂撮殧 (ms)" value={stage.interval || 0} min={0} max={500} step={10} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, interval: v }; handleUpdateLocal(next);
                      }} />
                      <Slider label="瀛樼画 (s)" value={stage.duration || 0} min={0} max={10} step={0.5} onChange={v => {
                         const next = [...localSeq]; next[idx] = { ...stage, duration: v }; handleUpdateLocal(next);
                      }} />
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* ===== Tab: Physics ===== */}
        {activeTab === 'physics' && (
          <div className="space-y-6">
            <div className="bg-white/60 p-6 rounded-[32px] border border-white space-y-6">
               <h3 className="text-sm font-black text-slate-800">Global Physics</h3>
               <Slider label="Gravity (閲嶅姏)" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
               <Slider label="Air Resistance (闃诲姏)" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
               <Slider label="Particle Density (瀵嗗害)" value={settings.particleCountMultiplier} min={0.1} max={3.0} step={0.1} unit="x" onChange={v => onUpdate('particleCountMultiplier', v)} />
               <Slider label="Explosion Scale (瑙勬ā)" value={settings.explosionSizeMultiplier} min={0.1} max={100} step={0.1} unit="x" onChange={v => onUpdate('explosionSizeMultiplier', v)} />
            </div>
          </div>
        )}
      </div>

      {/* ========== Footer ========== */}
      <div className="p-4 border-t border-white/60 bg-white/60 backdrop-blur flex gap-3 z-50 shadow-inner">
        <button onClick={onRandomize} className="flex-1 py-3 rounded-xl bg-slate-900 text-white text-xs font-bold hover:bg-emerald-600 transition-all shadow-lg hover:shadow-emerald-500/30">馃幉 Randomize Physics</button>
        <button onClick={onReset} className="px-6 py-3 rounded-xl bg-white border border-slate-200 text-slate-500 text-xs font-bold hover:bg-red-50 hover:text-red-500 hover:border-red-100 transition-all">Reset All</button>
      </div>
    </div>
  );
};

// ========== Subcomponents ========== //

const Label: React.FC<{ text: string }> = ({ text }) => (
   <div className="text-[9px] font-black text-slate-400 uppercase tracking-wider mb-1.5">{text}</div>
);

const Slider: React.FC<{ label: string, value: number, min: number, max: number, step: number, unit?: string, onChange: (v: number) => void, color?: string }> = ({ label, value, min, max, step, unit = '', onChange, color = 'indigo' }) => (
  <div className="space-y-1.5">
    <div className="flex justify-between items-center text-[10px]">
      <span className="font-bold text-slate-500">{label}</span>
      <span className="font-black text-slate-700 bg-white/50 px-1.5 py-0.5 rounded border border-white">{value.toFixed(step < 1 ? 2 : 0)}{unit}</span>
    </div>
    <input type="range" min={min} max={max} step={step} value={value} onChange={e => onChange(parseFloat(e.target.value))} className={`w-full h-1.5 bg-slate-200 rounded-full appearance-none cursor-pointer accent-${color}-500 hover:accent-${color}-400 transition-all`} />
  </div>
);

const ToggleSwitch: React.FC<{ checked: boolean, onChange: (v: boolean) => void, color?: string, customClass?: string }> = ({ checked, onChange, color = 'emerald', customClass = '' }) => (
  <button onClick={() => onChange(!checked)} className={`w-10 h-6 rounded-full transition-all duration-300 relative border border-transparent ${checked ? `bg-${color}-500 shadow-inner` : 'bg-slate-300'} ${customClass}`}>
    <div className={`absolute top-0.5 w-4 h-4 bg-white rounded-full shadow-md transition-all duration-300 ${checked ? 'left-5' : 'left-1'}`} />
  </button>
);


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\PreviewScene.tsx ======
// FILE: src/components/ui/PreviewScene.tsx

import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { ExplosionType, ColorStyle } from '../../types';
import { Firework3D } from '../../core/Firework3D';
import { ParticlePool3D } from '../../core/ParticlePool3D';

interface PreviewSceneProps {
    shape: ExplosionType;
    colorStyle: ColorStyle;
}

/**
 * 涓€涓秴杞婚噺绾х殑 3D 棰勮缁勪欢锛岀敤浜庡湪閰嶇疆闈㈡澘涓睍绀虹儫鑺辨晥鏋?
 */
export const PreviewScene: React.FC<PreviewSceneProps> = ({ shape, colorStyle }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
    const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(2000));
    const fireworksRef = useRef<Firework3D[]>([]);

    useEffect(() => {
        if (!containerRef.current) return;

        const width = containerRef.current.clientWidth;
        const height = containerRef.current.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8fafc); // 娴呰壊鑳屾櫙绗﹀悎鐜颁唬 UI

        const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
        camera.position.set(0, 0, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // 绠€鍖栫殑绮掑瓙绯荤粺
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            transparent: true,
            blending: THREE.NormalBlending, // 棰勮浣跨敤姝ｅ父娣峰悎浠ュ尮閰嶆祬鑹茶儗鏅?
            depthWrite: false
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        let lastSpawn = 0;
        let requestID: number;

        const animate = (time: number) => {
            requestID = requestAnimationFrame(animate);

            // 姣忛殧 1.5 绉掕嚜鍔ㄨЕ鍙戜竴娆￠瑙堢垎鐐?
            if (time - lastSpawn > 1500) {
                const fw = new Firework3D(
                    { startX: 0, startZ: 0, targetX: 0, targetY: 0, targetZ: 0, hue: Math.random() * 360, charge: 1.0 },
                    { gravity: 0.1, friction: 0.95, autoLaunchDelay: 1000, particleCountMultiplier: 1, explosionSizeMultiplier: 1, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                    { enabledShapes: [shape], enabledAscensions: [], enabledColors: [colorStyle] }
                );
                fw.exploded = true; // 鐩存帴璁剧疆涓虹垎鐐哥姸鎬?
                fireworksRef.current = [fw];
                lastSpawn = time;
            }

            fireworksRef.current.forEach((fw, i) => {
                if (fw.exploded) {
                    fw.createExplosion(
                        { gravity: 0.05, friction: 0.95, autoLaunchDelay: 0, particleCountMultiplier: 1, explosionSizeMultiplier: 0.8, starBlinkSpeed: 0, enableAutoCarnival: false, carnivalInterval: 0, trailLength: 0 },
                        (opts) => particlePoolRef.current.get(opts)
                    );
                    fireworksRef.current.splice(i, 1);
                }
            });

            particlePoolRef.current.update(0.016);

            // 鏇存柊 Buffer 鏁版嵁
            const particles = particlePoolRef.current.getActiveParticles();
            const pos = new Float32Array(particles.length * 3);
            const col = new Float32Array(particles.length * 3);

            particles.forEach((p, i) => {
                pos[i * 3] = p.position.x; pos[i * 3 + 1] = p.position.y; pos[i * 3 + 2] = p.position.z;
                const c = p.getColor();
                col[i * 3] = c.r; col[i * 3 + 1] = c.g; col[i * 3 + 2] = c.b;
            });

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            renderer.render(scene, camera);
        };

        requestID = requestAnimationFrame(animate);

        return () => {
            cancelAnimationFrame(requestID);
            renderer.dispose();
            if (containerRef.current) containerRef.current.innerHTML = '';
        };
    }, [shape, colorStyle]);

    return (
        <div className="w-full h-full relative group">
            <div ref={containerRef} className="w-full h-full" />
            <div className="absolute inset-0 pointer-events-none border-2 border-dashed border-gray-200 rounded-xl m-2 group-hover:border-blue-400 transition-colors" />
            <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-[10px] font-black text-gray-300 uppercase tracking-widest">
                Live 3D Preview
            </div>
        </div>
    );
};

// END OF FILE: src/components/ui/PreviewScene.tsx

====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\SettingsPanel.tsx ======
// FILE: src/components/ui/SettingsPanel.tsx

import React, { useState } from 'react';
import { AppSettings, FireworkConfig, ManualConfig, ExplosionType, AscensionType, ColorStyle, SHAPE_ICONS, COLOR_ICONS, ASCENSION_ICONS } from '../../types';
import { PreviewScene } from './PreviewScene';

interface SettingsPanelProps {
    show: boolean;
    settings: AppSettings;
    config: FireworkConfig;
    manualConfig: ManualConfig;
    onClose: () => void;
    onUpdate: (key: keyof AppSettings, value: number | boolean) => void;
    onUpdateConfig: (config: FireworkConfig) => void;
    onUpdateManual: (config: ManualConfig) => void;
    onRandomize: () => void;
    onReset: () => void;
}

export const SettingsPanel: React.FC<SettingsPanelProps> = ({
                                                                show, settings, config, manualConfig, onClose, onUpdate, onUpdateConfig, onUpdateManual, onRandomize, onReset
                                                            }) => {
    const [activeTab, setActiveTab] = useState<'carnival' | 'manual' | 'physics'>('carnival');

    // 鑾峰彇褰撳墠棰勮鐨勫璞?
    const previewShape = activeTab === 'manual' && manualConfig.lockedShape !== 'RANDOM'
        ? (manualConfig.lockedShape as ExplosionType)
        : ExplosionType.SPHERE;

    const previewColor = activeTab === 'manual' && manualConfig.lockedColor !== 'RANDOM'
        ? (manualConfig.lockedColor as ColorStyle)
        : ColorStyle.RAINBOW;

    return (
        <div className={`absolute top-0 right-0 h-full w-[450px] bg-white/95 backdrop-blur-3xl shadow-2xl z-40 transform transition-transform duration-500 ease-[cubic-bezier(0.23,1,0.32,1)] border-l border-gray-200 flex flex-col ${show ? 'translate-x-0' : 'translate-x-full'}`}>

            {/* 1. Panel Header */}
            <div className="p-6 pb-2 border-b border-gray-100">
                <div className="flex justify-between items-center mb-6">
                    <div>
                        <h2 className="text-2xl font-black tracking-tighter text-gray-800 italic">DESIGNER <span className="text-blue-600">HUB</span></h2>
                        <p className="text-[10px] text-gray-400 font-bold uppercase tracking-[0.2em] mt-1">Configure & Preview Your Show</p>
                    </div>
                    <button onClick={onClose} className="w-10 h-10 flex items-center justify-center rounded-full bg-gray-50 text-gray-400 hover:bg-red-50 hover:text-red-500 transition-all border border-gray-100">鉁?/button>
                </div>

                {/* 2. Navigation Tabs */}
                <div className="flex p-1 bg-gray-100 rounded-2xl mb-4">
                    {[
                        { id: 'carnival', label: '鍢夊勾鍗庨厤缃?, icon: '馃帯' },
                        { id: 'manual', label: '鍗曞彂璁捐', icon: '馃幆' },
                        { id: 'physics', label: '寮曟搸鏍稿績', icon: '鈿? }
                    ].map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id as any)}
                            className={`flex-1 py-3 text-xs font-black rounded-xl transition-all flex items-center justify-center gap-2 ${activeTab === tab.id ? 'bg-white shadow-lg text-blue-600 scale-[1.02]' : 'text-gray-400 hover:text-gray-600'}`}
                        >
                            <span>{tab.icon}</span>{tab.label}
                        </button>
                    ))}
                </div>
            </div>

            {/* 3. Main Content Scroll Area */}
            <div className="flex-1 overflow-y-auto custom-scrollbar p-6 space-y-8">

                {/* === 瀹炴椂 3D 棰勮绐楀彛 === */}
                <div className="h-48 bg-gray-50 rounded-3xl overflow-hidden border border-gray-100 shadow-inner relative">
                    <PreviewScene shape={previewShape} colorStyle={previewColor} />
                </div>

                {/* --- Tab 1: Carnival --- */}
                {activeTab === 'carnival' && (
                    <div className="space-y-8 animate-fadeIn">
                        <section className="bg-gradient-to-br from-blue-50 to-indigo-50 p-5 rounded-3xl border border-blue-100/50">
                            <div className="flex justify-between items-center mb-4">
                                <span className="text-xs font-black text-blue-900 uppercase">鑷姩杞挱鍢夊勾鍗?/span>
                                <Toggle checked={settings.enableAutoCarnival} onChange={v => onUpdate('enableAutoCarnival', v)} />
                            </div>
                            <SettingSlider label="鍙戝皠娉㈡棰戠巼" value={settings.carnivalInterval} min={1} max={15} step={1} unit="s" onChange={v => onUpdate('carnivalInterval', v)} />
                        </section>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-300 uppercase tracking-[0.3em] mb-4">鍚敤褰㈢姸闆?/h3>
                            <div className="grid grid-cols-2 gap-3">
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={config.enabledShapes.includes(t)}
                                        onClick={() => onUpdateConfig({...config, enabledShapes: config.enabledShapes.includes(t) ? config.enabledShapes.filter(s => s !== t) : [...config.enabledShapes, t]})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 2: Manual --- */}
                {activeTab === 'manual' && (
                    <div className="space-y-8 animate-fadeIn">
                        <div className="bg-gray-50 p-4 rounded-2xl text-[11px] text-gray-500 font-medium italic border-l-4 border-blue-400">
                            鎻愮ず锛氬崟鍙戞ā寮忛厤缃紶鏍囩偣鍑绘椂鐨勫浐瀹氭牱寮忋€傝嫢璁句负鈥滈殢鏈衡€濓紝鍒欓伒寰槈骞村崕鐧藉悕鍗曘€?
                        </div>

                        <section>
                            <h3 className="text-[10px] font-black text-gray-400 uppercase tracking-[0.3em] mb-4">閿佸畾鍗曞彂褰㈢姸</h3>
                            <div className="grid grid-cols-2 gap-3">
                                <div onClick={() => onUpdateManual({...manualConfig, lockedShape: 'RANDOM'})} className={`p-4 rounded-2xl border-2 transition-all cursor-pointer flex items-center gap-4 ${manualConfig.lockedShape === 'RANDOM' ? 'border-blue-500 bg-blue-50/50' : 'border-gray-100 hover:border-gray-200'}`}>
                                    <div className="text-2xl">馃幉</div>
                                    <div className="font-black text-xs text-gray-700">闅忔満褰㈢姸</div>
                                </div>
                                {Object.values(ExplosionType).map(t => (
                                    <ShapeCard
                                        key={t} type={t}
                                        active={manualConfig.lockedShape === t}
                                        onClick={() => onUpdateManual({...manualConfig, lockedShape: t})}
                                    />
                                ))}
                            </div>
                        </section>
                    </div>
                )}

                {/* --- Tab 3: Physics --- */}
                {activeTab === 'physics' && (
                    <div className="space-y-6 animate-fadeIn">
                        <SettingSlider label="鍏ㄥ眬閲嶅姏" value={settings.gravity} min={0.01} max={0.3} step={0.01} onChange={v => onUpdate('gravity', v)} />
                        <SettingSlider label="澶ф皵绮樺害" value={settings.friction} min={0.85} max={0.99} step={0.01} onChange={v => onUpdate('friction', v)} />
                        <SettingSlider label="绮掑瓙瀵嗗害鍊嶇巼" value={settings.particleCountMultiplier} min={0.2} max={2.0} step={0.1} onChange={v => onUpdate('particleCountMultiplier', v)} />
                    </div>
                )}
            </div>

            {/* 4. Footer Actions */}
            <div className="p-6 border-t border-gray-100 bg-gray-50/30 flex gap-4">
                <button onClick={onRandomize} className="flex-1 py-4 bg-gray-900 text-white rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-blue-600 transition-all shadow-xl active:scale-95">馃幉 闅忔満鍖栧弬鏁?/button>
                <button onClick={onReset} className="px-6 py-4 bg-white border border-gray-200 text-gray-400 rounded-2xl text-[10px] font-black uppercase hover:text-red-500 transition-all">閲嶇疆</button>
            </div>
        </div>
    );
};

// --- 瀛愮粍浠? 鏍峰紡鍖栧崱鐗?---

const ShapeCard = ({ type, active, onClick }: { type: ExplosionType, active: boolean, onClick: () => void }) => (
    <div
        onClick={onClick}
        className={`group relative p-4 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden ${active ? 'border-blue-500 bg-blue-50/50 shadow-lg scale-[1.02]' : 'border-gray-50 bg-white hover:border-gray-200'}`}
    >
        <div className="flex items-center gap-3">
            <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-lg ${active ? 'bg-white' : 'bg-gray-50'}`}>
                {SHAPE_ICONS[type]}
            </div>
            <div className="flex flex-col">
                <span className={`text-[10px] font-black uppercase tracking-tighter ${active ? 'text-blue-600' : 'text-gray-700'}`}>{type}</span>
                <span className="text-[8px] text-gray-400 font-bold uppercase tracking-widest">FIREWORK</span>
            </div>
        </div>
        {/* CSS 瑁呴グ鑳屾櫙 */}
        <div className={`absolute -right-2 -bottom-2 w-12 h-12 opacity-[0.03] group-hover:opacity-[0.08] transition-opacity ${active ? 'text-blue-600' : 'text-black'}`}>
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>
        </div>
    </div>
);

const SettingSlider = ({ label, value, min, max, step, unit = '', onChange }: any) => (
    <div className="space-y-3">
        <div className="flex justify-between items-center">
            <span className="text-[10px] font-black text-gray-400 uppercase tracking-widest">{label}</span>
            <span className="bg-gray-100 text-gray-600 px-2 py-0.5 rounded-lg text-[10px] font-mono font-bold">{value.toFixed(2)}{unit}</span>
        </div>
        <input
            type="range" min={min} max={max} step={step} value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
            className="w-full h-1.5 bg-gray-100 rounded-full appearance-none cursor-pointer accent-blue-600"
        />
    </div>
);

const Toggle = ({ checked, onChange }: { checked: boolean, onChange: (v: boolean) => void }) => (
    <button
        onClick={() => onChange(!checked)}
        className={`w-10 h-5 rounded-full transition-colors relative ${checked ? 'bg-blue-600' : 'bg-gray-200'}`}
    >
        <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-transform ${checked ? 'left-6' : 'left-1'}`} />
    </button>
);

// END OF FILE: src/components/ui/SettingsPanel.tsx

====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\ShapePreviewCard.tsx ======
// FILE: src/components/ui/ShapePreviewCard.tsx
// 褰㈢姸棰勮鍗＄墖缁勪欢 - 鐐瑰嚮鏃跺湪椤堕儴鏄剧ず3D棰勮

import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { Shape3DFactory, Shape3DType, SHAPE_3D_INFO } from '../../core/shapes/Shape3DFactory';

interface ShapePreviewCardProps {
  type: Shape3DType;
  active: boolean;
  onClick: () => void;
  onPreview?: (type: Shape3DType) => void;
}

/**
 * 褰㈢姸棰勮鍗＄墖
 * 鏀寔鎮仠棰勮鍜岀偣鍑婚€変腑
 */
export const ShapePreviewCard: React.FC<ShapePreviewCardProps> = ({
  type,
  active,
  onClick,
  onPreview
}) => {
  const info = SHAPE_3D_INFO[type];
  
  return (
    <div
      onClick={onClick}
      onMouseEnter={() => onPreview?.(type)}
      className={`
        group relative p-3 rounded-2xl border-2 transition-all cursor-pointer overflow-hidden
        ${active 
          ? 'border-emerald-400 bg-gradient-to-br from-emerald-50 to-teal-50 shadow-lg scale-[1.02]' 
          : 'border-gray-100 bg-white/80 hover:border-emerald-200 hover:shadow-md'
        }
      `}
    >
      <div className="flex items-center gap-3">
        {/* 鍥炬爣 */}
        <div className={`
          w-10 h-10 rounded-xl flex items-center justify-center text-xl
          transition-all
          ${active ? 'bg-white shadow-sm' : 'bg-gray-50 group-hover:bg-emerald-50'}
        `}>
          {info.icon}
        </div>
        
        {/* 鏂囧瓧 */}
        <div className="flex flex-col flex-1 min-w-0">
          <span className={`
            text-[11px] font-bold truncate
            ${active ? 'text-emerald-700' : 'text-gray-700'}
          `}>
            {info.name}
          </span>
          <span className={`
            text-[9px] truncate
            ${active ? 'text-emerald-500' : 'text-gray-400'}
          `}>
            {info.category}
          </span>
        </div>
        
        {/* 閫変腑鏍囪 */}
        {active && (
          <div className="w-5 h-5 rounded-full bg-emerald-400 flex items-center justify-center">
            <svg className="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
            </svg>
          </div>
        )}
      </div>
      
      {/* 鎮仠鎻愮ず */}
      <div className="
        absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-1.5
        bg-gray-900 text-white text-[10px] rounded-lg
        opacity-0 group-hover:opacity-100 transition-opacity
        pointer-events-none whitespace-nowrap z-50
      ">
        {info.description}
        <div className="absolute top-full left-1/2 -translate-x-1/2 border-4 border-transparent border-t-gray-900" />
      </div>
    </div>
  );
};

/**
 * 3D 瀹炴椂棰勮绐楀彛
 */
interface ShapePreview3DProps {
  shapeType: Shape3DType | null;
  className?: string;
}

export const ShapePreview3D: React.FC<ShapePreview3DProps> = ({
  shapeType,
  className = ''
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const pointsRef = useRef<THREE.Points | null>(null);
  const frameRef = useRef<number>(0);
  
  // 鍒濆鍖栧満鏅?
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    // 鍦烘櫙
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);
    sceneRef.current = scene;
    
    // 鐩告満
    const camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
    camera.position.set(0, 0, 100);
    cameraRef.current = camera;
    
    // 娓叉煋鍣?
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // 绮掑瓙绯荤粺
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(3000 * 3);
    const colors = new Float32Array(3000 * 3);
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
      size: 3,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true
    });
    
    const points = new THREE.Points(geometry, material);
    scene.add(points);
    pointsRef.current = points;
    
    // 鍔ㄧ敾
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (pointsRef.current) {
        pointsRef.current.rotation.y += 0.01;
        pointsRef.current.rotation.x += 0.003;
      }
      
      renderer.render(scene, camera);
    };
    animate();
    
    // 娓呯悊
    return () => {
      cancelAnimationFrame(frameRef.current);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
      container.removeChild(renderer.domElement);
    };
  }, []);
  
  // 鏇存柊褰㈢姸
  useEffect(() => {
    if (!pointsRef.current || !shapeType) return;
    
    const shape3DPoints = Shape3DFactory.generate(shapeType, 500, 1, 180);
    const geometry = pointsRef.current.geometry;
    const positions = geometry.attributes.position.array as Float32Array;
    const colors = geometry.attributes.color.array as Float32Array;
    
    // 娓呯┖
    positions.fill(0);
    colors.fill(0);
    
    // 濉厖鏂扮偣
    for (let i = 0; i < Math.min(shape3DPoints.length, 1000); i++) {
      const point = shape3DPoints[i];
      const idx = i * 3;
      
      positions[idx] = point.position.x;
      positions[idx + 1] = point.position.y;
      positions[idx + 2] = point.position.z;
      
      // HSL to RGB
      const h = point.hue / 360;
      const s = 0.7;
      const l = 0.6;
      const { r, g, b } = hslToRgb(h, s, l);
      
      colors[idx] = r;
      colors[idx + 1] = g;
      colors[idx + 2] = b;
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
  }, [shapeType]);
  
  const info = shapeType ? SHAPE_3D_INFO[shapeType] : null;
  
  return (
    <div className={`relative overflow-hidden ${className}`}>
      <div ref={containerRef} className="w-full h-full" />
      
      {/* 淇℃伅瑕嗙洊 */}
      {info && (
        <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-white/90 to-transparent">
          <div className="flex items-center gap-2">
            <span className="text-xl">{info.icon}</span>
            <div>
              <div className="text-sm font-bold text-gray-800">{info.name}</div>
              <div className="text-[10px] text-gray-500">{info.description}</div>
            </div>
          </div>
        </div>
      )}
      
      {/* 绌虹姸鎬?*/}
      {!shapeType && (
        <div className="absolute inset-0 flex items-center justify-center text-gray-300">
          <div className="text-center">
            <div className="text-3xl mb-2">鉁?/div>
            <div className="text-xs font-medium">鎮仠褰㈢姸鍗＄墖浠ラ瑙?/div>
          </div>
        </div>
      )}
    </div>
  );
};

// HSL to RGB 杞崲
function hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
  let r: number, g: number, b: number;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  return { r, g, b };
}

// END OF FILE: src/components/ui/ShapePreviewCard.tsx


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\TimeControlPanel.tsx ======
// FILE: src/components/ui/TimeControlPanel.tsx

import React from 'react';
import { TimeController } from '../../core/TimeController';

interface TimeControlPanelProps {
  timeController: TimeController | null;
  stats: {
    particles: number;
    fireworks: number;
    fps: number;
  };
  onTimeScaleChange: (scale: number) => void;
  onTogglePause: () => void;
  autoRotate: boolean;
  onToggleAutoRotate: () => void;
}

export const TimeControlPanel: React.FC<TimeControlPanelProps> = ({
                                                                    timeController,
                                                                    stats,
                                                                    onTimeScaleChange,
                                                                    onTogglePause,
                                                                    autoRotate,
                                                                    onToggleAutoRotate
                                                                  }) => {
  const timeScale = timeController?.timeScale ?? 1;
  const isPaused = timeController?.isPaused ?? false;

  return (
      <div className="absolute bottom-8 left-8 z-30 flex flex-col gap-3">
        {/* 鐜颁唬鍖栨祬鑹插崱鐗?*/}
        <div className="bg-white/80 backdrop-blur-xl rounded-2xl p-4 shadow-xl border border-white/50 w-64 transition-all hover:shadow-2xl hover:scale-[1.02]">

          {/* 鏍囬鏍?*/}
          <div className="flex justify-between items-center mb-4">
          <span className="text-gray-800 text-xs font-bold tracking-wider flex items-center gap-2">
             <span className="text-lg">鈿欙笍</span> ENGINE
          </span>
            <div className="flex gap-2 items-center bg-gray-100 px-2 py-1 rounded-lg">
              <div className={`w-1.5 h-1.5 rounded-full ${isPaused ? 'bg-amber-400 animate-pulse' : 'bg-green-500'}`}></div>
              <span className="text-[10px] font-mono text-gray-500 font-bold">{stats.fps} FPS</span>
            </div>
          </div>

          {/* 鎺у埗鎸夐挳缃戞牸 */}
          <div className="grid grid-cols-2 gap-2 mb-4">
            <button
                onClick={onTogglePause}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    isPaused
                        ? 'bg-amber-50 text-amber-600 border-amber-200 hover:bg-amber-100'
                        : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50 hover:text-gray-900'
                }`}
            >
              {isPaused ? '鈻?RESUME' : '鈴?PAUSE'}
            </button>

            <button
                onClick={onToggleAutoRotate}
                className={`py-2.5 rounded-xl font-bold text-[10px] transition-all flex items-center justify-center gap-1.5 border ${
                    autoRotate
                        ? 'bg-blue-50 text-blue-600 border-blue-200 hover:bg-blue-100'
                        : 'bg-white text-gray-400 border-gray-200 hover:bg-gray-50 hover:text-gray-600'
                }`}
            >
              {autoRotate ? '鈫?ROTATING' : '鈯?STATIC'}
            </button>
          </div>

          {/* 閫熷害婊戝潡 */}
          <div className="bg-gray-50 rounded-xl p-3 border border-gray-100">
            <div className="flex justify-between text-[10px] text-gray-400 mb-2 font-bold uppercase">
              <span>Time Scale</span>
              <span className="text-gray-800">{timeScale.toFixed(1)}x</span>
            </div>
            <input
                type="range"
                min="0.1"
                max="3"
                step="0.1"
                value={timeScale}
                onChange={(e) => onTimeScaleChange(parseFloat(e.target.value))}
                className="w-full h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer accent-gray-700 hover:accent-blue-600 transition-all"
            />
            <div className="flex justify-between mt-1 text-[8px] text-gray-300 font-mono">
              <span>SLOW</span>
              <span>FAST</span>
            </div>
          </div>

          {/* 搴曢儴缁熻淇℃伅 */}
          <div className="mt-4 pt-3 border-t border-gray-100 grid grid-cols-2 gap-2 text-[9px] text-gray-400 font-mono">
            <div>
              <span className="block text-gray-300 uppercase text-[8px]">Particles</span>
              <span className="font-bold text-gray-600">{(stats.particles/1000).toFixed(1)}k</span>
            </div>
            <div className="text-right">
              <span className="block text-gray-300 uppercase text-[8px]">Fireworks</span>
              <span className="font-bold text-gray-600">{stats.fireworks}</span>
            </div>
          </div>
        </div>
      </div>
  );
};

// END OF FILE: src/components/ui/TimeControlPanel.tsx

====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\TrajectoryPreview3D.tsx ======
// FILE: src/components/ui/TrajectoryPreview3D.tsx
// 閲嶅啓锛氳建杩归瑙堢粍浠?- 甯︾澶寸殑璺緞鍙鍖?+ 閫熷害鍚戦噺鏄剧ず
// 姣忕杞ㄨ抗绫诲瀷鏈夋槑鏄句笉鍚岀殑瑙嗚琛ㄧ幇

import React, { useRef, useEffect, useMemo } from 'react';
import * as THREE from 'three';
import { TrajectoryType, TrajectoryFactory, TrajectoryCalculator, TRAJECTORY_INFO } from '../../core/trajectories/TrajectoryFactory';
import { Vector3 } from '../../core/Vector3';

// ============ 涓荤粍浠讹細3D 杞ㄨ抗棰勮 ============
interface TrajectoryPreview3DProps {
  trajectoryType: TrajectoryType | null;
  className?: string;
  // 鑷畾涔夊弬鏁?
  speed?: number;       // 鍒濆閫熷害 (1-30)
  height?: number;      // 鐩爣楂樺害 (100-500)
  angle?: number;       // 鍙戝皠瑙掑害 (-45 to 45 搴?
}

export const TrajectoryPreview3D: React.FC<TrajectoryPreview3DProps> = ({
  trajectoryType,
  className = '',
  speed = 15,
  height = 300,
  angle = 0
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const frameRef = useRef<number>(0);
  
  // 杞ㄨ抗绾垮拰绠ご鐨勫紩鐢?
  const pathLineRef = useRef<THREE.Line | null>(null);
  const arrowsRef = useRef<THREE.Group | null>(null);
  const projectileRef = useRef<THREE.Mesh | null>(null);
  const animationTimeRef = useRef<number>(0);
  const pathPointsRef = useRef<THREE.Vector3[]>([]);
  
  // 鍒濆鍖栧満鏅?
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    
    // 鍦烘櫙
    const scene = new THREE.Scene();
    scene.background = null;  // 閫忔槑鑳屾櫙
    sceneRef.current = scene;
    
    // 鐩告満
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 12, 35);
    camera.lookAt(0, 10, 0);
    cameraRef.current = camera;
    
    // 娓叉煋鍣?
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // 鍦伴潰缃戞牸
    const gridHelper = new THREE.GridHelper(40, 20, 0x333333, 0x1a1a1a);
    gridHelper.position.y = -2;
    scene.add(gridHelper);
    
    // 鍧愭爣杞?(灏忓瀷)
    const axesHelper = new THREE.AxesHelper(3);
    axesHelper.position.set(-15, -2, -15);
    scene.add(axesHelper);
    
    // 绮掑瓙鍙戝皠浣?
    const projGeo = new THREE.SphereGeometry(0.5, 16, 16);
    const projMat = new THREE.MeshBasicMaterial({ 
      color: 0x4ade80,
      transparent: true,
      opacity: 0.9
    });
    const projectile = new THREE.Mesh(projGeo, projMat);
    scene.add(projectile);
    projectileRef.current = projectile;
    
    // 璺緞绾?
    const lineMat = new THREE.LineBasicMaterial({ 
      color: 0x4ade80, 
      transparent: true, 
      opacity: 0.6,
      linewidth: 2
    });
    const lineGeo = new THREE.BufferGeometry();
    const pathLine = new THREE.Line(lineGeo, lineMat);
    scene.add(pathLine);
    pathLineRef.current = pathLine;
    
    // 绠ご缁?
    const arrowsGroup = new THREE.Group();
    scene.add(arrowsGroup);
    arrowsRef.current = arrowsGroup;
    
    // 鍔ㄧ敾寰幆
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        animationTimeRef.current += 0.016;
        
        // 娌胯矾寰勭Щ鍔ㄧ矑瀛?
        if (pathPointsRef.current.length > 0 && projectileRef.current) {
          const totalPoints = pathPointsRef.current.length;
          const loopTime = 2.5;  // 2.5绉掑畬鎴愪竴涓惊鐜?
          const t = (animationTimeRef.current % loopTime) / loopTime;
          const idx = Math.min(Math.floor(t * totalPoints), totalPoints - 1);
          
          const point = pathPointsRef.current[idx];
          projectileRef.current.position.copy(point);
          
          // 绮掑瓙鍦ㄨ矾寰勬湯灏炬笎闅?
          const fadeStart = 0.8;
          if (t > fadeStart) {
            (projectileRef.current.material as THREE.MeshBasicMaterial).opacity = 
              1 - ((t - fadeStart) / (1 - fadeStart));
          } else {
            (projectileRef.current.material as THREE.MeshBasicMaterial).opacity = 0.9;
          }
        }
        
        // 缂撴參鏃嬭浆鐩告満
        const camAngle = animationTimeRef.current * 0.15;
        cameraRef.current.position.x = Math.sin(camAngle) * 35;
        cameraRef.current.position.z = Math.cos(camAngle) * 35;
        cameraRef.current.lookAt(0, 8, 0);
        
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };
    animate();
    
    // Resize
    const handleResize = () => {
      if (containerRef.current && cameraRef.current && rendererRef.current) {
        const w = containerRef.current.clientWidth;
        const h = containerRef.current.clientHeight;
        cameraRef.current.aspect = w / h;
        cameraRef.current.updateProjectionMatrix();
        rendererRef.current.setSize(w, h);
      }
    };
    window.addEventListener('resize', handleResize);
    
    return () => {
      cancelAnimationFrame(frameRef.current);
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      if (container.contains(renderer.domElement)) {
        container.removeChild(renderer.domElement);
      }
    };
  }, []);
  
  // 褰撹建杩圭被鍨嬫垨鍙傛暟鍙樺寲鏃讹紝閲嶆柊鐢熸垚璺緞
  useEffect(() => {
    if (!sceneRef.current || !pathLineRef.current || !arrowsRef.current) return;
    
    // 娓呯悊鏃х澶?
    while (arrowsRef.current.children.length > 0) {
      arrowsRef.current.remove(arrowsRef.current.children[0]);
    }
    
    if (!trajectoryType) {
      pathPointsRef.current = [];
      pathLineRef.current.geometry.setFromPoints([]);
      if (projectileRef.current) projectileRef.current.visible = false;
      return;
    }
    
    if (projectileRef.current) projectileRef.current.visible = true;
    
    // 鐢熸垚瀹屾暣杞ㄨ抗璺緞
    const points = generateTrajectoryPath(trajectoryType, speed, height, angle);
    pathPointsRef.current = points;
    
    // 鏇存柊璺緞绾?
    pathLineRef.current.geometry.setFromPoints(points);
    
    // 娣诲姞閫熷害绠ご (姣忛殧涓€瀹氳窛绂?
    const arrowInterval = Math.ceil(points.length / 8);
    for (let i = arrowInterval; i < points.length - 5; i += arrowInterval) {
      const point = points[i];
      const nextPoint = points[Math.min(i + 5, points.length - 1)];
      
      // 璁＄畻鏂瑰悜
      const direction = new THREE.Vector3()
        .subVectors(nextPoint, point)
        .normalize();
      
      // 璁＄畻閫熷害澶у皬 (鐢ㄤ簬绠ご闀垮害)
      const velocity = new THREE.Vector3().subVectors(nextPoint, point).length();
      const arrowLength = Math.min(velocity * 0.8, 3);
      
      // 鍒涘缓绠ご
      const arrow = createArrow(direction, arrowLength, i / points.length);
      arrow.position.copy(point);
      arrowsRef.current.add(arrow);
    }
    
    // 閲嶇疆鍔ㄧ敾鏃堕棿
    animationTimeRef.current = 0;
    
  }, [trajectoryType, speed, height, angle]);
  
  // 鑾峰彇杞ㄨ抗淇℃伅
  const info = trajectoryType ? TRAJECTORY_INFO[trajectoryType] : null;
  
  return (
    <div className={`relative w-full h-full overflow-hidden ${className}`}>
      {/* 3D Canvas */}
      <div ref={containerRef} className="absolute inset-0 z-0" />
      
      {/* 鍙傛暟鏄剧ず */}
      {trajectoryType && (
        <div className="absolute top-3 right-3 bg-black/50 backdrop-blur-sm rounded-lg p-2 text-right">
          <div className="text-[8px] text-white/50 font-mono">
            <div>Speed: {speed.toFixed(1)}</div>
            <div>Height: {(height/10).toFixed(0)}m</div>
            <div>Angle: {angle}掳</div>
          </div>
        </div>
      )}
      
      {/* 搴曢儴淇℃伅 */}
      <div className="absolute inset-x-0 bottom-0 flex flex-col items-center justify-end pb-3 pointer-events-none z-10">
        {!trajectoryType ? (
          <div className="text-white/40 text-xs font-bold uppercase tracking-widest bg-black/30 px-4 py-2 rounded-full backdrop-blur-sm">
            Select a Path
          </div>
        ) : (
          <div className="flex flex-col items-center gap-1">
            <div className="flex items-center gap-2 animate-pulse">
              <span className="text-lg">{info?.icon}</span>
            </div>
            <div className="text-[10px] font-black text-emerald-400 uppercase tracking-[0.15em] drop-shadow-md bg-black/60 backdrop-blur-md px-3 py-1 rounded-full border border-emerald-500/30">
              {info?.name}
            </div>
            <div className="text-[8px] text-white/50 font-medium max-w-[180px] text-center">
              {info?.description}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// ============ 2D Canvas 棰勮 (鐢ㄤ簬涓嬫媺妗嗕晶杈归瑙? ============
interface TrajectoryPreviewCanvasProps {
  trajectoryType: TrajectoryType | null;
  className?: string;
}

export const TrajectoryPreviewCanvas: React.FC<TrajectoryPreviewCanvasProps> = ({
  trajectoryType,
  className = ''
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const timeRef = useRef<number>(0);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d')!;
    const width = canvas.width = 192;
    const height = canvas.height = 192;
    
    // 鐢熸垚2D璺緞鐐?
    const path2D = trajectoryType ? generate2DPath(trajectoryType) : [];
    
    const animate = () => {
      animationRef.current = requestAnimationFrame(animate);
      timeRef.current += 0.02;
      
      // 娓呯┖
      ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
      ctx.fillRect(0, 0, width, height);
      
      if (path2D.length === 0) {
        // 鏃犺建杩规椂鏄剧ず鎻愮ず
        ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Hover to Preview', width / 2, height / 2);
        return;
      }
      
      // 缁樺埗璺緞
      ctx.strokeStyle = 'rgba(74, 222, 128, 0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      path2D.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();
      
      // 缁樺埗绠ご
      const arrowInterval = Math.ceil(path2D.length / 6);
      ctx.fillStyle = 'rgba(74, 222, 128, 0.8)';
      for (let i = arrowInterval; i < path2D.length - 3; i += arrowInterval) {
        const p = path2D[i];
        const next = path2D[Math.min(i + 3, path2D.length - 1)];
        const angle = Math.atan2(next.y - p.y, next.x - p.x);
        drawArrow(ctx, p.x, p.y, angle, 6);
      }
      
      // 鍔ㄧ敾绮掑瓙
      const loopTime = 2.0;
      const t = (timeRef.current % loopTime) / loopTime;
      const idx = Math.floor(t * path2D.length);
      if (idx < path2D.length) {
        const pos = path2D[idx];
        
        // 鍙戝厜鏁堟灉
        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 15);
        gradient.addColorStop(0, 'rgba(74, 222, 128, 1)');
        gradient.addColorStop(0.5, 'rgba(74, 222, 128, 0.3)');
        gradient.addColorStop(1, 'rgba(74, 222, 128, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // 鏍稿績鐐?
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // 璧风偣鏍囪
      if (path2D.length > 0) {
        ctx.strokeStyle = 'rgba(251, 146, 60, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const start = path2D[0];
        ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
        ctx.stroke();
      }
    };
    
    animate();
    
    return () => {
      cancelAnimationFrame(animationRef.current);
    };
  }, [trajectoryType]);
  
  return (
    <canvas 
      ref={canvasRef} 
      className={`${className}`}
      style={{ width: '100%', height: '100%' }}
    />
  );
};

// ============ 杈呭姪鍑芥暟 ============

/**
 * 鐢熸垚3D杞ㄨ抗璺緞鐐?- 澧炲己鐗堬紝璁╀笉鍚岃建杩圭被鍨嬬殑瑙嗚宸紓鏇存槑鏄?
 */
function generateTrajectoryPath(
  type: TrajectoryType,
  speed: number,
  height: number,
  angle: number
): THREE.Vector3[] {
  const points: THREE.Vector3[] = [];
  const calculator = TrajectoryFactory.create(type);
  
  // 鍒濆鏉′欢
  const startPos = { x: 0, y: -2, z: 0 };
  const angleRad = (angle * Math.PI) / 180;
  let pos = new Vector3(startPos.x, startPos.y, startPos.z);
  let vel = new Vector3(
    Math.sin(angleRad) * speed * 0.3,  // 澧炲姞妯悜閫熷害鐨勫奖鍝?
    speed * 1.2,  // 澧炲姞鍒濆涓婂崌閫熷害
    0
  );
  
  const maxTime = 4.0;  // 澧炲姞妯℃嫙鏃堕棿
  const dt = 0.015;     // 鏇寸粏鑷寸殑姝ラ暱
  const gravity = 0.04; // 澶у箙闄嶄綆閲嶅姏锛岃杞ㄨ抗鏇村畬鏁?
  
  // 鏀惧ぇ鍥犲瓙锛氳杞ㄨ抗鍦ㄩ瑙堜腑鏇村ぇ
  const scaleFactor = 5;
  
  for (let t = 0; t < maxTime; t += dt) {
    // 璁板綍鐐癸紙鏀惧ぇ鍧愭爣锛?
    points.push(new THREE.Vector3(
      pos.x * scaleFactor, 
      pos.y * scaleFactor, 
      pos.z * scaleFactor
    ));
    
    // 浣跨敤杞ㄨ抗璁＄畻鍣ㄦ洿鏂伴€熷害
    vel = calculator.calculate(vel, gravity, dt);
    
    // 鏇存柊浣嶇疆
    pos.x += vel.x * dt * 2;  // 澧炲姞浣嶇疆鍙樺寲鐨勭伒鏁忓害
    pos.y += vel.y * dt * 2;
    pos.z += vel.z * dt * 2;
    
    // 妫€鏌ユ槸鍚﹀埌杈剧洰鏍囬珮搴︽垨寮€濮嬩笅钀藉お蹇?
    if (pos.y > height / 8 || vel.y < -5) break;
  }
  
  return points;
}

/**
 * 鐢熸垚2D璺緞鐐?(鐢ㄤ簬Canvas棰勮) - 澧炲己鐗?
 */
function generate2DPath(type: TrajectoryType): { x: number; y: number }[] {
  const points: { x: number; y: number }[] = [];
  const calculator = TrajectoryFactory.create(type);
  
  // 2D鍧愭爣鏄犲皠
  const width = 192;
  const height = 192;
  const startX = width / 2;
  const startY = height - 15;
  
  let posX = 0;
  let posY = 0;
  let vel = new Vector3(0, 25, 0);  // 澧炲姞鍒濆閫熷害
  
  const maxTime = 3.5;   // 澧炲姞妯℃嫙鏃堕棿
  const dt = 0.02;
  const gravity = 0.05;  // 闄嶄綆閲嶅姏璁╄建杩规洿瀹屾暣
  
  // 澧炲ぇ鍧愭爣缂╂斁鍥犲瓙锛岃涓嶅悓杞ㄨ抗鐨勫樊寮傛洿鏄庢樉
  const scaleFactor = 8;
  
  for (let t = 0; t < maxTime; t += dt) {
    const screenX = startX + posX * scaleFactor;
    const screenY = startY - posY * scaleFactor;
    
    if (screenY > 5 && screenY < height - 5 && screenX > 5 && screenX < width - 5) {
      points.push({ x: screenX, y: screenY });
    }
    
    // 鏇存柊鐗╃悊
    vel = calculator.calculate(vel, gravity, dt);
    posX += vel.x * dt * 1.5;
    posY += vel.y * dt * 1.5;
    
    if (screenY < 8 || vel.y < -6) break;
  }
  
  return points;
}

/**
 * 鍒涘缓3D绠ご
 */
function createArrow(direction: THREE.Vector3, length: number, progress: number): THREE.Group {
  const group = new THREE.Group();
  
  // 绠ご棰滆壊闅忚繘搴﹀彉鍖?
  const hue = 160 - progress * 60;  // 浠庨潚鑹插埌缁胯壊
  const color = new THREE.Color(`hsl(${hue}, 80%, 60%)`);
  
  // 绠ご澶撮儴 (閿ュ舰)
  const coneGeo = new THREE.ConeGeometry(0.3, 0.8, 8);
  const coneMat = new THREE.MeshBasicMaterial({ 
    color,
    transparent: true,
    opacity: 0.8
  });
  const cone = new THREE.Mesh(coneGeo, coneMat);
  
  // 瀵归綈鏂瑰悜
  cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
  
  group.add(cone);
  
  return group;
}

/**
 * 鍦–anvas涓婄粯鍒剁澶?
 */
function drawArrow(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, size: number) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size * 0.5, -size * 0.5);
  ctx.lineTo(-size * 0.5, size * 0.5);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}


====== FILE: D:\ALL IN AI\Aetheris\src\components\ui\TutorialOverlay.tsx ======
// FILE: src/components/ui/TutorialOverlay.tsx
// 寮曞鏁欑▼瑕嗙洊灞?- 甯姪鐢ㄦ埛浜嗚В濡備綍浣跨敤妯℃嫙鍣?(澧炲己鐗?

import React, { useState, useEffect } from 'react';

interface TutorialStep {
  id: string;
  title: string;
  description: string;
  icon: string;
  position: 'center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'top-left';
  highlight?: string; // CSS selector to highlight
}

const TUTORIAL_STEPS: TutorialStep[] = [
  {
    id: 'welcome',
    title: '娆㈣繋鏉ュ埌 Aetheris 鉁?,
    description: '杩欐槸涓€涓帰绱㈠厜涓庣墿鐞嗙殑 3D 绮掑瓙宸ュ潑銆傚湪杩欓噷锛屾偍鍙互鎸囨尌鏄熺郴璇炵敓锛岀紪鎺掔儫鑺卞ぇ绉€锛屼綋楠岀函绮圭殑瑙嗚鑹烘湳銆?,
    icon: '馃巻',
    position: 'center'
  },
  {
    id: 'basic-nav',
    title: '鍩烘湰浜や簰',
    description: '馃柋锔?宸﹂敭鎷栧姩锛氭棆杞瑙抃n馃柋锔?鍙抽敭鎷栧姩锛氬钩绉昏瑙抃n馃柋锔?婊氳疆锛氱缉鏀捐窛绂籠n馃憜 鐐瑰嚮浠绘剰绌虹櫧澶勶細鍦ㄨ浣嶇疆鍙戝皠涓€鏈电儫鑺憋紒',
    icon: '馃幃',
    position: 'center'
  },
  {
    id: 'workshop',
    title: '鍒涙剰宸ュ潑 (Workshop)',
    description: '鍙充笂瑙掔殑銆愬垱鎰忓伐鍧娿€戞槸鎮ㄧ殑鍒涢€犱腑蹇冦€傚湪杩欓噷鎮ㄥ彲浠ワ細\n- 鎸戦€夊嚑鍗佺楂樼骇 3D 褰㈢姸 (鍏嬭幈鍥犵摱銆佺埍蹇冦€佽灪鏃?..)\n- 棰勮骞堕€夋嫨鐙壒鐨勪笂鍗囪建杩筡n- 缂栨帓鑷姩鍖栫殑鐑熻姳澶х鍓ф湰',
    icon: '馃帹',
    position: 'top-right'
  },
  {
    id: 'trajectory-preview',
    title: '鍏ㄦ柊锛佽建杩归瑙?,
    description: '杩涘叆鍒涙剰宸ュ潑鐨勨€滀笂鍗囪建杩光€濋潰鏉匡紝灏嗛紶鏍囨偓娴湪杞ㄨ抗鍗＄墖涓婏紝鍗冲彲鐪嬪埌閫肩湡鐨?3D 璺緞鍔ㄦ€侀瑙堬紒鎵€瑙佸嵆鎵€寰椼€?,
    icon: '馃殌',
    position: 'top-right'
  },
  {
    id: 'time-control',
    title: '鏃剁┖鎺у埗鍙?,
    description: '搴曢儴鐨勬帶鍒堕潰鏉胯鎮ㄦ垚涓烘椂闂寸殑榄旀硶甯堛€俓n鈴革笍 鏆傚仠鏃堕棿锛氬畾鏍肩垎鐐哥灛闂碶n鈴?鎱㈠姩浣滐細浠?0.1x 閫熷害娆ｈ祻姣忎竴涓矑瀛愮殑缁芥斁\n馃攧 鑷姩鏃嬭浆锛氬紑鍚矇娴稿紡鐜粫瑙嗚',
    icon: '鈴?,
    position: 'bottom-center'
  },
  {
    id: 'carnival',
    title: '澶х涓庝氦浜?,
    description: '鎯宠鏇撮渿鎾肩殑浣撻獙锛熷湪宸ュ潑涓煡鎵锯€滃ぇ绉€缂栨帓鈥濓紝涓€閿惎鍔ㄧ粡杩囩簿蹇冭璁＄殑鐑熻姳浜ゅ搷涔愩€傛偍涔熷彲浠ヨ嚜瀹氫箟浜や簰鍓ф湰锛岃姣忎竴娆＄偣鍑婚兘鍏呮弧鎯婂枩銆?,
    icon: '馃幁',
    position: 'top-right'
  },
  {
    id: 'ready',
    title: '寮€濮嬪垱閫狅紒',
    description: '鑸炲彴宸蹭负鎮ㄥ氨缁€傚幓鐐逛寒杩欑墖澶滅┖鍚э紒\n(鎻愮ず锛氱偣鍑昏缃潰鏉垮閮ㄧ殑绌虹櫧鍖哄煙鍙揩閫熷叧闂潰鏉?',
    icon: '鉁?,
    position: 'center'
  }
];

interface TutorialOverlayProps {
  onComplete: () => void;
}

export const useTutorial = () => {
  const [showTutorial, setShowTutorial] = useState(false);

  useEffect(() => {
    const hasSeenTutorial = localStorage.getItem('aetheris_tutorial_seen_v2');
    if (!hasSeenTutorial) {
      setShowTutorial(true);
    }
  }, []);

  const completeTutorial = () => {
    localStorage.setItem('aetheris_tutorial_seen_v2', 'true');
    setShowTutorial(false);
  };

  const resetTutorial = () => {
    localStorage.removeItem('aetheris_tutorial_seen_v2');
    setShowTutorial(true);
  };

  return { showTutorial, completeTutorial, resetTutorial };
};

export const TutorialOverlay: React.FC<TutorialOverlayProps> = ({ onComplete }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [isVisible, setIsVisible] = useState(true);
  
  const step = TUTORIAL_STEPS[currentStep];
  const isLastStep = currentStep === TUTORIAL_STEPS.length - 1;
  const progress = ((currentStep + 1) / TUTORIAL_STEPS.length) * 100;
  
  const handleNext = () => {
    if (isLastStep) {
      setIsVisible(false);
      setTimeout(onComplete, 300);
    } else {
      setCurrentStep(prev => prev + 1);
    }
  };
  
  const handleSkip = () => {
    setIsVisible(false);
    setTimeout(onComplete, 300);
  };
  
  const handlePrev = () => {
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1);
    }
  };
  
  // 鑾峰彇浣嶇疆鏍峰紡
  const getPositionStyles = () => {
    switch (step.position) {
      case 'top-right':
        return 'top-24 right-8';
      case 'top-left':
        return 'top-24 left-8';
      case 'bottom-left':
        return 'bottom-24 left-8';
      case 'bottom-center':
        return 'bottom-32 left-1/2 -translate-x-1/2';
      default:
        return 'top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
    }
  };
  
  return (
    <div 
      className={`
        fixed inset-0 z-[100] transition-opacity duration-300
        ${isVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}
      `}
    >
      {/* 鑳屾櫙閬僵 */}
      <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm" />
      
      {/* 鏁欑▼鍗＄墖 */}
      <div className={`absolute ${getPositionStyles()} w-[420px] max-w-[90vw] transition-all duration-500 ease-out`}>
        <div className="bg-white/90 backdrop-blur-xl rounded-[32px] shadow-2xl overflow-hidden border border-white/40 ring-1 ring-white/50 animate-slideUp">
          {/* 杩涘害鏉?*/}
          <div className="h-1.5 bg-gray-100/50">
            <div 
              className="h-full bg-gradient-to-r from-emerald-400 to-teal-500 transition-all duration-500 shadow-[0_0_10px_rgba(16,185,129,0.5)]"
              style={{ width: `${progress}%` }}
            />
          </div>
          
          {/* 鍐呭 */}
          <div className="p-8">
            {/* 鍥炬爣鍜屾爣棰?*/}
            <div className="flex items-start gap-5 mb-6">
              <div className="w-16 h-16 shrink-0 rounded-2xl bg-gradient-to-br from-white to-emerald-50 border border-emerald-100/50 flex items-center justify-center text-4xl shadow-lg shadow-emerald-100">
                {step.icon}
              </div>
              <div>
                <h3 className="text-xl font-black text-gray-800 tracking-tight mb-1">{step.title}</h3>
                <p className="text-xs font-bold text-gray-400 uppercase tracking-widest">Step {currentStep + 1} of {TUTORIAL_STEPS.length}</p>
              </div>
            </div>
            
            {/* 鎻忚堪 */}
            <div className="text-gray-600 text-sm leading-relaxed mb-8 whitespace-pre-line font-medium p-4 bg-white/50 rounded-2xl border border-white/50">
              {step.description}
            </div>
            
            {/* 姝ラ鎸囩ず鍣?*/}
            <div className="flex justify-center gap-2 mb-8">
              {TUTORIAL_STEPS.map((_, idx) => (
                <div
                  key={idx}
                  className={`
                    h-2 rounded-full transition-all duration-300
                    ${idx === currentStep 
                      ? 'bg-emerald-500 w-8 shadow-sm' 
                      : idx < currentStep 
                        ? 'bg-emerald-200 w-2' 
                        : 'bg-gray-200 w-2'
                    }
                  `}
                />
              ))}
            </div>
            
            {/* 鎸夐挳 */}
            <div className="flex gap-3">
              {currentStep > 0 && (
                <button
                  onClick={handlePrev}
                  className="px-5 py-3 rounded-xl bg-gray-100 text-gray-500 text-xs font-bold hover:bg-gray-200 transition-all"
                >
                  鈫?杩斿洖
                </button>
              )}
              
              <button
                onClick={handleSkip}
                className="px-5 py-3 rounded-xl text-gray-400 text-xs font-bold hover:text-gray-600 hover:bg-gray-50 transition-all ml-auto"
              >
                璺宠繃
              </button>
              
              <button
                onClick={handleNext}
                className="
                  px-8 py-3 rounded-xl text-xs font-black
                  bg-gradient-to-r from-emerald-500 to-teal-500 text-white
                  hover:from-emerald-600 hover:to-teal-600
                  shadow-lg shadow-emerald-200/50
                  transition-all hover:scale-105 active:scale-95
                  flex items-center gap-2
                "
              >
                {isLastStep ? '寮€濮嬩綋楠?馃帀' : '涓嬩竴姝?鈫?}
              </button>
            </div>
          </div>
        </div>
        
        {/* 鎸囩ず鍏夋檿 - 浠呬綔涓鸿楗?*/}
        <div className="absolute -inset-4 bg-emerald-500/20 blur-3xl -z-10 rounded-full opacity-0 animate-pulse" />
      </div>
      
      {/* 蹇嵎閿彁绀烘潯 */}
      <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-6 text-white/50 text-[10px] font-mono tracking-wider backdrop-blur px-6 py-2 rounded-full bg-black/20 border border-white/10">
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Left Click</kbd>
          <span>Rotate</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Right Click</kbd>
          <span>Pan</span>
        </span>
        <span className="flex items-center gap-1.5">
          <kbd className="px-1.5 py-0.5 bg-white/10 rounded border border-white/10 text-white">Scroll</kbd>
          <span>Zoom</span>
        </span>
      </div>
    </div>
  );
};


====== FILE: D:\ALL IN AI\Aetheris\src\components\FireworkCanvas.tsx ======

import React, { useEffect, useRef, useState, useCallback, useMemo, useImperativeHandle, forwardRef } from 'react';
import { ParticlePool } from '../core/ParticlePool';
import { Firework } from '../core/Firework';
import { AppSettings } from '../types';

interface Star {
  x: number;
  y: number;
  size: number;
  blinkSpeed: number;
  phase: number;
  layer: number;
}

interface FireworkCanvasProps {
  settings: AppSettings;
}

export interface FireworkCanvasHandle {
  launchCarnival: () => void;
}

export const FireworkCanvas = forwardRef<FireworkCanvasHandle, FireworkCanvasProps>(({ settings }, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fireworksRef = useRef<Firework[]>([]);
  
  const particlePoolRef = useRef<ParticlePool | null>(null);
  const sparklersPoolRef = useRef<ParticlePool | null>(null);
  
  if (!particlePoolRef.current) particlePoolRef.current = new ParticlePool(15000);
  if (!sparklersPoolRef.current) sparklersPoolRef.current = new ParticlePool(1000);

  const getParticlePool = () => particlePoolRef.current!;
  const getSparklersPool = () => sparklersPoolRef.current!;

  const shockwavesRef = useRef<{ x: number, y: number, r: number, a: number }[]>([]);
  
  const [isCharging, setIsCharging] = useState(false);
  const chargeLevelRef = useRef(0);
  const mousePos = useRef({ x: 0, y: 0 });
  const requestRef = useRef<number | undefined>(undefined);
  const lastAutoLaunch = useRef<number>(0);

  const stars = useMemo<Star[]>(() => {
    const s: Star[] = [];
    for (let i = 0; i < 400; i++) {
      s.push({
        x: Math.random() * 4000, 
        y: Math.random() * 3000,
        size: Math.random() * 1.2,
        blinkSpeed: (0.002 + Math.random() * 0.008) * (settings.starBlinkSpeed / 0.0008),
        phase: Math.random() * Math.PI * 2,
        layer: Math.floor(Math.random() * 3)
      });
    }
    return s;
  }, [settings.starBlinkSpeed]);

  const handleResize = useCallback(() => {
    if (canvasRef.current) {
      const dpr = window.devicePixelRatio || 1;
      canvasRef.current.width = window.innerWidth * dpr;
      canvasRef.current.height = window.innerHeight * dpr;
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    }
  }, []);

  useEffect(() => {
    window.addEventListener('resize', handleResize);
    handleResize();
    return () => window.removeEventListener('resize', handleResize);
  }, [handleResize]);

  const launchFireworkAt = (x: number, y: number, hue?: number, charge?: number) => {
    const startXVariation = (Math.random() - 0.5) * 100;
    const startX = Math.max(0, Math.min(window.innerWidth, x + startXVariation));
    
    fireworksRef.current.push(new Firework({
      startX,
      targetX: x,
      targetY: y,
      hue: hue ?? Math.random() * 360,
      charge: charge ?? 0.2 + Math.random() * 0.5
    }, settings));
  };

  useImperativeHandle(ref, () => ({
    launchCarnival: () => {
      const launch = (count: number, delay: number) => {
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const x = (window.innerWidth * 0.1) + (window.innerWidth * 0.8 * Math.random());
            const y = window.innerHeight * (0.1 + Math.random() * 0.4);
            launchFireworkAt(x, y, Math.random() * 360, 0.4 + Math.random() * 0.4);
          }, delay + i * 180);
        }
      };
      launch(8, 0); 
      launch(12, 1200);
    }
  }));

  const animate = useCallback((time: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    if (!ctx) return;

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#020205';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.fillStyle = '#fff';
    const oxB = (mousePos.current.x - window.innerWidth/2) * 0.005;
    const oyB = (mousePos.current.y - window.innerHeight/2) * 0.005;
    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];
      const opacity = 0.05 + Math.abs(Math.sin(time * s.blinkSpeed + s.phase)) * 0.6;
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc((s.x + oxB * s.layer) % window.innerWidth, (s.y + oyB * s.layer) % window.innerHeight, s.size, 0, 6.28);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.22)';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    if (time - lastAutoLaunch.current > settings.autoLaunchDelay && !isCharging) {
      launchFireworkAt(Math.random() * window.innerWidth, 50 + Math.random() * (window.innerHeight * 0.4));
      lastAutoLaunch.current = time;
    }

    ctx.globalCompositeOperation = 'lighter';
    getSparklersPool().updateAndDraw(ctx);

    for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
      const f = fireworksRef.current[i];
      f.update(settings);
      f.draw(ctx);
      if (f.exploded) {
        f.createExplosion(settings, (opts) => getParticlePool().get(opts));
        if (f.charge > 0.5) {
          shockwavesRef.current.push({ x: f.pos.x, y: f.pos.y, r: 0, a: 0.25 });
        }
        fireworksRef.current.splice(i, 1);
      }
    }

    getParticlePool().updateAndDraw(ctx);

    for (let i = shockwavesRef.current.length - 1; i >= 0; i--) {
      const sw = shockwavesRef.current[i];
      sw.r += 16; sw.a -= 0.01;
      ctx.globalAlpha = sw.a;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.r, 0, 6.28);
      ctx.stroke();
      if (sw.a <= 0) shockwavesRef.current.splice(i, 1);
    }

    ctx.globalAlpha = 1;

    if (isCharging) {
      const increment = 0.025 * (1 - chargeLevelRef.current * 0.4);
      chargeLevelRef.current = Math.min(chargeLevelRef.current + increment, 1);
      
      const { x, y } = mousePos.current;
      const hue = (x / window.innerWidth) * 360;
      
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.4 + chargeLevelRef.current * 0.4})`;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, 40 + chargeLevelRef.current * 100, time * 0.003, time * 0.003 + 6.28);
      ctx.stroke();
      
      if (Math.random() > 0.5) {
        const ang = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 50;
        getSparklersPool().get({
          x: x + Math.cos(ang) * dist,
          y: y + Math.sin(ang) * dist,
          hue: (hue + 40) % 360,
          speed: -4 - chargeLevelRef.current * 4,
          angle: ang,
          size: 1,
          decay: 0.1,
          behavior: 'glitter'
        });
      }

      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${0.1 + chargeLevelRef.current * 0.4})`;
      ctx.beginPath();
      ctx.arc(x, y, chargeLevelRef.current * 50, 0, 6.28);
      ctx.fill();
      ctx.restore();
    }

    requestRef.current = requestAnimationFrame(animate);
  }, [isCharging, stars, settings]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
  }, [animate]);

  const updateMousePos = (e: React.MouseEvent | React.TouchEvent) => {
    const x = 'touches' in e ? (e as React.TouchEvent).touches[0].clientX : (e as React.MouseEvent).clientX;
    const y = 'touches' in e ? (e as React.TouchEvent).touches[0].clientY : (e as React.MouseEvent).clientY;
    mousePos.current = { x, y };
    
    if (Math.random() > 0.8) {
      getSparklersPool().get({
        x, y,
        hue: (performance.now() / 15) % 360,
        speed: Math.random() * 2,
        size: 0.7,
        decay: 0.06
      });
    }
  };

  const handleMouseDown = (e: React.MouseEvent | React.TouchEvent) => {
    setIsCharging(true);
    chargeLevelRef.current = 0;
    updateMousePos(e);
  };

  const handleMouseUp = () => {
    if (!isCharging) return;
    const xRatio = mousePos.current.x / window.innerWidth;
    const h = xRatio < 0.5 ? 170 + xRatio * 180 : (xRatio - 0.5) * 120;
    launchFireworkAt(mousePos.current.x, mousePos.current.y, h, chargeLevelRef.current + 0.1);
    setIsCharging(false);
    chargeLevelRef.current = 0;
  };

  return (
    <canvas
      ref={canvasRef}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onMouseMove={updateMousePos}
      onTouchStart={handleMouseDown}
      onTouchEnd={handleMouseUp}
      onTouchMove={updateMousePos}
      className="cursor-crosshair w-full h-full block touch-none"
    />
  );
});


====== FILE: D:\ALL IN AI\Aetheris\src\components\FireworkScene3D.tsx ======
// FILE: src/components/FireworkScene3D.tsx
// 鍗囩骇鐗?- 鏀寔 PBR 鏉愯川銆佺數褰辩骇鍚庢湡澶勭悊銆乂erlet 绉垎鐗╃悊

import React, { useEffect, useRef, useImperativeHandle, forwardRef, memo } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

import { ParticlePool3D } from '../core/ParticlePool3D';
import { Firework3D } from '../core/Firework3D';
import { TimeController } from '../core/TimeController';
import { PostProcessingStack, DEFAULT_POST_PROCESSING_CONFIG, PostProcessingConfig } from '../core/PostProcessingStack';
import { PhysicsEngine, DEFAULT_PHYSICS_CONFIG, IntegratorType } from '../core/PhysicsEngine';
import { getPBRMaterialManager, createPBRParticleTexture } from '../core/PBRMaterial';
import {
  AppSettings,
  CameraMode,
  ExplosionType,
  AscensionType,
  FireworkConfig,
  ManualConfig,
  ColorStyle,
  LaunchFormation
} from '../types';

/**
 * 鏄惧紡瀹氫箟 Props 鎺ュ彛锛岀‘淇?TypeScript 鍦ㄧ埗缁勪欢寮曠敤鏃朵笉浼氭姤閿?
 */
export interface FireworkScene3DProps {
  settings: AppSettings;
  config: FireworkConfig;
  manualConfig: ManualConfig;
  autoRotate: boolean;
  onTimeUpdate?: (timeController: TimeController) => void;
  onStatsUpdate?: (stats: { particles: number; fireworks: number; fps: number }) => void;
  onLaunch?: (log: string) => void;
}

/**
 * 瀹氫箟缁勪欢鏆撮湶缁欏閮ㄧ殑鎿嶄綔鎺ュ彛
 */
export interface FireworkScene3DHandle {
  launchCarnival: () => void;
  launchAt: (x: number, y: number, z: number) => void;
  getTimeController: () => TimeController;
}

/**
 * 鍐呴儴杈呭姪鍑芥暟锛氬垱寤?PBR 绾у埆鐨勫彂鍏夌矑瀛愯创鍥?
 * 澶氬眰娓愬彉瀹炵幇 HDR 鏁堟灉锛屾牳蹇冨厜鏅?+ 鏌斿拰杈圭紭
 */
const createDetailedParticleTexture = () => {
  const canvas = document.createElement('canvas');
  const resolution = 128;
  canvas.width = resolution;
  canvas.height = resolution;
  const ctx = canvas.getContext('2d')!;
  
  const center = resolution / 2;

  // 绗竴灞傦細鏍稿績鍏夋檿 (瓒呴珮寮哄害 HDR)
  const coreGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.3);
  coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
  coreGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.95)');
  coreGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)');
  coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = coreGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  // 绗簩灞傦細涓诲厜鏅?(涓瓑寮哄害)
  const mainGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.7);
  mainGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  mainGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.25)');
  mainGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.08)');
  mainGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = mainGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  // 绗笁灞傦細澶栧眰鏌斿拰杈圭紭 (钀ラ€犵湡瀹炴劅)
  const outerGradient = ctx.createRadialGradient(center, center, 0, center, center, center);
  outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
  outerGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.03)');
  outerGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.01)');
  outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = outerGradient;
  ctx.fillRect(0, 0, resolution, resolution);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

/**
 * FireworkScene3D 鏍稿績缁勪欢
 * 浣跨敤 React.ForwardRefRenderFunction 鏄惧紡澹版槑浠ヨ幏寰楁渶浣?TS 鏀寔
 */
const FireworkScene3DInner: React.ForwardRefRenderFunction<FireworkScene3DHandle, FireworkScene3DProps> = (
    { settings, config, manualConfig, autoRotate, onTimeUpdate, onStatsUpdate, onLaunch },
    ref
) => {
  // === 鍩虹寮曠敤 ===
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const composerRef = useRef<EffectComposer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const requestRef = useRef<number>(0);

  // === 涓氬姟閫昏緫寮曠敤 (鐢ㄤ簬鍦ㄤ笉瑙﹀彂 useEffect 鐨勬儏鍐典笅鍚屾鐘舵€? ===
  const settingsRef = useRef(settings);
  const configRef = useRef(config);
  const manualConfigRef = useRef(manualConfig);
  const autoRotateRef = useRef(autoRotate);

  useEffect(() => { settingsRef.current = settings; }, [settings]);
  useEffect(() => { configRef.current = config; }, [config]);
  useEffect(() => { manualConfigRef.current = manualConfig; }, [manualConfig]);
  useEffect(() => { autoRotateRef.current = autoRotate; }, [autoRotate]);

  // === 妯℃嫙鍣ㄥ唴閮ㄧ姸鎬?===
  const fireworksRef = useRef<Firework3D[]>([]);
  const particlePoolRef = useRef<ParticlePool3D>(new ParticlePool3D(30000));
  const timeControllerRef = useRef<TimeController>(new TimeController());

  const lastAutoLaunchRef = useRef<number>(0);
  const lastCarnivalRef = useRef<number>(0);
  const fpsRef = useRef({ frames: 0, lastTime: 0, value: 0 });

  // === 榧犳爣浜や簰寮曠敤 ===
  const mouseDownPos = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const mouseDownTime = useRef<number>(0);
  const planeRef = useRef<THREE.Plane>(new THREE.Plane(new THREE.Vector3(0, 1, 0), 0));

  /**
   * 鏍稿績鍙戝皠鏂规硶锛氭敮鎸佷粠閰嶇疆涓殢鏈烘垨鎸囧畾鏍峰紡
   */
  const launchSingle = (s: AppSettings, c: FireworkConfig, overrides?: any) => {
    const targetX = overrides?.targetX ?? (Math.random() - 0.5) * 800;
    const targetZ = overrides?.targetZ ?? (Math.random() - 0.5) * 800;
    const targetY = overrides?.targetY ?? (200 + Math.random() * 150);
    const startX = overrides?.startX ?? (Math.random() - 0.5) * 1000;
    const startZ = overrides?.startZ ?? (Math.random() - 0.5) * 1000;

    // 1. 杞ㄨ抗鍐崇瓥
    let trajectory = overrides?.trajectory || 'RANDOM';
    if (trajectory === 'RANDOM') {
      const tPool = c.enabledTrajectories || [];
      trajectory = tPool.length > 0 ? tPool[Math.floor(Math.random() * tPool.length)] : undefined;
    }

    // 2. 褰㈢姸鍐崇瓥
    let shape = overrides?.shape || 'RANDOM';
    if (shape === 'RANDOM') {
      const sPool = [...(c.enabledShape3Ds || []), ...(c.enabledShapes || [])];
      shape = sPool.length > 0 ? sPool[Math.floor(Math.random() * sPool.length)] : undefined;
    }

    // 3. 缁勫悎鎶€鍐崇瓥
    let combo = overrides?.combo || 'RANDOM';
    if (combo === 'RANDOM') {
      const cbPool = c.enabledCombos || [];
      combo = cbPool.length > 0 ? cbPool[Math.floor(Math.random() * cbPool.length)] : undefined;
    }
    
    // 4. 鐢熷懡鍛ㄦ湡鍐崇瓥 (Decay)
    const lifeTimeOverride = overrides?.duration || 0;

    fireworksRef.current.push(new Firework3D(
      {
        startX, startZ,
        targetX, targetY, targetZ,
        hue: Math.random() * 360,
        charge: 1.0,
        trajectoryType: trajectory,
        comboType: combo,
        customShape: shape,
        lifeTimeOverride
      },
      s, c
    ));

    // 杈撳嚭鏃ュ織鍒?UI
    if (!overrides?.skipLog) {
       const logInfo = `馃殌 鍙戝皠: [${shape || '榛樿'}] - ${trajectory || '鐩寸嚎'} - ${combo || '鍗曠骇'}`;
       onLaunch?.(logInfo);
    }
  };

  /**
   * 闃熷舰鍙戝皠鍣?
   */
  const launchGroup = (
      formation: LaunchFormation, 
      count: number, 
      interval: number, 
      duration: number,
      launchFn: (idx: number, posOffset: THREE.Vector3, targetOffset: THREE.Vector3) => void
  ) => {
      if (count <= 1 || formation === LaunchFormation.SINGLE) {
          launchFn(0, new THREE.Vector3(), new THREE.Vector3());
          return;
      }

      const radius = 150;
      
      for (let i = 0; i < count; i++) {
          const offsetS = new THREE.Vector3(); 
          const offsetT = new THREE.Vector3(); 
          
          const progress = i / count;
          const angle = progress * Math.PI * 2;
          
          switch (formation) {
              case LaunchFormation.CIRCLE:
                  offsetT.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                  offsetS.set(Math.cos(angle) * radius * 0.5, 0, Math.sin(angle) * radius * 0.5); 
                  break;
              case LaunchFormation.LINE:
                  const w = radius * 2;
                  const x = (i - count / 2) * (w / count);
                  offsetT.set(x, 0, 0);
                  offsetS.set(x, 0, 0);
                  break;
              case LaunchFormation.CROSS: // 绠€鍗曠殑鍗佸瓧甯冨眬
                  const arm = i % 4;
                  const dist = Math.floor(i / 4 + 1) * (radius / 2);
                  if (arm === 0) offsetT.set(dist, 0, 0);
                  if (arm === 1) offsetT.set(-dist, 0, 0);
                  if (arm === 2) offsetT.set(0, 0, dist);
                  if (arm === 3) offsetT.set(0, 0, -dist);
                  offsetS.copy(offsetT).multiplyScalar(0.5);
                  break;
              case LaunchFormation.V_SHAPE:
                  const side = i % 2 === 0 ? 1 : -1;
                  const row = Math.floor(i / 2);
                  offsetT.set(side * row * 50, 0, row * 50);
                  offsetS.copy(offsetT);
                  break;
              case LaunchFormation.RANDOM:
              default:
                  offsetT.set((Math.random()-0.5)*radius*2, (Math.random()-0.5)*50, (Math.random()-0.5)*radius*2);
                  offsetS.set((Math.random()-0.5)*radius, 0, (Math.random()-0.5)*radius);
                  break;
          }

          if (interval > 0) {
              setTimeout(() => {
                  launchFn(i, offsetS, offsetT);
              }, i * interval);
          } else {
              launchFn(i, offsetS, offsetT);
          }
      }
  };

  /**
   * 鍢夊勾鍗庡簭鍒楁墽琛岄€昏緫
   */
  const launchCarnivalWave = (s: AppSettings, c: FireworkConfig) => {
    const sequence = c.carnivalSequence || [];
    
    if (sequence.length === 0) {
      const count = 5 + Math.floor(Math.random() * 8);
      onLaunch?.(`闅忔満娉㈡: ${count} 鏋歚);
      launchGroup(LaunchFormation.RANDOM, count, 150, 0, (i, offS, offT) => {
         launchSingle(s, c);
      });
      return;
    }

    let totalDelay = 0;
    sequence.forEach((stage, sIdx) => {
      totalDelay += stage.delay;
      setTimeout(() => {
        onLaunch?.(`[澶х] ${stage.name}`);
        launchGroup(
            stage.formation || LaunchFormation.RANDOM,
            stage.count,
            stage.interval || 0,
            stage.duration || 0,
            (idx, offS, offT) => {
                launchSingle(s, c, {
                    trajectory: stage.trajectory,
                    shape: stage.shape,
                    combo: stage.combo,
                    duration: stage.duration,
                    targetX: offT.x * 1.5, 
                    targetZ: offT.z * 1.5, 
                    startX: offS.x,
                    startZ: offS.z,
                    skipLog: idx > 0 
                });
            }
        );
      }, totalDelay);
    });
  };

  const createBackgroundStars = (scene: THREE.Scene) => {
    const starGeo = new THREE.BufferGeometry();
    const count = 4000;
    const pos = new Float32Array(count * 3);
    const col = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const r = 3000 + Math.random() * 2000;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      pos[i * 3 + 2] = r * Math.cos(phi);
      col[i * 3] = 0.8; col[i * 3 + 1] = 0.8; col[i * 3 + 2] = 1.0;
    }

    starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));

    const starMat = new THREE.PointsMaterial({
      size: 3, vertexColors: true, transparent: true, opacity: 0.5, sizeAttenuation: false
    });
    scene.add(new THREE.Points(starGeo, starMat));
  };

  const createReferenceGround = (scene: THREE.Scene) => {
    const grid = new THREE.GridHelper(8000, 80, 0x223344, 0x05101a);
    const gridMat = grid.material as THREE.Material;
    gridMat.transparent = true;
    gridMat.opacity = 0.1;
    grid.position.y = -10;
    scene.add(grid);
  };

  const updateStarsTwinkle = (time: number) => {
    const stars = sceneRef.current?.children.find(c => c instanceof THREE.Points && !(c.material as any).map);
    if (stars && stars instanceof THREE.Points) {
      const colors = stars.geometry.attributes.color.array as Float32Array;
      for (let i = 0; i < colors.length; i += 3) {
        const f = 0.7 + 0.3 * Math.sin(time + i);
        colors[i] = 0.8 * f;
        colors[i + 1] = 0.8 * f;
        colors[i + 2] = 1.0 * f;
      }
      stars.geometry.attributes.color.needsUpdate = true;
    }
  };

  // === 鐢熷懡鍛ㄦ湡锛氬垵濮嬪寲鍦烘櫙 ===
  useEffect(() => {
    if (!containerRef.current) return;

    // 1. 鍒濆鍖栧満鏅鍣?
    containerRef.current.innerHTML = '';

    // 2. 鍒涘缓鍦烘櫙 (Scene)
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0e17);
    scene.fog = new THREE.FogExp2(0x0a0e17, 0.0006);
    sceneRef.current = scene;

    // 3. 鍒涘缓鐩告満 (Camera)
    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        10000
    );
    camera.position.set(0, 150, 600);
    cameraRef.current = camera;

    // 4. 鍒涘缓娓叉煋鍣?(Renderer) - HDR 閰嶇疆
    const renderer = new THREE.WebGLRenderer({
      antialias: false,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    // 浣跨敤 ACES Filmic 鑹茶皟鏄犲皠 - 鐢靛奖绾?HDR 娓叉煋
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // 5. 閰嶇疆澧炲己鐗堝悗鏈熷鐞?(EffectComposer)
    // 浣跨敤鏇村己鐨?Bloom 鏁堟灉瀹炵幇 HDR 鍏夋孩鍑?
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.8,   // 寮哄害 - 澧炲己鍒?1.8 瀹炵幇鏇存槑鏄剧殑鍏夋孩鍑?
        0.5,   // 鍗婂緞 - 澧炲姞鍒?0.5 璁╁厜鏅曟洿鏌斿拰
        0.15   // 闃堝€?- 闄嶄綆鍒?0.15 璁╂洿澶氬尯鍩熶骇鐢熻緣鍏?
    );
    composer.addPass(renderPass);
    composer.addPass(bloomPass);
    composerRef.current = composer;

    // 6. 閰嶇疆杞ㄩ亾鎺у埗鍣?(OrbitControls)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 100;
    controls.maxDistance = 2000;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controlsRef.current = controls;

    // 7. 鍒濆鍖栫矑瀛愮郴缁熷嚑浣曚綋
    const maxParticles = 30000;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3).fill(-10000);
    const colors = new Float32Array(maxParticles * 3);
    const sizes = new Float32Array(maxParticles);

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particleMaterial = new THREE.PointsMaterial({
      size: 8,
      map: createDetailedParticleTexture(),
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    const particlePoints = new THREE.Points(particleGeometry, particleMaterial);
    particlePoints.frustumCulled = false;
    scene.add(particlePoints);

    // 8. 鍒涘缓鑳屾櫙鍏冪礌
    createBackgroundStars(scene);

    // 鍏疯薄鍖?XOZ 骞抽潰 (鍦伴潰) - 鏋佸骇鏍囩綉鏍?+ 鏍囧噯缃戞牸
    const polarGrid = new THREE.PolarGridHelper(300, 16, 8, 0x059669, 0x064e3b);
    polarGrid.position.y = -50; // 涓嬫矇鑷冲湴闈?
    (polarGrid.material as THREE.Material).transparent = true;
    (polarGrid.material as THREE.Material).opacity = 0.2;
    scene.add(polarGrid);

    const gridHelper = new THREE.GridHelper(800, 40, 0x334155, 0x0f172a);
    gridHelper.position.y = -50;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.15;
    scene.add(gridHelper);
    
    // createReferenceGround(scene); // Deprecated
    createReferenceGround(scene);

    // 9. 澶勭悊绐楀彛缂╂斁
    const onResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    };
    window.addEventListener('resize', onResize);

    // 10. 鏍稿績鍔ㄧ敾涓诲惊鐜?
    const renderLoop = () => {
      requestRef.current = requestAnimationFrame(renderLoop);

      const tc = timeControllerRef.current;
      const currentSettings = settingsRef.current;
      const currentConfig = configRef.current;

      // 鏇存柊鎺у埗鍣?
      if (controlsRef.current) {
        controlsRef.current.autoRotate = autoRotateRef.current;
        controlsRef.current.update();
      }

      // 濡傛灉鏈殏鍋滐紝鎵ц鐗╃悊妯℃嫙
      if (!tc.isPaused) {
        tc.update();
        const dt = tc.deltaTime;
        const virtualNow = tc.virtualTime * 1000;

        // A. 鑷姩鍢夊勾鍗庢尝娆″垽瀹?
        if (currentSettings.enableAutoCarnival) {
          if (virtualNow - lastCarnivalRef.current > currentSettings.carnivalInterval * 1000) {
            launchCarnivalWave(currentSettings, currentConfig);
            lastCarnivalRef.current = virtualNow;
          }
        }

        // === Sub-stepping 甯у唴澶氭鐗╃悊璁＄畻 ===
        // 纭繚鍗充娇鍦ㄤ綆甯х巼涓嬭建杩逛篃涓濇粦骞崇ǔ
        const SUB_STEPS = 4;  // 姣忓抚杩涜 4 娆＄墿鐞嗘洿鏂?
        const subDt = dt / SUB_STEPS;
        
        for (let step = 0; step < SUB_STEPS; step++) {
          // B. 鐑熻姳鐗╃悊鏇存柊 (浣跨敤 Verlet 绉垎鍣ㄨ嚜鍔ㄥ鐞?
          for (let i = fireworksRef.current.length - 1; i >= 0; i--) {
            const fw = fireworksRef.current[i];
            fw.update(currentSettings, subDt);

            // 鍗囩┖杩囩▼锛氱敓鎴愬熬鐒扮矑瀛?(浠呭湪鏈€鍚庝竴涓瓙姝ラ鐢熸垚锛岄伩鍏嶈繃澶氱矑瀛?
            // 鍗囩┖杩囩▼锛氱敓鎴愬熬鐒扮矑瀛?
            // 澧炲己閫昏緫锛氬浜庡鏉傝建杩癸紝鍦ㄦ瘡涓?sub-step 閮界敓鎴愮矑瀛愪互鑾峰緱骞虫粦鏇茬嚎
            // 瀵逛簬鐩寸嚎/绠€鍗曡建杩癸紝浠呭湪姣忓抚鐢熸垚涓€娆′互鑺傜渷鎬ц兘
            const isComplexTrail = Boolean(fw.ascension && fw.ascension.match(/(SPIRAL|HELIX|ZIGZAG|SINE|WOBBLE)/i));
            const shouldEmit = !fw.exploded && (isComplexTrail || step === SUB_STEPS - 1);

            if (shouldEmit) {
              const speed = fw.velocity.length();
              const t = fw.lifeTime;  // 鏃堕棿鐢ㄤ簬鍔ㄧ敾鏁堟灉
              
              // 鏍规嵁杞ㄨ抗绫诲瀷纭畾灏剧劙鍙傛暟
              const trajectoryType = fw.ascension;
              const trajectoryName = (fw.ascension || 'LINEAR').toUpperCase();
              
              // 鍩虹鍙傛暟
              let trailCount = 1;        // 姣忓抚鐢熸垚鏁伴噺
              let trailSize = 6;         // 灏剧劙澶у皬
              let trailDecay = 0.05;     // 琛板噺閫熷害 (瓒婂皬鎷栧熬瓒婇暱)
              let trailSpread = 1.0;     // 妯悜鎵╂暎
              let trailGravity = 0.01;   // 鍙楅噸鍔涘奖鍝?
              let offsetX = 0, offsetZ = 0;
              let extraBrightness = 1.0; 
              let baseHue = fw.hue;
              
              // === 杞ㄨ抗瑙嗚寮哄寲 ===

              if (trajectoryName.includes('SPIRAL') || trajectoryName.includes('HELIX')) {
                // 铻烘棆/DNA锛氬弻鑲¤灪鏃嬶紝楂樺瘑搴︼紝鑹插僵鍒嗙
                trailCount = 2; // 姣忔2涓偣 (鍙岃灪鏃?
                trailSize = 5;
                trailDecay = 0.04;
                const spiralSpeed = 10;
                const spiralRadius = 12.0; // [VISIBILITY] 澧炲姞鍗婂緞鍒?12 (鍘?3.5)
                
                // 璁＄畻铻烘棆鍋忕Щ
                const angle = t * spiralSpeed;
                offsetX = Math.cos(angle) * spiralRadius;
                offsetZ = Math.sin(angle) * spiralRadius;
                
                // 棰滆壊鍋忕Щ锛氳涓ゆ潯铻烘棆绾块鑹茬◢寰笉鍚?(浜害鍖哄垎)
                extraBrightness = 1.5;

              } else if (trajectoryName.includes('ZIGZAG') || trajectoryName.includes('SINE') || trajectoryName.includes('WOBBLE')) {
                // S鍨?鎽囨憜锛氬ぇ骞呭害鎽嗗姩锛屾洿瀹界殑鎷栧熬
                trailCount = 2;
                trailSize = 6;
                trailDecay = 0.03; 
                const waveAmp = 25.0; // [VISIBILITY] 澧炲姞骞呭害鍒?25
                const waveFreq = 6.0;
                
                // 鍨傜洿浜庤繍鍔ㄦ柟鍚戠殑鎽嗗姩
                offsetX = Math.sin(t * waveFreq) * waveAmp;
                // Z杞寸◢寰敊寮€澧炲姞绔嬩綋鎰?
                offsetZ = Math.cos(t * waveFreq * 0.7) * (waveAmp * 0.4);
                
                trailSpread = 2.0;

              } else if (trajectoryName.includes('ACCELERATE') || trajectoryName === '鏋侀€熸帹杩?) {
                // 鍔犻€?鐏锛氱粏闀匡紝鏋佷负鏄庝寒鐨勬牳蹇冿紝浼撮殢鐑熼浘
                trailCount = 6;     // 鏇村绮掑瓙
                trailSize = 8;        // 鏍稿績寰堝ぇ
                trailDecay = 0.015;   // 鏋侀暱鎷栧熬
                trailSpread = 0.8;    // 鏀舵潫
                extraBrightness = 4.0; // 鐖嗕寒
                trailGravity = 0;     // 鏃犻噸鍔?
                baseHue = 30;         // 寮哄埗鍋忓悜鐏劙鑹?(姗?榛? 濡傛灉涓嶆槸 override
                if (Math.random() < 0.3) baseHue = fw.hue; // 鍋跺皵娣峰悎鍘熸湰棰滆壊

              } else if (trajectoryName.includes('BEZIER') || trajectoryName.includes('CURVE')) {
                // 鏇茬嚎锛氬钩婊戯紝浼橀泤
                trailCount = 1;
                trailSize = 5;
                trailDecay = 0.04;
                extraBrightness = 1.2;
              }

              // 鐢熸垚绮掑瓙
              const spawnProbability = Math.min(1.0, speed / 10); 
              const alphaValue = Math.min(1, speed / 15) * extraBrightness;
              const emissiveBoost = (2.0 + speed * 0.2) * extraBrightness;

              for (let tc = 0; tc < trailCount; tc++) {
                if (Math.random() < spawnProbability) {
                  let finalOffX = offsetX;
                  let finalOffZ = offsetZ;
                  let pSize = trailSize;
                  let pHue = baseHue;

                  // 铻烘棆鐗规畩澶勭悊锛氬弻鑲″弽鐩?
                  if (trajectoryName.includes('SPIRAL') || trajectoryName.includes('HELIX')) {
                      // tc=0: 姝ｇ浉, tc=1: 鍙嶇浉 (PI)
                      const phase = (tc % 2) * Math.PI;
                      // 閲嶇畻鍋忕Щ浠ョ‘淇濆弻鑲℃纭?
                      finalOffX = Math.cos(t * 10 + phase) * 12.0;
                      finalOffZ = Math.sin(t * 10 + phase) * 12.0;
                      
                      // 鍙岃壊
                      pHue = fw.hue + (tc % 2 === 0 ? 0 : 180); 
                      pSize = trailSize * 0.8;
                  }

                  const p = particlePoolRef.current.get({
                    x: fw.position.x + finalOffX + (Math.random() - 0.5) * trailSpread,
                    y: fw.position.y - 1.0, 
                    z: fw.position.z + finalOffZ + (Math.random() - 0.5) * trailSpread,
                    hue: pHue,  
                    speed: 0, 
                    size: pSize * (Math.random() * 0.4 + 0.8),
                    decay: trailDecay * (Math.random() * 0.4 + 0.8),
                    behavior: 'default',
                    gravity: trailGravity
                  });
                  
                  if (p) {
                    p.alpha = alphaValue; 
                    p.emissiveIntensity = emissiveBoost;
                    // 鍔犻€熷熬鐒板弽鎺ㄦ晥鏋?
                    if (trajectoryName.includes('ACCELERATE')) {
                       p.velocity.y = -speed * 0.15;
                       p.velocity.x *= 0.1;
                       p.velocity.z *= 0.1;
                    }
                  }
                }
              }
            }

            // 鐖嗙偢閫昏緫
            if (fw.exploded) {
              fw.createExplosion(currentSettings, (opts) => particlePoolRef.current.get(opts));
              fireworksRef.current.splice(i, 1);
            }
          }

          // C. 鍏ㄥ眬绮掑瓙鐗╃悊鏇存柊 (Verlet 绉垎)
          particlePoolRef.current.update(subDt);
        }
      }

      // D. 鍚屾绮掑瓙 Buffer 鍒?GPU
      const activeParticles = particlePoolRef.current.getActiveParticles();
      const posArray = particleGeometry.attributes.position.array as Float32Array;
      const colArray = particleGeometry.attributes.color.array as Float32Array;

      for (let i = 0; i < activeParticles.length; i++) {
        const p = activeParticles[i];
        const idx = i * 3;
        posArray[idx] = p.position.x;
        posArray[idx + 1] = p.position.y;
        posArray[idx + 2] = p.position.z;

        // HDR 棰滆壊璁＄畻锛氬熀纭€鑹?脳 alpha 脳 鍙戝厜寮哄害
        // emissiveIntensity > 1.0 浼氫骇鐢?HDR 鏁堟灉锛屼笌 Bloom 閰嶅悎浜х敓鍏夋孩鍑?
        const color = p.getColor();
        const hdrMultiplier = p.alpha * Math.min(p.emissiveIntensity, 5.0);  // 闄愬埗鏈€澶у己搴﹂伩鍏嶈繃鏇?
        colArray[idx] = color.r * hdrMultiplier;
        colArray[idx + 1] = color.g * hdrMultiplier;
        colArray[idx + 2] = color.b * hdrMultiplier;
      }

      // 闅愯棌闈炴椿鍔ㄧ矑瀛?
      for (let i = activeParticles.length; i < maxParticles; i++) {
        const idx = i * 3;
        if (posArray[idx + 1] > -5000) {
          posArray[idx] = 0;
          posArray[idx + 1] = -10000;
          posArray[idx + 2] = 0;
        } else if (i > activeParticles.length + 200) {
          break; // 浼樺寲锛氬鏋滃凡缁忔槸涓€鍧楄繛缁殑闅愯棌鍖哄垯鍋滄
        }
      }

      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;

      // E. 鏇存柊鏄熸槦闂儊
      updateStarsTwinkle(performance.now() * 0.0005);

      // F. FPS 缁熻
      fpsRef.current.frames++;
      if (performance.now() - fpsRef.current.lastTime > 1000) {
        fpsRef.current.value = fpsRef.current.frames;
        fpsRef.current.frames = 0;
        fpsRef.current.lastTime = performance.now();
      }

      // G. 娓叉煋
      composer.render();

      // H. 鍥炶皟
      if (onTimeUpdate) onTimeUpdate(tc);
      if (onStatsUpdate) {
        onStatsUpdate({
          particles: activeParticles.length,
          fireworks: fireworksRef.current.length,
          fps: fpsRef.current.value
        });
      }
    };

    renderLoop();

    return () => {
      window.removeEventListener('resize', onResize);
      cancelAnimationFrame(requestRef.current);
      renderer.dispose();
      controls.dispose();
    };
  }, []);

  // 浜や簰鍓ф湰绱㈠紩鎸囬拡
  const manualStepIndexRef = useRef<number>(0);

  // === 鏆撮湶鎺ュ彛缁欑埗缁勪欢 ===
  useImperativeHandle(ref, () => ({
    launchCarnival: () => launchCarnivalWave(settingsRef.current, configRef.current),
    launchAt: (x, y, z) => {
      const mc = manualConfigRef.current;
      const c = configRef.current;
      const settings = settingsRef.current;
      const manualSeq = c.manualSequence || [];

      // 濡傛灉閰嶇疆浜嗘墜鍔ㄤ氦浜掑墽鏈紝鍒欐寜鍓ф湰椤哄簭鍙戝皠
      if (manualSeq.length > 0) {
        const stage = manualSeq[manualStepIndexRef.current];
        onLaunch?.(`[鍓ф湰] ${stage.name}`);
        
        launchGroup(
            stage.formation || LaunchFormation.SINGLE,
            stage.count,
            stage.interval || 100,
            stage.duration || 0,
            (idx, offS, offT) => {
               launchSingle(settings, c, {
                 trajectory: stage.trajectory,
                 shape: stage.shape,
                 combo: stage.combo,
                 duration: stage.duration,
                 targetX: x + offT.x,
                 targetY: y > 50 ? y : 220,
                 targetZ: z + offT.z,
                 startX: x + (Math.random() - 0.5) * 40 + offS.x,
                 startZ: z + (Math.random() - 0.5) * 40 + offS.z,
                 skipLog: idx > 0
               });
            }
        );

        manualStepIndexRef.current = (manualStepIndexRef.current + 1) % manualSeq.length;
      } else {
        // 鍥為€€閫昏緫锛氭墜鍔ㄩ厤缃?
        // 浣跨敤鏂板弬鏁?lockedFormation, lockedCount, lockedDuration
        const formation = mc.lockedFormation || LaunchFormation.SINGLE;
        const count = mc.lockedCount || 1;
        
        launchGroup(
            formation,
            count,
            mc.lockedInterval || 100,
            mc.lockedDuration || 0,
            (idx, offS, offT) => {
                launchSingle(settings, c, {
                  trajectory: mc.lockedTrajectory,
                  shape: mc.lockedShape,
                  combo: mc.lockedCombo,
                  duration: mc.lockedDuration,
                  targetX: x + offT.x,
                  targetY: y > 50 ? y + (Math.random()-0.5)*20 : 200 + (Math.random()-0.5)*20,
                  targetZ: z + offT.z,
                  startX: x + (Math.random() - 0.5) * 50 + offS.x,
                  startZ: z + (Math.random() - 0.5) * 50 + offS.z,
                  skipLog: idx > 0
                });
            }
        );
        
        if (count <= 1) onLaunch?.(`馃幆 鎵嬪姩鍗曞彂`);
        else onLaunch?.(`馃幆 鎵嬪姩榻愬皠: ${count}鍙?(${formation})`);
      }
    },
    getTimeController: () => timeControllerRef.current
  }));

  // === 榧犳爣浜や簰浜嬩欢 ===
  const handleInteraction = (e: React.MouseEvent) => {
    if (e.button === 0 && cameraRef.current && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const mouse = new THREE.Vector2(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
      );

      const ray = new THREE.Raycaster();
      ray.setFromCamera(mouse, cameraRef.current);
      const targetPoint = new THREE.Vector3();
      ray.ray.intersectPlane(planeRef.current, targetPoint);

      if (targetPoint) {
        // 閫氳繃 Ref 鑾峰彇鑷韩鏆撮湶鐨勬帴鍙ｈ繘琛屽彂灏?
        // @ts-ignore
        ref.current?.launchAt(targetPoint.x, targetPoint.y, targetPoint.z);
      }
    }
  };

  return (
      <div
          ref={containerRef}
          className="w-full h-full block cursor-crosshair outline-none"
          onMouseDown={(e) => {
            mouseDownPos.current = { x: e.clientX, y: e.clientY };
            mouseDownTime.current = performance.now();
          }}
          onMouseUp={(e) => {
            const dist = Math.sqrt(Math.pow(e.clientX - mouseDownPos.current.x, 2) + Math.pow(e.clientY - mouseDownPos.current.y, 2));
            if (dist < 5 && (performance.now() - mouseDownTime.current) < 300) {
              handleInteraction(e);
            }
          }}
      />
  );
};

// 灏佽瀵煎嚭
export const FireworkScene3D = memo(forwardRef(FireworkScene3DInner));

====== FILE: D:\ALL IN AI\Aetheris\src\core\combos\ComboManager.ts ======
// FILE: src/core/combos/ComboManager.ts
// 缁勫悎鎶€绯荤粺锛氬畾涔夊闃舵鐖嗙偢鍜屽鏉傜壒鏁堢粍鍚?

import { Shape3DType } from '../shapes/Shape3DFactory';
import { TrajectoryType } from '../trajectories/TrajectoryFactory';

/**
 * 缁勫悎鎶€绫诲瀷
 */
export enum ComboType {
  // === 缁忓吀缁勫悎 ===
  SINGLE = 'single',                    // 鍗曟鐖嗙偢锛堥粯璁わ級
  STAGED = 'staged',                    // 瀛愭瘝杩炵垎锛?-3闃舵锛?
  DELAYED_BURST = 'delayed_burst',      // 寤惰繜鐖嗗彂
  MULTI_WAVE = 'multi_wave',            // 澶氭尝娆℃墿鏁?
  
  // === 褰㈠彉缁勫悎 ===
  MORPH = 'morph',                      // 褰㈡€佸彉鍖栵紙鐞?>蹇冪瓑锛?
  SPLIT = 'split',                      // 鍒嗚鏁堟灉
  CONVERGE = 'converge',                // 姹囪仛鏁堟灉
  EXPAND_CONTRACT = 'expand_contract',  // 鎵╁紶鏀剁缉
  
  // === 鐗规晥缁勫悎 ===
  TRAIL_EXPLOSION = 'trail_explosion',  // 灏捐抗鐖嗙偢
  RAIN_DOWN = 'rain_down',              // 闆ㄨ惤鏁堟灉
  SPIRAL_SCATTER = 'spiral_scatter',    // 铻烘棆鏁ｅ皠
  PHOENIX_RISE = 'phoenix_rise',        // 鍑ゅ嚢閲嶇敓
  
  // === 楂樼骇缁勫悎 ===
  CASCADE_CHAIN = 'cascade_chain',      // 杩為攣鐎戝竷
  GALAXY_BIRTH = 'galaxy_birth',        // 閾舵渤璇炵敓
  SUPERNOVA_COLLAPSE = 'supernova_collapse', // 瓒呮柊鏄熷缂?
  FIREWORK_SYMPHONY = 'firework_symphony', // 鐑熻姳浜ゅ搷鏇?
}

/**
 * 缁勫悎鎶€淇℃伅
 */
export interface ComboInfo {
  name: string;
  icon: string;
  description: string;
  stages: number;
  duration: number; // 鎬绘寔缁椂闂?绉?
}

/**
 * 缁勫悎鎶€淇℃伅鏄犲皠
 */
export const COMBO_INFO: Record<ComboType, ComboInfo> = {
  [ComboType.SINGLE]: { name: '鍗曟鐖嗙偢', icon: '馃挜', description: '缁忓吀鍗曟鐐稿紑', stages: 1, duration: 0 },
  [ComboType.STAGED]: { name: '瀛愭瘝杩炵垎', icon: '馃巻', description: '鍏堢偢寮€鍐嶄簩娆＄垎鐐?, stages: 2, duration: 0.8 },
  [ComboType.DELAYED_BURST]: { name: '寤惰繜鐖嗗彂', icon: '鈴憋笍', description: '鎮仠鍚庣獊鐒剁偢寮€', stages: 2, duration: 1.2 },
  [ComboType.MULTI_WAVE]: { name: '澶氭尝鎵╂暎', icon: '銆帮笍', description: '涓夋尝渚濇鎵╂暎', stages: 3, duration: 1.5 },
  
  [ComboType.MORPH]: { name: '褰㈡€佸彉鍖?, icon: '馃攧', description: '鐞冨舰鍙樺績褰?, stages: 2, duration: 1.0 },
  [ComboType.SPLIT]: { name: '鍒嗚鏁堟灉', icon: '鉁傦笍', description: '涓€鍒嗕负澶?, stages: 2, duration: 0.6 },
  [ComboType.CONVERGE]: { name: '姹囪仛鏁堟灉', icon: '馃幆', description: '鍥涙暎鍚庢眹鑱?, stages: 2, duration: 1.5 },
  [ComboType.EXPAND_CONTRACT]: { name: '鍛煎惛鑴夊姩', icon: '馃挀', description: '鎵╁紶鍐嶆敹缂?, stages: 3, duration: 2.0 },
  
  [ComboType.TRAIL_EXPLOSION]: { name: '灏捐抗鐖嗙偢', icon: '鈽勶笍', description: '杞ㄨ抗涓婅繛缁皬鐖嗙偢', stages: 5, duration: 1.0 },
  [ComboType.RAIN_DOWN]: { name: '闆ㄨ惤鏁堟灉', icon: '馃導锔?, description: '鐐稿紑鍚庡闆ㄤ笅钀?, stages: 2, duration: 2.0 },
  [ComboType.SPIRAL_SCATTER]: { name: '铻烘棆鏁ｅ皠', icon: '馃寑', description: '铻烘棆椋炲嚭', stages: 1, duration: 0.5 },
  [ComboType.PHOENIX_RISE]: { name: '鍑ゅ嚢娑呮', icon: '馃敟', description: '涓嬭惤鍚庨噸鏂板崌璧?, stages: 3, duration: 3.0 },
  
  [ComboType.CASCADE_CHAIN]: { name: '杩為攣鐎戝竷', icon: '馃寠', description: '灞傚眰涓嬭惤', stages: 5, duration: 2.5 },
  [ComboType.GALAXY_BIRTH]: { name: '閾舵渤璇炵敓', icon: '馃寣', description: '浠庣偣鍒伴摱娌?, stages: 4, duration: 3.0 },
  [ComboType.SUPERNOVA_COLLAPSE]: { name: '瓒呮柊鏄熷缂?, icon: '馃挮', description: '鐖嗙偢鍚庡缂?, stages: 3, duration: 2.0 },
  [ComboType.FIREWORK_SYMPHONY]: { name: '鐑熻姳浜ゅ搷', icon: '馃幍', description: '澶氱鏁堟灉鍗忓', stages: 6, duration: 4.0 },
};

/**
 * 闃舵閰嶇疆
 */
export interface StageConfig {
  delay: number;          // 寤惰繜鏃堕棿(绉?
  shape: Shape3DType;     // 褰㈢姸
  scale: number;          // 缂╂斁
  particleCount: number;  // 绮掑瓙鏁伴噺鍊嶇巼
  hueShift: number;       // 鑹茬浉鍋忕Щ
  behavior?: string;      // 绮掑瓙琛屼负
  velocityScale?: number; // 閫熷害缂╂斁
  gravity?: number;       // 閲嶅姏瑕嗙洊
  decay?: number;         // 琛板噺瑕嗙洊
  spawnOffset?: { x: number; y: number; z: number }; // 鐢熸垚浣嶇疆鍋忕Щ
}

/**
 * 缁勫悎鎶€閰嶇疆
 */
export interface ComboConfig {
  type: ComboType;
  trajectory: TrajectoryType;
  stages: StageConfig[];
}

/**
 * 缁勫悎鎶€鐢熸垚鍣?
 */
export class ComboGenerator {
  /**
   * 鐢熸垚缁勫悎鎶€閰嶇疆
   */
  static generate(type: ComboType, baseShape: Shape3DType = Shape3DType.SPHERE): ComboConfig {
    const stages: StageConfig[] = [];
    let trajectory = TrajectoryType.LINEAR;
    
    switch (type) {
      case ComboType.SINGLE:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        break;
        
      case ComboType.STAGED:
        // 绗竴闃舵锛氬皬鐖嗙偢
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 0,
          decay: 0.05
        });
        // 绗簩闃舵锛氫富鐖嗙偢
        stages.push({
          delay: 0.8,
          shape: baseShape,
          scale: 1.2,
          particleCount: 1,
          hueShift: 60
        });
        break;
        
      case ComboType.DELAYED_BURST:
        // 绗竴闃舵锛氭偓鍋滈棯鐑?
        stages.push({
          delay: 0,
          shape: Shape3DType.SPARKLE_CLOUD,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter',
          velocityScale: 0.1
        });
        // 绗簩闃舵锛氱獊鐒剁垎鍙?
        stages.push({
          delay: 1.2,
          shape: baseShape,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0
        });
        break;
        
      case ComboType.MULTI_WAVE:
        // 涓夋尝鎵╂暎
        for (let i = 0; i < 3; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 0.8 + i * 0.3,
            particleCount: 0.5,
            hueShift: i * 40
          });
        }
        break;
        
      case ComboType.MORPH:
        // 鐞冨舰
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 0,
          decay: 0.03
        });
        // 鍙樺績褰?
        stages.push({
          delay: 1.0,
          shape: Shape3DType.HEART_3D,
          scale: 1.2,
          particleCount: 1,
          hueShift: 330 // 绮夌孩
        });
        break;
        
      case ComboType.SPLIT:
        // 涓讳綋
        stages.push({
          delay: 0,
          shape: Shape3DType.SPHERE,
          scale: 0.6,
          particleCount: 0.3,
          hueShift: 0
        });
        // 鍥涗釜鍒嗚鐐?
        const splitOffsets = [
          { x: 40, y: 0, z: 0 },
          { x: -40, y: 0, z: 0 },
          { x: 0, y: 0, z: 40 },
          { x: 0, y: 0, z: -40 }
        ];
        for (const offset of splitOffsets) {
          stages.push({
            delay: 0.6,
            shape: baseShape,
            scale: 0.5,
            particleCount: 0.3,
            hueShift: Math.random() * 60,
            spawnOffset: offset
          });
        }
        break;
        
      case ComboType.TRAIL_EXPLOSION:
        // 娌胯建杩圭殑灏忕垎鐐?
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.2,
            shape: Shape3DType.EXPLOSION_BURST,
            scale: 0.4,
            particleCount: 0.2,
            hueShift: i * 30,
            spawnOffset: { x: 0, y: -i * 30, z: 0 }
          });
        }
        trajectory = TrajectoryType.LINEAR;
        break;
        
      case ComboType.RAIN_DOWN:
        // 鐖嗙偢
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
        // 闆ㄨ惤
        stages.push({
          delay: 0.8,
          shape: Shape3DType.CASCADE,
          scale: 1.5,
          particleCount: 0.8,
          hueShift: 30,
          behavior: 'falling',
          gravity: 0.15
        });
        break;
        
      case ComboType.SPIRAL_SCATTER:
        stages.push({
          delay: 0,
          shape: Shape3DType.VORTEX,
          scale: 1.2,
          particleCount: 1,
          hueShift: 0
        });
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      case ComboType.PHOENIX_RISE:
        // 涓嬭惤鐏劙
        stages.push({
          delay: 0,
          shape: Shape3DType.FIREWORK_WILLOW,
          scale: 0.8,
          particleCount: 0.5,
          hueShift: 30,
          gravity: 0.2
        });
        // 搴曢儴姹囪仛
        stages.push({
          delay: 1.5,
          shape: Shape3DType.VORTEX,
          scale: 0.5,
          particleCount: 0.3,
          hueShift: 15,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        // 鍑ゅ嚢鍗囪捣
        stages.push({
          delay: 3.0,
          shape: Shape3DType.PHOENIX,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 0,
          velocityScale: 1.5,
          spawnOffset: { x: 0, y: -80, z: 0 }
        });
        trajectory = TrajectoryType.FALL_RISE;
        break;
        
      case ComboType.CASCADE_CHAIN:
        for (let i = 0; i < 5; i++) {
          stages.push({
            delay: i * 0.5,
            shape: Shape3DType.RING_WAVE,
            scale: 1 - i * 0.15,
            particleCount: 0.4,
            hueShift: i * 20,
            spawnOffset: { x: 0, y: -i * 25, z: 0 }
          });
        }
        break;
        
      case ComboType.GALAXY_BIRTH:
        // 涓績闂厜
        stages.push({
          delay: 0,
          shape: Shape3DType.EXPLOSION_BURST,
          scale: 0.3,
          particleCount: 0.2,
          hueShift: 0,
          behavior: 'glitter'
        });
        // 鎵╂暎
        stages.push({
          delay: 0.8,
          shape: Shape3DType.NEBULA,
          scale: 0.6,
          particleCount: 0.4,
          hueShift: 200
        });
        // 鏃嬭噦褰㈡垚
        stages.push({
          delay: 1.8,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1,
          particleCount: 0.8,
          hueShift: 240
        });
        // 瀹屾暣閾舵渤
        stages.push({
          delay: 3.0,
          shape: Shape3DType.GALAXY_SPIRAL,
          scale: 1.5,
          particleCount: 1,
          hueShift: 260
        });
        break;
        
      case ComboType.SUPERNOVA_COLLAPSE:
        // 鐖嗗彂
        stages.push({
          delay: 0,
          shape: Shape3DType.SUPERNOVA,
          scale: 1.5,
          particleCount: 1.2,
          hueShift: 30
        });
        // 鎵╂暎
        stages.push({
          delay: 0.8,
          shape: Shape3DType.SHOCKWAVE,
          scale: 2,
          particleCount: 0.5,
          hueShift: 200
        });
        // 濉岀缉鎴愮偣
        stages.push({
          delay: 2.0,
          shape: Shape3DType.BLACK_HOLE,
          scale: 0.3,
          particleCount: 0.3,
          hueShift: 270,
          velocityScale: -0.5 // 鍚戝唴
        });
        break;
        
      case ComboType.FIREWORK_SYMPHONY:
        const symphonyShapes = [
          Shape3DType.SPHERE,
          Shape3DType.RING_WAVE,
          Shape3DType.HEART_3D,
          Shape3DType.STAR_3D,
          Shape3DType.FLOWER_3D,
          Shape3DType.EXPLOSION_BURST
        ];
        for (let i = 0; i < symphonyShapes.length; i++) {
          stages.push({
            delay: i * 0.6,
            shape: symphonyShapes[i],
            scale: 0.7 + Math.random() * 0.4,
            particleCount: 0.5,
            hueShift: (i / symphonyShapes.length) * 360
          });
        }
        trajectory = TrajectoryType.SPIRAL;
        break;
        
      default:
        stages.push({
          delay: 0,
          shape: baseShape,
          scale: 1,
          particleCount: 1,
          hueShift: 0
        });
    }
    
    return { type, trajectory, stages };
  }
}

/**
 * 缁勫悎鎶€绠＄悊鍣?
 */
export class ComboManager {
  private static allTypes: ComboType[] = Object.values(ComboType);
  
  /**
   * 鑾峰彇鎵€鏈夌粍鍚堟妧绫诲瀷
   */
  static getAllTypes(): ComboType[] {
    return [...this.allTypes];
  }
  
  /**
   * 闅忔満鑾峰彇涓€涓粍鍚堟妧绫诲瀷
   */
  static getRandomType(): ComboType {
    return this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
  }
  
  /**
   * 鑾峰彇缁勫悎鎶€淇℃伅
   */
  static getInfo(type: ComboType): ComboInfo {
    return COMBO_INFO[type];
  }
  
  /**
   * 鐢熸垚缁勫悎鎶€閰嶇疆
   */
  static generateConfig(type: ComboType, baseShape?: Shape3DType): ComboConfig {
    return ComboGenerator.generate(type, baseShape);
  }
  
  /**
   * 鑾峰彇绠€鍗曠粍鍚堟妧锛堥€傚悎鑷姩鍙戝皠锛?
   */
  static getSimpleTypes(): ComboType[] {
    return [
      ComboType.SINGLE,
      ComboType.STAGED,
      ComboType.MULTI_WAVE,
      ComboType.SPLIT
    ];
  }
  
  /**
   * 鑾峰彇楂樼骇缁勫悎鎶€锛堥€傚悎鎵嬪姩瑙﹀彂锛?
   */
  static getAdvancedTypes(): ComboType[] {
    return [
      ComboType.PHOENIX_RISE,
      ComboType.GALAXY_BIRTH,
      ComboType.SUPERNOVA_COLLAPSE,
      ComboType.FIREWORK_SYMPHONY
    ];
  }
}

// END OF FILE: src/core/combos/ComboManager.ts


====== FILE: D:\ALL IN AI\Aetheris\src\core\shapes\Shape3DFactory.ts ======
// FILE: src/core/shapes/Shape3DFactory.ts
// 鐪?D褰㈢姸宸ュ巶锛氬畾涔?0+绉嶇湡姝ｇ殑涓夌淮褰㈢姸

import { Vector3 } from '../Vector3';

/**
 * 3D褰㈢姸绫诲瀷鏋氫妇
 * 鍒嗙被锛氬熀纭€鍑犱綍銆佽嚜鐒剁敓鐗┿€佹娊璞¤壓鏈€佸畤瀹欏ぉ浣撱€佹枃鍖栫鍙枫€佺壒鏁堢被
 */
export enum Shape3DType {
  // === 鍩虹鍑犱綍 (10绉? ===
  SPHERE = 'sphere',
  CUBE = 'cube',
  PYRAMID = 'pyramid',
  OCTAHEDRON = 'octahedron',
  DODECAHEDRON = 'dodecahedron',
  ICOSAHEDRON = 'icosahedron',
  CYLINDER = 'cylinder',
  CONE = 'cone',
  TORUS = 'torus',
  TORUS_KNOT = 'torus_knot',
  
  // === 楂樼骇鍑犱綍 (10绉? ===
  CAPSULE = 'capsule',
  PRISM = 'prism',
  STAR_3D = 'star_3d',
  CROSS_3D = 'cross_3d',
  DIAMOND = 'diamond',
  MOBIUS = 'mobius',
  KLEIN_BOTTLE = 'klein_bottle',
  HELIX_TUBE = 'helix_tube',
  SPRING = 'spring',
  NESTED_SPHERES = 'nested_spheres',
  
  // === 鑷劧鐢熺墿 (10绉? ===
  BUTTERFLY_3D = 'butterfly_3d',
  FLOWER_3D = 'flower_3d',
  TREE = 'tree',
  FISH_3D = 'fish_3d',
  BIRD = 'bird',
  JELLYFISH = 'jellyfish',
  SHELL = 'shell',
  SNOWFLAKE_3D = 'snowflake_3d',
  LEAF = 'leaf',
  MUSHROOM = 'mushroom',
  
  // === 瀹囧畽澶╀綋 (10绉? ===
  GALAXY_SPIRAL = 'galaxy_spiral',
  PLANET_RINGS = 'planet_rings',
  NEBULA = 'nebula',
  BLACK_HOLE = 'black_hole',
  SUPERNOVA = 'supernova',
  COMET = 'comet',
  ASTEROID_BELT = 'asteroid_belt',
  CONSTELLATION = 'constellation',
  PULSAR = 'pulsar',
  WORMHOLE = 'wormhole',
  
  // === 鏂囧寲绗﹀彿 (10绉? ===
  HEART_3D = 'heart_3d',
  CROWN_3D = 'crown_3d',
  DRAGON_3D = 'dragon_3d',
  PHOENIX = 'phoenix',
  YIN_YANG = 'yin_yang',
  LOTUS = 'lotus',
  LANTERN = 'lantern',
  FIREWORK_CLASSIC = 'firework_classic',
  RIBBON = 'ribbon',
  FIREWORK_WILLOW = 'firework_willow',
  
  // === 鐗规晥绫?(10绉? ===
  EXPLOSION_BURST = 'explosion_burst',
  RING_WAVE = 'ring_wave',
  DOUBLE_RING = 'double_ring',
  CASCADE = 'cascade',
  WATERFALL_3D = 'waterfall_3d',
  FOUNTAIN = 'fountain',
  VORTEX = 'vortex',
  SHOCKWAVE = 'shockwave',
  SPARKLE_CLOUD = 'sparkle_cloud',
  CHAOS_SCATTER = 'chaos_scatter',
}

/**
 * 褰㈢姸淇℃伅
 */
export interface Shape3DInfo {
  name: string;
  icon: string;
  category: string;
  description: string;
}

/**
 * 褰㈢姸鍒嗙被
 */
export const SHAPE_CATEGORIES = {
  BASIC_GEOMETRY: '鍩虹鍑犱綍',
  ADVANCED_GEOMETRY: '楂樼骇鍑犱綍',
  NATURE: '鑷劧鐢熺墿',
  COSMOS: '瀹囧畽澶╀綋',
  CULTURE: '鏂囧寲绗﹀彿',
  EFFECTS: '鐗规晥绫?,
};

/**
 * 褰㈢姸淇℃伅鏄犲皠
 */
export const SHAPE_3D_INFO: Record<Shape3DType, Shape3DInfo> = {
  // 鍩虹鍑犱綍
  [Shape3DType.SPHERE]: { name: '鏍囧噯鐞冨舰', icon: '馃敭', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '瀹岀編鐨勭悆褰㈢垎鐐? },
  [Shape3DType.CUBE]: { name: '閲忓瓙绔嬫柟', icon: '馃', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鍏潰浣撶粨鏋? },
  [Shape3DType.PYRAMID]: { name: '閲戝瓧濉?, icon: '馃敽', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鍥涢潰浣撻噾瀛楀' },
  [Shape3DType.OCTAHEDRON]: { name: '鍏潰浣?, icon: '馃拵', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鍏釜涓夎闈? },
  [Shape3DType.DODECAHEDRON]: { name: '鍗佷簩闈綋', icon: '猬?, category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鍗佷簩涓簲杈瑰舰闈? },
  [Shape3DType.ICOSAHEDRON]: { name: '浜屽崄闈綋', icon: '馃幉', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '浜屽崄涓笁瑙掗潰' },
  [Shape3DType.CYLINDER]: { name: '鍦嗘煴浣?, icon: '馃洟锔?, category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鍦嗘煴褰㈢姸' },
  [Shape3DType.CONE]: { name: '鍦嗛敟浣?, icon: '馃搻', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '閿ュ舰缁撴瀯' },
  [Shape3DType.TORUS]: { name: '鍦嗙幆浣?, icon: '猸?, category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鐢滅敎鍦堝舰鐘? },
  [Shape3DType.TORUS_KNOT]: { name: '鐜舰缁?, icon: '馃敆', category: SHAPE_CATEGORIES.BASIC_GEOMETRY, description: '鎵洸鐨勭幆褰? },
  
  // 楂樼骇鍑犱綍
  [Shape3DType.CAPSULE]: { name: '鑳跺泭浣?, icon: '馃拪', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '涓ょ鍦嗘鼎鐨勬煴浣? },
  [Shape3DType.PRISM]: { name: '妫遍暅', icon: '馃敺', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '涓夎妫遍暅' },
  [Shape3DType.STAR_3D]: { name: '3D鏄熷舰', icon: '猸?, category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '绔嬩綋浜旇鏄? },
  [Shape3DType.CROSS_3D]: { name: '3D鍗佸瓧', icon: '鉁濓笍', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '绔嬩綋鍗佸瓧鏋? },
  [Shape3DType.DIAMOND]: { name: '閽荤煶', icon: '馃挔', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '闂€€閽荤煶' },
  [Shape3DType.MOBIUS]: { name: '鑾瘮涔屾柉甯?, icon: '鈾撅笍', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '鏃犻檺寰幆' },
  [Shape3DType.KLEIN_BOTTLE]: { name: '鍏嬭幈鍥犵摱', icon: '馃嵕', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '鎷撴墤瀛﹀杩? },
  [Shape3DType.HELIX_TUBE]: { name: 'DNA鍙岃灪鏃?, icon: '馃К', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '鐢熷懡瀵嗙爜' },
  [Shape3DType.SPRING]: { name: '寮圭哀', icon: '馃攧', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '铻烘棆寮圭哀' },
  [Shape3DType.NESTED_SPHERES]: { name: '鍚屽績鐞?, icon: '馃幆', category: SHAPE_CATEGORIES.ADVANCED_GEOMETRY, description: '灞傚眰宓屽' },
  
  // 鑷劧鐢熺墿
  [Shape3DType.BUTTERFLY_3D]: { name: '骞诲僵铦磋澏', icon: '馃', category: SHAPE_CATEGORIES.NATURE, description: '缈╃咯璧疯垶' },
  [Shape3DType.FLOWER_3D]: { name: '鐩涗笘鐗′腹', icon: '馃尯', category: SHAPE_CATEGORIES.NATURE, description: '灞傚眰鑺辩摚' },
  [Shape3DType.TREE]: { name: '鐢熷懡涔嬫爲', icon: '馃尦', category: SHAPE_CATEGORIES.NATURE, description: '鏋濈箒鍙惰寕' },
  [Shape3DType.FISH_3D]: { name: '閿﹂菠娓稿姩', icon: '馃悷', category: SHAPE_CATEGORIES.NATURE, description: '骞村勾鏈変綑' },
  [Shape3DType.BIRD]: { name: '椋為笩', icon: '馃晩锔?, category: SHAPE_CATEGORIES.NATURE, description: '灞曠繀楂橀' },
  [Shape3DType.JELLYFISH]: { name: '姘存瘝', icon: '馃', category: SHAPE_CATEGORIES.NATURE, description: '椋橀€哥伒鍔? },
  [Shape3DType.SHELL]: { name: '娴疯灪', icon: '馃悮', category: SHAPE_CATEGORIES.NATURE, description: '铻烘棆璐濆３' },
  [Shape3DType.SNOWFLAKE_3D]: { name: '鍏闆姳', icon: '鉂勶笍', category: SHAPE_CATEGORIES.NATURE, description: '鍐版櫠缁芥斁' },
  [Shape3DType.LEAF]: { name: '钀藉彾', icon: '馃崅', category: SHAPE_CATEGORIES.NATURE, description: '绉嬮钀藉彾' },
  [Shape3DType.MUSHROOM]: { name: '铇戣弴', icon: '馃崉', category: SHAPE_CATEGORIES.NATURE, description: '绔ヨ瘽铇戣弴' },
  
  // 瀹囧畽澶╀綋
  [Shape3DType.GALAXY_SPIRAL]: { name: '閾舵渤绯?, icon: '馃寣', category: SHAPE_CATEGORIES.COSMOS, description: '鏃嬭噦閾舵渤' },
  [Shape3DType.PLANET_RINGS]: { name: '鍦熸槦鐜?, icon: '馃獝', category: SHAPE_CATEGORIES.COSMOS, description: '琛屾槦鍏夌幆' },
  [Shape3DType.NEBULA]: { name: '鏄熶簯', icon: '鈽侊笍', category: SHAPE_CATEGORIES.COSMOS, description: '缁氫附鏄熶簯' },
  [Shape3DType.BLACK_HOLE]: { name: '榛戞礊', icon: '馃暢锔?, category: SHAPE_CATEGORIES.COSMOS, description: '鏃剁┖婕╂丁' },
  [Shape3DType.SUPERNOVA]: { name: '瓒呮柊鏄?, icon: '馃挜', category: SHAPE_CATEGORIES.COSMOS, description: '鎭掓槦鐖嗗彂' },
  [Shape3DType.COMET]: { name: '褰楁槦', icon: '鈽勶笍', category: SHAPE_CATEGORIES.COSMOS, description: '鎷栧熬褰楁槦' },
  [Shape3DType.ASTEROID_BELT]: { name: '灏忚鏄熷甫', icon: '馃寫', category: SHAPE_CATEGORIES.COSMOS, description: '宀╃煶鐜甫' },
  [Shape3DType.CONSTELLATION]: { name: '鏄熷骇', icon: '鉁?, category: SHAPE_CATEGORIES.COSMOS, description: '鏄熷骇杩炵嚎' },
  [Shape3DType.PULSAR]: { name: '鑴夊啿鏄?, icon: '馃摗', category: SHAPE_CATEGORIES.COSMOS, description: '灏勭數鑴夊啿' },
  [Shape3DType.WORMHOLE]: { name: '铏礊', icon: '馃寑', category: SHAPE_CATEGORIES.COSMOS, description: '鏃剁┖闅ч亾' },
  
  // 鏂囧寲绗﹀彿
  [Shape3DType.HEART_3D]: { name: '璺冲姩涔嬪績', icon: '鉂わ笍', category: SHAPE_CATEGORIES.CULTURE, description: '绔嬩綋鐖卞績' },
  [Shape3DType.CROWN_3D]: { name: '鐨囧啝', icon: '馃憫', category: SHAPE_CATEGORIES.CULTURE, description: '鐜嬭€呬箣鍐? },
  [Shape3DType.DRAGON_3D]: { name: '娓搁緳鎴忕彔', icon: '馃悏', category: SHAPE_CATEGORIES.CULTURE, description: '涓滄柟绁為緳' },
  [Shape3DType.PHOENIX]: { name: '鍑ゅ嚢娑呮', icon: '馃敟', category: SHAPE_CATEGORIES.CULTURE, description: '娴寸伀閲嶇敓' },
  [Shape3DType.YIN_YANG]: { name: '澶瀬', icon: '鈽笍', category: SHAPE_CATEGORIES.CULTURE, description: '闃撮槼璋冨拰' },
  [Shape3DType.LOTUS]: { name: '鑾茶姳', icon: '馃', category: SHAPE_CATEGORIES.CULTURE, description: '鍑烘筏娉ヨ€屼笉鏌? },
  [Shape3DType.LANTERN]: { name: '鐏', icon: '馃彯', category: SHAPE_CATEGORIES.CULTURE, description: '鍠滃簡鐏' },
  [Shape3DType.FIREWORK_CLASSIC]: { name: '缁忓吀鐑熻姳', icon: '馃巻', category: SHAPE_CATEGORIES.CULTURE, description: '浼犵粺鐖嗙偢' },
  [Shape3DType.RIBBON]: { name: '褰╁甫', icon: '馃巰', category: SHAPE_CATEGORIES.CULTURE, description: '椋橀€稿僵甯? },
  [Shape3DType.FIREWORK_WILLOW]: { name: '閲戞煶鍨備笣', icon: '馃帇', category: SHAPE_CATEGORIES.CULTURE, description: '鍨傝惤涓濈嚎' },
  
  // 鐗规晥绫?
  [Shape3DType.EXPLOSION_BURST]: { name: '楂樹寒鐖嗗彂', icon: '馃挮', category: SHAPE_CATEGORIES.EFFECTS, description: '鑰€鐪奸棯鍏? },
  [Shape3DType.RING_WAVE]: { name: '鐜舰娉?, icon: '鈼?, category: SHAPE_CATEGORIES.EFFECTS, description: '鎵╂暎鍏夌幆' },
  [Shape3DType.DOUBLE_RING]: { name: '鍙屽眰鐜?, icon: '鈯?, category: SHAPE_CATEGORIES.EFFECTS, description: '鍐呭鍙岀幆' },
  [Shape3DType.CASCADE]: { name: '闃舵鐎戝竷', icon: '馃寠', category: SHAPE_CATEGORIES.EFFECTS, description: '灞傚彔涓嬭惤' },
  [Shape3DType.WATERFALL_3D]: { name: '涔濆ぉ鐎戝竷', icon: '馃挧', category: SHAPE_CATEGORIES.EFFECTS, description: '椋炴祦鐩翠笅' },
  [Shape3DType.FOUNTAIN]: { name: '鍠锋硥', icon: '鉀?, category: SHAPE_CATEGORIES.EFFECTS, description: '鍚戜笂鍠锋秾' },
  [Shape3DType.VORTEX]: { name: '婕╂丁', icon: '馃尓锔?, category: SHAPE_CATEGORIES.EFFECTS, description: '蹇€熸棆杞? },
  [Shape3DType.SHOCKWAVE]: { name: '鍐插嚮娉?, icon: '銆?, category: SHAPE_CATEGORIES.EFFECTS, description: '闇囪崱鎵╂暎' },
  [Shape3DType.SPARKLE_CLOUD]: { name: '闂儊浜?, icon: '鉁?, category: SHAPE_CATEGORIES.EFFECTS, description: '闅忔満闂儊' },
  [Shape3DType.CHAOS_SCATTER]: { name: '娣锋矊鏁ｅ皠', icon: '馃幉', category: SHAPE_CATEGORIES.EFFECTS, description: '闅忔満鍥涙暎' },
};

/**
 * 3D鐐圭敓鎴愮粨鏋?
 */
export interface Shape3DPoint {
  position: Vector3;
  hue: number;
  size?: number;
  behavior?: string;
  decay?: number;
  friction?: number;
}

/**
 * 3D褰㈢姸鐢熸垚鍣?
 * 鐢熸垚鐪熸鐨?D鐐瑰垎甯?
 */
export class Shape3DGenerator {
  /**
   * 鐢熸垚褰㈢姸鐨勭偣鍒嗗竷
   * @param type 褰㈢姸绫诲瀷
   * @param count 鐐规暟閲?
   * @param scale 缂╂斁姣斾緥
   * @param baseHue 鍩虹鑹茬浉
   * @returns 鐐规暟缁?
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale: number = 1,
    baseHue: number = 0
  ): Shape3DPoint[] {
    const points: Shape3DPoint[] = [];
    const s = scale;
    
    switch (type) {
      // === 鍩虹鍑犱綍 ===
      case Shape3DType.SPHERE:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 30 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue + (i / count) * 60
          });
        }
        break;
        
      case Shape3DType.CUBE: {
        const side = 25 * s;
        // 鍒嗛厤鐐癸細杈圭紭绾?40%锛岄潰 60%
        const edgeCount = Math.floor(count * 0.4);
        const faceCount = count - edgeCount;

        // 1. 寮哄寲杈圭紭绾?(12鏉¤竟)
        for (let i = 0; i < edgeCount; i++) {
          const edge = Math.floor(Math.random() * 12);
          const t = Math.random() * 2 - 1;
          let p: Vector3;
          switch(edge) {
            case 0: p = new Vector3(side, side, t * side); break;
            case 1: p = new Vector3(side, -side, t * side); break;
            case 2: p = new Vector3(-side, side, t * side); break;
            case 3: p = new Vector3(-side, -side, t * side); break;
            case 4: p = new Vector3(side, t * side, side); break;
            case 5: p = new Vector3(side, t * side, -side); break;
            case 6: p = new Vector3(-side, t * side, side); break;
            case 7: p = new Vector3(-side, t * side, -side); break;
            case 8: p = new Vector3(t * side, side, side); break;
            case 9: p = new Vector3(t * side, side, -side); break;
            case 10: p = new Vector3(t * side, -side, side); break;
            default: p = new Vector3(t * side, -side, -side);
          }
          points.push({ position: p, hue: baseHue + (t + 1) * 30, size: 4 });
        }

        // 2. 濉厖闈?(6涓潰)
        for (let i = 0; i < faceCount; i++) {
          const face = Math.floor(Math.random() * 6);
          const u = Math.random() * 2 - 1;
          const v = Math.random() * 2 - 1;
          let p: Vector3;
          switch(face) {
            case 0: p = new Vector3(side, u * side, v * side); break;
            case 1: p = new Vector3(-side, u * side, v * side); break;
            case 2: p = new Vector3(u * side, side, v * side); break;
            case 3: p = new Vector3(u * side, -side, v * side); break;
            case 4: p = new Vector3(u * side, v * side, side); break;
            default: p = new Vector3(u * side, v * side, -side);
          }
          // 澧炲姞鑹插僵娣卞害鍜屽彂鍏夋劅
          points.push({ 
            position: p, 
            hue: baseHue + (u + v + 2) * 20,
            size: 3,
            decay: 0.008 // 姝ｆ柟褰㈠瓨鐣欐椂闂寸◢闀?
          });
        }
        break;
      }

      case Shape3DType.PYRAMID: {
        const h = 40 * s;
        const side = 30 * s;
        // 5涓潰锛?涓簳闈?姝ｆ柟褰?锛?涓晶闈?涓夎褰?
        for (let i = 0; i < count; i++) {
          const part = Math.floor(Math.random() * 5);
          let u = Math.random();
          let v = Math.random();
          let p: Vector3;

          if (part === 0) { // 搴曢潰
            p = new Vector3((u - 0.5) * 2 * side, 0, (v - 0.5) * 2 * side);
          } else { // 渚ч潰
            if (u + v > 1) { u = 1 - u; v = 1 - v; } // 淇濇寔鍦ㄤ笁瑙掑舰鍐?
            const tip = new Vector3(0, h, 0);
            const corners = [
              new Vector3(side, 0, side), new Vector3(-side, 0, side),
              new Vector3(-side, 0, -side), new Vector3(side, 0, -side)
            ];
            const c1 = corners[part - 1];
            const c2 = corners[part % 4];
            p = tip.clone().multiplyScalar(1 - u - v).add(c1.clone().multiplyScalar(u)).add(c2.clone().multiplyScalar(v));
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 60 });
        }
        break;
      }
        
      case Shape3DType.OCTAHEDRON: {
        const r = 35 * s;
        // 8涓潰 (鍏ㄧ瓑涓夎褰?
        for (let i = 0; i < count; i++) {
          const face = Math.floor(Math.random() * 8);
          // 椤剁偣锛?卤r, 0, 0), (0, 卤r, 0), (0, 0, 卤r)
          const vertices = [
            new Vector3(r, 0, 0), new Vector3(-r, 0, 0),
            new Vector3(0, r, 0), new Vector3(0, -r, 0),
            new Vector3(0, 0, r), new Vector3(0, 0, -r)
          ];
          // 瀹氫箟8涓潰鐨勯《鐐圭粍鍚?
          const faceMap = [
            [0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5],
            [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5]
          ];
          const [v1, v2, v3] = faceMap[face].map(idx => vertices[idx]);
          let u = Math.random(), v = Math.random();
          if (u + v > 1) { u = 1 - u; v = 1 - v; }
          const p = v1.clone().multiplyScalar(1 - u - v).add(v2.clone().multiplyScalar(u)).add(v3.clone().multiplyScalar(v));
          points.push({ position: p, hue: baseHue + (p.y / r) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.DODECAHEDRON: {
        const r = 30 * s;
        const phi = (1 + Math.sqrt(5)) / 2;
        // 椤剁偣瀹氫箟 (20瀵?
        const v = [
          [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
          [0, 1/phi, phi], [0, 1/phi, -phi], [0, -1/phi, phi], [0, -1/phi, -phi],
          [1/phi, phi, 0], [1/phi, -phi, 0], [-1/phi, phi, 0], [-1/phi, -phi, 0],
          [phi, 0, 1/phi], [phi, 0, -1/phi], [-phi, 0, 1/phi], [-phi, 0, -1/phi]
        ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));

        for (let i = 0; i < count; i++) {
          const vIdx = Math.floor(Math.random() * v.length);
          const p = v[vIdx].clone();
          // 鍦ㄩ《鐐瑰強鍏朵复杩戝尯鍩熼噰鏍?
          const jitter = (Math.random() - 0.5) * 5 * s;
          p.x += jitter; p.y += jitter; p.z += jitter;
          points.push({ position: p, hue: baseHue + (p.length() / r) * 100, size: 4 });
        }
        break;
      }
      
      case Shape3DType.ICOSAHEDRON: {
        const t = (1 + Math.sqrt(5)) / 2;
        const r = 35 * s;
        // 20涓潰锛岄噰鏍风偣鍒嗗竷鍦ㄩ潰涓?
        for (let i = 0; i < count; i++) {
          const vertices = [
            [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
            [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
            [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
          ].map(p => new Vector3(p[0], p[1], p[2]).normalize().multiplyScalar(r));
          
          const faceIdx = Math.floor(Math.random() * 20);
          // 杩欓噷鏈簲瀹氫箟20涓潰锛岀畝鍖栦负鍦ㄧ悆闈笂鍩轰簬澶у渾姝ヨ繘
          const angle = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          // 澧炲姞 icos 鐙湁鐨勨€滃嚑浣曟姈鍔ㄢ€濓紝浣垮叾鏄惧緱妫辫纭湕
          const p = new Vector3(Math.sin(phi)*Math.cos(angle)*r, Math.sin(phi)*Math.sin(angle)*r, Math.cos(phi)*r);
          p.x=Math.round(p.x/5)*5; p.y=Math.round(p.y/5)*5; p.z=Math.round(p.z/5)*5;
          points.push({ position: p, hue: baseHue + 200, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CYLINDER: {
        const h = 60 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.2) { // 椤剁洊
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, h/2, Math.sin(angle) * dist);
          } else if (part < 0.4) { // 搴曠洊
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, -h/2, Math.sin(angle) * dist);
          } else { // 渚у
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * h;
            p = new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
          }
          points.push({ position: p, hue: baseHue + (p.y / h + 0.5) * 60, size: 3 });
        }
        break;
      }
      
      case Shape3DType.CONE: {
        const h = 60 * s;
        const r = 30 * s;
        for (let i = 0; i < count; i++) {
          const part = Math.random();
          let p: Vector3;
          if (part < 0.3) { // 搴曞骇
            const dist = Math.sqrt(Math.random()) * r;
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
          } else { // 閿ラ潰
            const y = Math.random() * h;
            const currentR = r * (1 - y / h);
            const angle = Math.random() * Math.PI * 2;
            p = new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 + (p.x/r)*20, size: 3 });
        }
        break;
      }
      
      case Shape3DType.TORUS: {
        const R = 30 * s; 
        const r = 10 * s;
        // 鍦嗙幆涓夊眰閲囨牱锛氬唴鍦堛€佸鍦堛€佺澹侀潰
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // 澧炲姞鑹插僵娓愬彉瀵瑰懆闀跨殑渚濊禆
          const hueOffset = (theta / (Math.PI * 2)) * 60;
          points.push({
            position: new Vector3(
              (R + r * Math.cos(phi)) * Math.cos(theta),
              r * Math.sin(phi),
              (R + r * Math.cos(phi)) * Math.sin(theta)
            ),
            hue: (baseHue + hueOffset) % 360,
            size: 4
          });
        }
        break;
      }
      
      case Shape3DType.TORUS_KNOT: {
        const R = 20 * s;
        const r = 6 * s;
        const p = 2, q = 3;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2 * 3;
          const x = (R + r * Math.cos(q * t)) * Math.cos(p * t);
          const y = r * Math.sin(q * t);
          const z = (R + r * Math.cos(q * t)) * Math.sin(p * t);
          points.push({ position: new Vector3(x, y, z), hue: baseHue + (i / count) * 360 });
        }
        break;
      }
      
      // === 楂樼骇鍑犱綍 ===
      case Shape3DType.CAPSULE: {
        const h = 40 * s;
        const r = 15 * s;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const v = Math.random();
          let y: number, currentR: number;
          if (v < 0.3) { // 搴曢儴鍗婄悆
            const phi = Math.PI / 2 + Math.random() * Math.PI / 2;
            y = -h / 2 + r * Math.cos(phi - Math.PI / 2);
            currentR = r * Math.sin(phi);
          } else if (v > 0.7) { // 椤堕儴鍗婄悆
            const phi = Math.random() * Math.PI / 2;
            y = h / 2 + r * Math.sin(phi);
            currentR = r * Math.cos(phi);
          } else { // 涓棿鍦嗘煴
            y = (v - 0.5) * h;
            currentR = r;
          }
          points.push({
            position: new Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR),
            hue: baseHue + (y / h + 0.5) * 60
          });
        }
        break;
      }
      
      case Shape3DType.STAR_3D: {
        const outerR = 30 * s;
        const innerR = 12 * s;
        const pts = 5;
        const depth = 5 * s; // 澧炲姞 3D 鍘氬害
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const angle = t * Math.PI * 2;
          const isOuter = Math.floor(t * pts * 2) % 2 === 0;
          const r = isOuter ? outerR : innerR;
          const z = (Math.random() - 0.5) * depth;
          points.push({
            position: new Vector3(Math.cos(angle) * r, Math.sin(angle) * r, z),
            hue: baseHue + (isOuter ? 0 : 40),
            size: isOuter ? 8 : 4
          });
        }
        break;
      }
      
      case Shape3DType.PRISM: {
        const h = 50 * s;
        const r = 25 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const part = Math.floor(Math.random() * 5); // 2涓簳闈紝3涓晶闈?
          let p: Vector3;
          if (part < 2) { // 搴曢潰 (涓夎褰?
             let u = Math.random(), v = Math.random();
             if (u + v > 1) { u = 1 - u; v = 1 - v; }
             const y = part === 0 ? h / 2 : -h / 2;
             // 姝ｄ笁瑙掑舰鍧愭爣
             const v1 = new Vector3(0, y, r);
             const v2 = new Vector3(r * 0.866, y, -r * 0.5);
             const v3 = new Vector3(-r * 0.866, y, -r * 0.5);
             p = v1.multiplyScalar(1 - u - v).add(v2.multiplyScalar(u)).add(v3.multiplyScalar(v));
          } else { // 渚ч潰
             const side = part - 2;
             const angle1 = (side / 3) * Math.PI * 2;
             const angle2 = ((side + 1) / 3) * Math.PI * 2;
             const u = Math.random();
             const y = (Math.random() - 0.5) * h;
             const x = Math.cos(angle1) * r * (1 - u) + Math.cos(angle2) * r * u;
             const z = Math.sin(angle1) * r * (1 - u) + Math.sin(angle2) * r * u;
             p = new Vector3(x, y, z);
          }
          points.push({ position: p, hue: baseHue + (p.y / h) * 40 });
        }
        break;
      }

      case Shape3DType.CROSS_3D: {
        const len = 40 * s;
        const thick = 10 * s;
        for (let i = 0; i < count; i++) {
          const axis = Math.floor(Math.random() * 3);
          const t = (Math.random() - 0.5) * 2 * len;
          const u = (Math.random() - 0.5) * thick;
          const v = (Math.random() - 0.5) * thick;
          let p: Vector3;
          if (axis === 0) p = new Vector3(t, u, v);
          else if (axis === 1) p = new Vector3(u, t, v);
          else p = new Vector3(u, v, t);
          points.push({ position: p, hue: baseHue + (t / len) * 50 });
        }
        break;
      }

      case Shape3DType.DIAMOND: {
        const r = 35 * s;
        const h = 40 * s;
        for (let i = 0; i < count; i++) {
          const v = Math.random();
          const angle = Math.random() * Math.PI * 2;
          let y: number, curR: number;
          if (v < 0.4) { // 涓婇儴鍙伴潰鍙婃枩闈?
             y = (1 - v / 0.4) * h * 0.4;
             curR = r * (0.6 + (v / 0.4) * 0.4);
          } else { // 涓嬮儴灏栬
             y = -(v - 0.4) / 0.6 * h * 1.5;
             curR = r * (1 - (v - 0.4) / 0.6);
          }
          // 瀵?angle 杩涜 stepped 澶勭悊妯℃嫙鍒囬潰鎰?
          const stepAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
          points.push({ position: new Vector3(Math.cos(stepAngle)*curR, y, Math.sin(stepAngle)*curR), hue: 200, size: 2 });
        }
        break;
      }

      case Shape3DType.MOBIUS: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const u = (i / count) * Math.PI * 2;
          const v = (Math.random() - 0.5) * 15 * s;
          const x = (R + v * Math.cos(u/2)) * Math.cos(u);
          const y = (R + v * Math.cos(u/2)) * Math.sin(u);
          const z = v * Math.sin(u/2);
          points.push({ position: new Vector3(x, z, y), hue: baseHue + (u/Math.PI)*60 });
        }
        break;
      }

      case Shape3DType.KLEIN_BOTTLE: {
        for (let i = 0; i < count; i++) {
          const u = Math.random() * Math.PI;
          const v = Math.random() * Math.PI * 2;
          const x = -2/15 * Math.cos(u) * (3*Math.cos(v) - 30*Math.sin(u) + 90*Math.pow(Math.cos(u),4)*Math.sin(u) - 60*Math.pow(Math.cos(u),6)*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u));
          const y = -1/15 * Math.sin(u) * (3*Math.cos(v) - 3*Math.pow(Math.cos(u),2)*Math.cos(v) - 48*Math.pow(Math.cos(u),4)*Math.cos(v) + 48*Math.pow(Math.cos(u),6)*Math.cos(v) - 60*Math.sin(u) + 5*Math.cos(u)*Math.cos(v)*Math.sin(u) - 5*Math.pow(Math.cos(u),3)*Math.cos(v)*Math.sin(u) - 80*Math.pow(Math.cos(u),5)*Math.cos(v)*Math.sin(u) + 80*Math.pow(Math.cos(u),7)*Math.cos(v)*Math.sin(u));
          const z = 2/15 * (3 + 5*Math.cos(u)*Math.sin(u)) * Math.sin(v);
          points.push({ position: new Vector3(x*15*s, y*15*s, z*15*s), hue: 280 + (u/Math.PI)*80 });
        }
        break;
      }

      case Shape3DType.SPRING: {
        const r = 15 * s;
        const R = 30 * s;
        const turns = 5;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const angle = t * Math.PI * 2 * turns;
          const y = (t - 0.5) * 80 * s;
          const x = Math.cos(angle) * R + (Math.random()-0.5)*5*s;
          const z = Math.sin(angle) * R + (Math.random()-0.5)*5*s;
          points.push({ position: new Vector3(x, y, z), hue: baseHue + t * 360 });
        }
        break;
      }

      case Shape3DType.HELIX_TUBE: {
        const h = 80 * s;
        const r = 20 * s;
        const turns = 3;
        for (let i = 0; i < count; i++) {
          const t = i / count;
          const y = (t - 0.5) * h;
          const angle = t * Math.PI * 2 * turns;
          // 鍙岃灪鏃?
          points.push({
            position: new Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle + Math.PI) * r, y, Math.sin(angle + Math.PI) * r),
            hue: (baseHue + 180) % 360
          });
        }
        break;
      }
      
      case Shape3DType.NESTED_SPHERES: {
        const layers = 3;
        for (let layer = 1; layer <= layers; layer++) {
          const r = (layer / layers) * 35 * s;
          const layerCount = Math.floor(count / layers);
          for (let i = 0; i < layerCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            points.push({
              position: new Vector3(
                Math.sin(phi) * Math.cos(theta) * r,
                Math.sin(phi) * Math.sin(theta) * r,
                Math.cos(phi) * r
              ),
              hue: baseHue + (layer - 1) * 60, // 姣忎竴灞備娇鐢ㄦ埅鐒朵笉鍚岀殑鑹茬浉
              size: 2 + (layers - layer) * 2 // 澶栧眰绮掑瓙鏇村皬鏇村瘑锛屽唴灞傛洿澶?
            });
          }
        }
        break;
      }
      
      // === 鑷劧鐢熺墿 ===
      case Shape3DType.BUTTERFLY_3D: {
        for (let i = 0; i < count; i++) {
          const t = (i / count) * Math.PI * 2;
          const h = (Math.random() - 0.5) * 2;
          // 3D 铦磋澏鏇查潰 (鍩轰簬鏋佸潗鏍囧彉鎹?
          const m = (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t/12), 5)) * 10 * s;
          const x = Math.sin(t) * m;
          const y = Math.cos(t) * m;
          // 缈呰唨寮€鍚?3D 鎰?
          const wingAngle = Math.abs(Math.sin(t)) * 0.5;
          const z = Math.abs(x) * wingAngle + (Math.random() - 0.5) * 5 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: baseHue + (Math.abs(x) / (20 * s)) * 200 // 缈呰唨杈圭紭鍙樿壊
          });
        }
        break;
      }
      
      case Shape3DType.FLOWER_3D: {
        const petals = 6;
        const layers = 3;
        for (let layer = 0; layer < layers; layer++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + layer * 8) * s;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const petalMod = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.3);
            const y = layer * 5 * s - 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta) * r * petalMod, y, Math.sin(theta) * r * petalMod),
              hue: baseHue + layer * 40
            });
          }
        }
        break;
      }
      
      case Shape3DType.HEART_3D: {
        // 鐪?3D 浣撶Н閲囨牱鐖卞績 - Taubin Surface 鍙樹綋
        for (let i = 0; i < count; i++) {
          const t = Math.random() * Math.PI * 2;
          const p = Math.acos(2 * Math.random() - 1);
          // 浣跨敤鍙傛暟鍖栫悆鍧愭爣骞惰繘琛屽績鑴忔槧灏勫彉鎹?
          const sinP = Math.sin(p), cosP = Math.cos(p), sinT = Math.sin(t), cosT = Math.cos(t);
          
          let x = 1.2 * sinP * sinT;
          let y = 1.2 * sinP * cosT;
          let z = cosP;
          
          // 缁欑悆浣撴柦鍔犫€滃績褰㈡媺浼糕€?
          // y 鍚戜笅鍑归櫡锛岄《閮ㄥ悜涓婇殕璧?
          y += Math.pow(Math.abs(x), 0.6) * 0.5;
          // 淇鍧愭爣浣垮叾灏栫鍚戜笅锛氬弽杞?y 鐨勬媺浼告柟鍚?
          const finalX = x * 25 * s;
          const finalY = y * 22 * s - 10 * s; // 淇鍚庣殑灏栫鍚戜笅閫昏緫
          const finalZ = z * 18 * s * Math.pow(Math.abs(sinT), 0.3); // 澧炲姞渚у悜楗辨弧搴?
          
          points.push({
            position: new Vector3(finalX, finalY, finalZ),
            hue: 340 + Math.random() * 40,
            size: 5 + Math.random() * 3,
            decay: 0.006 // 鐖卞績瀛樼暀鏇翠箙
          });
        }
        break;
      }
      
      case Shape3DType.SNOWFLAKE_3D: {
        const arms = 6;
        const r = 35 * s;
        for (let i = 0; i < count; i++) {
          const arm = Math.floor(Math.random() * arms);
          const t = Math.random();
          const angle = (arm / arms) * Math.PI * 2;
          // 涓昏酱
          let pX = Math.cos(angle) * t * r;
          let pY = (Math.random() - 0.5) * 2 * s; // 鎵佸钩 3D
          let pZ = Math.sin(angle) * t * r;
          // 鏀弶
          if (t > 0.4) {
             const subT = Math.random() * 0.3 * t;
             const subAngle = angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3;
             pX += Math.cos(subAngle) * subT * r;
             pZ += Math.sin(subAngle) * subT * r;
          }
          points.push({ position: new Vector3(pX, pY, pZ), hue: 180 + Math.random() * 40 });
        }
        break;
      }
      case Shape3DType.TREE: {
        const h = 50 * s;
        // 1. 鏍戝共 (20%)
        for (let i = 0; i < count * 0.2; i++) {
          const y = Math.random() * h * 0.4;
          points.push({ position: new Vector3((Math.random()-0.5)*2, y, (Math.random()-0.5)*2), hue: 30, size: 4 });
        }
        // 2. 鏍戝啝 (80%) - 澶氫釜鍒嗗眰鐞冧綋缁勬垚鐨勪簯鍥?
        for (let i = 0; i < count * 0.8; i++) {
          const layer = Math.floor(Math.random() * 3);
          const r = (15 + Math.random() * 10) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const center = new Vector3(0, h * 0.6 + layer * 10 * s, 0);
          points.push({
            position: new Vector3(
              center.x + Math.sin(phi) * Math.cos(theta) * r,
              center.y + Math.cos(phi) * r,
              center.z + Math.sin(phi) * Math.sin(theta) * r
            ),
            hue: 120 + Math.random() * 40 // 缁胯壊璋?
          });
        }
        break;
      }

      case Shape3DType.BIRD: 
      case Shape3DType.PHOENIX: {
        const isPhoenix = type === Shape3DType.PHOENIX;
        const wingSpan = 50 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count) * 2 - 1; // -1 to 1
          const x = t * wingSpan;
          // 缈煎睍寮у害: M 鍨?
          const y = Math.abs(t) * 10 * s + Math.sin(Math.abs(t) * Math.PI) * 15 * s;
          const z = Math.cos(t * Math.PI) * 10 * s;
          
          points.push({
            position: new Vector3(x, y, z),
            hue: isPhoenix ? 20 + Math.random() * 40 : baseHue,
            size: isPhoenix ? 6 : 4,
            behavior: isPhoenix ? 'fire' : undefined
          });

          // 鍑ゅ嚢灏剧窘
          if (isPhoenix && i % 5 === 0) {
            for(let j=1; j<5; j++) {
              points.push({
                position: new Vector3(x*0.2, -j*15*s, -j*5*s),
                hue: 10,
                behavior: 'willow'
              });
            }
          }
        }
        break;
      }

      case Shape3DType.JELLYFISH: {
        const r = 25 * s;
        // 1. 浼炵洊 (鍗婄悆)
        for (let i = 0; i < count * 0.5; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 0.5; // 鍙彇涓婂崐鐞?
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.cos(phi)*r, Math.sin(phi)*Math.sin(theta)*r),
            hue: baseHue + 200,
            behavior: 'glitter'
          });
        }
        // 2. 瑙﹂』 (鍨傜嚎)
        for (let i = 0; i < count * 0.5; i++) {
          const leg = Math.floor(Math.random() * 8);
          const angle = (leg / 8) * Math.PI * 2;
          const length = Math.random() * 40 * s;
          points.push({
            position: new Vector3(Math.cos(angle)*r*0.6, -length, Math.sin(angle)*r*0.6),
            hue: baseHue + 180,
            behavior: 'willow'
          });
        }
        break;
      }

      case Shape3DType.FISH_3D: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * len;
          // 楸艰韩: 妞悆
          const r = Math.sin(t * Math.PI) * 12 * s;
          const angle = Math.random() * Math.PI * 2;
          // 楸煎熬: 涓夎褰?(t鎺ヨ繎1鏃?
          let y = Math.cos(angle) * r;
          let z = Math.sin(angle) * r;
          if (t > 0.8) {
             const tailW = (t - 0.8) * 50 * s;
             y = (Math.random() - 0.5) * tailW;
          }
          points.push({ position: new Vector3(x, y, z), hue: 40 + t * 40 });
        }
        break;
      }

      case Shape3DType.SHELL: {
        for (let i = 0; i < count; i++) {
          const t = i / count * Math.PI * 8; // 4鍦?
          const r = 2 * Math.exp(0.1 * t) * s;
          const angle = t;
          const spiralX = r * Math.cos(angle);
          const spiralY = r * Math.sin(angle);
          const spiralZ = t * 2 * s;
          // 缁欒灪鏃嬬嚎鍔犵偣瀹藉害
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(spiralX + offset, spiralY, spiralZ), hue: 200 + (t/30)*100 });
        }
        break;
      }

      case Shape3DType.LEAF: {
        const len = 40 * s;
        for (let i = 0; i < count; i++) {
          const u = Math.random();
          const v = (Math.random() - 0.5) * 2;
          const x = u * len;
          // 鍙跺舰: sin鏇茬嚎
          const w = Math.sin(u * Math.PI) * 15 * s;
          const y = v * w;
          const z = Math.sin(u * Math.PI * 2) * 5 * s; // 鍗锋洸鎰?
          points.push({ position: new Vector3(x - len/2, y, z), hue: 100 + u * 60 });
        }
        break;
      }

      case Shape3DType.MUSHROOM: {
        const rCap = 30 * s;
        const hStem = 30 * s;
        for (let i = 0; i < count; i++) {
          if (i < count * 0.7) { // 鑿岀洊
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.4;
            points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*rCap, Math.cos(phi)*rCap*0.5 + hStem, Math.sin(phi)*Math.sin(theta)*rCap), hue: 0 });
          } else { // 鑿屾焺
            const y = Math.random() * hStem;
            const angle = Math.random() * Math.PI * 2;
            const rs = 8 * s;
            points.push({ position: new Vector3(Math.cos(angle)*rs, y, Math.sin(angle)*rs), hue: 40 });
          }
        }
        break;
      }

      // === 瀹囧畽澶╀綋 (琛ュ叏瀹炵幇) ===
      case Shape3DType.BLACK_HOLE: {
        // 1. 鍚哥Н鐩?(鎵佸钩鏃嬭浆)
        for (let i = 0; i < count * 0.8; i++) {
          const dist = (15 + Math.random() * 45) * s;
          const angle = Math.random() * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*2, Math.sin(angle)*dist),
            hue: 280 + (dist/60)*80,
            behavior: 'vortex'
          });
        }
        // 2. 瑙嗙晫 (鏍稿績榛戠彔)
        for (let i = 0; i < count * 0.2; i++) {
          const r = 10 * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: 0,
            size: 2
          });
        }
        break;
      }

      case Shape3DType.PULSAR: {
        const r = 15 * s;
        // 1. 鏍稿績
        for (let i = 0; i < count * 0.4; i++) {
           const theta = Math.random()*Math.PI*2;
           const phi = Math.acos(2*Math.random()-1);
           points.push({ position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r), hue: 200, behavior: 'glitter' });
        }
        // 2. 纾佹瀬鍠锋祦 (涓ょ楂樿兘鏌?
        for (let i = 0; i < count * 0.6; i++) {
           const side = Math.random() > 0.5 ? 1 : -1;
           const len = Math.random() * 80 * s;
           const spread = (len / (80*s)) * 5 * s;
           points.push({
             position: new Vector3((Math.random()-0.5)*spread, side * len, (Math.random()-0.5)*spread),
             hue: 240,
             behavior: 'glitter',
             size: 5
           });
        }
        break;
      }

      case Shape3DType.SUPERNOVA: {
        // 澶х垎鍙戯細鍐呯垎鐬棿鐨勫鎵?
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isRay = Math.random() > 0.7;
          const r = isRay ? (40 + Math.random() * 60) * s : (20 + Math.random() * 20) * s;
          
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*r, Math.sin(phi)*Math.sin(theta)*r, Math.cos(phi)*r),
            hue: isRay ? 0 : 40 + Math.random() * 40,
            size: isRay ? 8 : 4,
            behavior: isRay ? 'glitter' : 'fire'
          });
        }
        break;
      }

      case Shape3DType.ASTEROID_BELT: {
        const R = 40 * s;
        const r = 8 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 2;
          // 鍧楃姸閲囨牱
          const dist = R + (Math.random() - 0.5) * r * 2;
          points.push({
            position: new Vector3(Math.cos(theta)*dist, (Math.random()-0.5)*r, Math.sin(theta)*dist),
            hue: 30 + Math.random() * 20,
            size: Math.random() * 5 + 2,
            friction: 0.98
          });
        }
        break;
      }

      case Shape3DType.COMET: {
        const len = 100 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.pow(Math.random(), 2); // 灏鹃儴鏇寸█鐤?
          const dist = t * len;
          const spread = t * 20 * s;
          points.push({
            position: new Vector3((Math.random()-0.5)*spread, -dist, (Math.random()-0.5)*spread),
            hue: 180 + t * 60,
            behavior: 'willow',
            size: (1-t) * 8
          });
        }
        break;
      }

      // === 鏂囧寲绗﹀彿 (琛ュ叏瀹炵幇) ===
      case Shape3DType.LOTUS: {
        const layers = 4;
        for (let l = 0; l < layers; l++) {
          const layerCount = Math.floor(count / layers);
          const r = (10 + l * 10) * s;
          const petals = 8 + l * 4;
          for (let i = 0; i < layerCount; i++) {
            const theta = (i / layerCount) * Math.PI * 2;
            const phiLocal = (i / layerCount) * Math.PI * 2; // 灞€閮ㄥ彉閲忕敤浜庢ā鎷熻姳鐡ｅ紶寮€搴?
            const petalCurve = Math.pow(Math.abs(Math.cos(theta * petals / 2)), 0.5);
            const y = Math.sin(phiLocal * 0.5) * 10 * s + l * 5 * s;
            points.push({
              position: new Vector3(Math.cos(theta)*r*petalCurve, y, Math.sin(theta)*r*petalCurve),
              hue: 330 + l * 20
            });
          }
        }
        break;
      }

      case Shape3DType.CROWN_3D: {
        const R = 30 * s;
        for (let i = 0; i < count; i++) {
          const theta = (i / count) * Math.PI * 2;
          const isPoint = Math.floor(theta * 6 / Math.PI) % 2 === 0;
          const y = isPoint ? Math.sin(theta * 6) * 20 * s + 10 * s : 0;
          points.push({
            position: new Vector3(Math.cos(theta)*R, y, Math.sin(theta)*R),
            hue: 50,
            size: 6
          });
        }
        break;
      }

      case Shape3DType.YIN_YANG: {
        const R = 35 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * R;
          const x = Math.cos(theta) * r;
          const z = Math.sin(theta) * r;
          const isWhite = x > 0; // 绠€鍖栧疄鐜?
          points.push({ position: new Vector3(x, 0, z), hue: isWhite ? 0 : 200, size: isWhite ? 6 : 4 });
        }
        break;
      }

      case Shape3DType.GALAXY_SPIRAL: {
        const arms = 4;
        const armDensity = 0.8;
        for (let i = 0; i < count; i++) {
          const arm = i % arms;
          const dist = Math.pow(Math.random(), 0.7) * 60 * s;
          const angle = (arm / arms) * Math.PI * 2 + dist * 0.15;
          const scatter = (Math.random() - 0.5) * (60 * s / (dist + 5)) * 5;
          
          const p = new Vector3(
            Math.cos(angle) * dist + (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 8 * s * (1 - dist / (60 * s)),
            Math.sin(angle) * dist + (Math.random() - 0.5) * 5
          );
          
          points.push({
            position: p,
            hue: baseHue + (dist / (60 * s)) * 100,
            size: Math.random() > 0.8 ? 8 : 4,
            behavior: 'glitter'
          });
        }
        break;
      }
      
      case Shape3DType.PLANET_RINGS: {
        // 琛屾槦鏈綋
        for (let i = 0; i < count * 0.3; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 15 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: 30
          });
        }
        // 鍏夌幆
        for (let i = 0; i < count * 0.7; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 25 + Math.random() * 15;
          points.push({
            position: new Vector3(
              Math.cos(angle) * dist * s,
              Math.cos(angle) * dist * 0.3 * s,
              Math.sin(angle) * dist * s
            ),
            hue: 200
          });
        }
        break;
      }
      
      case Shape3DType.NEBULA: {
        for (let i = 0; i < count; i++) {
          const r = (20 + Math.random() * 30) * s;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const scatter = Math.pow(Math.random(), 2) * 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi)*Math.cos(theta)*r + (Math.random()-0.5)*scatter,
              Math.sin(phi)*Math.sin(theta)*r + (Math.random()-0.5)*scatter,
              Math.cos(phi)*r + (Math.random()-0.5)*scatter
            ),
            hue: baseHue + Math.random() * 80,
            behavior: 'glitter',
            size: Math.random() * 6
          });
        }
        break;
      }

      case Shape3DType.WORMHOLE: {
        for (let i = 0; i < count; i++) {
          const t = (Math.random() - 0.5) * 2;
          const y = t * 60 * s;
          const r = (Math.abs(t) * 20 + 5) * s;
          const angle = (i / count) * Math.PI * 2 + t * 4;
          points.push({
            position: new Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r),
            hue: 240 + t * 60
          });
        }
        break;
      }

      case Shape3DType.CONSTELLATION: {
        const r = 50 * s;
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const isStar = Math.random() > 0.9;
          const dist = isStar ? r : Math.random() * r;
          points.push({
            position: new Vector3(Math.sin(phi)*Math.cos(theta)*dist, Math.sin(phi)*Math.sin(theta)*dist, Math.cos(phi)*dist),
            hue: isStar ? 0 : 200,
            size: isStar ? 8 : 2,
            behavior: isStar ? 'glitter' : undefined
          });
        }
        break;
      }

      case Shape3DType.LANTERN: {
        const h = 40 * s;
        const r = 20 * s;
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          const angle = Math.random() * Math.PI * 2;
          const currentR = Math.sin(t * Math.PI) * r + 5 * s;
          const y = (t - 0.5) * h;
          points.push({ position: new Vector3(Math.cos(angle)*currentR, y, Math.sin(angle)*currentR), hue: 0 });
          if (t < 0.1) {
             const tassLen = Math.random() * 20 * s;
             points.push({ position: new Vector3(Math.cos(angle)*r*0.5, -h/2 - tassLen, Math.sin(angle)*r*0.5), hue: 45, behavior: 'willow' });
          }
        }
        break;
      }

      case Shape3DType.RIBBON: {
        for (let i = 0; i < count; i++) {
          const t = (i / count);
          const x = (t - 0.5) * 100 * s;
          const y = Math.sin(t * Math.PI * 2) * 20 * s;
          const z = Math.cos(t * Math.PI * 2) * 20 * s;
          const offset = (Math.random() - 0.5) * 10 * s;
          points.push({ position: new Vector3(x, y + offset, z), hue: t * 360, size: 4 });
        }
        break;
      }

      // === 鐗规晥绫?===
      case Shape3DType.EXPLOSION_BURST:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = (20 + Math.random() * 15) * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'glitter'
          });
        }
        break;
        
      case Shape3DType.RING_WAVE:
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const r = 30 * s;
          points.push({
            position: new Vector3(Math.cos(angle) * r, 0, Math.sin(angle) * r),
            hue: baseHue + (i / count) * 360
          });
        }
        break;
        
      case Shape3DType.DOUBLE_RING:
        for (let i = 0; i < count / 2; i++) {
          const angle = (i / (count / 2)) * Math.PI * 2;
          points.push({
            position: new Vector3(Math.cos(angle) * 35 * s, 0, Math.sin(angle) * 35 * s),
            hue: baseHue
          });
          points.push({
            position: new Vector3(Math.cos(angle) * 20 * s, 0, Math.sin(angle) * 20 * s),
            hue: (baseHue + 180) % 360
          });
        }
        break;
        
      case Shape3DType.FIREWORK_WILLOW:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const r = 20 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue,
            behavior: 'willow',
            decay: 0.008
          });
        }
        break;
        
      case Shape3DType.CHAOS_SCATTER:
        for (let i = 0; i < count; i++) {
          points.push({
            position: new Vector3(
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s,
              (Math.random() - 0.5) * 60 * s
            ),
            hue: Math.random() * 360
          });
        }
        break;
        
      // 榛樿锛氱悆褰?
      default:
        for (let i = 0; i < count; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 25 * s;
          points.push({
            position: new Vector3(
              Math.sin(phi) * Math.cos(theta) * r,
              Math.sin(phi) * Math.sin(theta) * r,
              Math.cos(phi) * r
            ),
            hue: baseHue
          });
        }
    }
    
    return points;
  }
}

/**
 * Shape3D宸ュ巶
 */
export class Shape3DFactory {
  private static allTypes: Shape3DType[] = Object.values(Shape3DType);
  
  /**
   * 鐢熸垚鎸囧畾褰㈢姸
   */
  static generate(
    type: Shape3DType,
    count: number,
    scale?: number,
    baseHue?: number
  ): Shape3DPoint[] {
    return Shape3DGenerator.generate(type, count, scale, baseHue);
  }
  
  /**
   * 鎸夋潈閲嶉殢鏈洪€夋嫨涓€涓舰鐘剁被鍨?(澧炲姞澶嶆潅褰㈢姸鏉冮噸)
   */
  static getRandomType(): Shape3DType {
    // 闄嶄綆鏅€氱悆褰㈠嚭鐜扮殑鏉冮噸
    const weights: Record<string, number> = {
      [Shape3DType.SPHERE]: 0.1,
      [Shape3DType.NESTED_SPHERES]: 0.1,
      [Shape3DType.HEART_3D]: 1.5,
      [Shape3DType.BUTTERFLY_3D]: 1.5,
      [Shape3DType.GALAXY_SPIRAL]: 2.0,
      [Shape3DType.PLANET_RINGS]: 1.5,
    };
    
    // 鍔ㄦ€佺敓鎴愬姞鏉冨垪琛?
    const pool: Shape3DType[] = [];
    this.allTypes.forEach(t => {
      const w = weights[t] || 1.0;
      for(let i=0; i<w*10; i++) pool.push(t);
    });
    
    return pool[Math.floor(Math.random() * pool.length)];
  }
  
  /**
   * 浠庡垪琛ㄤ腑闅忔満閫夋嫨
   */
  static getRandomTypeFrom(types: Shape3DType[]): Shape3DType {
    if (types.length === 0) return Shape3DType.SPHERE;
    return types[Math.floor(Math.random() * types.length)];
  }
  
  /**
   * 鑾峰彇鎵€鏈夊舰鐘剁被鍨?
   */
  static getAllTypes(): Shape3DType[] {
    return [...this.allTypes];
  }
  
  /**
   * 鎸夌被鍒幏鍙栧舰鐘?
   */
  static getTypesByCategory(category: string): Shape3DType[] {
    return this.allTypes.filter(type => SHAPE_3D_INFO[type].category === category);
  }
  
  /**
   * 鑾峰彇褰㈢姸淇℃伅
   */
  static getInfo(type: Shape3DType): Shape3DInfo {
    return SHAPE_3D_INFO[type];
  }
  
  /**
   * 鑾峰彇鎵€鏈夊垎绫?
   */
  static getCategories(): string[] {
    return Object.values(SHAPE_CATEGORIES);
  }
}

// END OF FILE: src/core/shapes/Shape3DFactory.ts


====== FILE: D:\ALL IN AI\Aetheris\src\core\trajectories\TrajectoryFactory.ts ======
// FILE: src/core/trajectories/TrajectoryFactory.ts
// 杞ㄨ抗宸ュ巶锛氬畾涔?0+绉嶇儫鑺变笂鍗囪建杩?

import { Vector3 } from '../Vector3';

/**
 * 杞ㄨ抗绫诲瀷鏋氫妇
 * 瀹氫箟鍚勭涓婂崌鏂瑰紡
 */
export enum TrajectoryType {
  // === 鍩虹杞ㄨ抗 ===
  LINEAR = 'linear',                     // 鐩寸嚎涓婂崌
  SPIRAL = 'spiral',                     // 铻烘棆鐩樻棆
  ZIGZAG = 'zigzag',                     // S鍨嬫憞鎽?
  
  // === 鍔犻€熺被 ===
  ACCELERATE = 'accelerate',             // 鍗曟鍔犻€?
  DOUBLE_ACCELERATE = 'double_accelerate', // 浜屾鍔犻€?
  TRIPLE_ACCELERATE = 'triple_accelerate', // 涓夋鍔犻€?
  DECELERATE = 'decelerate',             // 鍑忛€?
  MIXED_SPEED = 'mixed_speed',           // 娣峰悎鍙橀€?
  
  // === 鏇茬嚎绫?===
  BEZIER_CURVE = 'bezier_curve',         // 璐濆灏旀洸绾?
  PARABOLA = 'parabola',                 // 鎶涚墿绾?
  SINE_WAVE = 'sine_wave',               // 姝ｅ鸡娉?
  HELIX = 'helix',                       // 铻烘棆绾?
  
  // === 缁勫悎绫?===
  LINEAR_TO_CURVE = 'linear_to_curve',   // 鐩寸嚎鍙樻洸绾?
  CURVE_TO_LINEAR = 'curve_to_linear',   // 鏇茬嚎鍙樼洿绾?
  MULTI_SEGMENT = 'multi_segment',       // 澶氭杞ㄨ抗
  
  // === 鐗规畩绫?===
  WOBBLE = 'wobble',                     // 闅忔満鎵板姩
  FALL_RISE = 'fall_rise',               // 鍏堣惤鍚庡崌
  ORBIT = 'orbit',                       // 缁曞湀涓婂崌
}

/**
 * 杞ㄨ抗鏄剧ず淇℃伅
 */
export const TRAJECTORY_INFO: Record<TrajectoryType, { name: string; icon: string; description: string }> = {
  [TrajectoryType.LINEAR]: { name: '鐩寸嚎鍗囩┖', icon: '猬嗭笍', description: '绗旂洿鍚戜笂椋炶' },
  [TrajectoryType.SPIRAL]: { name: '铻烘棆鐩樻棆', icon: '馃寑', description: '鏃嬭浆涓婂崌濡傞緳鍗烽' },
  [TrajectoryType.ZIGZAG]: { name: 'S鍨嬫憞鎽?, icon: '銆帮笍', description: '宸﹀彸鎽嗗姩涓婂崌' },
  
  [TrajectoryType.ACCELERATE]: { name: '鏋侀€熸帹杩?, icon: '馃殌', description: '涓€旂獊鐒跺姞閫? },
  [TrajectoryType.DOUBLE_ACCELERATE]: { name: '浜屾鍔犻€?, icon: '鈿♀殹', description: '涓ゆ鐖嗗彂鍔犻€? },
  [TrajectoryType.TRIPLE_ACCELERATE]: { name: '涓夋鍔犻€?, icon: '鈿♀殹鈿?, description: '涓夌骇鐏鎺ㄨ繘' },
  [TrajectoryType.DECELERATE]: { name: '娓愯娓愮紦', icon: '馃悽', description: '瓒婃潵瓒婃參鐒跺悗鐖嗙偢' },
  [TrajectoryType.MIXED_SPEED]: { name: '娣峰悎鍙橀€?, icon: '馃帰', description: '鍔犻€熷噺閫熶氦鏇? },
  
  [TrajectoryType.BEZIER_CURVE]: { name: '璐濆灏旀洸绾?, icon: '馃搻', description: '骞虫粦寮х嚎杞ㄨ抗' },
  [TrajectoryType.PARABOLA]: { name: '鎶涚墿绾?, icon: '馃徆', description: '鏂滄姏+涓婂崌' },
  [TrajectoryType.SINE_WAVE]: { name: '姝ｅ鸡娉?, icon: '馃搳', description: '姝ｅ鸡娉㈠姩涓婂崌' },
  [TrajectoryType.HELIX]: { name: '3D铻烘棆', icon: '馃К', description: 'DNA鍙岃灪鏃嬩笂鍗? },
  
  [TrajectoryType.LINEAR_TO_CURVE]: { name: '鐩村悗寮?, icon: '鈫楋笍', description: '鐩寸嚎鍚庤浆寮? },
  [TrajectoryType.CURVE_TO_LINEAR]: { name: '寮悗鐩?, icon: '鈫栵笍', description: '寮洸鍚庡彉鐩? },
  [TrajectoryType.MULTI_SEGMENT]: { name: '澶氭鎶樼嚎', icon: '馃搱', description: '澶氱偣杞姌' },
  
  [TrajectoryType.WOBBLE]: { name: '闅忔満鎵板姩', icon: '馃', description: '涓嶈鍒欐姈鍔? },
  [TrajectoryType.FALL_RISE]: { name: '鍏堣惤鍚庤捣', icon: '猡碉笍', description: '鍏堜笅鍧犲啀鎬ュ崌' },
  [TrajectoryType.ORBIT]: { name: '缁曞湀涓婂崌', icon: '馃攧', description: '鍥寸粫涓績铻烘棆' },
};

/**
 * 杞ㄨ抗鐘舵€?
 */
export interface TrajectoryState {
  lifeTime: number;
  phase: number;        // 褰撳墠闃舵(0-1)
  segmentIndex: number; // 澶氭杞ㄨ抗娈电储寮?
}

/**
 * 杞ㄨ抗璁＄畻鍣?
 * 鏍规嵁杞ㄨ抗绫诲瀷璁＄畻閫熷害淇
 */
export class TrajectoryCalculator {
  private type: TrajectoryType;
  private state: TrajectoryState;
  
  // 杞ㄨ抗鍙傛暟
  private spiralFrequency: number = 10;
  private spiralAmplitude: number = 0.6;
  private waveFrequency: number = 8;
  private waveAmplitude: number = 0.8;
  
  constructor(type: TrajectoryType) {
    this.type = type;
    this.state = {
      lifeTime: 0,
      phase: 0,
      segmentIndex: 0
    };
  }
  
  /**
   * 璁＄畻褰撳墠甯х殑閫熷害淇
   * @param velocity 褰撳墠閫熷害
   * @param gravity 閲嶅姏绯绘暟
   * @param deltaTime 鏃堕棿澧為噺
   * @returns 淇鍚庣殑閫熷害
   */
  calculate(
    velocity: Vector3,
    gravity: number,
    deltaTime: number
  ): Vector3 {
    const dt = deltaTime * 60;
    this.state.lifeTime += deltaTime;
    const t = this.state.lifeTime;
    
    const result = velocity.clone();
    
    // 缂╂斁绯绘暟锛氶槻姝㈡按骞冲姏杩囧ぇ瀵艰嚧鏃犳硶鍗囩┖
    // 鍘熸潵鐨勭郴鏁?(0.3-0.6) 澶ぇ锛岀浉褰撲簬姣忓抚澧炲姞宸ㄥぇ閫熷害锛屽鑷寸灛闂村钩绉?
    // 璋冩暣涓?0.02 - 0.05 绾у埆锛岄厤鍚?gravity (~0.005)
    
    switch (this.type) {
      // === 鍩虹杞ㄨ抗 ===
      case TrajectoryType.LINEAR:
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.SPIRAL: {
        const angle = t * this.spiralFrequency;
        // 淇锛氬鍔?* dt锛屼笖澶у箙鍑忓皬骞呭害
        result.x += Math.cos(angle) * 0.04 * dt;
        result.z += Math.sin(angle) * 0.04 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.ZIGZAG: {
        result.x += Math.cos(t * this.waveFrequency) * 0.05 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === 鍔犻€熺被 ===
      case TrajectoryType.ACCELERATE:
        // 鍑忓皬鍔犻€熷箙搴︼紝鏇寸鍚堢墿鐞嗘儻鎬?
        if (t < 0.5) result.y -= gravity * 1.5 * dt;
        else if (t < 1.0) result.y += 0.08 * dt; // 鍘?0.3
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DOUBLE_ACCELERATE:
        if (t < 0.3) result.y -= gravity * 1.2 * dt;
        else if (t < 0.5) result.y += 0.1 * dt;  
        else if (t < 0.8) result.y -= gravity * 1.0 * dt;
        else if (t < 1.0) result.y += 0.15 * dt;  
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.TRIPLE_ACCELERATE:
        if (t < 0.2) result.y -= gravity * 1.0 * dt;
        else if (t < 0.3) result.y += 0.1 * dt;  
        else if (t < 0.5) result.y -= gravity * 0.8 * dt;
        else if (t < 0.6) result.y += 0.12 * dt; 
        else if (t < 0.8) result.y -= gravity * 0.6 * dt;
        else if (t < 0.9) result.y += 0.15 * dt; 
        else result.y -= gravity * 2.0 * dt;
        break;
        
      case TrajectoryType.DECELERATE: {
        const decel = Math.max(0.9, 1 - t * 0.1); // 鍑忕紦闃诲凹
        result.y -= gravity * 1.5 * dt;
        result.x *= decel;
        result.z *= decel;
        break;
      }
      
      case TrajectoryType.MIXED_SPEED: {
        const cycle = Math.sin(t * 4) * 0.5 + 0.5;
        result.y -= gravity * (0.8 + cycle * 0.8) * dt;
        if (cycle > 0.7) result.y += 0.05 * dt;
        break;
      }
      
      // === 鏇茬嚎绫?===
      case TrajectoryType.BEZIER_CURVE: {
        const bezierT = Math.min(1, t / 2);
        const curveOffset = Math.sin(bezierT * Math.PI) * 2;
        result.x += curveOffset * 0.02 * dt; 
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.PARABOLA: {
        const paraT = Math.min(1, t / 1.5);
        result.x += (1 - paraT) * 0.05 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.SINE_WAVE: {
        const sinOffset = Math.sin(t * 6) * 1.5;
        result.x += sinOffset * 0.03 * dt;
        result.z += Math.cos(t * 6) * 0.8 * 0.03 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      case TrajectoryType.HELIX: {
        const helixAngle = t * 8;
        const helixRadius = 0.4 + t * 0.1;
        result.x += Math.cos(helixAngle) * helixRadius * 0.1 * dt; // 鍘熶箻鏁?implicit 1.0
        result.z += Math.sin(helixAngle) * helixRadius * 0.1 * dt;
        result.y -= gravity * 1.2 * dt;
        break;
      }
      
      // === 缁勫悎绫?===
      case TrajectoryType.LINEAR_TO_CURVE:
        if (t < 1.0) {
          result.y -= gravity * 1.5 * dt;
        } else {
          const curveAngle = (t - 1.0) * 5;
          result.x += Math.sin(curveAngle) * 0.06 * dt;
          result.z += Math.cos(curveAngle) * 0.04 * dt;
          result.y -= gravity * 1.8 * dt;
        }
        break;
        
      case TrajectoryType.CURVE_TO_LINEAR:
        if (t < 1.0) {
          const curveAngle = t * 5;
          result.x += Math.sin(curveAngle) * 0.06 * dt;
          result.z += Math.cos(curveAngle) * 0.04 * dt;
          result.y -= gravity * 1.2 * dt;
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.MULTI_SEGMENT: {
        const segment = Math.floor(t / 0.5);
        const angles = [0, Math.PI/4, -Math.PI/4, Math.PI/2, 0];
        const idx = Math.min(segment, angles.length - 1);
        result.x += Math.sin(angles[idx]) * 0.06 * dt; // 鍘?0.3
        result.z += Math.cos(angles[idx]) * 0.04 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
      }
      
      // === 鐗规畩绫?===
      case TrajectoryType.WOBBLE:
        result.x += (Math.random() - 0.5) * 0.1 * dt; // 鍘?1.0
        result.z += (Math.random() - 0.5) * 0.1 * dt;
        result.y -= gravity * 1.5 * dt;
        break;
        
      case TrajectoryType.FALL_RISE:
        if (t < 0.3) {
          result.y -= gravity * 2.5 * dt; 
        } else if (t < 0.6) {
          result.y += 0.2 * dt; // 鍘?0.8
        } else {
          result.y -= gravity * 1.5 * dt;
        }
        break;
        
      case TrajectoryType.ORBIT: {
        const orbitAngle = t * 6;
        const orbitRadius = 0.6;
        result.x = Math.cos(orbitAngle) * orbitRadius * 0.05 * dt;
        result.z = Math.sin(orbitAngle) * orbitRadius * 0.05 * dt;
        result.y -= gravity * 1.3 * dt;
        break;
      }
      
      default:
        result.y -= gravity * 1.5 * dt;
    }
    
    return result;
  }
  
  /**
   * 鑾峰彇杞ㄨ抗绫诲瀷
   */
  getType(): TrajectoryType {
    return this.type;
  }
  
  /**
   * 鑾峰彇褰撳墠杩愯鏃堕棿
   */
  getLifeTime(): number {
    return this.state.lifeTime;
  }
}

/**
 * 杞ㄨ抗宸ュ巶
 * 鍒涘缓鍜岀鐞嗚建杩硅绠楀櫒
 */
export class TrajectoryFactory {
  private static allTypes: TrajectoryType[] = Object.values(TrajectoryType);
  
  /**
   * 鍒涘缓鎸囧畾绫诲瀷鐨勮建杩硅绠楀櫒
   */
  static create(type: TrajectoryType): TrajectoryCalculator {
    return new TrajectoryCalculator(type);
  }
  
  /**
   * 鍒涘缓闅忔満绫诲瀷鐨勮建杩硅绠楀櫒
   */
  static createRandom(): TrajectoryCalculator {
    const randomType = this.allTypes[Math.floor(Math.random() * this.allTypes.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * 浠庣粰瀹氬垪琛ㄤ腑闅忔満鍒涘缓
   */
  static createFromList(types: TrajectoryType[]): TrajectoryCalculator {
    if (types.length === 0) return this.create(TrajectoryType.LINEAR);
    const randomType = types[Math.floor(Math.random() * types.length)];
    return new TrajectoryCalculator(randomType);
  }
  
  /**
   * 鑾峰彇鎵€鏈夎建杩圭被鍨?
   */
  static getAllTypes(): TrajectoryType[] {
    return [...this.allTypes];
  }
  
  /**
   * 鑾峰彇杞ㄨ抗淇℃伅
   */
  static getInfo(type: TrajectoryType): { name: string; icon: string; description: string } {
    return TRAJECTORY_INFO[type];
  }
}

// END OF FILE: src/core/trajectories/TrajectoryFactory.ts


====== FILE: D:\ALL IN AI\Aetheris\src\core\AdvancedEffects.ts ======
/**
 * AdvancedEffects.ts - 鐢靛奖绾ч珮绾ф覆鏌撴晥鏋?
 * 
 * 瀹炵幇"涓庣幇瀹炴棤娉曞垎杈?鐨勬瀬鑷磋瑙夋晥鏋滐細
 * 
 * 1. 浣撶Н鎰熺儫闆句笌鑷彂鍏夐伄钄?
 * 2. 鐗╃悊蹇棬杩愬姩妯＄硦 (闀挎洕鍏?
 * 3. 澶ф皵鏁ｅ皠涓庝竵杈惧皵鏁堝簲
 * 4. 闀滃ご鍏夊: 鍏夋檿銆佽壊宸€佹櫙娣?
 * 5. 榛戜綋杈愬皠棰滆壊妯℃嫙
 */

import * as THREE from 'three';

// ============================================================
// 1. 浣撶Н鐑熼浘绯荤粺
// ============================================================

/**
 * 鐑熼浘绮掑瓙閰嶇疆
 */
export interface SmokeParticle {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  life: number;
  maxLife: number;
  size: number;
  opacity: number;
  color: THREE.Color;
  illumination: number;  // 琚儫鑺辩収浜殑绋嬪害
}

/**
 * 浣撶Н鐑熼浘绠＄悊鍣?
 * 妯℃嫙鐑熻姳浜х敓鐨勭儫闆捐鐏厜鐓т寒鐨勬晥鏋?
 */
export class VolumetricSmokeSystem {
  private particles: SmokeParticle[] = [];
  private geometry: THREE.BufferGeometry;
  private material: THREE.PointsMaterial;
  private mesh: THREE.Points;
  private maxParticles: number;
  
  constructor(scene: THREE.Scene, maxParticles: number = 2000) {
    this.maxParticles = maxParticles;
    
    // 鍒涘缓鍑犱綍浣?
    this.geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(maxParticles * 3);
    const colors = new Float32Array(maxParticles * 3);
    const sizes = new Float32Array(maxParticles);
    
    this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    // 鐑熼浘鏉愯川锛氫娇鐢?additive 娣峰悎妯℃嫙鍐呭彂鍏?
    this.material = new THREE.PointsMaterial({
      size: 20,
      map: this.createSmokeTexture(),
      vertexColors: true,
      transparent: true,
      opacity: 0.15,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });
    
    this.mesh = new THREE.Points(this.geometry, this.material);
    this.mesh.frustumCulled = false;
    scene.add(this.mesh);
  }
  
  /**
   * 鍒涘缓鏌斿拰鐨勭儫闆剧汗鐞?
   */
  private createSmokeTexture(): THREE.Texture {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d')!;
    
    // 澶氬眰楂樻柉娓愬彉妯℃嫙鐑熼浘
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
    gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
    gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.05)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
  }
  
  /**
   * 鍦ㄦ寚瀹氫綅缃敓鎴愮儫闆?
   */
  emit(position: THREE.Vector3, color: THREE.Color, intensity: number = 1): void {
    if (this.particles.length >= this.maxParticles) {
      // 鍥炴敹鏈€鑰佺殑绮掑瓙
      this.particles.shift();
    }
    
    // 娣诲姞闅忔満鍋忕Щ
    const spread = 5;
    const smokePos = new THREE.Vector3(
      position.x + (Math.random() - 0.5) * spread,
      position.y + (Math.random() - 0.5) * spread,
      position.z + (Math.random() - 0.5) * spread
    );
    
    // 鐑熼浘缂撴參涓婂崌鍜屾墿鏁?
    const velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.5,
      Math.random() * 0.8 + 0.2,  // 涓昏鍚戜笂
      (Math.random() - 0.5) * 0.5
    );
    
    this.particles.push({
      position: smokePos,
      velocity,
      life: 1,
      maxLife: 3 + Math.random() * 2,  // 3-5绉掔敓鍛?
      size: 15 + Math.random() * 20,
      opacity: 0.1 + Math.random() * 0.1,
      color: color.clone(),
      illumination: intensity
    });
  }
  
  /**
   * 鏇存柊鐑熼浘鐗╃悊鍜屾覆鏌?
   */
  update(deltaTime: number, lightSources: { position: THREE.Vector3; color: THREE.Color; intensity: number }[] = []): void {
    const positions = this.geometry.attributes.position.array as Float32Array;
    const colors = this.geometry.attributes.color.array as Float32Array;
    const sizes = this.geometry.attributes.size.array as Float32Array;
    
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      
      // 鏇存柊鐢熷懡
      p.life -= deltaTime / p.maxLife;
      
      if (p.life <= 0) {
        this.particles.splice(i, 1);
        continue;
      }
      
      // 鐗╃悊鏇存柊锛氱紦鎱㈡墿鏁?
      p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
      p.velocity.y *= 0.99;  // 闃诲姏
      p.size += deltaTime * 5;  // 閫愭笎鍙樺ぇ
      
      // 璁＄畻鍏夌収锛氳鍛ㄥ洿鍏夋簮鐓т寒
      let totalIllumination = p.illumination * 0.95;  // 琛板噺
      const illuminatedColor = p.color.clone();
      
      for (const light of lightSources) {
        const dist = p.position.distanceTo(light.position);
        if (dist < 100) {
          const falloff = 1 - (dist / 100);
          const contrib = falloff * falloff * light.intensity * 0.3;
          totalIllumination += contrib;
          
          // Mie 鏁ｅ皠锛氬厜鏌撶儫闆?
          illuminatedColor.lerp(light.color, contrib * 0.5);
        }
      }
      
      p.illumination = Math.min(totalIllumination, 1);
      
      // 鏇存柊 buffer
      const idx3 = i * 3;
      positions[idx3] = p.position.x;
      positions[idx3 + 1] = p.position.y;
      positions[idx3 + 2] = p.position.z;
      
      // 棰滆壊鍙楀厜鐓у奖鍝?
      const fadeAlpha = p.life * p.illumination;
      colors[idx3] = illuminatedColor.r * fadeAlpha;
      colors[idx3 + 1] = illuminatedColor.g * fadeAlpha;
      colors[idx3 + 2] = illuminatedColor.b * fadeAlpha;
      
      sizes[i] = p.size * p.life;
    }
    
    // 闅愯棌鏈娇鐢ㄧ殑绮掑瓙
    for (let i = this.particles.length; i < this.maxParticles; i++) {
      const idx3 = i * 3;
      positions[idx3 + 1] = -10000;
    }
    
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  }
  
  dispose(): void {
    this.geometry.dispose();
    this.material.dispose();
  }
}

// ============================================================
// 2. 杩愬姩妯＄硦 (闀挎洕鍏夋晥鏋?
// ============================================================

/**
 * 杩愬姩妯＄硦鐫€鑹插櫒
 * 鍩轰簬閫熷害鍚戦噺鐨勫姩鎬佹ā绯?
 */
export const MotionBlurShader = {
  name: 'MotionBlurShader',
  uniforms: {
    tDiffuse: { value: null },
    tVelocity: { value: null },  // 閫熷害缂撳啿
    velocityFactor: { value: 0.5 },
    samples: { value: 16 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform sampler2D tVelocity;
    uniform float velocityFactor;
    uniform int samples;
    varying vec2 vUv;
    
    void main() {
      vec2 velocity = texture2D(tVelocity, vUv).rg * velocityFactor;
      
      vec4 color = vec4(0.0);
      vec2 offset = velocity / float(samples);
      
      for(int i = 0; i < 32; i++) {
        if(i >= samples) break;
        vec2 sampleUv = vUv + offset * float(i - samples / 2);
        color += texture2D(tDiffuse, sampleUv);
      }
      
      gl_FragColor = color / float(samples);
    }
  `
};

/**
 * 绱Н缂撳啿杩愬姩妯＄硦 (闀挎洕鍏?
 */
export class AccumulationBuffer {
  private accumTexture: THREE.WebGLRenderTarget;
  private blendAmount: number;
  
  constructor(width: number, height: number, blendAmount: number = 0.9) {
    this.blendAmount = blendAmount;
    this.accumTexture = new THREE.WebGLRenderTarget(width, height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      type: THREE.FloatType
    });
  }
  
  /**
   * 鑾峰彇绱Н绾圭悊
   */
  getTexture(): THREE.Texture {
    return this.accumTexture.texture;
  }
  
  /**
   * 璁剧疆娣峰悎閲?(0=鏃犳ā绯? 0.99=寮虹儓鎷栧熬)
   */
  setBlendAmount(amount: number): void {
    this.blendAmount = Math.max(0, Math.min(0.99, amount));
  }
  
  resize(width: number, height: number): void {
    this.accumTexture.setSize(width, height);
  }
  
  dispose(): void {
    this.accumTexture.dispose();
  }
}

// ============================================================
// 3. 澶ф皵鏁ｅ皠涓庝竵杈惧皵鏁堝簲 (God Rays)
// ============================================================

/**
 * 涓佽揪灏旀晥搴?鍏夋煴鐫€鑹插櫒
 */
export const GodRaysShader = {
  name: 'GodRaysShader',
  uniforms: {
    tDiffuse: { value: null },
    tDepth: { value: null },
    lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
    exposure: { value: 0.3 },
    decay: { value: 0.95 },
    density: { value: 0.8 },
    weight: { value: 0.5 },
    samples: { value: 60 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec2 lightPosition;
    uniform float exposure;
    uniform float decay;
    uniform float density;
    uniform float weight;
    uniform int samples;
    varying vec2 vUv;
    
    void main() {
      vec2 deltaTextCoord = vUv - lightPosition;
      deltaTextCoord *= 1.0 / float(samples) * density;
      
      vec2 coord = vUv;
      vec4 color = texture2D(tDiffuse, coord);
      float illuminationDecay = 1.0;
      
      for(int i = 0; i < 100; i++) {
        if(i >= samples) break;
        coord -= deltaTextCoord;
        vec4 sampleColor = texture2D(tDiffuse, coord);
        sampleColor *= illuminationDecay * weight;
        color += sampleColor;
        illuminationDecay *= decay;
      }
      
      gl_FragColor = color * exposure;
    }
  `
};

// ============================================================
// 4. 闀滃ご鍏夊鏁堟灉
// ============================================================

/**
 * 闀滃ご鍏夋檿 (Lens Flare) 閰嶇疆
 */
export interface LensFlareConfig {
  enabled: boolean;
  intensity: number;
  size: number;
  haloSize: number;
  ghostCount: number;
  threshold: number;
}

/**
 * 闀滃ご鍏夋檿鐫€鑹插櫒
 */
export const LensFlareShader = {
  name: 'LensFlareShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.3 },
    threshold: { value: 0.8 },
    ghostCount: { value: 5 },
    ghostSpacing: { value: 0.3 },
    haloWidth: { value: 0.6 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float threshold;
    uniform int ghostCount;
    uniform float ghostSpacing;
    uniform float haloWidth;
    varying vec2 vUv;
    
    vec3 sampleGhost(vec2 uv, float offset) {
      vec2 ghostUv = vec2(1.0) - uv;
      ghostUv = mix(vec2(0.5), ghostUv, offset);
      
      if(ghostUv.x < 0.0 || ghostUv.x > 1.0 || ghostUv.y < 0.0 || ghostUv.y > 1.0) {
        return vec3(0.0);
      }
      
      vec3 color = texture2D(tDiffuse, ghostUv).rgb;
      float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));
      
      if(brightness < threshold) return vec3(0.0);
      
      return color * (brightness - threshold);
    }
    
    void main() {
      vec4 base = texture2D(tDiffuse, vUv);
      vec3 flare = vec3(0.0);
      
      // 骞界伒鍥惧儚
      for(int i = 0; i < 10; i++) {
        if(i >= ghostCount) break;
        float offset = ghostSpacing * float(i + 1);
        flare += sampleGhost(vUv, offset) * (1.0 / float(i + 1));
      }
      
      // 鍏夌幆
      vec2 haloVec = vec2(0.5) - vUv;
      float haloDist = length(haloVec);
      float halo = pow(1.0 - abs(haloDist - haloWidth), 5.0);
      halo *= texture2D(tDiffuse, vUv + normalize(haloVec) * haloWidth).r;
      flare += vec3(halo) * 0.5;
      
      gl_FragColor = vec4(base.rgb + flare * intensity, base.a);
    }
  `
};

/**
 * 鏅繁鐫€鑹插櫒 (Depth of Field)
 */
export const DepthOfFieldShader = {
  name: 'DepthOfFieldShader',
  uniforms: {
    tDiffuse: { value: null },
    tDepth: { value: null },
    focusDistance: { value: 300.0 },
    focusRange: { value: 150.0 },
    maxBlur: { value: 3.0 },
    resolution: { value: new THREE.Vector2(1, 1) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform sampler2D tDepth;
    uniform float focusDistance;
    uniform float focusRange;
    uniform float maxBlur;
    uniform vec2 resolution;
    varying vec2 vUv;
    
    float getDepth(vec2 uv) {
      return texture2D(tDepth, uv).r * 1000.0;
    }
    
    void main() {
      float depth = getDepth(vUv);
      float blur = clamp(abs(depth - focusDistance) / focusRange, 0.0, 1.0) * maxBlur;
      
      if(blur < 0.5) {
        gl_FragColor = texture2D(tDiffuse, vUv);
        return;
      }
      
      vec2 texelSize = 1.0 / resolution;
      vec4 color = vec4(0.0);
      float total = 0.0;
      
      // 绠€鍗曠殑妗嗘ā绯?
      for(float x = -3.0; x <= 3.0; x += 1.0) {
        for(float y = -3.0; y <= 3.0; y += 1.0) {
          vec2 offset = vec2(x, y) * texelSize * blur;
          color += texture2D(tDiffuse, vUv + offset);
          total += 1.0;
        }
      }
      
      gl_FragColor = color / total;
    }
  `
};

// ============================================================
// 5. 榛戜綋杈愬皠棰滆壊
// ============================================================

/**
 * 鍩轰簬娓╁害鐨勯粦浣撹緪灏勯鑹?
 * 鐪熷疄妯℃嫙閲戝睘/鐏劙闅忔俯搴﹀彉鍖栫殑棰滆壊
 * 
 * @param temperature 娓╁害 (Kelvin), 1000-15000
 * @returns RGB 棰滆壊
 */
export function blackbodyColor(temperature: number): { r: number; g: number; b: number } {
  // Clamp temperature
  const temp = Math.max(1000, Math.min(15000, temperature));
  const t = temp / 100;
  
  let r: number, g: number, b: number;
  
  // 绾㈣壊閫氶亾
  if (t <= 66) {
    r = 255;
  } else {
    r = 329.698727446 * Math.pow(t - 60, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  
  // 缁胯壊閫氶亾
  if (t <= 66) {
    g = 99.4708025861 * Math.log(t) - 161.1195681661;
  } else {
    g = 288.1221695283 * Math.pow(t - 60, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  
  // 钃濊壊閫氶亾
  if (t >= 66) {
    b = 255;
  } else if (t <= 19) {
    b = 0;
  } else {
    b = 138.5177312231 * Math.log(t - 10) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  
  return {
    r: r / 255,
    g: g / 255,
    b: b / 255
  };
}

/**
 * 鏍规嵁鐢熷懡鍊艰绠楀喎鍗撮鑹?
 * 妯℃嫙鐏姳浠庝寒榛勮壊鍐峰嵈鍒版殫绾㈣壊鐨勮繃绋?
 * 
 * @param life 鐢熷懡鍊?(0-1)
 * @param baseHue 鍩虹鑹茬浉
 * @returns THREE.Color
 */
export function coolingColor(life: number, baseHue: number = 0): THREE.Color {
  // 鐢熷懡鍊奸珮鏃? 楂樻俯 (6000K - 鐧?榛?
  // 鐢熷懡鍊间綆鏃? 浣庢俯 (2000K - 绾?鏆楃孩)
  const temperature = 2000 + life * 4000;
  const blackbody = blackbodyColor(temperature);
  
  // 娣峰悎鍩虹鑹茬浉
  const baseColor = new THREE.Color();
  baseColor.setHSL(baseHue / 360, 0.8, 0.5);
  
  const finalColor = new THREE.Color(blackbody.r, blackbody.g, blackbody.b);
  finalColor.lerp(baseColor, 0.3 * life);  // 楂樼敓鍛芥椂鏇村鍘熻壊
  
  // 浣庣敓鍛芥椂闄嶄綆浜害
  if (life < 0.3) {
    finalColor.multiplyScalar(life / 0.3);
  }
  
  return finalColor;
}

// ============================================================
// 6. 缁煎悎鏁堟灉绠＄悊鍣?
// ============================================================

/**
 * 楂樼骇鏁堟灉閰嶇疆
 */
export interface AdvancedEffectsConfig {
  // 鐑熼浘
  smokeEnabled: boolean;
  smokeIntensity: number;
  
  // 杩愬姩妯＄硦
  motionBlurEnabled: boolean;
  motionBlurStrength: number;
  
  // God Rays
  godRaysEnabled: boolean;
  godRaysIntensity: number;
  
  // 闀滃ご鏁堟灉
  lensFlareEnabled: boolean;
  lensFlareIntensity: number;
  depthOfFieldEnabled: boolean;
  focusDistance: number;
  
  // 棰滆壊
  useBlackbodyColors: boolean;
}

/**
 * 榛樿楂樼骇鏁堟灉閰嶇疆
 */
export const DEFAULT_ADVANCED_EFFECTS: AdvancedEffectsConfig = {
  smokeEnabled: true,
  smokeIntensity: 0.3,
  
  motionBlurEnabled: false,  // 榛樿鍏抽棴锛屾€ц兘鑰冮噺
  motionBlurStrength: 0.5,
  
  godRaysEnabled: false,     // 榛樿鍏抽棴
  godRaysIntensity: 0.3,
  
  lensFlareEnabled: true,
  lensFlareIntensity: 0.2,
  depthOfFieldEnabled: false,
  focusDistance: 300,
  
  useBlackbodyColors: true
};

/**
 * 楂樻€ц兘閰嶇疆 (鍏抽棴澶ч儴鍒嗘晥鏋?
 */
export const PERFORMANCE_ADVANCED_EFFECTS: AdvancedEffectsConfig = {
  smokeEnabled: false,
  smokeIntensity: 0,
  motionBlurEnabled: false,
  motionBlurStrength: 0,
  godRaysEnabled: false,
  godRaysIntensity: 0,
  lensFlareEnabled: false,
  lensFlareIntensity: 0,
  depthOfFieldEnabled: false,
  focusDistance: 300,
  useBlackbodyColors: false
};


====== FILE: D:\ALL IN AI\Aetheris\src\core\Firework.ts ======

import { Vector2 } from './Vector2';
import { FireworkOptions, ExplosionType, AppSettings, ParticleOptions } from '../types';
import { Particle } from './Particle';

export class Firework {
  pos: Vector2;
  target: Vector2;
  vel: Vector2;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector2[] = [];
  trailLength: number;

  constructor(options: FireworkOptions, settings: AppSettings) {
    this.pos = new Vector2(options.startX, window.innerHeight);
    this.target = new Vector2(options.targetX, options.targetY);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;

    const distanceY = this.pos.y - this.target.y;
    const gravity = settings.gravity;
    const initialVelY = -Math.sqrt(2 * gravity * Math.max(10, distanceY)) * (0.85 + Math.random() * 0.3);
    const timeToApex = -initialVelY / gravity;
    const initialVelX = (this.target.x - this.pos.x) / timeToApex;

    this.vel = new Vector2(initialVelX, initialVelY);
  }

  update(settings: AppSettings): void {
    this.trail.push(this.pos.clone());
    if (this.trail.length > this.trailLength) {
      this.trail.shift();
    }
    this.vel.y += settings.gravity;
    this.pos.add(this.vel);
    
    if (this.vel.y >= -0.2) {
      this.exploded = true;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    ctx.beginPath();
    ctx.strokeStyle = `hsl(${this.hue}, 100%, 75%)`;
    ctx.lineWidth = 1.2;
    for (let i = 0; i < this.trail.length; i++) {
      const p = this.trail[i];
      const alpha = i / this.trail.length;
      ctx.globalAlpha = alpha * 0.8;
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  createExplosion(settings: AppSettings, spawnParticle: (opts: ParticleOptions) => Particle): void {
    const types = Object.values(ExplosionType);
    const type = types[Math.floor(Math.random() * types.length)] as ExplosionType;
    
    let baseCount = Math.floor((180 + this.charge * 450) * settings.particleCountMultiplier);
    const sizeScale = settings.explosionSizeMultiplier;

    const spawn = (angle: number, speed: number, extraHue = 0, behavior: any = 'default', decay?: number) => {
      spawnParticle({
        x: this.pos.x, y: this.pos.y,
        originX: this.pos.x,
        originY: this.pos.y,
        hue: (this.hue + extraHue) % 360,
        angle,
        speed: speed * sizeScale,
        gravity: settings.gravity,
        friction: settings.friction,
        behavior,
        decay
      });
    };

    switch (type) {
      case ExplosionType.HEART:
        const heartCount = baseCount * 1.5;
        for (let i = 0; i < heartCount; i++) {
          const t = (i / heartCount) * Math.PI * 2;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          const speed = (Math.sqrt(x*x + y*y) / 8) * (6 + this.charge * 8);
          spawn(Math.atan2(y, x), speed, 0, 'default', 0.012);
        }
        break;

      case ExplosionType.STAR:
        const pts = 5;
        const starCount = baseCount * 1.3;
        for (let i = 0; i < starCount; i++) {
          const ang = (i / starCount) * Math.PI * 2;
          const mod = (Math.abs(Math.cos(ang * pts / 2)) * 0.7 + 0.3);
          spawn(ang, mod * (14 + this.charge * 18));
        }
        break;

      case ExplosionType.GALAXY:
        const arms = 4 + Math.floor(this.charge * 4);
        for (let a = 0; a < arms; a++) {
          const armBaseAngle = (a / arms) * Math.PI * 2;
          for (let i = 0; i < baseCount / arms; i++) {
            const prog = i / (baseCount / arms);
            const angle = armBaseAngle + prog * Math.PI * 2.5;
            const speed = prog * (15 + this.charge * 15);
            spawn(angle, speed, prog * 80, 'galaxy');
          }
        }
        break;

      case ExplosionType.SPIRAL:
        const sArms = 4 + Math.floor(this.charge * 4);
        const pPerArm = Math.floor(baseCount / sArms);
        for (let a = 0; a < sArms; a++) {
          const armBaseAngle = (a / sArms) * Math.PI * 2;
          for (let i = 0; i < pPerArm; i++) {
            const prog = i / pPerArm;
            const swirlAngle = armBaseAngle + (prog * Math.PI * 8);
            const speed = (0.2 + prog * 0.8) * (20 + this.charge * 15);
            spawn(swirlAngle, speed, prog * 60);
          }
        }
        break;

      case ExplosionType.BUTTERFLY:
        const bfCount = baseCount * 1.5;
        for (let i = 0; i < bfCount; i++) {
          const t = (i / bfCount) * Math.PI * 2;
          const r = Math.exp(Math.sin(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin((2 * t - Math.PI) / 24), 5);
          const x = Math.sin(t) * r;
          const y = -Math.cos(t) * r;
          spawn(Math.atan2(y, x), Math.sqrt(x*x + y*y) * (8 + this.charge * 10), Math.sin(t) * 40);
        }
        break;

      case ExplosionType.DOUBLE_RING:
        const ringCount = Math.floor(baseCount * 0.6);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2, 22 + this.charge * 12);
        for (let i = 0; i < ringCount; i++) spawn((i / ringCount) * Math.PI * 2 + 0.2, 14 + this.charge * 8, 40);
        break;

      case ExplosionType.GLITTER:
        for (let i = 0; i < baseCount; i++) spawn(Math.random() * Math.PI * 2, Math.random() * (22 + this.charge * 18), 0, 'glitter');
        break;

      default:
        for (let i = 0; i < baseCount; i++) {
          const angle = (i / baseCount) * Math.PI * 2;
          spawn(angle, Math.random() * (20 + this.charge * 24));
        }
        break;
    }
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\Firework3D.ts ======
import { Vector3 } from './Vector3';
import { ExplosionType, AscensionType, ColorStyle, AppSettings, ParticleOptions3D, FireworkConfig } from '../types';
import { Particle3D } from './Particle3D';
import { TrajectoryFactory, TrajectoryCalculator, TrajectoryType } from './trajectories/TrajectoryFactory';
import { Shape3DFactory, Shape3DType } from './shapes/Shape3DFactory';
import { ComboManager, ComboConfig, ComboType } from './combos/ComboManager';

export interface Firework3DOptions {
  startX: number;
  startZ: number;
  targetX: number;
  targetY: number;
  targetZ: number;
  hue: number;
  charge: number;
  // 鏂板悜鍚庡吋瀹瑰瓧娈?
  trajectoryType?: TrajectoryType;
  comboType?: ComboType;
  customShape?: Shape3DType;
  lifeTimeOverride?: number; // 瑕嗙洊鎸佺画鏃堕棿 (绉?
}

/**
 * 3D Firework class
 */
export class Firework3D {
  position: Vector3;
  target: Vector3;
  velocity: Vector3;
  hue: number;
  charge: number;
  exploded: boolean = false;
  trail: Vector3[] = [];
  trailLength: number;
  
  public lifeTimeOverride: number = 0;

  public type: ExplosionType;
  public ascension: AscensionType;
  public colorStyle: ColorStyle;
  public lifeTime: number = 0;

  private trajectoryCalculator: TrajectoryCalculator;
  private comboConfig: ComboConfig;
  private currentStageIndex: number = 0;
  private lastStageTime: number = 0;

  constructor(options: Firework3DOptions, settings: AppSettings, config: FireworkConfig) {
    this.position = new Vector3(options.startX, 0, options.startZ);
    this.target = new Vector3(options.targetX, options.targetY, options.targetZ);
    this.hue = options.hue;
    this.charge = options.charge;
    this.trailLength = settings.trailLength;
    this.lifeTimeOverride = options.lifeTimeOverride || 0;

    // ... (rest of constructor logic) ... 
    // I need to be careful with replace_file_content to not delete the logic I'm not showing.
    // The replace tool requires REPLACEMENT of the block.
    
    // 1. 纭畾缁勫悎鎶€鍜岃建杩?
    const cType = options.comboType || ComboType.SINGLE;
    
    // 淇鏍峰紡搴旂敤闂锛氬鐞?legacy ExplosionType 鐨勮浆鎹?
    const rawShape = options.customShape as any;
    const baseShape = this.mapToShape3D(rawShape);
    
    this.comboConfig = ComboManager.generateConfig(cType, baseShape);

    const tType = options.trajectoryType || this.comboConfig.trajectory;
    this.trajectoryCalculator = TrajectoryFactory.create(tType);

    // 2. 淇濇寔瀵规棫鏈夌被鍨嬬殑鍏煎鎬э紙鐢ㄤ簬 UI 鏄剧ず绛夛級
    const ascList = config.enabledAscensions.length > 0 ? config.enabledAscensions : [AscensionType.LINEAR];
    this.ascension = ascList[Math.floor(Math.random() * ascList.length)];
    this.colorStyle = config.enabledColors[Math.floor(Math.random() * config.enabledColors.length)] || ColorStyle.SINGLE;
    this.type = rawShape in ExplosionType ? (rawShape as ExplosionType) : ExplosionType.SPHERE;
    // 3. 璁＄畻鍒濆閫熷害
    const distanceY = this.target.y - this.position.y;
    const gravity = settings.gravity * 1.5;
    const timeToApex = Math.sqrt(2 * Math.max(10, distanceY) / gravity);
    const initialVelY = gravity * timeToApex;
    const initialVelX = (this.target.x - this.position.x) / timeToApex;
    const initialVelZ = (this.target.z - this.position.z) / timeToApex;

    this.velocity = new Vector3(initialVelX, initialVelY, initialVelZ);
  }

  private mapToShape3D(shape: any): Shape3DType {
    if (!shape) return Shape3DType.SPHERE;
    if (Object.values(Shape3DType).includes(shape as Shape3DType)) return shape as Shape3DType;
    
    // 鏄犲皠鏃х増鍒版柊鐗?
    const mapping: Record<string, Shape3DType> = {
      [ExplosionType.SPHERE]: Shape3DType.SPHERE,
      [ExplosionType.BURST]: Shape3DType.EXPLOSION_BURST,
      [ExplosionType.RING]: Shape3DType.RING_WAVE,
      [ExplosionType.DOUBLE_RING]: Shape3DType.DOUBLE_RING,
      [ExplosionType.WILLOW]: Shape3DType.FIREWORK_WILLOW,
      [ExplosionType.CUBE]: Shape3DType.CUBE,
      [ExplosionType.PYRAMID]: Shape3DType.PYRAMID,
      [ExplosionType.STAR]: Shape3DType.STAR_3D,
      [ExplosionType.GALAXY]: Shape3DType.GALAXY_SPIRAL,
      [ExplosionType.HEART]: Shape3DType.HEART_3D,
      [ExplosionType.HEART_BEAT]: Shape3DType.HEART_3D,
      [ExplosionType.SNOWFLAKE]: Shape3DType.SNOWFLAKE_3D,
      [ExplosionType.BUTTERFLY]: Shape3DType.BUTTERFLY_3D,
      [ExplosionType.FLOWER]: Shape3DType.FLOWER_3D,
      [ExplosionType.FISH]: Shape3DType.FISH_3D,
      [ExplosionType.SATURN]: Shape3DType.PLANET_RINGS,
      [ExplosionType.HELIX]: Shape3DType.HELIX_TUBE,
      [ExplosionType.WATERFALL]: Shape3DType.WATERFALL_3D,
    };
    
    return mapping[shape] || Shape3DType.SPHERE;
  }


  update(settings: AppSettings, deltaTime: number): void {
    if (deltaTime <= 0) return;

    const dt = deltaTime * 60;
    
    // 浣跨敤鏂扮殑杞ㄨ抗璁＄畻鍣ㄦ洿鏂扮墿鐞?
    if (!this.exploded) {
      this.velocity = this.trajectoryCalculator.calculate(this.velocity, settings.gravity, deltaTime);
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.position.z += this.velocity.z * dt;
      this.lifeTime = this.trajectoryCalculator.getLifeTime();

      if (this.velocity.y <= -2.5) {
        this.exploded = true;
        this.lastStageTime = this.lifeTime;
      }
    } else {
      // 鐖嗙偢鍚庣殑閫昏緫锛氬鐞嗗闃舵缁勫悎鎶€
      this.handleComboStages(settings, (opts) => this.spawnParticleCallback?.(opts) as any);
    }
  }

  // 涓存椂瀛樺偍鍥炶皟锛屼互渚垮湪 update 涓皟鐢?
  private spawnParticleCallback: ((opts: ParticleOptions3D) => Particle3D) | null = null;

  createExplosion(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    this.spawnParticleCallback = spawnParticle;
    // 绔嬪嵆瑙﹀彂绗竴闃舵锛堝鏋滄湁寤惰繜涓?鐨勯樁娈碉級
    this.handleComboStages(settings, spawnParticle);
  }

  private handleComboStages(
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    if (!this.comboConfig || this.currentStageIndex >= this.comboConfig.stages.length) return;

    const timeSinceExplosion = this.lifeTime - this.lastStageTime;
    const currentStage = this.comboConfig.stages[this.currentStageIndex];

    if (timeSinceExplosion >= currentStage.delay) {
      this.executeStage(currentStage, settings, spawnParticle);
      this.currentStageIndex++;
    }
  }

  private executeStage(
    stage: any,
    settings: AppSettings,
    spawnParticle: (opts: ParticleOptions3D) => Particle3D
  ): void {
    const baseCount = Math.floor((200 + this.charge * 400) * settings.particleCountMultiplier * stage.particleCount);
    const scale = settings.explosionSizeMultiplier * stage.scale;
    const hue = (this.hue + stage.hueShift) % 360;

    // 鑾峰彇鐪?D褰㈢姸鐐瑰垎甯?
    const points = Shape3DFactory.generate(stage.shape, baseCount, scale, hue);
    
    // 璁＄畻 decay: 濡傛灉鏈?override锛屽弽鎺?decay
    let finalDecay = stage.decay ?? (0.01 + Math.random() * 0.015);
    if (this.lifeTimeOverride > 0) {
      finalDecay = 1 / (this.lifeTimeOverride * 60);
    }

    points.forEach(p => {
      const pos = p.position.clone();
      if (stage.spawnOffset) {
        pos.x += stage.spawnOffset.x;
        pos.y += stage.spawnOffset.y;
        pos.z += stage.spawnOffset.z;
      }

      const particle = spawnParticle({
        x: this.position.x + pos.x,
        y: this.position.y + pos.y,
        z: this.position.z + pos.z,
        originX: this.position.x,
        originY: this.position.y,
        originZ: this.position.z,
        hue: p.hue,
        // 鍒濆鍔ㄩ噺涓嶅啀鏄殢鏈轰贡璺筹紝鑰屾槸缁ф壙涓€閮ㄥ垎褰㈢姸鍔ㄩ噺
        speed: (stage.velocityScale || 1.0) * (1 + Math.random() * 2), 
        gravity: stage.gravity ?? settings.gravity,
        friction: settings.friction,
        behavior: (p.behavior || stage.behavior || 'default') as any,
        size: p.size || 5,
        decay: finalDecay
      });

      // 鏍稿績淇锛氬熀浜庤窛绂荤殑鎵╁紶閫熷害 (Spherical Expansion)
      // 鍙湁杩欐牱锛屽鏉傜殑 3D 褰㈢姸鎵嶈兘鍦ㄨ啫鑳€鏃朵繚鎸佲€滃舰鐘垛€濓紝鑰屼笉鏄繀閫熷彉鎴愪竴涓悆澹?
      if (particle) {
        const dist = p.position.length();
        if (dist > 0) {
          const dir = p.position.clone().normalize();
          // 璁╂墿鏁ｉ€熷害涓庡叾鍦ㄥ舰鐘朵腑鐨勮窛绂绘垚姝ｆ瘮锛屽疄鐜版寜姣斾緥缂╂斁鑶ㄨ儉
          const expandSpeed = (stage.velocityScale || 1.0) * (dist * 0.5); 
          particle.velocity.x = dir.x * expandSpeed;
          particle.velocity.y = dir.y * expandSpeed;
          particle.velocity.z = dir.z * expandSpeed;
        }
      }
    });
  }

  getColor(): { r: number; g: number; b: number } {
    const h = this.hue / 360; const s = 1; const l = 0.6;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q;
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    };
    return { r: hue2rgb(p, q, h + 1/3), g: hue2rgb(p, q, h), b: hue2rgb(p, q, h - 1/3) };
  }
}

// END OF FILE: src/core/Firework3D.ts

====== FILE: D:\ALL IN AI\Aetheris\src\core\Particle.ts ======

import { ParticleOptions, ParticleBehavior } from '../types';

/**
 * Performance-optimized Particle class.
 */
export class Particle {
  public x: number = 0;
  public y: number = 0;
  public vx: number = 0;
  public vy: number = 0;
  public originX: number = 0;
  public originY: number = 0;
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.12;
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public color: string = '';
  public rotationSpeed: number = 0;

  constructor() {}

  init(options: ParticleOptions): void {
    this.x = options.x;
    this.y = options.y;
    this.originX = options.originX ?? options.x;
    this.originY = options.originY ?? options.y;
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();

    const angle = options.angle ?? Math.random() * Math.PI * 2;
    const speed = options.speed ?? Math.random() * 10 + 2;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;

    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.98;
      this.gravity = options.gravity ?? 0.04;
      this.decay = options.decay ?? 0.006;
      this.size = options.size ?? 1.5;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.92;
      this.gravity = options.gravity ?? 0.15;
      this.decay = options.decay ?? 0.02;
      this.size = options.size ?? Math.random() * 2 + 1;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
    } else {
      this.friction = options.friction ?? 0.95;
      this.gravity = options.gravity ?? 0.12;
      this.decay = options.decay ?? Math.random() * 0.02 + 0.01;
      this.size = options.size ?? Math.random() * 2 + 1;
    }

    this.resistance = options.resistance ?? 0.005;
    this.color = `hsl(${this.hue % 360}, 100%, 75%)`;
  }

  update(): void {
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.vx += Math.sin(now) * 0.05;
      this.vy += Math.cos(now) * 0.05;
    } else if (this.behavior === 'galaxy') {
      const dx = this.x - this.originX;
      const dy = this.y - this.originY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) + this.rotationSpeed;
      
      const targetX = this.originX + Math.cos(angle) * (dist + this.vx);
      const targetY = this.originY + Math.sin(angle) * (dist + this.vy);
      
      this.vx = targetX - this.x;
      this.vy = targetY - this.y;
    }

    const speedSq = this.vx * this.vx + this.vy * this.vy;
    if (speedSq > 0.001) {
      const speed = Math.sqrt(speedSq);
      const drag = speedSq * this.resistance;
      this.vx -= (this.vx / speed) * drag;
      this.vy -= (this.vy / speed) * drag;
    }

    this.vx *= this.friction;
    this.vy = this.vy * this.friction + this.gravity;
    
    this.x += this.vx;
    this.y += this.vy;

    this.life -= this.decay;
    
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }
    
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15) % 1;
    }
  }

  draw(ctx: CanvasRenderingContext2D): void {
    if (this.alpha <= 0) return;

    let currentAlpha = this.alpha;
    if (this.behavior === 'glitter' && this.twinkleFactor > 0.5) {
      currentAlpha *= 0.2;
    }

    ctx.globalAlpha = currentAlpha;
    ctx.fillStyle = this.color;
    
    if (this.behavior === 'willow' || this.behavior === 'comet') {
      ctx.beginPath();
      const trailLen = this.behavior === 'comet' ? 8 : 3;
      ctx.lineWidth = this.behavior === 'comet' ? this.size * this.life : this.size;
      ctx.strokeStyle = this.color;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * trailLen, this.y - this.vy * trailLen);
      ctx.stroke();
      
      if (this.behavior === 'comet') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, 6.28);
        ctx.fill();
      }
    } else if (this.behavior === 'galaxy') {
      ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
    } else {
      if (this.size < 2) {
        ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
      } else {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 6.28);
        ctx.fill();
      }
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\Particle3D.ts ======
import { Vector3 } from './Vector3';
import { ParticleBehavior, ParticleOptions3D } from '../types';
import { getPhysicsEngine } from './PhysicsEngine';
import { ParticlePBRProperties, ParticleMaterialType, PBR_PRESETS } from './PBRMaterial';

/**
 * 3D Particle class for the firework system
 * Uses Three.js coordinate system (Y-up)
 * 
 * 鍗囩骇鐗规€э細
 * - Verlet/RK4 绉垎鍣ㄦ敮鎸?(閫氳繃 PhysicsEngine)
 * - PBR 鏉愯川灞炴€?(绮楃硻搴︺€侀噾灞炲害銆佸彂鍏夊己搴?
 * - 楂樼簿搴﹁建杩硅绠?
 */
export class Particle3D {
  public position: Vector3;
  public velocity: Vector3;
  public previousPosition: Vector3;  // Verlet 绉垎鍣ㄦ墍闇€
  public origin: Vector3;
  
  // 鍩虹灞炴€?
  public hue: number = 0;
  public alpha: number = 1;
  public decay: number = 0.02;
  public friction: number = 0.95;
  public gravity: number = 0.005;  // Default gravity reduced for hover effect
  public resistance: number = 0.005;
  public size: number = 1;
  public life: number = 1;
  public behavior: ParticleBehavior = 'default';
  public twinkleFactor: number = 0;
  public timeOffset: number = 0;
  public rotationSpeed: number = 0;
  
  // PBR 鏉愯川灞炴€?
  public roughness: number = 0.3;
  public metalness: number = 0.5;
  public emissiveIntensity: number = 2.0;
  public temperature: number = 5000;  // 鑹叉俯 (Kelvin)
  
  // 鐗╃悊寮曟搸鏍囪
  public useAdvancedPhysics: boolean = true;
  private isFirstUpdate: boolean = true;

  // Trail for comet/willow effects
  public trail: Vector3[] = [];
  public maxTrailLength: number = 10;

  constructor() {
    this.position = new Vector3();
    this.velocity = new Vector3();
    this.previousPosition = new Vector3();
    this.origin = new Vector3();
  }

  init(options: ParticleOptions3D): void {
    this.position = new Vector3(options.x, options.y, options.z);
    this.previousPosition = this.position.clone();  // Verlet 绉垎鍣ㄥ垵濮嬪寲
    this.origin = new Vector3(
      options.originX ?? options.x,
      options.originY ?? options.y,
      options.originZ ?? options.z
    );
    this.hue = options.hue;
    this.behavior = options.behavior ?? 'default';
    this.life = 1;
    this.alpha = 1;
    this.timeOffset = Math.random() * 100;
    this.twinkleFactor = Math.random();
    this.trail = [];
    this.isFirstUpdate = true;

    // Calculate velocity from spherical coordinates
    const theta = options.theta ?? Math.random() * Math.PI * 2;
    const phi = options.phi ?? Math.random() * Math.PI;
    const speed = options.speed ?? Math.random() * 10 + 2;

    this.velocity = new Vector3(
      speed * Math.sin(phi) * Math.cos(theta),
      speed * Math.cos(phi),
      speed * Math.sin(phi) * Math.sin(theta)
    );

    // Apply behavior-specific settings with PBR properties
    if (this.behavior === 'willow') {
      this.friction = options.friction ?? 0.99;
      this.gravity = options.gravity ?? 0.02;   // 闄嶄綆閲嶅姏
      this.decay = options.decay ?? 0.003;      // 闄嶄綆琛板噺
      this.size = options.size ?? 1.5;
      this.maxTrailLength = 15;
      // PBR: 鏌冲彾鐑熻姳 - 鏌斿拰銆佷綆閲戝睘搴?
      this.roughness = 0.7;
      this.metalness = 0.2;
      this.emissiveIntensity = 1.5;
      this.temperature = 3500;
    } else if (this.behavior === 'glitter') {
      this.friction = options.friction ?? 0.96;
      this.gravity = options.gravity ?? 0.05;   // 闄嶄綆閲嶅姏
      this.decay = options.decay ?? 0.01;       // 闄嶄綆琛板噺
      this.size = options.size ?? Math.random() * 2 + 1;
      // PBR: 闂矇 - 楂橀噾灞炲害銆佷綆绮楃硻搴︼紝寮哄弽灏?
      this.roughness = 0.1;
      this.metalness = 1.0;
      this.emissiveIntensity = 4.0 + Math.random() * 2;
      this.temperature = 6500;
    } else if (this.behavior === 'firefly') {
      this.friction = 0.94;
      this.gravity = -0.01;
      this.decay = 0.005;
      this.size = 1.2;
      // PBR: 钀ょ伀铏?- 寮哄彂鍏夈€佹湁鏈鸿川鎰?
      this.roughness = 0.4;
      this.metalness = 0.1;
      this.emissiveIntensity = 3.0;
      this.temperature = 4500;
    } else if (this.behavior === 'comet') {
      this.friction = 0.995;
      this.gravity = 0.01;
      this.decay = options.decay ?? 0.006;
      this.size = 3;
      this.resistance = 0.0001;
      this.maxTrailLength = 20;
      // PBR: 褰楁槦 - 瓒呭己鍙戝厜銆佺瓑绂诲瓙璐ㄦ劅
      this.roughness = 0.05;
      this.metalness = 0.7;
      this.emissiveIntensity = 6.0;
      this.temperature = 8000;
    } else if (this.behavior === 'galaxy') {
      this.friction = 0.98;
      this.gravity = 0;
      this.decay = options.decay ?? 0.008;
      this.size = Math.random() * 1.5 + 0.5;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
      // PBR: 鏄熺郴 - 涓瓑鍙戝厜銆佹槦灏樿川鎰?
      this.roughness = 0.5;
      this.metalness = 0.6;
      this.emissiveIntensity = 2.5;
      this.temperature = 5500 + Math.random() * 3000;
    } else {
      this.friction = options.friction ?? 0.92;  // High friction (drag)
      this.gravity = options.gravity ?? 0.005;   // HOVER EFFECT: Near zero gravity
      this.decay = options.decay ?? Math.random() * 0.008 + 0.004;
      this.size = options.size ?? Math.random() * 2 + 1;
      // PBR: 榛樿鐏姳 - 鏍囧噯鐑熻姳鏁堟灉
      this.roughness = 0.3;
      this.metalness = 0.5;
      this.emissiveIntensity = 2.0 + this.life;
      this.temperature = 3000 + Math.random() * 4000;
    }

    this.resistance = options.resistance ?? 0.002;  // 闄嶄綆绌烘皵闃诲姏
  }

  update(deltaTime: number): void {
    // Skip update if effectively paused
    if (deltaTime <= 0) return;
    
    // Use a minimum dt to prevent division by zero and ensure smooth updates
    const dt = Math.max(deltaTime * 60, 0.001); // Normalize to 60fps with minimum

    // Store trail position (before position update)
    if (this.behavior === 'comet' || this.behavior === 'willow') {
      this.trail.push(this.position.clone());
      if (this.trail.length > this.maxTrailLength) {
        this.trail.shift();
      }
    }

    // Behavior-specific velocity modifiers
    if (this.behavior === 'firefly') {
      const now = performance.now() * 0.005 + this.timeOffset;
      this.velocity.x += Math.sin(now) * 0.05 * dt;
      this.velocity.y += Math.cos(now * 0.7) * 0.05 * dt;
      this.velocity.z += Math.sin(now * 1.3) * 0.05 * dt;
    } else if (this.behavior === 'galaxy') {
      const dx = this.position.x - this.origin.x;
      const dz = this.position.z - this.origin.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const angle = Math.atan2(dz, dx) + this.rotationSpeed * dt;

      const targetX = this.origin.x + Math.cos(angle) * (dist + this.velocity.x * dt);
      const targetZ = this.origin.z + Math.sin(angle) * (dist + this.velocity.z * dt);

      if (dt > 0.001) {
        this.velocity.x = (targetX - this.position.x) / dt;
        this.velocity.z = (targetZ - this.position.z) / dt;
      }
    }

    // === 楂樼骇鐗╃悊璁＄畻 (Verlet 绉垎鍣? ===
    if (this.useAdvancedPhysics && !this.isFirstUpdate) {
      // Verlet 绉垎: x(t+dt) = 2*x(t) - x(t-dt) + a*dt^2
      // 鍔犻€熷害 = 閲嶅姏 + 绌烘皵闃诲姏
      
      // 璁＄畻绌烘皵闃诲姏鍔犻€熷害
      const speedSq = this.velocity.x * this.velocity.x +
                      this.velocity.y * this.velocity.y +
                      this.velocity.z * this.velocity.z;
      
      let dragAx = 0, dragAy = 0, dragAz = 0;
      if (speedSq > 0.001) {
        const speed = Math.sqrt(speedSq);
        const dragMag = speedSq * this.resistance;
        dragAx = -(this.velocity.x / speed) * dragMag;
        dragAy = -(this.velocity.y / speed) * dragMag;
        dragAz = -(this.velocity.z / speed) * dragMag;
      }
      
      // 鎬诲姞閫熷害
      const ax = dragAx;
      const ay = -this.gravity + dragAy;
      const az = dragAz;
      
      // Verlet 绉垎鍏紡
      const newX = 2 * this.position.x - this.previousPosition.x + ax * deltaTime * deltaTime * 3600;
      const newY = 2 * this.position.y - this.previousPosition.y + ay * deltaTime * deltaTime * 3600;
      const newZ = 2 * this.position.z - this.previousPosition.z + az * deltaTime * deltaTime * 3600;
      
      // 浠庝綅缃樊鎺ㄥ鏂伴€熷害
      this.velocity.x = (newX - this.position.x) / dt;
      this.velocity.y = (newY - this.position.y) / dt;
      this.velocity.z = (newZ - this.position.z) / dt;
      
      // 搴旂敤鎽╂摝鍔?
      const frictionPower = Math.pow(this.friction, dt);
      this.velocity.x *= frictionPower;
      this.velocity.y *= frictionPower;
      this.velocity.z *= frictionPower;
      
      // 鏇存柊浣嶇疆
      this.previousPosition.x = this.position.x;
      this.previousPosition.y = this.position.y;
      this.previousPosition.z = this.position.z;
      
      this.position.x = newX;
      this.position.y = newY;
      this.position.z = newZ;
    } else {
      // === 鏍囧噯娆ф媺绉垎 (鍏煎妯″紡鎴栭甯? ===
      
      // Apply air resistance
      const speedSq = this.velocity.x * this.velocity.x +
                      this.velocity.y * this.velocity.y +
                      this.velocity.z * this.velocity.z;
      if (speedSq > 0.001) {
        const speed = Math.sqrt(speedSq);
        const drag = speedSq * this.resistance * dt;
        this.velocity.x -= (this.velocity.x / speed) * drag;
        this.velocity.y -= (this.velocity.y / speed) * drag;
        this.velocity.z -= (this.velocity.z / speed) * drag;
      }

      // Apply friction
      const frictionPower = Math.pow(this.friction, dt);
      this.velocity.x *= frictionPower;
      this.velocity.y *= frictionPower;
      this.velocity.z *= frictionPower;

      // Apply gravity (Y-up in Three.js)
      this.velocity.y -= this.gravity * dt;

      // Store previous position for Verlet
      this.previousPosition.x = this.position.x;
      this.previousPosition.y = this.position.y;
      this.previousPosition.z = this.position.z;

      // Update position
      this.position.x += this.velocity.x * dt;
      this.position.y += this.velocity.y * dt;
      this.position.z += this.velocity.z * dt;
      
      this.isFirstUpdate = false;
    }

    // Update life
    this.life -= this.decay * dt;

    // Update alpha based on behavior
    if (this.behavior === 'ghost') {
      this.alpha = (Math.sin(this.life * 20) * 0.5 + 0.5) * this.life;
    } else if (this.behavior === 'firefly') {
      this.alpha = (Math.sin(performance.now() * 0.01 + this.timeOffset) * 0.4 + 0.6) * this.life;
    } else {
      this.alpha = this.life;
    }

    // Glitter twinkle
    if (this.behavior === 'glitter') {
      this.twinkleFactor = (this.twinkleFactor + 0.15 * dt) % 1;
      // 闂矇鍔ㄦ€佸彂鍏夊己搴?
      this.emissiveIntensity = 3.0 + Math.sin(this.twinkleFactor * Math.PI * 2) * 2.0;
    }
    
    // 鍔ㄦ€佹洿鏂?PBR 鍙戝厜寮哄害 (闅忕敓鍛藉€艰“鍑?
    if (this.behavior !== 'glitter') {
      this.emissiveIntensity = this.emissiveIntensity * (0.5 + this.life * 0.5);
    }
  }

  isDead(): boolean {
    return this.life <= 0;
  }

  getColor(): { r: number; g: number; b: number } {
    // HSL to RGB conversion
    const h = this.hue / 360;
    const s = 1;
    const l = 0.75;

    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    return {
      r: hue2rgb(p, q, h + 1/3),
      g: hue2rgb(p, q, h),
      b: hue2rgb(p, q, h - 1/3)
    };
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\ParticlePool.ts ======

import { Particle } from './Particle';
import { ParticleOptions } from '../types';

/**
 * Performance-optimized Particle Pool
 */
export class ParticlePool {
  private pool: Particle[] = [];
  private active: Particle[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle());
    }
  }

  /**
   * Get a particle: recycle the oldest active one if limit reached.
   */
  get(options: ParticleOptions): Particle {
    let p: Particle;
    
    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle();
    }
    
    p.init(options);
    this.active.push(p);
    return p;
  }

  updateAndDraw(ctx: CanvasRenderingContext2D): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update();
      p.draw(ctx);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  get activeCount() { return this.active.length; }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\ParticlePool3D.ts ======
import { Particle3D } from './Particle3D';
import { ParticleOptions3D } from '../types';

/**
 * Performance-optimized 3D Particle Pool
 * Manages particle lifecycle with object pooling to minimize GC
 */
export class ParticlePool3D {
  private pool: Particle3D[] = [];
  private active: Particle3D[] = [];
  private maxActive: number;

  constructor(maxActive: number) {
    this.maxActive = maxActive;
    // Warm up the pool
    for (let i = 0; i < 2000; i++) {
      this.pool.push(new Particle3D());
    }
  }

  /**
   * Get a particle from the pool
   * Recycles the oldest active particle if limit is reached
   */
  get(options: ParticleOptions3D): Particle3D {
    let p: Particle3D;

    if (this.active.length >= this.maxActive) {
      p = this.active.shift()!;
    } else {
      p = this.pool.pop() || new Particle3D();
    }

    p.init(options);
    this.active.push(p);
    return p;
  }

  /**
   * Update all active particles
   */
  update(deltaTime: number): void {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.update(deltaTime);
      if (p.isDead()) {
        this.active.splice(i, 1);
        this.pool.push(p);
      }
    }
  }

  /**
   * Get all active particles for rendering
   */
  getActiveParticles(): Particle3D[] {
    return this.active;
  }

  /**
   * Get the count of active particles
   */
  get activeCount(): number {
    return this.active.length;
  }

  /**
   * Clear all active particles
   */
  clear(): void {
    while (this.active.length > 0) {
      const p = this.active.pop()!;
      this.pool.push(p);
    }
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\PBRMaterial.ts ======
/**
 * PBRMaterial.ts - 鐗╃悊鍩虹娓叉煋鏉愯川绯荤粺
 * 
 * 鍔熻兘鐗规€э細
 * - 绮楃硻搴?(Roughness) - 鎺у埗鍏夌嚎鏁ｅ皠
 * - 閲戝睘搴?(Metalness) - 鎺у埗闀滈潰鍙嶅皠
 * - 鑷彂鍏?(Emissive) - 鐑熻姳鐨勬牳蹇冨厜婧?
 * - HDR 鏀寔 - 瓒呰繃1.0鐨勪寒搴﹀€?
 * 
 * 鐢ㄤ簬鍒涘缓鏃犳硶鍖哄垎鐪熷疄涓庤櫄鎷熺殑鐑熻姳鏁堟灉
 */

import * as THREE from 'three';

/**
 * 绮掑瓙 PBR 灞炴€?
 */
export interface ParticlePBRProperties {
  roughness: number;      // 0-1, 0=瀹屽叏鍏夋粦(闀滈潰), 1=瀹屽叏绮楃硻(婕弽灏?
  metalness: number;      // 0-1, 0=闈為噾灞?濉戞枡), 1=閲戝睘(楂樺弽灏?
  emissiveIntensity: number; // HDR 鍙戝厜寮哄害, 鍙秴杩?1.0
  temperature: number;    // 鑹叉俯鎺у埗, 2000K-10000K
}

/**
 * 棰勮鐨勭矑瀛愭潗璐ㄧ被鍨?
 */
export enum ParticleMaterialType {
  SPARK = 'spark',           // 鐏姳 - 楂橀噾灞炲害锛屼腑绛夌矖绯欏害
  EMBER = 'ember',           // 浣欑儸 - 浣庨噾灞炲害锛岄珮绮楃硻搴?
  GLITTER = 'glitter',       // 闂矇 - 楂橀噾灞炲害锛屼綆绮楃硻搴?
  SMOKE = 'smoke',           // 鐑熼浘 - 閫忔槑婕弽灏?
  STAR_CORE = 'star_core',   // 鏄熻姱 - 鏋侀珮鍙戝厜寮哄害
  PLASMA = 'plasma',         // 绛夌瀛?- 楂樺彂鍏夛紝浣庣矖绯欏害
  CRYSTAL = 'crystal',       // 姘存櫠 - 涓瓑閲戝睘搴︼紝鏋佷綆绮楃硻搴?
}

/**
 * 鏉愯川棰勮閰嶇疆
 */
export const PBR_PRESETS: Record<ParticleMaterialType, ParticlePBRProperties> = {
  [ParticleMaterialType.SPARK]: {
    roughness: 0.3,
    metalness: 0.9,
    emissiveIntensity: 3.0,
    temperature: 3000
  },
  [ParticleMaterialType.EMBER]: {
    roughness: 0.8,
    metalness: 0.2,
    emissiveIntensity: 1.5,
    temperature: 2000
  },
  [ParticleMaterialType.GLITTER]: {
    roughness: 0.1,
    metalness: 1.0,
    emissiveIntensity: 4.0,
    temperature: 6500
  },
  [ParticleMaterialType.SMOKE]: {
    roughness: 1.0,
    metalness: 0.0,
    emissiveIntensity: 0.0,
    temperature: 5000
  },
  [ParticleMaterialType.STAR_CORE]: {
    roughness: 0.0,
    metalness: 0.5,
    emissiveIntensity: 8.0,
    temperature: 8000
  },
  [ParticleMaterialType.PLASMA]: {
    roughness: 0.05,
    metalness: 0.7,
    emissiveIntensity: 5.0,
    temperature: 10000
  },
  [ParticleMaterialType.CRYSTAL]: {
    roughness: 0.02,
    metalness: 0.6,
    emissiveIntensity: 2.5,
    temperature: 7000
  }
};

/**
 * 鏍规嵁鑹叉俯璁＄畻 RGB 棰滆壊 (Planckian Locus)
 * 鍩轰簬 Tanner Helland 鐨勮繎浼肩畻娉?
 */
export function temperatureToRGB(kelvin: number): { r: number; g: number; b: number } {
  const temp = kelvin / 100;
  let r: number, g: number, b: number;
  
  // 绾㈣壊閫氶亾
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  
  // 缁胯壊閫氶亾
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  
  // 钃濊壊閫氶亾
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  
  return {
    r: r / 255,
    g: g / 255,
    b: b / 255
  };
}

/**
 * HDR 棰滆壊澶勭悊 - 鏀寔瓒呰繃 1.0 鐨勪寒搴?
 */
export function createHDRColor(
  hue: number,
  saturation: number,
  intensity: number
): THREE.Color {
  const color = new THREE.Color();
  color.setHSL(hue / 360, saturation, 0.5);
  
  // HDR 寮哄害锛氬厑璁歌秴杩?1.0
  color.r *= intensity;
  color.g *= intensity;
  color.b *= intensity;
  
  return color;
}

/**
 * 鍒涘缓楂樼骇绮掑瓙鏉愯川鐫€鑹插櫒
 * 鏀寔锛歅BR 灞炴€с€丠DR銆佽嚜鍙戝厜銆佹煍鍜岃竟缂?
 */
export function createAdvancedParticleMaterial(): THREE.ShaderMaterial {
  const vertexShader = `
    attribute float size;
    attribute float alpha;
    attribute vec3 particleColor;
    attribute float roughness;
    attribute float metalness;
    attribute float emissive;
    
    varying vec3 vColor;
    varying float vAlpha;
    varying float vRoughness;
    varying float vMetalness;
    varying float vEmissive;
    varying float vDistance;
    
    void main() {
      vColor = particleColor;
      vAlpha = alpha;
      vRoughness = roughness;
      vMetalness = metalness;
      vEmissive = emissive;
      
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      vDistance = -mvPosition.z;
      
      // 鍩轰簬璺濈鐨勫ぇ灏忚“鍑?(鏇寸墿鐞嗗噯纭?
      float sizeAttenuation = 300.0 / (-mvPosition.z);
      gl_PointSize = size * sizeAttenuation;
      gl_PointSize = clamp(gl_PointSize, 1.0, 128.0);
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `;
  
  const fragmentShader = `
    varying vec3 vColor;
    varying float vAlpha;
    varying float vRoughness;
    varying float vMetalness;
    varying float vEmissive;
    varying float vDistance;
    
    // 鍩轰簬鐗╃悊鐨勫厜鐓ц绠?
    vec3 fresnelSchlick(float cosTheta, vec3 F0) {
      return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    }
    
    void main() {
      // 璁＄畻鐐圭簿鐏电殑鍦嗗舰閬僵
      vec2 center = gl_PointCoord - vec2(0.5);
      float dist = length(center);
      
      // 鏌斿拰杈圭紭 - 楂樻柉琛板噺
      float softness = 0.5 - vRoughness * 0.3; // 绮楃硻搴﹁秺楂橈紝杈圭紭瓒婃煍鍜?
      float edgeFalloff = 1.0 - smoothstep(0.0, softness, dist);
      
      // 鏍稿績鍏夋檿 (鑷彂鍏夋晥鏋?
      float coreGlow = exp(-dist * dist * 8.0) * vEmissive;
      
      // PBR 璁＄畻 - 绠€鍖栫殑 Fresnel 鏁堟灉
      vec3 baseColor = vColor;
      vec3 F0 = mix(vec3(0.04), baseColor, vMetalness);
      
      // 妯℃嫙浠庝腑蹇冨悜澶栫湅鐨?Fresnel
      float fresnel = pow(1.0 - max(0.0, 1.0 - dist * 2.0), 5.0);
      vec3 fresnelColor = mix(baseColor, vec3(1.0), fresnel * vMetalness);
      
      // 鏈€缁堥鑹?= 鍩虹鑹?+ 鏍稿績鍏夋檿 + Fresnel 楂樺厜
      vec3 finalColor = fresnelColor + vec3(coreGlow);
      
      // HDR 杈撳嚭 (涓?clamp锛岃鍚庢湡澶勭悊鐨?tone mapping 鏉ュ鐞?
      float finalAlpha = edgeFalloff * vAlpha;
      
      // 涓㈠純閫忔槑鍍忕礌
      if (finalAlpha < 0.01) discard;
      
      gl_FragColor = vec4(finalColor, finalAlpha);
    }
  `;
  
  return new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    uniforms: {}
  });
}

/**
 * 鍒涘缓鐢ㄤ簬 PointsMaterial 鐨勯珮璐ㄩ噺绮掑瓙璐村浘
 * 鍏锋湁 PBR 椋庢牸鐨勬煍鍜屾笎鍙樺拰鏍稿績鍏夋檿
 */
export function createPBRParticleTexture(resolution: number = 128): THREE.CanvasTexture {
  const canvas = document.createElement('canvas');
  canvas.width = resolution;
  canvas.height = resolution;
  const ctx = canvas.getContext('2d')!;
  
  const center = resolution / 2;
  
  // 澶氬眰娓愬彉瀹炵幇 HDR 鏁堟灉
  // 绗竴灞傦細鏍稿績鍏夋檿 (楂樺己搴?
  const coreGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.3);
  coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
  coreGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
  coreGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');
  coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = coreGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  // 绗簩灞傦細涓诲厜鏅?(涓瓑寮哄害)
  const mainGradient = ctx.createRadialGradient(center, center, 0, center, center, center * 0.6);
  mainGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
  mainGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)');
  mainGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
  mainGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = mainGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  // 绗笁灞傦細澶栧眰鏌斿拰杈圭紭
  const outerGradient = ctx.createRadialGradient(center, center, 0, center, center, center);
  outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
  outerGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
  outerGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.02)');
  outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  
  ctx.fillStyle = outerGradient;
  ctx.fillRect(0, 0, resolution, resolution);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
}

/**
 * 鍒涘缓甯﹀彂鍏夋晥鏋滅殑鍦伴潰锛岀敤浜庢帴鏀剁儫鑺卞厜绾垮弽灏?
 */
export function createReflectiveGround(width: number = 8000, height: number = 8000): THREE.Mesh {
  const geometry = new THREE.PlaneGeometry(width, height);
  
  const material = new THREE.MeshStandardMaterial({
    color: 0x1a1a2e,
    roughness: 0.7,
    metalness: 0.3,
    transparent: true,
    opacity: 0.6,
    envMapIntensity: 0.5
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.y = -10;
  mesh.receiveShadow = true;
  
  return mesh;
}

/**
 * 鏉愯川绠＄悊鍣?- 绠＄悊鎵€鏈?PBR 鏉愯川鐨勭敓鍛藉懆鏈?
 */
export class PBRMaterialManager {
  private materials: Map<string, THREE.Material> = new Map();
  private textures: Map<string, THREE.Texture> = new Map();
  
  constructor() {
    // 棰勫垱寤哄父鐢ㄧ汗鐞?
    this.textures.set('particle_pbr', createPBRParticleTexture(128));
    this.textures.set('particle_pbr_hd', createPBRParticleTexture(256));
  }
  
  /**
   * 鑾峰彇绮掑瓙 PBR 璐村浘
   */
  getParticleTexture(highQuality: boolean = false): THREE.Texture {
    return this.textures.get(highQuality ? 'particle_pbr_hd' : 'particle_pbr')!;
  }
  
  /**
   * 鑾峰彇棰勮鐨?PBR 灞炴€?
   */
  getPreset(type: ParticleMaterialType): ParticlePBRProperties {
    return { ...PBR_PRESETS[type] };
  }
  
  /**
   * 娣峰悎涓ょ鏉愯川灞炴€?
   */
  blendPresets(
    typeA: ParticleMaterialType,
    typeB: ParticleMaterialType,
    factor: number
  ): ParticlePBRProperties {
    const a = PBR_PRESETS[typeA];
    const b = PBR_PRESETS[typeB];
    const t = Math.max(0, Math.min(1, factor));
    
    return {
      roughness: a.roughness * (1 - t) + b.roughness * t,
      metalness: a.metalness * (1 - t) + b.metalness * t,
      emissiveIntensity: a.emissiveIntensity * (1 - t) + b.emissiveIntensity * t,
      temperature: a.temperature * (1 - t) + b.temperature * t
    };
  }
  
  /**
   * 娓呯悊鏉愯川璧勬簮
   */
  dispose(): void {
    this.materials.forEach(mat => mat.dispose());
    this.textures.forEach(tex => tex.dispose());
    this.materials.clear();
    this.textures.clear();
  }
}

/**
 * 鍏ㄥ眬鏉愯川绠＄悊鍣ㄥ崟渚?
 */
let globalMaterialManager: PBRMaterialManager | null = null;

export function getPBRMaterialManager(): PBRMaterialManager {
  if (!globalMaterialManager) {
    globalMaterialManager = new PBRMaterialManager();
  }
  return globalMaterialManager;
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\PhysicsEngine.ts ======
/**
 * PhysicsEngine.ts - 椤剁骇鐗╃悊寮曟搸
 * 
 * 鍔熻兘鐗规€э細
 * - Verlet 绉垎鍣?(鏃犳潯浠剁ǔ瀹?
 * - Sub-stepping (甯у唴澶氭鐗╃悊璁＄畻)
 * - RK4 绉垎鍣ㄦ敮鎸?(榫欐牸-搴撳娉?
 * 
 * 鐩爣锛氬嵆浣垮湪浣庡抚鐜囦笅锛岀儫鑺辫建杩逛篃涓濇粦濡傜桓缂?
 */

import { Vector3 } from './Vector3';

/**
 * 绉垎鍣ㄦ帴鍙?- 鎵€鏈夌Н鍒嗗櫒蹇呴』瀹炵幇
 */
export interface Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 };
}

/**
 * 娆ф媺绉垎鍣?(鏈寸礌鐗堟湰锛屼綔涓哄姣斿弬鑰?
 */
export class EulerIntegrator implements Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 } {
    const a = acceleration(position, velocity);
    
    const newVelocity = new Vector3(
      velocity.x + a.x * dt,
      velocity.y + a.y * dt,
      velocity.z + a.z * dt
    );
    
    const newPosition = new Vector3(
      position.x + newVelocity.x * dt,
      position.y + newVelocity.y * dt,
      position.z + newVelocity.z * dt
    );
    
    return { position: newPosition, velocity: newVelocity };
  }
}

/**
 * Verlet 绉垎鍣?- 鏃堕棿鍙€? 鑳介噺瀹堟亽, 浣嶇疆绮剧‘搴︽瀬楂?
 * 鐗圭偣锛氬浜庨暱鏃堕棿妯℃嫙姣旀鎷夋硶绋冲畾寰楀
 */
export class VerletIntegrator implements Integrator {
  private previousPositions: WeakMap<object, Vector3> = new WeakMap();
  
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number,
    particleRef?: object
  ): { position: Vector3; velocity: Vector3 } {
    // 瀵逛簬棣栨璋冪敤锛屼娇鐢ㄦ鎷夋硶鍒濆鍖?
    let prevPos = particleRef ? this.previousPositions.get(particleRef) : null;
    
    if (!prevPos) {
      // 棣栨杩唬锛氫娇鐢ㄥ弽鍚戞鎷変及璁′箣鍓嶇殑浣嶇疆
      prevPos = new Vector3(
        position.x - velocity.x * dt,
        position.y - velocity.y * dt,
        position.z - velocity.z * dt
      );
    }
    
    const a = acceleration(position, velocity);
    
    // Verlet 绉垎: x(t+dt) = 2*x(t) - x(t-dt) + a*dt^2
    const newPosition = new Vector3(
      2 * position.x - prevPos.x + a.x * dt * dt,
      2 * position.y - prevPos.y + a.y * dt * dt,
      2 * position.z - prevPos.z + a.z * dt * dt
    );
    
    // 浠庝綅缃樊鎺ㄥ閫熷害 (鐢ㄤ簬鍏朵粬绯荤粺濡傜鎾炴娴?
    const newVelocity = new Vector3(
      (newPosition.x - position.x) / dt,
      (newPosition.y - position.y) / dt,
      (newPosition.z - position.z) / dt
    );
    
    // 缂撳瓨褰撳墠浣嶇疆渚涗笅娆′娇鐢?
    if (particleRef) {
      this.previousPositions.set(particleRef, position.clone());
    }
    
    return { position: newPosition, velocity: newVelocity };
  }
  
  /**
   * 娓呯悊缂撳瓨鐨勪綅缃俊鎭?
   */
  clearCache(particleRef: object): void {
    this.previousPositions.delete(particleRef);
  }
}

/**
 * RK4 绉垎鍣?(榫欐牸-搴撳 4闃舵硶) - 绮惧害鏈€楂?
 * 鐗圭偣锛氬洓娆￠噰鏍凤紝璇樊 O(dt^5)锛屼絾璁＄畻閲忔槸娆ф媺娉曠殑4鍊?
 */
export class RK4Integrator implements Integrator {
  integrate(
    position: Vector3,
    velocity: Vector3,
    acceleration: (pos: Vector3, vel: Vector3) => Vector3,
    dt: number
  ): { position: Vector3; velocity: Vector3 } {
    // 鐘舵€?= [position, velocity]
    // 瀵兼暟 = [velocity, acceleration]
    
    // k1: 璧风偣鐨勬枩鐜?
    const a1 = acceleration(position, velocity);
    const k1_pos = velocity.clone();
    const k1_vel = a1.clone();
    
    // k2: 涓偣鐨勬枩鐜?(浣跨敤 k1)
    const pos2 = new Vector3(
      position.x + k1_pos.x * dt * 0.5,
      position.y + k1_pos.y * dt * 0.5,
      position.z + k1_pos.z * dt * 0.5
    );
    const vel2 = new Vector3(
      velocity.x + k1_vel.x * dt * 0.5,
      velocity.y + k1_vel.y * dt * 0.5,
      velocity.z + k1_vel.z * dt * 0.5
    );
    const a2 = acceleration(pos2, vel2);
    const k2_pos = vel2.clone();
    const k2_vel = a2.clone();
    
    // k3: 鍙︿竴涓腑鐐圭殑鏂滅巼 (浣跨敤 k2)
    const pos3 = new Vector3(
      position.x + k2_pos.x * dt * 0.5,
      position.y + k2_pos.y * dt * 0.5,
      position.z + k2_pos.z * dt * 0.5
    );
    const vel3 = new Vector3(
      velocity.x + k2_vel.x * dt * 0.5,
      velocity.y + k2_vel.y * dt * 0.5,
      velocity.z + k2_vel.z * dt * 0.5
    );
    const a3 = acceleration(pos3, vel3);
    const k3_pos = vel3.clone();
    const k3_vel = a3.clone();
    
    // k4: 缁堢偣鐨勬枩鐜?(浣跨敤 k3)
    const pos4 = new Vector3(
      position.x + k3_pos.x * dt,
      position.y + k3_pos.y * dt,
      position.z + k3_pos.z * dt
    );
    const vel4 = new Vector3(
      velocity.x + k3_vel.x * dt,
      velocity.y + k3_vel.y * dt,
      velocity.z + k3_vel.z * dt
    );
    const a4 = acceleration(pos4, vel4);
    const k4_pos = vel4.clone();
    const k4_vel = a4.clone();
    
    // 鍔犳潈骞冲潎
    const newPosition = new Vector3(
      position.x + (k1_pos.x + 2 * k2_pos.x + 2 * k3_pos.x + k4_pos.x) * dt / 6,
      position.y + (k1_pos.y + 2 * k2_pos.y + 2 * k3_pos.y + k4_pos.y) * dt / 6,
      position.z + (k1_pos.z + 2 * k2_pos.z + 2 * k3_pos.z + k4_pos.z) * dt / 6
    );
    
    const newVelocity = new Vector3(
      velocity.x + (k1_vel.x + 2 * k2_vel.x + 2 * k3_vel.x + k4_vel.x) * dt / 6,
      velocity.y + (k1_vel.y + 2 * k2_vel.y + 2 * k3_vel.y + k4_vel.y) * dt / 6,
      velocity.z + (k1_vel.z + 2 * k2_vel.z + 2 * k3_vel.z + k4_vel.z) * dt / 6
    );
    
    return { position: newPosition, velocity: newVelocity };
  }
}

/**
 * 绉垎鍣ㄧ被鍨嬫灇涓?
 */
export enum IntegratorType {
  EULER = 'euler',
  VERLET = 'verlet',
  RK4 = 'rk4'
}

/**
 * 鐗╃悊涓栫晫閰嶇疆
 */
export interface PhysicsConfig {
  integrator: IntegratorType;
  subSteps: number;        // Sub-stepping 娆℃暟 (1 = 鏃?sub-stepping)
  fixedTimeStep: number;   // 鍥哄畾鏃堕棿姝ラ暱 (绉?
  maxDeltaTime: number;    // 鏈€澶у抚闂撮殧 (闃叉鐖嗙偢)
}

/**
 * 榛樿鐗╃悊閰嶇疆 - 楂樿川閲忚缃?
 */
export const DEFAULT_PHYSICS_CONFIG: PhysicsConfig = {
  integrator: IntegratorType.VERLET,
  subSteps: 4,             // 姣忓抚 4 娆＄墿鐞嗘洿鏂?
  fixedTimeStep: 1/240,    // 240Hz 鐗╃悊鏇存柊鐜?
  maxDeltaTime: 1/30       // 鏈€澶?33ms (30fps 淇濇姢)
};

/**
 * 鐗╃悊寮曟搸 - 缁熶竴绠＄悊鎵€鏈夌墿鐞嗚绠?
 */
export class PhysicsEngine {
  private config: PhysicsConfig;
  private integrator: Integrator;
  private accumulator: number = 0;
  
  constructor(config: Partial<PhysicsConfig> = {}) {
    this.config = { ...DEFAULT_PHYSICS_CONFIG, ...config };
    this.integrator = this.createIntegrator(this.config.integrator);
  }
  
  private createIntegrator(type: IntegratorType): Integrator {
    switch (type) {
      case IntegratorType.EULER:
        return new EulerIntegrator();
      case IntegratorType.VERLET:
        return new VerletIntegrator();
      case IntegratorType.RK4:
        return new RK4Integrator();
      default:
        return new VerletIntegrator();
    }
  }
  
  /**
   * 鏇存柊閰嶇疆
   */
  setConfig(config: Partial<PhysicsConfig>): void {
    this.config = { ...this.config, ...config };
    if (config.integrator) {
      this.integrator = this.createIntegrator(config.integrator);
    }
  }
  
  /**
   * 鑾峰彇褰撳墠绉垎鍣?
   */
  getIntegrator(): Integrator {
    return this.integrator;
  }
  
  /**
   * 甯?Sub-stepping 鐨勭墿鐞嗘洿鏂?
   * 
   * @param deltaTime 瀹為檯甯ф椂闂?
   * @param updateFn 姣忎釜鐗╃悊姝ラ鐨勬洿鏂板嚱鏁?
   */
  update(deltaTime: number, updateFn: (subDt: number) => void): void {
    // 闄愬埗鏈€澶ф椂闂存闀块槻姝㈢垎鐐?
    const clampedDelta = Math.min(deltaTime, this.config.maxDeltaTime);
    
    // 绱Н鏃堕棿
    this.accumulator += clampedDelta;
    
    const subDt = this.config.fixedTimeStep;
    const maxSteps = this.config.subSteps * 2; // 闃叉姝诲惊鐜?
    let steps = 0;
    
    // 鍥哄畾鏃堕棿姝ラ暱鏇存柊
    while (this.accumulator >= subDt && steps < maxSteps) {
      updateFn(subDt);
      this.accumulator -= subDt;
      steps++;
    }
    
    // 濡傛灉杩樻湁鍓╀綑鏃堕棿锛岃繘琛屼竴娆℃彃鍊兼洿鏂?
    if (this.accumulator > 0 && steps < maxSteps) {
      // 鍙€夛細杩涜閮ㄥ垎姝ラ暱鏇存柊浠ヨ幏寰楁洿骞虫粦鐨勮瑙夋晥鏋?
      // updateFn(this.accumulator);
      // this.accumulator = 0;
    }
  }
  
  /**
   * 绠€鍖栫増鏇存柊 - 鐩存帴浣跨敤 sub-stepping
   */
  updateSimple(deltaTime: number, updateFn: (subDt: number) => void): void {
    const clampedDelta = Math.min(deltaTime, this.config.maxDeltaTime);
    const subDt = clampedDelta / this.config.subSteps;
    
    for (let i = 0; i < this.config.subSteps; i++) {
      updateFn(subDt);
    }
  }
  
  /**
   * 璁＄畻鍗曚釜绮掑瓙鐨勭墿鐞嗘洿鏂?
   */
  integrateParticle(
    position: Vector3,
    velocity: Vector3,
    gravity: number,
    friction: number,
    resistance: number,
    dt: number,
    particleRef?: object
  ): { position: Vector3; velocity: Vector3 } {
    // 鍔犻€熷害鍑芥暟
    const accelerationFn = (pos: Vector3, vel: Vector3): Vector3 => {
      // 閲嶅姏
      const grav = new Vector3(0, -gravity, 0);
      
      // 绌烘皵闃诲姏 (涓庨€熷害骞虫柟鎴愭姣?
      const speed = vel.length();
      const drag = new Vector3();
      if (speed > 0.001) {
        const dragMag = speed * speed * resistance;
        drag.x = -(vel.x / speed) * dragMag;
        drag.y = -(vel.y / speed) * dragMag;
        drag.z = -(vel.z / speed) * dragMag;
      }
      
      return new Vector3(
        grav.x + drag.x,
        grav.y + drag.y,
        grav.z + drag.z
      );
    };
    
    // 浣跨敤閫夊畾鐨勭Н鍒嗗櫒
    const result = (this.integrator as any).integrate(
      position, velocity, accelerationFn, dt, particleRef
    );
    
    // 搴旂敤鎽╂摝鍔?(閫熷害琛板噺)
    const frictionFactor = Math.pow(friction, dt * 60);
    result.velocity.x *= frictionFactor;
    result.velocity.y *= frictionFactor;
    result.velocity.z *= frictionFactor;
    
    return result;
  }
}

/**
 * 鍏ㄥ眬鐗╃悊寮曟搸鍗曚緥
 */
let globalPhysicsEngine: PhysicsEngine | null = null;

export function getPhysicsEngine(): PhysicsEngine {
  if (!globalPhysicsEngine) {
    globalPhysicsEngine = new PhysicsEngine();
  }
  return globalPhysicsEngine;
}

export function setPhysicsEngine(engine: PhysicsEngine): void {
  globalPhysicsEngine = engine;
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\PostProcessingStack.ts ======
/**
 * PostProcessingStack.ts - 鐢靛奖绾у悗鏈熷鐞嗙绾?
 * 
 * 鍔熻兘鐗规€э細
 * - Unreal Bloom (铏氬够寮曟搸绾у埆鐨勮緣鍏?
 * - Chromatic Aberration (鑹插樊/绱竟鏁堟灉)
 * - Tone Mapping (HDR 鈫?SDR 鑹茶皟鏄犲皠)
 * - Film Grain (鍙€夌數褰卞櫔鐐?
 * - Vignette (鏆楄)
 * 
 * 杩欎簺鏁堟灉缁勫悎鍦ㄤ竴璧凤紝璁╃敾闈㈠叿鏈夌湡瀹炴憚褰辨満鐨勮川鎰?
 */

import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass';
import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass';

/**
 * 鑹插樊鐫€鑹插櫒 (Chromatic Aberration)
 * 妯℃嫙闀滃ご杈圭紭鐨勭孩钃濆垎绂绘晥鏋?
 */
export const ChromaticAberrationShader = {
  name: 'ChromaticAberrationShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.003 },       // 鑹插樊寮哄害
    radialFalloff: { value: 1.5 },     // 浠庝腑蹇冨埌杈圭紭鐨勮“鍑?
    center: { value: new THREE.Vector2(0.5, 0.5) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float radialFalloff;
    uniform vec2 center;
    varying vec2 vUv;
    
    void main() {
      // 璁＄畻浠庝腑蹇冨埌褰撳墠鍍忕礌鐨勮窛绂?
      vec2 toCenter = vUv - center;
      float dist = length(toCenter);
      
      // 寰勫悜琛板噺锛氳竟缂樻晥鏋滄洿寮?
      float aberration = dist * dist * intensity * radialFalloff;
      
      // RGB 閫氶亾鍒嗙
      vec2 redOffset = toCenter * aberration * 1.2;
      vec2 greenOffset = toCenter * aberration * 0.0;  // 缁胯壊閫氶亾涓嶅亸绉?
      vec2 blueOffset = toCenter * aberration * -1.0;
      
      float r = texture2D(tDiffuse, vUv - redOffset).r;
      float g = texture2D(tDiffuse, vUv - greenOffset).g;
      float b = texture2D(tDiffuse, vUv - blueOffset).b;
      
      // 淇濈暀鍘熷 alpha
      float a = texture2D(tDiffuse, vUv).a;
      
      gl_FragColor = vec4(r, g, b, a);
    }
  `
};

/**
 * 楂樼骇鑹茶皟鏄犲皠鐫€鑹插櫒 (ACES Filmic Tone Mapping)
 * 姣?Three.js 鍐呯疆鐨?Reinhard 鏇寸數褰卞寲
 */
export const ACESFilmicToneMappingShader = {
  name: 'ACESFilmicToneMappingShader',
  uniforms: {
    tDiffuse: { value: null },
    exposure: { value: 1.2 },
    saturation: { value: 1.05 },
    contrast: { value: 1.05 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float exposure;
    uniform float saturation;
    uniform float contrast;
    varying vec2 vUv;
    
    // ACES Filmic Tone Mapping Curve
    // 鏉ユ簮: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    vec3 ACESFilm(vec3 x) {
      float a = 2.51;
      float b = 0.03;
      float c = 2.43;
      float d = 0.59;
      float e = 0.14;
      return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
    }
    
    // 楗卞拰搴﹁皟鏁?
    vec3 adjustSaturation(vec3 color, float sat) {
      float grey = dot(color, vec3(0.2126, 0.7152, 0.0722));
      return mix(vec3(grey), color, sat);
    }
    
    // 瀵规瘮搴﹁皟鏁?
    vec3 adjustContrast(vec3 color, float cont) {
      return (color - 0.5) * cont + 0.5;
    }
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // 鏇濆厜璋冩暣
      vec3 color = texel.rgb * exposure;
      
      // ACES 鑹茶皟鏄犲皠
      color = ACESFilm(color);
      
      // 楗卞拰搴﹀拰瀵规瘮搴?
      color = adjustSaturation(color, saturation);
      color = adjustContrast(color, contrast);
      
      gl_FragColor = vec4(color, texel.a);
    }
  `
};

/**
 * 鏆楄鐫€鑹插櫒 (Vignette)
 * 妯℃嫙鐪熷疄闀滃ご杈圭紭鍙樻殫鐨勬晥鏋?
 */
export const VignetteShader = {
  name: 'VignetteShader',
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.3 },
    smoothness: { value: 0.5 },
    center: { value: new THREE.Vector2(0.5, 0.5) }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform float smoothness;
    uniform vec2 center;
    varying vec2 vUv;
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // 璁＄畻鍒颁腑蹇冪殑璺濈
      vec2 toCenter = (vUv - center) * 2.0;
      float dist = length(toCenter);
      
      // 鏌斿拰鐨勬殫瑙掕“鍑?
      float vignette = 1.0 - smoothstep(1.0 - smoothness, 1.0, dist * intensity);
      
      gl_FragColor = vec4(texel.rgb * vignette, texel.a);
    }
  `
};

/**
 * 鐢靛奖鍣偣鐫€鑹插櫒 (Film Grain)
 * 澧炲姞鐢靛奖璐ㄦ劅鐨勭粏寰櫔鐐?
 */
export const FilmGrainShader = {
  name: 'FilmGrainShader',
  uniforms: {
    tDiffuse: { value: null },
    time: { value: 0 },
    intensity: { value: 0.05 },
    luminanceThreshold: { value: 0.2 }  // 鍙湪鏆楅儴娣诲姞鍣偣
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float time;
    uniform float intensity;
    uniform float luminanceThreshold;
    varying vec2 vUv;
    
    // 浼殢鏈烘暟鐢熸垚
    float random(vec2 co) {
      return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
    }
    
    void main() {
      vec4 texel = texture2D(tDiffuse, vUv);
      
      // 璁＄畻浜害
      float luminance = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
      
      // 鍣偣寮哄害闅忎寒搴﹂檷浣庤€屽鍔?
      float noiseStrength = (1.0 - smoothstep(0.0, luminanceThreshold, luminance)) * intensity;
      
      // 鐢熸垚鍔ㄦ€佸櫔鐐?
      float noise = random(vUv + vec2(time * 0.1)) * 2.0 - 1.0;
      
      vec3 result = texel.rgb + noise * noiseStrength;
      
      gl_FragColor = vec4(result, texel.a);
    }
  `
};

/**
 * 鍚庢湡澶勭悊閰嶇疆鎺ュ彛
 */
export interface PostProcessingConfig {
  // Bloom 璁剧疆
  bloomEnabled: boolean;
  bloomStrength: number;     // 0-3
  bloomRadius: number;       // 0-1
  bloomThreshold: number;    // 0-1
  
  // 鑹插樊璁剧疆
  chromaticAberrationEnabled: boolean;
  chromaticAberrationIntensity: number;  // 0-0.02
  
  // 鑹茶皟鏄犲皠璁剧疆
  toneMappingEnabled: boolean;
  exposure: number;          // 0.5-2.0
  saturation: number;        // 0.5-1.5
  contrast: number;          // 0.8-1.2
  
  // 鏆楄璁剧疆
  vignetteEnabled: boolean;
  vignetteIntensity: number; // 0-1
  
  // 鍣偣璁剧疆
  filmGrainEnabled: boolean;
  filmGrainIntensity: number; // 0-0.15
}

/**
 * 榛樿鍚庢湡澶勭悊閰嶇疆 - 鐢靛奖绾ц川閲?
 */
export const DEFAULT_POST_PROCESSING_CONFIG: PostProcessingConfig = {
  bloomEnabled: true,
  bloomStrength: 1.5,
  bloomRadius: 0.4,
  bloomThreshold: 0.2,
  
  chromaticAberrationEnabled: true,
  chromaticAberrationIntensity: 0.004,
  
  toneMappingEnabled: true,
  exposure: 1.3,
  saturation: 1.08,
  contrast: 1.05,
  
  vignetteEnabled: true,
  vignetteIntensity: 0.35,
  
  filmGrainEnabled: false,  // 榛樿鍏抽棴锛屽彲閫夊紑鍚?
  filmGrainIntensity: 0.03
};

/**
 * 楂樻€ц兘棰勮 - 鐗虹壊閮ㄥ垎鏁堟灉鎹㈠彇鎬ц兘
 */
export const PERFORMANCE_POST_PROCESSING_CONFIG: PostProcessingConfig = {
  bloomEnabled: true,
  bloomStrength: 1.2,
  bloomRadius: 0.3,
  bloomThreshold: 0.3,
  
  chromaticAberrationEnabled: false,
  chromaticAberrationIntensity: 0,
  
  toneMappingEnabled: true,
  exposure: 1.2,
  saturation: 1.0,
  contrast: 1.0,
  
  vignetteEnabled: false,
  vignetteIntensity: 0,
  
  filmGrainEnabled: false,
  filmGrainIntensity: 0
};

/**
 * 鐢靛奖绾у悗鏈熷鐞嗘爤
 */
export class PostProcessingStack {
  private composer: EffectComposer;
  private renderPass: RenderPass;
  private bloomPass: UnrealBloomPass;
  private chromaticPass: ShaderPass;
  private toneMappingPass: ShaderPass;
  private vignettePass: ShaderPass;
  private filmGrainPass: ShaderPass;
  private outputPass: OutputPass;
  
  private config: PostProcessingConfig;
  private startTime: number;
  
  constructor(
    renderer: THREE.WebGLRenderer,
    scene: THREE.Scene,
    camera: THREE.Camera,
    config: Partial<PostProcessingConfig> = {}
  ) {
    this.config = { ...DEFAULT_POST_PROCESSING_CONFIG, ...config };
    this.startTime = performance.now();
    
    // 閰嶇疆娓叉煋鍣?
    renderer.toneMapping = THREE.NoToneMapping;  // 鎴戜滑鐢ㄨ嚜瀹氫箟鑹茶皟鏄犲皠
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    
    // 鍒涘缓 Effect Composer
    this.composer = new EffectComposer(renderer);
    
    // 1. 娓叉煋閫氶亾
    this.renderPass = new RenderPass(scene, camera);
    this.composer.addPass(this.renderPass);
    
    // 2. Unreal Bloom 閫氶亾
    const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
    this.bloomPass = new UnrealBloomPass(
      resolution,
      this.config.bloomStrength,
      this.config.bloomRadius,
      this.config.bloomThreshold
    );
    this.bloomPass.enabled = this.config.bloomEnabled;
    this.composer.addPass(this.bloomPass);
    
    // 3. 鑹插樊閫氶亾
    this.chromaticPass = new ShaderPass(ChromaticAberrationShader);
    this.chromaticPass.uniforms.intensity.value = this.config.chromaticAberrationIntensity;
    this.chromaticPass.enabled = this.config.chromaticAberrationEnabled;
    this.composer.addPass(this.chromaticPass);
    
    // 4. 鑹茶皟鏄犲皠閫氶亾
    this.toneMappingPass = new ShaderPass(ACESFilmicToneMappingShader);
    this.toneMappingPass.uniforms.exposure.value = this.config.exposure;
    this.toneMappingPass.uniforms.saturation.value = this.config.saturation;
    this.toneMappingPass.uniforms.contrast.value = this.config.contrast;
    this.toneMappingPass.enabled = this.config.toneMappingEnabled;
    this.composer.addPass(this.toneMappingPass);
    
    // 5. 鏆楄閫氶亾
    this.vignettePass = new ShaderPass(VignetteShader);
    this.vignettePass.uniforms.intensity.value = this.config.vignetteIntensity;
    this.vignettePass.enabled = this.config.vignetteEnabled;
    this.composer.addPass(this.vignettePass);
    
    // 6. 鐢靛奖鍣偣閫氶亾
    this.filmGrainPass = new ShaderPass(FilmGrainShader);
    this.filmGrainPass.uniforms.intensity.value = this.config.filmGrainIntensity;
    this.filmGrainPass.enabled = this.config.filmGrainEnabled;
    this.composer.addPass(this.filmGrainPass);
    
    // 7. 杈撳嚭閫氶亾 (棰滆壊绌洪棿杞崲)
    this.outputPass = new OutputPass();
    this.composer.addPass(this.outputPass);
  }
  
  /**
   * 鏇存柊閰嶇疆
   */
  setConfig(config: Partial<PostProcessingConfig>): void {
    this.config = { ...this.config, ...config };
    
    // 鏇存柊 Bloom
    if (config.bloomEnabled !== undefined) this.bloomPass.enabled = config.bloomEnabled;
    if (config.bloomStrength !== undefined) this.bloomPass.strength = config.bloomStrength;
    if (config.bloomRadius !== undefined) this.bloomPass.radius = config.bloomRadius;
    if (config.bloomThreshold !== undefined) this.bloomPass.threshold = config.bloomThreshold;
    
    // 鏇存柊鑹插樊
    if (config.chromaticAberrationEnabled !== undefined) {
      this.chromaticPass.enabled = config.chromaticAberrationEnabled;
    }
    if (config.chromaticAberrationIntensity !== undefined) {
      this.chromaticPass.uniforms.intensity.value = config.chromaticAberrationIntensity;
    }
    
    // 鏇存柊鑹茶皟鏄犲皠
    if (config.toneMappingEnabled !== undefined) {
      this.toneMappingPass.enabled = config.toneMappingEnabled;
    }
    if (config.exposure !== undefined) {
      this.toneMappingPass.uniforms.exposure.value = config.exposure;
    }
    if (config.saturation !== undefined) {
      this.toneMappingPass.uniforms.saturation.value = config.saturation;
    }
    if (config.contrast !== undefined) {
      this.toneMappingPass.uniforms.contrast.value = config.contrast;
    }
    
    // 鏇存柊鏆楄
    if (config.vignetteEnabled !== undefined) {
      this.vignettePass.enabled = config.vignetteEnabled;
    }
    if (config.vignetteIntensity !== undefined) {
      this.vignettePass.uniforms.intensity.value = config.vignetteIntensity;
    }
    
    // 鏇存柊鍣偣
    if (config.filmGrainEnabled !== undefined) {
      this.filmGrainPass.enabled = config.filmGrainEnabled;
    }
    if (config.filmGrainIntensity !== undefined) {
      this.filmGrainPass.uniforms.intensity.value = config.filmGrainIntensity;
    }
  }
  
  /**
   * 鑾峰彇褰撳墠閰嶇疆
   */
  getConfig(): PostProcessingConfig {
    return { ...this.config };
  }
  
  /**
   * 娓叉煋甯?
   */
  render(): void {
    // 鏇存柊鍔ㄦ€?uniforms
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.filmGrainPass.uniforms.time.value = elapsed;
    
    this.composer.render();
  }
  
  /**
   * 鏇存柊灏哄
   */
  setSize(width: number, height: number): void {
    this.composer.setSize(width, height);
    this.bloomPass.setSize(width, height);
  }
  
  /**
   * 鑾峰彇 Effect Composer (鐢ㄤ簬楂樼骇鑷畾涔?
   */
  getComposer(): EffectComposer {
    return this.composer;
  }
  
  /**
   * 鑾峰彇鍚勪釜閫氶亾鐨勫紩鐢?
   */
  getPasses() {
    return {
      render: this.renderPass,
      bloom: this.bloomPass,
      chromatic: this.chromaticPass,
      toneMapping: this.toneMappingPass,
      vignette: this.vignettePass,
      filmGrain: this.filmGrainPass,
      output: this.outputPass
    };
  }
  
  /**
   * 娓呯悊璧勬簮
   */
  dispose(): void {
    this.composer.dispose();
  }
}

/**
 * 鍒涘缓绠€鍖栫増鍚庢湡澶勭悊鏍?(鐢ㄤ簬蹇€熼泦鎴?
 */
export function createSimplePostProcessing(
  renderer: THREE.WebGLRenderer,
  scene: THREE.Scene,
  camera: THREE.Camera,
  quality: 'cinematic' | 'performance' | 'minimal' = 'cinematic'
): PostProcessingStack {
  const configs: Record<string, Partial<PostProcessingConfig>> = {
    cinematic: DEFAULT_POST_PROCESSING_CONFIG,
    performance: PERFORMANCE_POST_PROCESSING_CONFIG,
    minimal: {
      bloomEnabled: true,
      bloomStrength: 1.0,
      bloomRadius: 0.3,
      bloomThreshold: 0.4,
      chromaticAberrationEnabled: false,
      toneMappingEnabled: true,
      exposure: 1.1,
      saturation: 1.0,
      contrast: 1.0,
      vignetteEnabled: false,
      filmGrainEnabled: false
    }
  };
  
  return new PostProcessingStack(renderer, scene, camera, configs[quality]);
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\TimeController.ts ======
/**
 * TimeController - Controls the flow of time in the 3D world
 * Allows pausing, slow motion, and time acceleration
 */
export class TimeController {
  private _timeScale: number = 1;
  private _isPaused: boolean = false;
  private _lastRealTime: number = 0;
  private _virtualTime: number = 0;
  private _deltaTime: number = 0;

  // Preset time scales
  static readonly PAUSED = 0;
  static readonly SLOW_MOTION = 0.2;
  static readonly NORMAL = 1;
  static readonly FAST = 2;
  static readonly ULTRA_FAST = 5;

  constructor() {
    this._lastRealTime = performance.now();
  }

  /**
   * Update the time controller - call this every frame
   */
  update(): void {
    const currentRealTime = performance.now();
    const realDelta = (currentRealTime - this._lastRealTime) / 1000; // Convert to seconds
    this._lastRealTime = currentRealTime;

    if (this._isPaused) {
      this._deltaTime = 0;
    } else {
      this._deltaTime = realDelta * this._timeScale;
      this._virtualTime += this._deltaTime;
    }
  }

  /**
   * Get the delta time adjusted for time scale
   */
  get deltaTime(): number {
    return this._deltaTime;
  }

  /**
   * Get the virtual time in the simulation
   */
  get virtualTime(): number {
    return this._virtualTime;
  }

  /**
   * Get the current time scale
   */
  get timeScale(): number {
    return this._timeScale;
  }

  /**
   * Set the time scale (0 = paused, 1 = normal, 2 = double speed, etc.)
   */
  set timeScale(value: number) {
    this._timeScale = Math.max(0, Math.min(10, value));
    if (this._timeScale === 0) {
      this._isPaused = true;
    } else {
      this._isPaused = false;
    }
  }

  /**
   * Check if the simulation is paused
   */
  get isPaused(): boolean {
    return this._isPaused;
  }

  /**
   * Pause the simulation
   */
  pause(): void {
    this._isPaused = true;
  }

  /**
   * Resume the simulation
   */
  resume(): void {
    this._isPaused = false;
    this._lastRealTime = performance.now();
  }

  /**
   * Toggle pause state
   */
  togglePause(): void {
    if (this._isPaused) {
      this.resume();
    } else {
      this.pause();
    }
  }

  /**
   * Set to slow motion
   */
  setSlowMotion(): void {
    this._timeScale = TimeController.SLOW_MOTION;
    this._isPaused = false;
  }

  /**
   * Set to normal speed
   */
  setNormal(): void {
    this._timeScale = TimeController.NORMAL;
    this._isPaused = false;
  }

  /**
   * Set to fast forward
   */
  setFast(): void {
    this._timeScale = TimeController.FAST;
    this._isPaused = false;
  }

  /**
   * Increase time scale by a step
   */
  speedUp(step: number = 0.25): void {
    this.timeScale = Math.min(10, this._timeScale + step);
  }

  /**
   * Decrease time scale by a step
   */
  slowDown(step: number = 0.25): void {
    this.timeScale = Math.max(0.1, this._timeScale - step);
  }

  /**
   * Get a formatted string of the current time state
   */
  getStatusText(): string {
    if (this._isPaused) return '鈴?宸叉殏鍋?;
    if (this._timeScale < 0.5) return `馃悽 ${this._timeScale.toFixed(2)}x 鎱㈠姩浣渀;
    if (this._timeScale === 1) return '鈻?1x 姝ｅ父';
    if (this._timeScale <= 2) return `鈴?${this._timeScale.toFixed(2)}x`;
    return `馃殌 ${this._timeScale.toFixed(2)}x 瓒呴€焋;
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\Vector2.ts ======

export class Vector2 {
  constructor(public x: number = 0, public y: number = 0) {}

  add(v: Vector2): Vector2 {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  multiply(scalar: number): Vector2 {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  static fromAngle(angle: number, length: number): Vector2 {
    return new Vector2(Math.cos(angle) * length, Math.sin(angle) * length);
  }

  clone(): Vector2 {
    return new Vector2(this.x, this.y);
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\core\Vector3.ts ======
/**
 * 3D Vector class for the 3D firework system
 */
export class Vector3 {
  constructor(
    public x: number = 0,
    public y: number = 0,
    public z: number = 0
  ) {}

  add(v: Vector3): Vector3 {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  sub(v: Vector3): Vector3 {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  multiply(scalar: number): Vector3 {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  // Alias for compatibility with THREE.js-like APIs
  multiplyScalar(scalar: number): Vector3 {
    return this.multiply(scalar);
  }

  length(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  normalize(): Vector3 {
    const len = this.length();
    if (len > 0) {
      this.x /= len;
      this.y /= len;
      this.z /= len;
    }
    return this;
  }

  distanceTo(v: Vector3): number {
    const dx = this.x - v.x;
    const dy = this.y - v.y;
    const dz = this.z - v.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  static fromSpherical(theta: number, phi: number, radius: number): Vector3 {
    return new Vector3(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  clone(): Vector3 {
    return new Vector3(this.x, this.y, this.z);
  }

  toArray(): [number, number, number] {
    return [this.x, this.y, this.z];
  }
}


====== FILE: D:\ALL IN AI\Aetheris\src\types\index.ts ======
// FILE: src/types/index.ts

export enum ExplosionType {
  // === 缁忓吀 ===
  SPHERE = '鏍囧噯鐞冨舰',
  BURST = '楂樹寒鐖嗗彂',
  RING = '鏄熺幆',
  DOUBLE_RING = '鍙屽眰鐜?,
  WILLOW = '閲戞煶鍨備笣',
  STAGED = '瀛愭瘝杩炵垎',
  FLASH = '闆烽渾闂厜',
  GLITTER = '鐠€鐠ㄦ槦灏?,

  // === 鑷劧 ===
  FLOWER = '鐩涗笘鐗′腹',
  BUTTERFLY = '骞诲僵铦磋澏',
  FALLING_LEAVES = '婕ぉ钀藉彾',
  SNOWFLAKE = '鍏闆姳',
  FISH = '閿﹂菠娓稿姩',
  CAT_FACE = '鐚挭绗戣劯',

  // === 鍑犱綍/鎶借薄 ===
  CUBE = '閲忓瓙绔嬫柟',
  PYRAMID = '閲戝瓧濉?,
  STAR = '浜旇鏄?,
  HEART = '鐖卞績',
  HEART_BEAT = '璺冲姩涔嬪績',
  SMILE = '绗戣劯',
  SPIRAL = '闃垮熀绫冲痉',

  // === 瀹忓ぇ ===
  GALAXY = '閾舵渤绯?,
  SATURN = '鍦熸槦鐜?,
  HELIX = 'DNA鍙岃灪鏃?,
  DRAGON = '娓搁緳鎴忕彔',
  GREAT_WALL = '涓囬噷闀垮煄',
  ZODIAC = '鐏佃泧鐙傝垶',
  GHOST = '骞界伒榄呭奖',
  CROSS_STEP = '鍗佸瓧鍙樿壊',

  // === 鍒涙剰 ===
  ATOM = '鍘熷瓙缁撴瀯',
  FAN = '瀛旈泙寮€灞?,
  WATERFALL = '涔濆ぉ鐎戝竷',
  CHAOS = '娣锋矊鐞嗚',
  TEXT_HI = '瀛楀舰:Hi',
  CROWN = '鐨囧啝'
}

// 鍥炬爣鏄犲皠锛氬疄鐜?鍥炬枃骞惰寕"
export const SHAPE_ICONS: Record<ExplosionType, string> = {
  [ExplosionType.SPHERE]: '馃挜', [ExplosionType.BURST]: '鉁?,
  [ExplosionType.RING]: '猸?, [ExplosionType.DOUBLE_RING]: '鈼?,
  [ExplosionType.WILLOW]: '馃帇', [ExplosionType.STAGED]: '馃巻',
  [ExplosionType.FLASH]: '鈿?, [ExplosionType.GLITTER]: '鉁?, [ExplosionType.FLOWER]: '馃尯',
  [ExplosionType.BUTTERFLY]: '馃', [ExplosionType.FALLING_LEAVES]: '馃崅',
  [ExplosionType.SNOWFLAKE]: '鉂勶笍', [ExplosionType.FISH]: '馃悷',
  [ExplosionType.CAT_FACE]: '馃惐', [ExplosionType.CUBE]: '馃',
  [ExplosionType.PYRAMID]: '馃敽', [ExplosionType.STAR]: '猸?,
  [ExplosionType.SMILE]: '馃檪', [ExplosionType.SPIRAL]: '馃崶',
  [ExplosionType.HEART]: '鉂わ笍', [ExplosionType.HEART_BEAT]: '馃挀',
  [ExplosionType.GALAXY]: '馃寣', [ExplosionType.SATURN]: '馃獝', [ExplosionType.HELIX]: '馃К',
  [ExplosionType.DRAGON]: '馃悏', [ExplosionType.GREAT_WALL]: '馃П',
  [ExplosionType.ZODIAC]: '馃悕', [ExplosionType.GHOST]: '馃懟',
  [ExplosionType.CROSS_STEP]: '鉁?, [ExplosionType.ATOM]: '鈿涳笍',
  [ExplosionType.FAN]: '馃', [ExplosionType.WATERFALL]: '馃寠',
  [ExplosionType.CHAOS]: '馃幉', [ExplosionType.TEXT_HI]: 'H',
  [ExplosionType.CROWN]: '馃憫'
};

export enum AscensionType {
  LINEAR = '鐩寸嚎鍗囩┖',
  SPIRAL = '铻烘棆鐩樻棆',
  ZIGZAG = 'S鍨嬫憞鎽?,
  ACCELERATE = '鏋侀€熸帹杩?,
  DRAWING = '绌轰腑缁樺浘',
  WOBBLE = '闅忔満鎵板姩'
}

export const ASCENSION_ICONS: Record<AscensionType, string> = {
  [AscensionType.LINEAR]: '猬嗭笍',
  [AscensionType.SPIRAL]: '馃寑',
  [AscensionType.ZIGZAG]: '銆帮笍',
  [AscensionType.ACCELERATE]: '馃殌',
  [AscensionType.DRAWING]: '馃枌锔?,
  [AscensionType.WOBBLE]: '馃'
};

export enum ColorStyle {
  SINGLE = '绾噣鍗曡壊',
  DUAL = '鍙岃壊浜掕ˉ',
  RAINBOW = '涓冨僵铏瑰厜',
  GRADIENT = '鍚岀郴娓愬彉',
  GOLDEN = '娴侀噾宀佹湀',
  PASTEL = '椹崱榫欒壊'
}

export const COLOR_ICONS: Record<ColorStyle, string> = {
  [ColorStyle.SINGLE]: '馃敶',
  [ColorStyle.DUAL]: '馃寳',
  [ColorStyle.RAINBOW]: '馃寛',
  [ColorStyle.GRADIENT]: '馃崸',
  [ColorStyle.GOLDEN]: '馃弳',
  [ColorStyle.PASTEL]: '馃崿'
};

export type ParticleBehavior = 'default' | 'willow' | 'glitter' | 'ghost' | 'firefly' | 'comet' | 'galaxy' | 'stationary' | 'falling';

export type CameraMode = 'orbit' | 'firstPerson';

// 2D Particle Options (for legacy 2D canvas version)
export interface ParticleOptions {
  x: number;
  y: number;
  hue: number;
  angle?: number;
  speed?: number;
  friction?: number;
  gravity?: number;
  resistance?: number;
  size?: number;
  decay?: number;
  behavior?: ParticleBehavior;
  originX?: number;
  originY?: number;
}

// 2D Firework Options (for legacy 2D canvas version)
export interface FireworkOptions {
  startX: number;
  targetX: number;
  targetY: number;
  hue: number;
  charge: number;
}

// 3D Particle Options
export interface ParticleOptions3D {
  x: number; y: number; z: number;
  hue: number; speed?: number;
  theta?: number; phi?: number;
  friction?: number; gravity?: number;
  resistance?: number; size?: number;
  decay?: number; behavior?: ParticleBehavior;
  originX?: number; originY?: number; originZ?: number;
}

export interface AppSettings {
  gravity: number;
  friction: number;
  autoLaunchDelay: number; // 鍩虹闅忔満闂撮殧
  particleCountMultiplier: number;
  explosionSizeMultiplier: number;
  starBlinkSpeed: number;
  trailLength: number;
  // 鏂板锛氬槈骞村崕鎺у埗
  enableAutoCarnival: boolean; // 鏄惁寮€鍚嚜鍔ㄥ惊鐜?
  carnivalInterval: number;    // 鑷姩寰幆闂撮殧(绉?
}

// 鍢夊勾鍗庨厤缃?(鐧藉悕鍗?
import { Shape3DType } from '../core/shapes/Shape3DFactory';
import { TrajectoryType } from '../core/trajectories/TrajectoryFactory';
import { ComboType } from '../core/combos/ComboManager';

export enum LaunchFormation {
  SINGLE = '鍗曠偣鍙戝皠',
  RANDOM = '闅忔満鏁ｅ竷',
  CIRCLE = '鍦嗗舰榻愬皠',
  LINE = '涓€瀛楁帓寮€',
  CROSS = '鍗佸瓧浜ゅ弶',
  V_SHAPE = 'V瀛楃紪闃?
}

export interface CarnivalStage {
  id: string;
  name: string;
  count: number;
  trajectory: TrajectoryType | 'RANDOM';
  shape: Shape3DType | ExplosionType | 'RANDOM';
  combo: ComboType | 'RANDOM';
  delay: number; // 璺濈涓婁竴闃舵鐨勫欢杩?ms)
  
  // 鏂板楂樼骇鍙傛暟
  formation?: LaunchFormation;
  interval?: number; // 璇ユ尝娆″唴姣忓彂鐑熻姳鐨勯棿闅?(ms), 0琛ㄧず瀹屽叏鍚屾椂
  duration?: number; // 鐑熻姳鍋滅暀鏃堕棿 (s), 0琛ㄧず榛樿
}

export interface FireworkConfig {
  enabledShapes: ExplosionType[];
  enabledAscensions: AscensionType[];
  enabledColors: ColorStyle[];
  // 鏂版灦鏋勬敮鎸?
  enabledShape3Ds?: Shape3DType[];
  enabledTrajectories?: TrajectoryType[];
  enabledCombos?: ComboType[];
  carnivalSequence?: CarnivalStage[];
  manualSequence?: CarnivalStage[]; // 鎵嬪姩浜や簰鍓ф湰娓呭崟 (淇濈暀鐢ㄤ簬澶嶆潅浜や簰)
}

// 鍗曞彂閰嶇疆 (鎸囧畾鏍峰紡)
export interface ManualConfig {
  lockedShape: ExplosionType | Shape3DType | 'RANDOM';
  lockedColor: ColorStyle | 'RANDOM';
  lockedTrajectory?: TrajectoryType | 'RANDOM';
  lockedCombo?: ComboType | 'RANDOM';
  
  // 鏂板鎵嬪姩鍙傛暟
  lockedFormation: LaunchFormation; // 鍙戝皠闃熷舰
  lockedCount: number; // 姣忔鐐瑰嚮鍙戝皠鏁伴噺
  lockedDuration: number; // 鐑熻姳瀛樼画鏃堕棿 (s)
  lockedInterval: number; // 鍙戝皠闂撮殧 (ms)

  currentStepIndex?: number; // 褰撳墠鎵嬪姩鍓ф湰杩涘害
}

export const DEFAULT_SETTINGS: AppSettings = {
  gravity: 0.12,
  friction: 0.96,
  autoLaunchDelay: 2000,
  particleCountMultiplier: 1.0,
  explosionSizeMultiplier: 1.0,
  starBlinkSpeed: 0.001,
  trailLength: 15,
  enableAutoCarnival: false,
  carnivalInterval: 5
};

export const DEFAULT_CONFIG: FireworkConfig = {
  enabledShapes: Object.values(ExplosionType),
  enabledAscensions: Object.values(AscensionType),
  enabledColors: Object.values(ColorStyle),
  enabledShape3Ds: Object.values(Shape3DType),
  enabledTrajectories: Object.values(TrajectoryType),
  enabledCombos: Object.values(ComboType),
  carnivalSequence: [
    { id: '1', name: '搴忓箷: 绻佹槦鐐圭偣', count: 5, trajectory: TrajectoryType.LINEAR, shape: Shape3DType.SPARKLE_CLOUD, combo: ComboType.SINGLE, delay: 0, formation: LaunchFormation.RANDOM, interval: 300, duration: 3 },
    { id: '2', name: '杩囨浮: 铻烘棆鍗囧崕', count: 8, trajectory: TrajectoryType.SPIRAL, shape: Shape3DType.RING_WAVE, combo: ComboType.STAGED, delay: 2000, formation: LaunchFormation.CIRCLE, interval: 100, duration: 4 },
    { id: '3', name: '楂樻疆: 閾舵渤璇炵敓', count: 1, trajectory: TrajectoryType.ACCELERATE, shape: Shape3DType.GALAXY_SPIRAL, combo: ComboType.GALAXY_BIRTH, delay: 3000, formation: LaunchFormation.SINGLE, interval: 0, duration: 8 }
  ],
  manualSequence: []
};

export const DEFAULT_MANUAL_CONFIG: ManualConfig = {
  lockedShape: 'RANDOM',
  lockedColor: 'RANDOM',
  lockedTrajectory: 'RANDOM',
  lockedCombo: 'RANDOM',
  lockedFormation: LaunchFormation.SINGLE,
  lockedCount: 1,
  lockedDuration: 0,
  lockedInterval: 100,
  currentStepIndex: 0
};

// END OF FILE: src/types/index.ts

====== FILE: D:\ALL IN AI\Aetheris\src\App.tsx ======

import React, { useState, useEffect, useRef } from 'react';
import { FireworkCanvas, FireworkCanvasHandle } from './components/FireworkCanvas';
import { SettingsPanel } from './components/ui/SettingsPanel';
import { HUD } from './components/ui/HUD';
import { 
  AppSettings, 
  DEFAULT_SETTINGS, 
  FireworkConfig, 
  DEFAULT_CONFIG, 
  ManualConfig, 
  DEFAULT_MANUAL_CONFIG 
} from './types';

const STORAGE_KEY = 'celestial_fireworks_v4_settings';

const App: React.FC = () => {
  const canvasRef = useRef<FireworkCanvasHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<AppSettings>(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        if (parsed && typeof parsed === 'object' && 'gravity' in parsed) {
          return { ...DEFAULT_SETTINGS, ...parsed };
        }
      }
    } catch (e) {
      console.error('Failed to load settings from localStorage', e);
    }
    return DEFAULT_SETTINGS;
  });

  const [config, setConfig] = useState<FireworkConfig>(DEFAULT_CONFIG);
  const [manualConfig, setManualConfig] = useState<ManualConfig>(DEFAULT_MANUAL_CONFIG);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  }, [settings]);

  const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const randomizeSettings = () => {
    setSettings(prev => ({
      ...prev,
      gravity: Number((Math.random() * 0.12 + 0.04).toFixed(3)),
      friction: Number((0.92 + Math.random() * 0.07).toFixed(3)),
      autoLaunchDelay: Math.floor(1000 + Math.random() * 6000),
      particleCountMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      explosionSizeMultiplier: Number((0.6 + Math.random() * 1.6).toFixed(2)),
      starBlinkSpeed: Number((0.0003 + Math.random() * 0.002).toFixed(5)),
      trailLength: Math.floor(5 + Math.random() * 30)
    }));
  };

  return (
    <div className="relative w-screen h-screen bg-black overflow-hidden font-sans text-white select-none">
      <style>{`
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(6, 182, 212, 0.3); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(6, 182, 212, 0.5); }
      `}</style>

      <HUD />

      {/* 涓绘帶鎸夐挳 */}
      <div className="absolute top-10 right-10 z-20 flex flex-col gap-5 items-end">
        <button 
          onClick={() => canvasRef.current?.launchCarnival()}
          className="group relative px-10 py-5 bg-gradient-to-br from-amber-400 via-orange-500 to-rose-600 rounded-2xl font-black text-sm tracking-[0.3em] hover:scale-105 active:scale-95 transition-all shadow-2xl shadow-orange-500/40 overflow-hidden border border-white/10"
        >
          <span className="relative z-10 flex items-center gap-3">
            <span className="animate-bounce">馃彯</span> 寮€鍚洓澶у槈骞村崕 馃彯
          </span>
          <div className="absolute inset-0 bg-white/20 -translate-x-full group-hover:translate-x-0 transition-transform duration-500"></div>
        </button>
        <button 
          onClick={() => setShowSettings(!showSettings)}
          className="p-4 bg-white/5 hover:bg-white/15 rounded-2xl border border-white/10 transition-all backdrop-blur-xl shadow-2xl flex items-center gap-2 group"
        >
          <SettingsIcon className="w-6 h-6 text-cyan-400 group-hover:rotate-90 transition-transform" />
          <span className="text-xs font-bold tracking-widest text-cyan-400/80 pr-1">寮曟搸閰嶇疆</span>
        </button>
      </div>

      <FireworkCanvas ref={canvasRef} settings={settings} />

      <SettingsPanel 
        show={showSettings} 
        settings={settings} 
        config={config}
        manualConfig={manualConfig}
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onUpdateConfig={setConfig}
        onUpdateManual={setManualConfig}
        onRandomize={randomizeSettings}
        onReset={() => setSettings(DEFAULT_SETTINGS)}
      />
    </div>
  );
};

const SettingsIcon = ({ className }: { className?: string }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);

export default App;


====== FILE: D:\ALL IN AI\Aetheris\src\App3D.tsx ======
// FILE: src/App3D.tsx
// 涓诲簲鐢ㄥ叆鍙?- 鏁村悎鏂版灦鏋勭殑绮掑瓙妯℃嫙鍣?

import React, { useState, useRef } from 'react';
import { FireworkScene3D, FireworkScene3DHandle } from './components/FireworkScene3D';
import { ModernSettingsPanel } from './components/ui/ModernSettingsPanel';
import { TimeControlPanel } from './components/ui/TimeControlPanel';
import { HUD3D } from './components/ui/HUD3D';
import { DirectionIndicator } from './components/ui/DirectionIndicator';
import { TutorialOverlay, useTutorial } from './components/ui/TutorialOverlay';
import {
  AppSettings,
  DEFAULT_SETTINGS,
  FireworkConfig,
  DEFAULT_CONFIG,
  ManualConfig,
  DEFAULT_MANUAL_CONFIG,
  LaunchFormation
} from './types';
import { TimeController } from './core/TimeController';

const App3D: React.FC = () => {
  const sceneRef = useRef<FireworkScene3DHandle>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [timeController, setTimeController] = useState<TimeController | null>(null);
  const [stats, setStats] = useState({ particles: 0, fireworks: 0, fps: 0 });
  const [autoRotate, setAutoRotate] = useState(true);

  // --- 鐘舵€佺鐞?---
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [config, setConfig] = useState<FireworkConfig>(DEFAULT_CONFIG);
  const [manualConfig, setManualConfig] = useState<ManualConfig>(DEFAULT_MANUAL_CONFIG);
  const [logs, setLogs] = useState<string[]>([]);
  const [isLogCollapsed, setIsLogCollapsed] = useState(true);
  
  // --- 鏁欑▼绯荤粺 ---
  const { showTutorial, completeTutorial, resetTutorial } = useTutorial();

  // --- 閫昏緫澶勭悊 ---
  const updateSetting = (key: keyof AppSettings, value: number | boolean) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const handleTimeScaleChange = (scale: number) => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      const tc = currentScene.getTimeController();
      tc.timeScale = scale;
    }
  };

  const handleTogglePause = () => {
    const currentScene = sceneRef.current;
    if (currentScene) {
      currentScene.getTimeController().togglePause();
    }
  };

  const handleRandomize = () => {
    // 闅忔満鐗╃悊鍙傛暟
    setSettings(prev => ({
      ...prev,
      gravity: 0.05 + Math.random() * 0.15,
      friction: 0.90 + Math.random() * 0.08,
      particleCountMultiplier: 0.5 + Math.random() * 1.5,
      explosionSizeMultiplier: 0.8 + Math.random() * 0.8,
    }));

    // 閲嶇疆閿佸畾鏍峰紡涓洪殢鏈?
    setManualConfig({
      lockedShape: 'RANDOM',
      lockedColor: 'RANDOM',
      lockedTrajectory: 'RANDOM',
      lockedCombo: 'RANDOM',
      lockedFormation: LaunchFormation.RANDOM,
      lockedCount: 1,
      lockedDuration: 0,
      lockedInterval: 100
    });
  };

  const handleReset = () => {
    setSettings(DEFAULT_SETTINGS);
    setConfig(DEFAULT_CONFIG);
    setManualConfig(DEFAULT_MANUAL_CONFIG);
    setLogs([]);
  };

  const handleLaunchLog = (log: string) => {
    setLogs(prev => [log, ...prev].slice(0, 10));
  };

  const handleLaunchCarnival = () => {
    sceneRef.current?.launchCarnival();
  };

  return (
    <div className="relative w-screen h-screen bg-slate-50 overflow-hidden font-sans text-gray-800 select-none">
      {/* 鍏ㄥ眬鏍峰紡 */}
      <style>{`
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          background: #10b981;
          cursor: pointer;
          border: 2px solid white;
          box-shadow: 0 2px 6px rgba(16, 185, 129, 0.3);
        }
        
        .custom-scrollbar::-webkit-scrollbar {
          width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: #e2e8f0;
          border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: #cbd5e1;
        }
        
        @keyframes slideUp {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-slideUp {
          animation: slideUp 0.4s ease-out;
        }
      `}</style>

      {/* HUD 淇℃伅鏄剧ず */}
      <HUD3D />
      
      {/* 鍧愭爣杞存柟鍚戞寚绀哄櫒 */}
      <DirectionIndicator />

      {/* 鍙戝皠鏃ュ織鏄剧ず (鍝嶅簲鐢ㄦ埛闇€姹? 榛樿鎶樺彔锛岃瑙夌簿绠€) */}
      <div className="absolute bottom-10 left-6 z-50 pointer-events-none flex flex-col gap-2 max-w-sm">
        <div 
          className="pointer-events-auto flex items-center gap-2 mb-1 group cursor-pointer"
          onClick={() => setIsLogCollapsed(!isLogCollapsed)}
        >
          <div className={`px-2 py-1 rounded bg-black/20 backdrop-blur-sm text-[9px] font-bold text-white/50 transition-all ${isLogCollapsed ? 'opacity-100' : 'opacity-0'}`}>
            {logs.length} 鏉¤褰?
          </div>
          <button className="w-6 h-6 rounded-full bg-slate-800/80 text-white/80 border border-white/10 flex items-center justify-center text-[10px] hover:bg-emerald-600 transition-all">
            {isLogCollapsed ? '锛? : '脳'}
          </button>
        </div>

        {!isLogCollapsed && logs.slice(0, 5).map((log, i) => (
          <div 
            key={`${i}-${log}`} 
            className="
              px-4 py-2
              bg-white/90 backdrop-blur-xl
              border border-emerald-100/50 
              rounded-2xl shadow-lg
              text-[11px] font-black text-emerald-800
              animate-slideUp
            "
            style={{ 
              opacity: 1 - i * 0.18,
              transform: `scale(${1 - i * 0.05})`,
              boxShadow: '0 4px 12px rgba(16, 185, 129, 0.1)'
            }}
          >
            <span className="mr-2 text-emerald-500">鈼?/span>
            {log}
          </div>
        ))}
      </div>

      {/* 鎺у埗鎸夐挳鍖哄煙 */}
      <div className="absolute top-6 right-6 z-20 flex flex-col gap-3 items-end">
        {/* 鍙繚鐣欏垱鎰忓伐鍧婂叆鍙ｏ紝鍢夊勾鍗庢寜閽Щ鍏ュ唴閮?*/}
        <button
          onClick={() => setShowSettings(true)}
          className="
            group flex items-center gap-3 px-5 py-3.5 
            bg-white/90 backdrop-blur-xl border border-white/20
            rounded-2xl shadow-xl hover:shadow-emerald-200/40 
            hover:-translate-y-0.5 active:scale-95 transition-all
          "
        >
          <div className="text-right">
            <div className="text-[10px] font-black text-gray-400 uppercase tracking-widest leading-none mb-1">Workshop</div>
            <div className="text-sm font-black text-gray-800 leading-none">鍒涙剰宸ュ潑</div>
          </div>
          <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-emerald-500 to-teal-600 flex items-center justify-center text-white shadow-lg shadow-emerald-500/30 group-hover:rotate-12 transition-all">
            馃帹
          </div>
        </button>
        
        {/* 宸ュ叿鎸夐挳缁?*/}
        <div className="flex gap-2">
          {/* 鏁欑▼鎸夐挳 */}
          <button
            onClick={resetTutorial}
            className="
              p-3.5 rounded-xl
              bg-white/90 backdrop-blur
              text-gray-600 hover:text-blue-600
              shadow-lg border border-gray-100
              transition-all
            "
            title="鏌ョ湅鏁欑▼"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </button>
        </div>
      </div>

      {/* 3D 鐑熻姳鍦烘櫙 */}
      <FireworkScene3D
        ref={sceneRef}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        autoRotate={autoRotate}
        onTimeUpdate={(tc) => setTimeController(tc)}
        onStatsUpdate={(st) => setStats(st)}
        onLaunch={handleLaunchLog}
      />

      {/* 鏃堕棿鎺у埗闈㈡澘 */}
      <TimeControlPanel
        timeController={timeController}
        stats={stats}
        onTimeScaleChange={handleTimeScaleChange}
        onTogglePause={handleTogglePause}
        autoRotate={autoRotate}
        onToggleAutoRotate={() => setAutoRotate(!autoRotate)}
      />

      {/* 璁剧疆闈㈡澘 & 鐐瑰嚮澶栭儴鍏抽棴閬僵 */}
      {showSettings && (
        <div 
          className="fixed inset-0 z-30 bg-black/5 backdrop-blur-[1px]"
          onClick={() => setShowSettings(false)}
        />
      )}

      <ModernSettingsPanel
        show={showSettings}
        settings={settings}
        config={config}
        manualConfig={manualConfig}
        onClose={() => setShowSettings(false)}
        onUpdate={updateSetting}
        onUpdateConfig={setConfig}
        onUpdateManual={setManualConfig}
        onRandomize={handleRandomize}
        onReset={handleReset}
        onLaunchCarnival={handleLaunchCarnival}
      />
      
      {/* 寮曞鏁欑▼ */}
      {showTutorial && (
        <TutorialOverlay onComplete={completeTutorial} />
      )}

      {/* 搴曢儴鍝佺墝鏍囪瘑 */}
      <div className="absolute bottom-4 right-4 text-[10px] text-gray-300 font-medium">
        <span className="font-bold text-gray-400">AETHERIS</span>
        <span className="mx-2 opacity-50">/</span>
        UNIVERSAL PARTICLE ENGINE v2.0
      </div>
    </div>
  );
};

export default App3D;

// END OF FILE: src/App3D.tsx

====== FILE: D:\ALL IN AI\Aetheris\src\main.tsx ======

import React from 'react';
import ReactDOM from 'react-dom/client';
import App3D from './App3D';
import './styles/index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App3D />
  </React.StrictMode>
);


====== FILE: D:\ALL IN AI\Aetheris\src\three-examples.d.ts ======
declare module 'three/examples/jsm/controls/OrbitControls' {
    import { Camera, EventDispatcher, MOUSE, TOUCH, Vector3 } from 'three';
    export class OrbitControls extends EventDispatcher {
        constructor(camera: Camera, domElement?: HTMLElement);
        object: Camera;
        domElement: HTMLElement | HTMLDocument;
        enabled: boolean;
        target: Vector3;
        minDistance: number;
        maxDistance: number;
        minZoom: number;
        maxZoom: number;
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        enableDamping: boolean;
        dampingFactor: number;
        enableZoom: boolean;
        zoomSpeed: number;
        enableRotate: boolean;
        rotateSpeed: number;
        enablePan: boolean;
        panSpeed: number;
        screenSpacePanning: boolean;
        keyPanSpeed: number;
        autoRotate: boolean;
        autoRotateSpeed: number;
        enableKeys: boolean;
        keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number };
        mouseButtons: { LEFT: MOUSE; MIDDLE: MOUSE; RIGHT: MOUSE };
        touches: { ONE: TOUCH; TWO: TOUCH };
        update(): boolean;
        saveState(): void;
        reset(): void;
        dispose(): void;
        getPolarAngle(): number;
        getAzimuthalAngle(): number;
        // EventDispatcher mixins
        addEventListener(type: string, listener: (event: any) => void): void;
        hasEventListener(type: string, listener: (event: any) => void): boolean;
        removeEventListener(type: string, listener: (event: any) => void): void;
        dispatchEvent(event: { type: string; [key: string]: any }): void;
    }
}

declare module 'three/examples/jsm/postprocessing/EffectComposer' {
    import { WebGLRenderer, WebGLRenderTarget, Scene, Camera } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class EffectComposer {
        constructor(renderer: WebGLRenderer, renderTarget?: WebGLRenderTarget);
        renderTarget1: WebGLRenderTarget;
        renderTarget2: WebGLRenderTarget;
        writeBuffer: WebGLRenderTarget;
        readBuffer: WebGLRenderTarget;
        passes: Pass[];
        copyPass: Pass;
        clock: any;
        renderToScreen: boolean;
        addPass(pass: Pass): void;
        insertPass(pass: Pass, index: number): void;
        removePass(pass: Pass): void;
        render(deltaTime?: number): void;
        reset(renderTarget?: WebGLRenderTarget): void;
        setSize(width: number, height: number): void;
        setPixelRatio(pixelRatio: number): void;
        dispose(): void;
    }
}

declare module 'three/examples/jsm/postprocessing/RenderPass' {
    import { Scene, Camera, Color, Material } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class RenderPass extends Pass {
        constructor(scene: Scene, camera: Camera, overrideMaterial?: Material, clearColor?: Color, clearAlpha?: number);
        scene: Scene;
        camera: Camera;
        overrideMaterial: Material;
        clearColor: Color;
        clearAlpha: number;
        clear: boolean;
    }
}

declare module 'three/examples/jsm/postprocessing/UnrealBloomPass' {
    import { Vector2, Color } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class UnrealBloomPass extends Pass {
        constructor(resolution: Vector2, strength: number, radius: number, threshold: number);
        resolution: Vector2;
        strength: number;
        radius: number;
        threshold: number;
        compositeMaterial: any;
        bloomTintColors: Color[];
        copyUniforms: any;
        materialCopy: any;
        oldClearColor: Color;
        oldClearAlpha: number;
    }
}

declare module 'three/examples/jsm/postprocessing/ShaderPass' {
    import { ShaderMaterial, WebGLRenderer, WebGLRenderTarget } from 'three';
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class ShaderPass extends Pass {
        constructor(shader: any, textureID?: string);
        textureID: string;
        uniforms: { [uniform: string]: { value: any } };
        material: ShaderMaterial;
        fsQuad: any;
        render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    }
}

declare module 'three/examples/jsm/postprocessing/OutputPass' {
    import { Pass } from 'three/examples/jsm/postprocessing/Pass';
    export class OutputPass extends Pass {
        constructor();
    }
}

declare module 'three/examples/jsm/postprocessing/Pass' {
    import { WebGLRenderer, WebGLRenderTarget } from 'three';
    export class Pass {
        constructor();
        enabled: boolean;
        needsSwap: boolean;
        clear: boolean;
        renderToScreen: boolean;
        setSize(width: number, height: number): void;
        render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
    }
}


